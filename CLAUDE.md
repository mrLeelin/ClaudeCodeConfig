# 🔴 紧急规则 - 代码修改必须流程

**任何代码修改操作（Edit、Write）之前，必须：**

1. 先列出修改计划
   - 要改哪些文件
   - 改什么内容
   - 为什么这样改

2. 等待用户明确确认
   - 用户说"确认"、"可以"、"执行"、"继续"等
   - 收到确认前不能执行任何修改操作

3. 收到确认后才能执行修改
   - 按计划分步骤执行
   - 每步完成后汇报
   - 最后提供代码 diff 和回退方案

**违反此规则立即停止操作。**

---

# ⚠️ 每次必做清单（最高优先级）

**以下规则必须在每次回答时都严格遵守：**

1. ✅ **明确说明使用的模型**：在每次回答开头说明"当前使用模型：Claude Sonnet 4.5"
2. ✅ **使用简体中文**：所有回答必须使用简体中文
3. ✅ **修改代码前先列计划**：不要直接改代码，先写详细计划，解释原因，等待用户确认
4. ✅ **修改后自动跑测试**：每次代码修改完成后自动运行测试
5. ✅ **提供 diff 和回退方案**：修改完代码后给出完整的代码 diff 和功能对比，支持回退
6. ✅ **分步骤修改**：每次修改都要分步骤，等待用户确认后才继续
7. ✅ **询问是否写入代码**：每次给完建议后询问用户是否写入代码
8. ✅ **每次回答后提供下一步建议**：完成任务或回答问题后，主动提供2-4个可选的下一步建议，帮助用户决定后续方向
9. ✅ **等待明确执行指令**：如果用户没有输入很强烈的执行命令（如"继续"、"可以"、"下一步"、"执行"等），不要自动执行下一步操作，而是等待用户明确指示
10. ✅ **处理模糊指令**：如果用户输入的指令比较模糊或无法理解，给出2-4条具体的建议选项，以确认用户的真实意图

---

## 基本规则

- 当回答 Unity 内部属性、API、组件配置等问题时，优先查阅 Unity 官方文档或询问用户是否有官方文档链接，确保信息准确性

## 输出控制规范

### 分段输出原则
- **避免长篇输出**：单次回答控制在合理长度，避免信息过载
- **使用工具时分段**：使用 Read、Grep 等工具时，分多次调用而不是一次读取大量内容
- **代码修改分步骤**：大型修改分解为多个小步骤，每步完成后汇报
- **提供进度反馈**：长时间操作时及时告知进度

### 内容组织原则
- 使用清晰的标题和分隔符
- 重要信息使用加粗或列表突出
- 复杂内容使用表格或图表展示
- 提供目录索引方便快速定位

## 错误处理规范

### 遇到错误时的处理流程
1. **立即停止当前操作**：不要继续执行可能导致更多错误的操作
2. **详细记录错误信息**：包括错误消息、堆栈跟踪、上下文信息
3. **分析错误原因**：使用日志、调试工具等手段定位问题
4. **提供解决方案**：给出2-3个可能的解决方案，说明优缺点
5. **验证修复效果**：修复后运行测试确认问题已解决

### 调试策略
- 优先使用日志和断点调试，避免盲目修改代码
- 使用二分法缩小问题范围
- 查阅官方文档和已知问题列表
- 记录调试过程和解决方案，避免重复问题

## 代码审查检查清单

### 提交代码前必须检查
- [ ] 代码编译无错误和警告
- [ ] 所有测试通过
- [ ] 代码符合项目编码规范
- [ ] 添加了必要的注释和文档
- [ ] 移除了调试代码和注释掉的代码
- [ ] 没有硬编码的敏感信息（密钥、密码等）
- [ ] 性能敏感代码已优化
- [ ] 添加了必要的错误处理

### 代码质量标准
- 方法长度控制在50行以内
- 嵌套层级不超过3层
- 避免重复代码，提取公共逻辑
- 使用有意义的变量和方法名

## 代码修改工作流程

### 修改代码的步骤
1. **列出计划** - 提交给用户审核
   - 说明要改哪些文件
   - 详细列出每个步骤
   - 解释为什么这样做

2. **等待用户确认** - 用户审阅计划后才能开始
   - 用户可以提出建议或修改
   - 用户同意后才能写代码
   - 绝不未经确认直接修改代码

3. **按计划逐步写代码** - 凭借计划一步一步的写代码
   - 执行确认过的计划
   - 每个步骤完成后汇报
   - 最后给出完整的代码 diff 和功能对比


## Unity 开发规范

### 架构与代码结构
- 遵循 MVC 或 MVP 架构模式，分离数据、逻辑和表现层
- 使用单一职责原则：每个类只负责一个功能
- 业务逻辑与 Unity API 解耦，便于单元测试
- 使用接口和抽象类提高代码可扩展性
- Manager 类使用单例模式或依赖注入
- 逻辑保持清晰简洁，避免嵌套超过3层
- 方法长度控制在50行以内，复杂逻辑拆分成小方法
- 相关功能的类放在同一命名空间和文件夹中

### 代码规范
- 使用 C# 命名约定：类名用 PascalCase，方法名用 PascalCase，私有字段用 camelCase 或 _camelCase
- MonoBehaviour 脚本必须包含必要的生命周期方法注释（Awake, Start, Update等）
- 避免在 Update 中进行高开销操作，优先使用事件驱动
- 使用序列化字段 [SerializeField] 而不是 public 字段
- 对所有协程添加空引用检查

### 注释规范
- 所有公共类和方法必须添加 XML 文档注释 (/// <summary>)
- 复杂算法和业务逻辑必须添加行内注释说明
- 关键变量声明时注释其用途和取值范围
- TODO、FIXME、HACK 等标记必须说明原因和计划
- 注释使用简体中文，保持简洁明了
- 避免无意义注释，代码应自解释

### 性能优化规范
- **struct vs class 选择**：
  - 优先使用 `struct` 的场景：
    - 数据量小（通常少于 16 字节）
    - 表示值对象（无身份语义）
    - 频繁创建/销毁（减少 GC 压力）
    - 不可变数据结构
  - 必须使用 `class` 的场景：
    - 数据量大（超过 16 字节）
    - 需要继承或多态
    - 有身份语义（对象相等性基于引用）
    - 需要频繁修改且拷贝成本高
  - 示例：状态对象、配置对象、临时数据应使用 struct

### Unity 项目结构
- 保持 Assets 文件夹结构清晰：Scripts/, Prefabs/, Materials/, Scenes/, Resources/
- Scripts 按功能分类：UI/, Gameplay/, Managers/, Utils/, Data/
- 场景文件必须保存在 Assets/Scenes/ 目录下
- 预制体修改后必须应用到源预制体
- 材质和贴图应分类存放

### 性能优化
- 对象池化：频繁实例化的对象使用对象池
- 避免在 Update/FixedUpdate 中使用 GameObject.Find 和 GetComponent
- 缓存组件引用：在 Awake/Start 中获取并缓存常用组件
- 使用 CompareTag 而不是 tag == "TagName"
- 字符串拼接使用 StringBuilder，避免在循环中创建新字符串
- 合理使用协程，避免内存泄漏，停止时使用 StopCoroutine
- UGUI 优化：减少 Canvas 重建，合理使用 Canvas 分层
- 避免空 Unity 事件方法（空的 Update、FixedUpdate 等）
- 使用对象禁用而非销毁来提高性能
- 批处理优化：合并材质和网格减少 Draw Call

### 测试与调试
- 每次修改后运行 Play Mode 测试
- 检查 Console 中的警告和错误
- 性能敏感代码使用 Profiler 分析
- 修改脚本后确认没有编译错误

### Unity 特定工具使用
- 优先使用 Unity MCP 工具操作场景和对象
- 修改场景前先保存当前场景
- 使用 get_unity_logs 检查运行时错误
- 大量修改前使用 get_scene_view_screenshot 记录初始状态
- Diff 对比为 代码对比和功能对比两个都要有
- 如果出现错误记录下来放到工程Claude.md同目录下的ReportError文件夹并且新建md文件 下次不要再犯

## 错误处理与调试

### 异常处理规范
- 在可能出现异常的地方使用 try-catch，特别是：
  - 文件 I/O 操作
  - 网络请求
  - 序列化/反序列化
  - 外部 API 调用
- 捕获具体的异常类型，避免使用空的 catch 块
- 异常处理后必须记录日志，包含上下文信息
- 不要用异常来控制正常的程序流程

### 日志记录规范
- 使用分级日志：Debug.Log（信息）、Debug.LogWarning（警告）、Debug.LogError（错误）
- 日志信息应包含：时间戳、模块名称、具体描述
- 生产环境中禁用 Debug.Log，使用条件编译：
  ```csharp
  #if UNITY_EDITOR || DEVELOPMENT_BUILD
      Debug.Log("调试信息");
  #endif
  ```
- 关键业务逻辑必须记录日志，便于追踪问题

### 空引用检查
- 所有外部引用在使用前必须检查是否为 null
- 使用空合并运算符简化检查：`var obj = GetComponent<T>() ?? AddComponent<T>();`
- 序列化字段在 Awake/Start 中验证是否已赋值
- 使用 `?.` 和 `??` 运算符提高代码安全性

### 调试工具使用
- 开发阶段使用 Gizmos 可视化调试（碰撞体、路径等）
- 使用 Debug.DrawLine/DrawRay 绘制调试信息
- 条件编译符号：`#if UNITY_EDITOR` 用于编辑器专用代码
- 使用 [Conditional("UNITY_EDITOR")] 特性标记调试方法

## 代码质量保证

### 代码提交前自查清单
- [ ] 代码编译无错误和警告
- [ ] 所有公共方法都有 XML 注释
- [ ] 移除了所有调试用的 Debug.Log
- [ ] 没有注释掉的代码（应删除而非注释）
- [ ] 变量命名清晰，符合命名规范
- [ ] 没有硬编码的魔法数字，使用常量或配置
- [ ] 添加了必要的空引用检查
- [ ] 性能敏感代码已优化（避免 GC、缓存引用等）

### 常见错误预防清单
- 避免在循环中使用 string 拼接，使用 StringBuilder
- 避免在 Update 中频繁调用 Find、GetComponent
- 协程使用后必须正确停止，避免内存泄漏
- 事件订阅后必须取消订阅（OnDestroy 中）
- 单例模式要处理场景切换时的生命周期
- 序列化字段的默认值要合理设置
- 避免循环引用导致的内存泄漏

### 代码审查要点
- 逻辑正确性：是否实现了需求功能
- 边界条件：是否处理了空值、零值、极端情况
- 性能影响：是否引入了性能瓶颈
- 可维护性：代码是否易于理解和修改
- 安全性：是否存在潜在的安全隐患
- 测试覆盖：关键逻辑是否可测试

## 第三方库管理

### 插件选择标准
- 优先选择活跃维护的插件（最近6个月内有更新）
- 检查插件的 Unity 版本兼容性
- 查看用户评价和已知问题
- 评估插件大小对项目的影响
- 确认插件的许可证类型（商业/开源）
- 优先选择有完整文档和示例的插件

### 依赖管理规范
- 使用 Package Manager 管理官方和第三方包
- 记录所有第三方插件的版本号和来源
- 定期检查插件更新，但谨慎升级（先在分支测试）
- 避免使用功能重复的插件
- 最小化依赖数量，只引入必要的插件
- 大型插件考虑按需加载

### 版本兼容性
- 升级 Unity 版本前检查所有插件的兼容性
- 保持插件版本稳定，避免频繁更新
- 记录插件升级历史和遇到的问题
- 使用版本控制忽略插件的临时文件

## 数据持久化基础

### PlayerPrefs 使用规范
- 仅用于存储简单的配置数据（音量、画质设置等）
- 不要存储敏感信息（密码、密钥等）
- 键名使用统一的命名规范，建议使用常量管理
- 写入后及时调用 PlayerPrefs.Save() 确保数据保存
- 避免频繁读写，考虑使用内存缓存

### 序列化规范
- 优先使用 JSON 序列化（JsonUtility 或第三方库如 Newtonsoft.Json）
- 复杂数据结构使用 [Serializable] 特性标记
- 避免序列化 Unity 对象引用（Transform、GameObject 等）
- 大数据量考虑使用二进制序列化提高性能
- 序列化前验证数据完整性，反序列化后验证数据有效性

### 配置文件管理
- 配置文件统一放在 StreamingAssets 或 Resources 文件夹
- 使用 JSON 或 ScriptableObject 管理配置数据
- 配置文件修改后要有版本控制
- 运行时配置和编辑器配置分离
- 敏感配置不要硬编码在代码中

### 数据安全
- 重要数据考虑加密存储
- 存档数据添加校验和防止篡改
- 定期备份重要数据
- 处理数据加载失败的情况（损坏、版本不兼容等）