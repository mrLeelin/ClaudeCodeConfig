{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","type":"user","message":{"role":"user","content":"请将文件 `e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs` 中的所有英文注释翻译为中文，并为没有注释的重要代码段补充中文注释。\n\n要求：\n1. 保持代码结构完全不变\n2. 将所有 `/// <summary>` 和单行 `//` 注释翻译为中文\n3. 为重要的私有方法、字段和属性添加中文注释\n4. 翻译要准确、专业，符合游戏开发术语\n5. 补充的注释要简洁明了\n\n文件很大（2688行），请完整处理整个文件，然后将翻译后的完整内容写入原文件。\n\n特别注意：\n- `/// <summary>` 注释格式保持不变\n- Tooltip 文本也要翻译\n- 保持代码的可读性和格式\n\n开始处理吧！"},"uuid":"e6e4c0b6-24ee-4bc9-b453-15dd8cac64ee","timestamp":"2025-12-19T10:12:46.999Z"}
{"parentUuid":"e6e4c0b6-24ee-4bc9-b453-15dd8cac64ee","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013ZhAHV6k6RqEta6zHjsmFn","type":"message","role":"assistant","content":[{"type":"text","text":"我将帮你翻译这个文件中的所有英文注释为中文，并为重要代码段补充注释。首先让我读取这个文件。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":38905,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":38905,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"c7f83afa-7824-47e1-a62b-387a422dc468","timestamp":"2025-12-19T10:12:52.264Z"}
{"parentUuid":"c7f83afa-7824-47e1-a62b-387a422dc468","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013ZhAHV6k6RqEta6zHjsmFn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MmNTsQjexUxqjC6Vv7sXim","name":"Read","input":{"file_path":"e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":38905,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":38905,"ephemeral_1h_input_tokens":0},"output_tokens":140,"service_tier":"standard"}},"type":"assistant","uuid":"c3f37295-795b-4b62-8d93-a61063eabb21","timestamp":"2025-12-19T10:12:52.977Z"}
{"parentUuid":"176b5abd-4120-4d35-9b06-02522011a32f","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (30804 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01MmNTsQjexUxqjC6Vv7sXim"}]},"uuid":"454b1b72-d433-4777-8184-13bfa822a650","timestamp":"2025-12-19T10:12:54.989Z","toolUseResult":"Error: File content (30804 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"parentUuid":"454b1b72-d433-4777-8184-13bfa822a650","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01R6zuGKf8QJL2DSpbFYhP4T","type":"message","role":"assistant","content":[{"type":"text","text":"文件太大了，我需要分段读取。让我先查看文件的总行数，然后分段处理。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":193,"cache_read_input_tokens":38905,"cache_creation":{"ephemeral_5m_input_tokens":193,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"dd441c6e-3685-462e-8871-274d0e083cc0","timestamp":"2025-12-19T10:12:59.987Z"}
{"parentUuid":"dd441c6e-3685-462e-8871-274d0e083cc0","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01R6zuGKf8QJL2DSpbFYhP4T","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011QSN7CSK8qWRGTLVmXbr9G","name":"Bash","input":{"command":"wc -l \"e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs\"","description":"Count total lines in the file"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":193,"cache_read_input_tokens":38905,"cache_creation":{"ephemeral_5m_input_tokens":193,"ephemeral_1h_input_tokens":0},"output_tokens":152,"service_tier":"standard"}},"type":"assistant","uuid":"b7b94d2e-4518-4a27-9349-4e94a59584f0","timestamp":"2025-12-19T10:13:00.555Z"}
{"parentUuid":"b7b94d2e-4518-4a27-9349-4e94a59584f0","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011QSN7CSK8qWRGTLVmXbr9G","type":"tool_result","content":"2688 e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs","is_error":false}]},"uuid":"f6cd7e4c-beb4-4735-a047-ef8dbab6f58e","timestamp":"2025-12-19T10:13:01.225Z","toolUseResult":{"stdout":"2688 e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs\r","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"f6cd7e4c-beb4-4735-a047-ef8dbab6f58e","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01A3SWsDj8Jgybxq2TisRJ47","type":"message","role":"assistant","content":[{"type":"text","text":"好的，文件有2688行。我将分5段读取和处理。让我开始："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":272,"cache_read_input_tokens":39039,"cache_creation":{"ephemeral_5m_input_tokens":272,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"e048a510-8737-4473-b950-49f148f7fa85","timestamp":"2025-12-19T10:13:05.972Z"}
{"parentUuid":"e048a510-8737-4473-b950-49f148f7fa85","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01A3SWsDj8Jgybxq2TisRJ47","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WhZdmjCgJ1wdPKccBWjAh1","name":"Read","input":{"file_path":"e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs","offset":1,"limit":540}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":272,"cache_read_input_tokens":39039,"cache_creation":{"ephemeral_5m_input_tokens":272,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"5e937399-db1c-4e39-b3fc-aeacb5b169d7","timestamp":"2025-12-19T10:13:06.598Z"}
{"parentUuid":"5e937399-db1c-4e39-b3fc-aeacb5b169d7","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01A3SWsDj8Jgybxq2TisRJ47","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BuaKcv2mNuYMLcb128YkmE","name":"Read","input":{"file_path":"e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs","offset":541,"limit":540}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":272,"cache_read_input_tokens":39039,"cache_creation":{"ephemeral_5m_input_tokens":272,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"ea7ecbc5-639c-4219-b403-a9383dab7973","timestamp":"2025-12-19T10:13:07.401Z"}
{"parentUuid":"ea7ecbc5-639c-4219-b403-a9383dab7973","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01A3SWsDj8Jgybxq2TisRJ47","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GwX3teoa25tnkbazHnLiTw","name":"Read","input":{"file_path":"e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs","offset":1081,"limit":540}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":272,"cache_read_input_tokens":39039,"cache_creation":{"ephemeral_5m_input_tokens":272,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"e09610ec-ca68-4c7c-b11d-497a68047924","timestamp":"2025-12-19T10:13:08.222Z"}
{"parentUuid":"e09610ec-ca68-4c7c-b11d-497a68047924","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01A3SWsDj8Jgybxq2TisRJ47","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013F7y5PgBRkQY2o3XAvPcbJ","name":"Read","input":{"file_path":"e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs","offset":1621,"limit":540}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":272,"cache_read_input_tokens":39039,"cache_creation":{"ephemeral_5m_input_tokens":272,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"c1125d23-22db-438f-8d48-f3914c9597e6","timestamp":"2025-12-19T10:13:09.039Z"}
{"parentUuid":"c1125d23-22db-438f-8d48-f3914c9597e6","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01A3SWsDj8Jgybxq2TisRJ47","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NMGKjgvTp4onXa7Ur1h3ZH","name":"Read","input":{"file_path":"e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs","offset":2161,"limit":540}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":272,"cache_read_input_tokens":39039,"cache_creation":{"ephemeral_5m_input_tokens":272,"ephemeral_1h_input_tokens":0},"output_tokens":587,"service_tier":"standard"}},"type":"assistant","uuid":"f7943160-cf0f-4c9e-a058-7b129d8b9b5b","timestamp":"2025-12-19T10:13:09.878Z"}
{"parentUuid":"c9515bbf-1d3b-4c0c-b783-0546e01b7dd8","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WhZdmjCgJ1wdPKccBWjAh1","type":"tool_result","content":"     1→﻿using System;\n     2→using System.Collections.Generic;\n     3→using UnityEngine;\n     4→\n     5→namespace KinematicCharacterController\n     6→{\n     7→    public enum RigidbodyInteractionType\n     8→    {\n     9→        None,\n    10→        Kinematic,\n    11→        SimulatedDynamic\n    12→    }\n    13→\n    14→    public enum StepHandlingMethod\n    15→    {\n    16→        None,\n    17→        Standard,\n    18→        Extra\n    19→    }\n    20→\n    21→    public enum MovementSweepState\n    22→    {\n    23→        Initial,\n    24→        AfterFirstHit,\n    25→        FoundBlockingCrease,\n    26→        FoundBlockingCorner,\n    27→    }\n    28→\n    29→    /// <summary>\n    30→    /// Represents the entire state of a character motor that is pertinent for simulation.\n    31→    /// Use this to save state or revert to past state\n    32→    /// </summary>\n    33→    [System.Serializable]\n    34→    public struct KinematicCharacterMotorState\n    35→    {\n    36→        public Vector3 Position;\n    37→        public Quaternion Rotation;\n    38→        public Vector3 BaseVelocity;\n    39→\n    40→        public bool MustUnground;\n    41→        public float MustUngroundTime;\n    42→        public bool LastMovementIterationFoundAnyGround;\n    43→        public CharacterTransientGroundingReport GroundingStatus;\n    44→\n    45→        public Rigidbody AttachedRigidbody;\n    46→        public Vector3 AttachedRigidbodyVelocity;\n    47→    }\n    48→\n    49→    /// <summary>\n    50→    /// Describes an overlap between the character capsule and another collider\n    51→    /// </summary>\n    52→    public struct OverlapResult\n    53→    {\n    54→        public Vector3 Normal;\n    55→        public Collider Collider;\n    56→\n    57→        public OverlapResult(Vector3 normal, Collider collider)\n    58→        {\n    59→            Normal = normal;\n    60→            Collider = collider;\n    61→        }\n    62→    }\n    63→\n    64→    /// <summary>\n    65→    /// Contains all the information for the motor's grounding status\n    66→    /// </summary>\n    67→    public struct CharacterGroundingReport\n    68→    {\n    69→        public bool FoundAnyGround;\n    70→        public bool IsStableOnGround;\n    71→        public bool SnappingPrevented;\n    72→        public Vector3 GroundNormal;\n    73→        public Vector3 InnerGroundNormal;\n    74→        public Vector3 OuterGroundNormal;\n    75→\n    76→        public Collider GroundCollider;\n    77→        public Vector3 GroundPoint;\n    78→\n    79→        public void CopyFrom(CharacterTransientGroundingReport transientGroundingReport)\n    80→        {\n    81→            FoundAnyGround = transientGroundingReport.FoundAnyGround;\n    82→            IsStableOnGround = transientGroundingReport.IsStableOnGround;\n    83→            SnappingPrevented = transientGroundingReport.SnappingPrevented;\n    84→            GroundNormal = transientGroundingReport.GroundNormal;\n    85→            InnerGroundNormal = transientGroundingReport.InnerGroundNormal;\n    86→            OuterGroundNormal = transientGroundingReport.OuterGroundNormal;\n    87→\n    88→            GroundCollider = null;\n    89→            GroundPoint = Vector3.zero;\n    90→        }\n    91→    }\n    92→\n    93→    /// <summary>\n    94→    /// Contains the simulation-relevant information for the motor's grounding status\n    95→    /// </summary>\n    96→    public struct CharacterTransientGroundingReport\n    97→    {\n    98→        public bool FoundAnyGround;\n    99→        public bool IsStableOnGround;\n   100→        public bool SnappingPrevented;\n   101→        public Vector3 GroundNormal;\n   102→        public Vector3 InnerGroundNormal;\n   103→        public Vector3 OuterGroundNormal;\n   104→\n   105→        public void CopyFrom(CharacterGroundingReport groundingReport)\n   106→        {\n   107→            FoundAnyGround = groundingReport.FoundAnyGround;\n   108→            IsStableOnGround = groundingReport.IsStableOnGround;\n   109→            SnappingPrevented = groundingReport.SnappingPrevented;\n   110→            GroundNormal = groundingReport.GroundNormal;\n   111→            InnerGroundNormal = groundingReport.InnerGroundNormal;\n   112→            OuterGroundNormal = groundingReport.OuterGroundNormal;\n   113→        }\n   114→    }\n   115→\n   116→    /// <summary>\n   117→    /// Contains all the information from a hit stability evaluation\n   118→    /// </summary>\n   119→    public struct HitStabilityReport\n   120→    {\n   121→        public bool IsStable;\n   122→\n   123→        public bool FoundInnerNormal;\n   124→        public Vector3 InnerNormal;\n   125→        public bool FoundOuterNormal;\n   126→        public Vector3 OuterNormal;\n   127→\n   128→        public bool ValidStepDetected;\n   129→        public Collider SteppedCollider;\n   130→\n   131→        public bool LedgeDetected;\n   132→        public bool IsOnEmptySideOfLedge;\n   133→        public float DistanceFromLedge;\n   134→        public bool IsMovingTowardsEmptySideOfLedge;\n   135→        public Vector3 LedgeGroundNormal;\n   136→        public Vector3 LedgeRightDirection;\n   137→        public Vector3 LedgeFacingDirection;\n   138→    }\n   139→\n   140→    /// <summary>\n   141→    /// Contains the information of hit rigidbodies during the movement phase, so they can be processed afterwards\n   142→    /// </summary>\n   143→    public struct RigidbodyProjectionHit\n   144→    {\n   145→        public Rigidbody Rigidbody;\n   146→        public Vector3 HitPoint;\n   147→        public Vector3 EffectiveHitNormal;\n   148→        public Vector3 HitVelocity;\n   149→        public bool StableOnHit;\n   150→    }\n   151→\n   152→    /// <summary>\n   153→    /// Component that manages character collisions and movement solving\n   154→    /// </summary>\n   155→    [RequireComponent(typeof(CapsuleCollider))]\n   156→    public class KinematicCharacterMotor : MonoBehaviour\n   157→    {\n   158→#pragma warning disable 0414\n   159→        [Header(\"Components\")]\n   160→        /// <summary>\n   161→        /// The capsule collider of this motor\n   162→        /// </summary>\n   163→        [ReadOnly]\n   164→        public CapsuleCollider Capsule;\n   165→\n   166→        [Header(\"Capsule Settings\")]\n   167→        /// <summary>\n   168→        /// Radius of the character's capsule\n   169→        /// </summary>\n   170→        [SerializeField]\n   171→        [Tooltip(\"Radius of the Character Capsule\")]\n   172→        private float CapsuleRadius = 0.5f;\n   173→        /// <summary>\n   174→        /// Height of the character's capsule\n   175→        /// </summary>\n   176→        [SerializeField]\n   177→        [Tooltip(\"Height of the Character Capsule\")]\n   178→        private float CapsuleHeight = 2f;\n   179→        /// <summary>\n   180→        /// Local y position of the character's capsule center\n   181→        /// </summary>\n   182→        [SerializeField]\n   183→        [Tooltip(\"Height of the Character Capsule\")]\n   184→        private float CapsuleYOffset = 1f;\n   185→        /// <summary>\n   186→        /// Physics material of the character's capsule\n   187→        /// </summary>\n   188→        [SerializeField]\n   189→        [Tooltip(\"Physics material of the Character Capsule (Does not affect character movement. Only affects things colliding with it)\")]\n   190→#pragma warning disable 0649\n   191→        private PhysicsMaterial CapsulePhysicsMaterial;\n   192→#pragma warning restore 0649\n   193→\n   194→\n   195→        [Header(\"Grounding settings\")]\n   196→        /// <summary>\n   197→        /// Increases the range of ground detection, to allow snapping to ground at very high speeds\n   198→        /// </summary>    \n   199→        [Tooltip(\"Increases the range of ground detection, to allow snapping to ground at very high speeds\")]\n   200→        public float GroundDetectionExtraDistance = 0f;\n   201→        /// <summary>\n   202→        /// Maximum slope angle on which the character can be stable\n   203→        /// </summary>    \n   204→        [Range(0f, 89f)]\n   205→        [Tooltip(\"Maximum slope angle on which the character can be stable\")]\n   206→        public float MaxStableSlopeAngle = 60f;\n   207→        /// <summary>\n   208→        /// Which layers can the character be considered stable on\n   209→        /// </summary>    \n   210→        [Tooltip(\"Which layers can the character be considered stable on\")]\n   211→        public LayerMask StableGroundLayers = -1;\n   212→        /// <summary>\n   213→        /// Notifies the Character Controller when discrete collisions are detected\n   214→        /// </summary>    \n   215→        [Tooltip(\"Notifies the Character Controller when discrete collisions are detected\")]\n   216→        public bool DiscreteCollisionEvents = false;\n   217→\n   218→\n   219→        [Header(\"Step settings\")]\n   220→        /// <summary>\n   221→        /// Handles properly detecting grounding status on steps, but has a performance cost.\n   222→        /// </summary>\n   223→        [Tooltip(\"Handles properly detecting grounding status on steps, but has a performance cost.\")]\n   224→        public StepHandlingMethod StepHandling = StepHandlingMethod.Standard;\n   225→        /// <summary>\n   226→        /// Maximum height of a step which the character can climb\n   227→        /// </summary>    \n   228→        [Tooltip(\"Maximum height of a step which the character can climb\")]\n   229→        public float MaxStepHeight = 0.5f;\n   230→        /// <summary>\n   231→        /// Can the character step up obstacles even if it is not currently stable?\n   232→        /// </summary>    \n   233→        [Tooltip(\"Can the character step up obstacles even if it is not currently stable?\")]\n   234→        public bool AllowSteppingWithoutStableGrounding = false;\n   235→        /// <summary>\n   236→        /// Minimum length of a step that the character can step on (used in Extra stepping method. Use this to let the character step on steps that are smaller that its radius\n   237→        /// </summary>    \n   238→        [Tooltip(\"Minimum length of a step that the character can step on (used in Extra stepping method). Use this to let the character step on steps that are smaller that its radius\")]\n   239→        public float MinRequiredStepDepth = 0.1f;\n   240→\n   241→\n   242→        [Header(\"Ledge settings\")]\n   243→        /// <summary>\n   244→        /// Handles properly detecting ledge information and grounding status, but has a performance cost.\n   245→        /// </summary>\n   246→        [Tooltip(\"Handles properly detecting ledge information and grounding status, but has a performance cost.\")]\n   247→        public bool LedgeAndDenivelationHandling = true;\n   248→        /// <summary>\n   249→        /// The distance from the capsule central axis at which the character can stand on a ledge and still be stable\n   250→        /// </summary>    \n   251→        [Tooltip(\"The distance from the capsule central axis at which the character can stand on a ledge and still be stable\")]\n   252→        public float MaxStableDistanceFromLedge = 0.5f;\n   253→        /// <summary>\n   254→        /// Prevents snapping to ground on ledges beyond a certain velocity\n   255→        /// </summary>    \n   256→        [Tooltip(\"Prevents snapping to ground on ledges beyond a certain velocity\")]\n   257→        public float MaxVelocityForLedgeSnap = 0f;\n   258→        /// <summary>\n   259→        /// The maximun downward slope angle change that the character can be subjected to and still be snapping to the ground\n   260→        /// </summary>    \n   261→        [Tooltip(\"The maximun downward slope angle change that the character can be subjected to and still be snapping to the ground\")]\n   262→        [Range(1f, 180f)]\n   263→        public float MaxStableDenivelationAngle = 180f;\n   264→\n   265→\n   266→        [Header(\"Rigidbody interaction settings\")]\n   267→        /// <summary>\n   268→        /// Handles properly being pushed by and standing on PhysicsMovers or dynamic rigidbodies. Also handles pushing dynamic rigidbodies\n   269→        /// </summary>\n   270→        [Tooltip(\"Handles properly being pushed by and standing on PhysicsMovers or dynamic rigidbodies. Also handles pushing dynamic rigidbodies\")]\n   271→        public bool InteractiveRigidbodyHandling = true;\n   272→        /// <summary>\n   273→        /// How the character interacts with non-kinematic rigidbodies. \\\"Kinematic\\\" mode means the character pushes the rigidbodies with infinite force (as a kinematic body would). \\\"SimulatedDynamic\\\" pushes the rigidbodies with a simulated mass value.\n   274→        /// </summary>\n   275→        [Tooltip(\"How the character interacts with non-kinematic rigidbodies. \\\"Kinematic\\\" mode means the character pushes the rigidbodies with infinite force (as a kinematic body would). \\\"SimulatedDynamic\\\" pushes the rigidbodies with a simulated mass value.\")]\n   276→        public RigidbodyInteractionType RigidbodyInteractionType;\n   277→        [Tooltip(\"Mass used for pushing bodies\")]\n   278→        public float SimulatedCharacterMass = 1f;\n   279→        /// <summary>\n   280→        /// Determines if the character preserves moving platform velocities when de-grounding from them\n   281→        /// </summary>\n   282→        [Tooltip(\"Determines if the character preserves moving platform velocities when de-grounding from them\")]\n   283→        public bool PreserveAttachedRigidbodyMomentum = true;\n   284→\n   285→\n   286→        [Header(\"Constraints settings\")]\n   287→        /// <summary>\n   288→        /// Determines if the character's movement uses the planar constraint\n   289→        /// </summary>\n   290→        [Tooltip(\"Determines if the character's movement uses the planar constraint\")]\n   291→        public bool HasPlanarConstraint = false;\n   292→        /// <summary>\n   293→        /// Defines the plane that the character's movement is constrained on, if HasMovementConstraintPlane is active\n   294→        /// </summary>\n   295→        [Tooltip(\"Defines the plane that the character's movement is constrained on, if HasMovementConstraintPlane is active\")]\n   296→        public Vector3 PlanarConstraintAxis = Vector3.forward;\n   297→\n   298→        [Header(\"Other settings\")]\n   299→        /// <summary>\n   300→        /// How many times can we sweep for movement per update\n   301→        /// </summary>\n   302→        [Tooltip(\"How many times can we sweep for movement per update\")]\n   303→        public int MaxMovementIterations = 5;\n   304→        /// <summary>\n   305→        /// How many times can we check for decollision per update\n   306→        /// </summary>\n   307→        [Tooltip(\"How many times can we check for decollision per update\")]\n   308→        public int MaxDecollisionIterations = 1;\n   309→        /// <summary>\n   310→        /// Checks for overlaps before casting movement, making sure all collisions are detected even when already intersecting geometry (has a performance cost, but provides safety against tunneling through colliders)\n   311→        /// </summary>\n   312→        [Tooltip(\"Checks for overlaps before casting movement, making sure all collisions are detected even when already intersecting geometry (has a performance cost, but provides safety against tunneling through colliders)\")]\n   313→        public bool CheckMovementInitialOverlaps = true;\n   314→        /// <summary>\n   315→        /// Sets the velocity to zero if exceed max movement iterations\n   316→        /// </summary>\n   317→        [Tooltip(\"Sets the velocity to zero if exceed max movement iterations\")]\n   318→        public bool KillVelocityWhenExceedMaxMovementIterations = true;\n   319→        /// <summary>\n   320→        /// Sets the remaining movement to zero if exceed max movement iterations\n   321→        /// </summary>\n   322→        [Tooltip(\"Sets the remaining movement to zero if exceed max movement iterations\")]\n   323→        public bool KillRemainingMovementWhenExceedMaxMovementIterations = true;\n   324→\n   325→        /// <summary>\n   326→        /// Contains the current grounding information\n   327→        /// </summary>\n   328→        [System.NonSerialized]\n   329→        public CharacterGroundingReport GroundingStatus = new CharacterGroundingReport();\n   330→        /// <summary>\n   331→        /// Contains the previous grounding information\n   332→        /// </summary>\n   333→        [System.NonSerialized]\n   334→        public CharacterTransientGroundingReport LastGroundingStatus = new CharacterTransientGroundingReport();\n   335→        /// <summary>\n   336→        /// Specifies the LayerMask that the character's movement algorithm can detect collisions with. By default, this uses the rigidbody's layer's collision matrix\n   337→        /// </summary>\n   338→        [System.NonSerialized]\n   339→        public LayerMask CollidableLayers = -1;\n   340→\n   341→        /// <summary>\n   342→        /// The Transform of the character motor\n   343→        /// </summary>\n   344→        public Transform Transform { get { return _transform; } }\n   345→        private Transform _transform;\n   346→        /// <summary>\n   347→        /// The character's goal position in its movement calculations (always up-to-date during the character update phase)\n   348→        /// </summary>\n   349→        public Vector3 TransientPosition { get { return _transientPosition; } }\n   350→        private Vector3 _transientPosition;\n   351→        /// <summary>\n   352→        /// The character's up direction (always up-to-date during the character update phase)\n   353→        /// </summary>\n   354→        public Vector3 CharacterUp { get { return _characterUp; } }\n   355→        private Vector3 _characterUp;\n   356→        /// <summary>\n   357→        /// The character's forward direction (always up-to-date during the character update phase)\n   358→        /// </summary>\n   359→        public Vector3 CharacterForward { get { return _characterForward; } }\n   360→        private Vector3 _characterForward;\n   361→        /// <summary>\n   362→        /// The character's right direction (always up-to-date during the character update phase)\n   363→        /// </summary>\n   364→        public Vector3 CharacterRight { get { return _characterRight; } }\n   365→        private Vector3 _characterRight;\n   366→        /// <summary>\n   367→        /// The character's position before the movement calculations began\n   368→        /// </summary>\n   369→        public Vector3 InitialSimulationPosition { get { return _initialSimulationPosition; } }\n   370→        private Vector3 _initialSimulationPosition;\n   371→        /// <summary>\n   372→        /// The character's rotation before the movement calculations began\n   373→        /// </summary>\n   374→        public Quaternion InitialSimulationRotation { get { return _initialSimulationRotation; } }\n   375→        private Quaternion _initialSimulationRotation;\n   376→        /// <summary>\n   377→        /// Represents the Rigidbody to stay attached to\n   378→        /// </summary>\n   379→        public Rigidbody AttachedRigidbody { get { return _attachedRigidbody; } }\n   380→        private Rigidbody _attachedRigidbody;\n   381→        /// <summary>\n   382→        /// Vector3 from the character transform position to the capsule center\n   383→        /// </summary>\n   384→        public Vector3 CharacterTransformToCapsuleCenter { get { return _characterTransformToCapsuleCenter; } }\n   385→        private Vector3 _characterTransformToCapsuleCenter;\n   386→        /// <summary>\n   387→        /// Vector3 from the character transform position to the capsule bottom\n   388→        /// </summary>\n   389→        public Vector3 CharacterTransformToCapsuleBottom { get { return _characterTransformToCapsuleBottom; } }\n   390→        private Vector3 _characterTransformToCapsuleBottom;\n   391→        /// <summary>\n   392→        /// Vector3 from the character transform position to the capsule top\n   393→        /// </summary>\n   394→        public Vector3 CharacterTransformToCapsuleTop { get { return _characterTransformToCapsuleTop; } }\n   395→        private Vector3 _characterTransformToCapsuleTop;\n   396→        /// <summary>\n   397→        /// Vector3 from the character transform position to the capsule bottom hemi center\n   398→        /// </summary>\n   399→        public Vector3 CharacterTransformToCapsuleBottomHemi { get { return _characterTransformToCapsuleBottomHemi; } }\n   400→        private Vector3 _characterTransformToCapsuleBottomHemi;\n   401→        /// <summary>\n   402→        /// Vector3 from the character transform position to the capsule top hemi center\n   403→        /// </summary>\n   404→        public Vector3 CharacterTransformToCapsuleTopHemi { get { return _characterTransformToCapsuleTopHemi; } }\n   405→        private Vector3 _characterTransformToCapsuleTopHemi;\n   406→        /// <summary>\n   407→        /// The character's velocity resulting from standing on rigidbodies or PhysicsMover\n   408→        /// </summary>\n   409→        public Vector3 AttachedRigidbodyVelocity { get { return _attachedRigidbodyVelocity; } }\n   410→        private Vector3 _attachedRigidbodyVelocity;\n   411→        /// <summary>\n   412→        /// The number of overlaps detected so far during character update (is reset at the beginning of the update)\n   413→        /// </summary>\n   414→        public int OverlapsCount { get { return _overlapsCount; } }\n   415→        private int _overlapsCount;\n   416→        /// <summary>\n   417→        /// The overlaps detected so far during character update\n   418→        /// </summary>\n   419→        public OverlapResult[] Overlaps { get { return _overlaps; } }\n   420→        private OverlapResult[] _overlaps = new OverlapResult[MaxRigidbodyOverlapsCount];\n   421→\n   422→        /// <summary>\n   423→        /// The motor's assigned controller\n   424→        /// </summary>\n   425→        [NonSerialized]\n   426→        public ICharacterController CharacterController;\n   427→        /// <summary>\n   428→        /// Did the motor's last swept collision detection find a ground?\n   429→        /// </summary>\n   430→        [NonSerialized]\n   431→        public bool LastMovementIterationFoundAnyGround;\n   432→        /// <summary>\n   433→        /// Index of this motor in KinematicCharacterSystem arrays\n   434→        /// </summary>\n   435→        [NonSerialized]\n   436→        public int IndexInCharacterSystem;\n   437→        /// <summary>\n   438→        /// Remembers initial position before all simulation are done\n   439→        /// </summary>\n   440→        [NonSerialized]\n   441→        public Vector3 InitialTickPosition;\n   442→        /// <summary>\n   443→        /// Remembers initial rotation before all simulation are done\n   444→        /// </summary>\n   445→        [NonSerialized]\n   446→        public Quaternion InitialTickRotation;\n   447→        /// <summary>\n   448→        /// Specifies a Rigidbody to stay attached to\n   449→        /// </summary>\n   450→        [NonSerialized]\n   451→        public Rigidbody AttachedRigidbodyOverride;\n   452→        /// <summary>\n   453→        /// The character's velocity resulting from direct movement\n   454→        /// </summary>\n   455→        [NonSerialized]\n   456→        public Vector3 BaseVelocity;\n   457→\n   458→        // Private\n   459→        private RaycastHit[] _internalCharacterHits = new RaycastHit[MaxHitsBudget];\n   460→        private Collider[] _internalProbedColliders = new Collider[MaxCollisionBudget];\n   461→        private List<Rigidbody> _rigidbodiesPushedThisMove = new List<Rigidbody>(16);\n   462→        private RigidbodyProjectionHit[] _internalRigidbodyProjectionHits = new RigidbodyProjectionHit[MaxRigidbodyOverlapsCount];\n   463→        private Rigidbody _lastAttachedRigidbody;\n   464→        private bool _solveMovementCollisions = true;\n   465→        private bool _solveGrounding = true;\n   466→        private bool _movePositionDirty = false;\n   467→        private Vector3 _movePositionTarget = Vector3.zero;\n   468→        private bool _moveRotationDirty = false;\n   469→        private Quaternion _moveRotationTarget = Quaternion.identity;\n   470→        private bool _lastSolvedOverlapNormalDirty = false;\n   471→        private Vector3 _lastSolvedOverlapNormal = Vector3.forward;\n   472→        private int _rigidbodyProjectionHitCount = 0;\n   473→        private bool _isMovingFromAttachedRigidbody = false;\n   474→        private bool _mustUnground = false;\n   475→        private float _mustUngroundTimeCounter = 0f;\n   476→        private Vector3 _cachedWorldUp = Vector3.up;\n   477→        private Vector3 _cachedWorldForward = Vector3.forward;\n   478→        private Vector3 _cachedWorldRight = Vector3.right;\n   479→        private Vector3 _cachedZeroVector = Vector3.zero;\n   480→\n   481→        private Quaternion _transientRotation;\n   482→        /// <summary>\n   483→        /// The character's goal rotation in its movement calculations (always up-to-date during the character update phase)\n   484→        /// </summary>\n   485→        public Quaternion TransientRotation\n   486→        {\n   487→            get\n   488→            {\n   489→                return _transientRotation;\n   490→            }\n   491→            private set\n   492→            {\n   493→                _transientRotation = value;\n   494→                _characterUp = _transientRotation * _cachedWorldUp;\n   495→                _characterForward = _transientRotation * _cachedWorldForward;\n   496→                _characterRight = _transientRotation * _cachedWorldRight;\n   497→            }\n   498→        }\n   499→\n   500→        /// <summary>\n   501→        /// The character's total velocity, including velocity from standing on rigidbodies or PhysicsMover\n   502→        /// </summary>\n   503→        public Vector3 Velocity\n   504→        {\n   505→            get\n   506→            {\n   507→                return BaseVelocity + _attachedRigidbodyVelocity;\n   508→            }\n   509→        }\n   510→\n   511→        // Warning: Don't touch these constants unless you know exactly what you're doing!\n   512→        public const int MaxHitsBudget = 16;\n   513→        public const int MaxCollisionBudget = 16;\n   514→        public const int MaxGroundingSweepIterations = 2;\n   515→        public const int MaxSteppingSweepIterations = 3;\n   516→        public const int MaxRigidbodyOverlapsCount = 16;\n   517→        public const float CollisionOffset = 0.01f;\n   518→        public const float GroundProbeReboundDistance = 0.02f;\n   519→        public const float MinimumGroundProbingDistance = 0.005f;\n   520→        public const float GroundProbingBackstepDistance = 0.1f;\n   521→        public const float SweepProbingBackstepDistance = 0.002f;\n   522→        public const float SecondaryProbesVertical = 0.02f;\n   523→        public const float SecondaryProbesHorizontal = 0.001f;\n   524→        public const float MinVelocityMagnitude = 0.01f;\n   525→        public const float SteppingForwardDistance = 0.03f;\n   526→        public const float MinDistanceForLedge = 0.05f;\n   527→        public const float CorrelationForVerticalObstruction = 0.01f;\n   528→        public const float ExtraSteppingForwardDistance = 0.01f;\n   529→        public const float ExtraStepHeightPadding = 0.01f;\n   530→#pragma warning restore 0414 \n   531→\n   532→        private void OnEnable()\n   533→        {\n   534→            KinematicCharacterSystem.EnsureCreation();\n   535→            KinematicCharacterSystem.RegisterCharacterMotor(this);\n   536→        }\n   537→\n   538→        private void OnDisable()\n   539→        {\n   540→            KinematicCharacterSystem.UnregisterCharacterMotor(this);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"faaaba7c-6cfd-4997-ab68-779e65aa379f","timestamp":"2025-12-19T10:13:12.951Z","toolUseResult":{"type":"text","file":{"filePath":"e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs","content":"﻿using System;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nnamespace KinematicCharacterController\n{\n    public enum RigidbodyInteractionType\n    {\n        None,\n        Kinematic,\n        SimulatedDynamic\n    }\n\n    public enum StepHandlingMethod\n    {\n        None,\n        Standard,\n        Extra\n    }\n\n    public enum MovementSweepState\n    {\n        Initial,\n        AfterFirstHit,\n        FoundBlockingCrease,\n        FoundBlockingCorner,\n    }\n\n    /// <summary>\n    /// Represents the entire state of a character motor that is pertinent for simulation.\n    /// Use this to save state or revert to past state\n    /// </summary>\n    [System.Serializable]\n    public struct KinematicCharacterMotorState\n    {\n        public Vector3 Position;\n        public Quaternion Rotation;\n        public Vector3 BaseVelocity;\n\n        public bool MustUnground;\n        public float MustUngroundTime;\n        public bool LastMovementIterationFoundAnyGround;\n        public CharacterTransientGroundingReport GroundingStatus;\n\n        public Rigidbody AttachedRigidbody;\n        public Vector3 AttachedRigidbodyVelocity;\n    }\n\n    /// <summary>\n    /// Describes an overlap between the character capsule and another collider\n    /// </summary>\n    public struct OverlapResult\n    {\n        public Vector3 Normal;\n        public Collider Collider;\n\n        public OverlapResult(Vector3 normal, Collider collider)\n        {\n            Normal = normal;\n            Collider = collider;\n        }\n    }\n\n    /// <summary>\n    /// Contains all the information for the motor's grounding status\n    /// </summary>\n    public struct CharacterGroundingReport\n    {\n        public bool FoundAnyGround;\n        public bool IsStableOnGround;\n        public bool SnappingPrevented;\n        public Vector3 GroundNormal;\n        public Vector3 InnerGroundNormal;\n        public Vector3 OuterGroundNormal;\n\n        public Collider GroundCollider;\n        public Vector3 GroundPoint;\n\n        public void CopyFrom(CharacterTransientGroundingReport transientGroundingReport)\n        {\n            FoundAnyGround = transientGroundingReport.FoundAnyGround;\n            IsStableOnGround = transientGroundingReport.IsStableOnGround;\n            SnappingPrevented = transientGroundingReport.SnappingPrevented;\n            GroundNormal = transientGroundingReport.GroundNormal;\n            InnerGroundNormal = transientGroundingReport.InnerGroundNormal;\n            OuterGroundNormal = transientGroundingReport.OuterGroundNormal;\n\n            GroundCollider = null;\n            GroundPoint = Vector3.zero;\n        }\n    }\n\n    /// <summary>\n    /// Contains the simulation-relevant information for the motor's grounding status\n    /// </summary>\n    public struct CharacterTransientGroundingReport\n    {\n        public bool FoundAnyGround;\n        public bool IsStableOnGround;\n        public bool SnappingPrevented;\n        public Vector3 GroundNormal;\n        public Vector3 InnerGroundNormal;\n        public Vector3 OuterGroundNormal;\n\n        public void CopyFrom(CharacterGroundingReport groundingReport)\n        {\n            FoundAnyGround = groundingReport.FoundAnyGround;\n            IsStableOnGround = groundingReport.IsStableOnGround;\n            SnappingPrevented = groundingReport.SnappingPrevented;\n            GroundNormal = groundingReport.GroundNormal;\n            InnerGroundNormal = groundingReport.InnerGroundNormal;\n            OuterGroundNormal = groundingReport.OuterGroundNormal;\n        }\n    }\n\n    /// <summary>\n    /// Contains all the information from a hit stability evaluation\n    /// </summary>\n    public struct HitStabilityReport\n    {\n        public bool IsStable;\n\n        public bool FoundInnerNormal;\n        public Vector3 InnerNormal;\n        public bool FoundOuterNormal;\n        public Vector3 OuterNormal;\n\n        public bool ValidStepDetected;\n        public Collider SteppedCollider;\n\n        public bool LedgeDetected;\n        public bool IsOnEmptySideOfLedge;\n        public float DistanceFromLedge;\n        public bool IsMovingTowardsEmptySideOfLedge;\n        public Vector3 LedgeGroundNormal;\n        public Vector3 LedgeRightDirection;\n        public Vector3 LedgeFacingDirection;\n    }\n\n    /// <summary>\n    /// Contains the information of hit rigidbodies during the movement phase, so they can be processed afterwards\n    /// </summary>\n    public struct RigidbodyProjectionHit\n    {\n        public Rigidbody Rigidbody;\n        public Vector3 HitPoint;\n        public Vector3 EffectiveHitNormal;\n        public Vector3 HitVelocity;\n        public bool StableOnHit;\n    }\n\n    /// <summary>\n    /// Component that manages character collisions and movement solving\n    /// </summary>\n    [RequireComponent(typeof(CapsuleCollider))]\n    public class KinematicCharacterMotor : MonoBehaviour\n    {\n#pragma warning disable 0414\n        [Header(\"Components\")]\n        /// <summary>\n        /// The capsule collider of this motor\n        /// </summary>\n        [ReadOnly]\n        public CapsuleCollider Capsule;\n\n        [Header(\"Capsule Settings\")]\n        /// <summary>\n        /// Radius of the character's capsule\n        /// </summary>\n        [SerializeField]\n        [Tooltip(\"Radius of the Character Capsule\")]\n        private float CapsuleRadius = 0.5f;\n        /// <summary>\n        /// Height of the character's capsule\n        /// </summary>\n        [SerializeField]\n        [Tooltip(\"Height of the Character Capsule\")]\n        private float CapsuleHeight = 2f;\n        /// <summary>\n        /// Local y position of the character's capsule center\n        /// </summary>\n        [SerializeField]\n        [Tooltip(\"Height of the Character Capsule\")]\n        private float CapsuleYOffset = 1f;\n        /// <summary>\n        /// Physics material of the character's capsule\n        /// </summary>\n        [SerializeField]\n        [Tooltip(\"Physics material of the Character Capsule (Does not affect character movement. Only affects things colliding with it)\")]\n#pragma warning disable 0649\n        private PhysicsMaterial CapsulePhysicsMaterial;\n#pragma warning restore 0649\n\n\n        [Header(\"Grounding settings\")]\n        /// <summary>\n        /// Increases the range of ground detection, to allow snapping to ground at very high speeds\n        /// </summary>    \n        [Tooltip(\"Increases the range of ground detection, to allow snapping to ground at very high speeds\")]\n        public float GroundDetectionExtraDistance = 0f;\n        /// <summary>\n        /// Maximum slope angle on which the character can be stable\n        /// </summary>    \n        [Range(0f, 89f)]\n        [Tooltip(\"Maximum slope angle on which the character can be stable\")]\n        public float MaxStableSlopeAngle = 60f;\n        /// <summary>\n        /// Which layers can the character be considered stable on\n        /// </summary>    \n        [Tooltip(\"Which layers can the character be considered stable on\")]\n        public LayerMask StableGroundLayers = -1;\n        /// <summary>\n        /// Notifies the Character Controller when discrete collisions are detected\n        /// </summary>    \n        [Tooltip(\"Notifies the Character Controller when discrete collisions are detected\")]\n        public bool DiscreteCollisionEvents = false;\n\n\n        [Header(\"Step settings\")]\n        /// <summary>\n        /// Handles properly detecting grounding status on steps, but has a performance cost.\n        /// </summary>\n        [Tooltip(\"Handles properly detecting grounding status on steps, but has a performance cost.\")]\n        public StepHandlingMethod StepHandling = StepHandlingMethod.Standard;\n        /// <summary>\n        /// Maximum height of a step which the character can climb\n        /// </summary>    \n        [Tooltip(\"Maximum height of a step which the character can climb\")]\n        public float MaxStepHeight = 0.5f;\n        /// <summary>\n        /// Can the character step up obstacles even if it is not currently stable?\n        /// </summary>    \n        [Tooltip(\"Can the character step up obstacles even if it is not currently stable?\")]\n        public bool AllowSteppingWithoutStableGrounding = false;\n        /// <summary>\n        /// Minimum length of a step that the character can step on (used in Extra stepping method. Use this to let the character step on steps that are smaller that its radius\n        /// </summary>    \n        [Tooltip(\"Minimum length of a step that the character can step on (used in Extra stepping method). Use this to let the character step on steps that are smaller that its radius\")]\n        public float MinRequiredStepDepth = 0.1f;\n\n\n        [Header(\"Ledge settings\")]\n        /// <summary>\n        /// Handles properly detecting ledge information and grounding status, but has a performance cost.\n        /// </summary>\n        [Tooltip(\"Handles properly detecting ledge information and grounding status, but has a performance cost.\")]\n        public bool LedgeAndDenivelationHandling = true;\n        /// <summary>\n        /// The distance from the capsule central axis at which the character can stand on a ledge and still be stable\n        /// </summary>    \n        [Tooltip(\"The distance from the capsule central axis at which the character can stand on a ledge and still be stable\")]\n        public float MaxStableDistanceFromLedge = 0.5f;\n        /// <summary>\n        /// Prevents snapping to ground on ledges beyond a certain velocity\n        /// </summary>    \n        [Tooltip(\"Prevents snapping to ground on ledges beyond a certain velocity\")]\n        public float MaxVelocityForLedgeSnap = 0f;\n        /// <summary>\n        /// The maximun downward slope angle change that the character can be subjected to and still be snapping to the ground\n        /// </summary>    \n        [Tooltip(\"The maximun downward slope angle change that the character can be subjected to and still be snapping to the ground\")]\n        [Range(1f, 180f)]\n        public float MaxStableDenivelationAngle = 180f;\n\n\n        [Header(\"Rigidbody interaction settings\")]\n        /// <summary>\n        /// Handles properly being pushed by and standing on PhysicsMovers or dynamic rigidbodies. Also handles pushing dynamic rigidbodies\n        /// </summary>\n        [Tooltip(\"Handles properly being pushed by and standing on PhysicsMovers or dynamic rigidbodies. Also handles pushing dynamic rigidbodies\")]\n        public bool InteractiveRigidbodyHandling = true;\n        /// <summary>\n        /// How the character interacts with non-kinematic rigidbodies. \\\"Kinematic\\\" mode means the character pushes the rigidbodies with infinite force (as a kinematic body would). \\\"SimulatedDynamic\\\" pushes the rigidbodies with a simulated mass value.\n        /// </summary>\n        [Tooltip(\"How the character interacts with non-kinematic rigidbodies. \\\"Kinematic\\\" mode means the character pushes the rigidbodies with infinite force (as a kinematic body would). \\\"SimulatedDynamic\\\" pushes the rigidbodies with a simulated mass value.\")]\n        public RigidbodyInteractionType RigidbodyInteractionType;\n        [Tooltip(\"Mass used for pushing bodies\")]\n        public float SimulatedCharacterMass = 1f;\n        /// <summary>\n        /// Determines if the character preserves moving platform velocities when de-grounding from them\n        /// </summary>\n        [Tooltip(\"Determines if the character preserves moving platform velocities when de-grounding from them\")]\n        public bool PreserveAttachedRigidbodyMomentum = true;\n\n\n        [Header(\"Constraints settings\")]\n        /// <summary>\n        /// Determines if the character's movement uses the planar constraint\n        /// </summary>\n        [Tooltip(\"Determines if the character's movement uses the planar constraint\")]\n        public bool HasPlanarConstraint = false;\n        /// <summary>\n        /// Defines the plane that the character's movement is constrained on, if HasMovementConstraintPlane is active\n        /// </summary>\n        [Tooltip(\"Defines the plane that the character's movement is constrained on, if HasMovementConstraintPlane is active\")]\n        public Vector3 PlanarConstraintAxis = Vector3.forward;\n\n        [Header(\"Other settings\")]\n        /// <summary>\n        /// How many times can we sweep for movement per update\n        /// </summary>\n        [Tooltip(\"How many times can we sweep for movement per update\")]\n        public int MaxMovementIterations = 5;\n        /// <summary>\n        /// How many times can we check for decollision per update\n        /// </summary>\n        [Tooltip(\"How many times can we check for decollision per update\")]\n        public int MaxDecollisionIterations = 1;\n        /// <summary>\n        /// Checks for overlaps before casting movement, making sure all collisions are detected even when already intersecting geometry (has a performance cost, but provides safety against tunneling through colliders)\n        /// </summary>\n        [Tooltip(\"Checks for overlaps before casting movement, making sure all collisions are detected even when already intersecting geometry (has a performance cost, but provides safety against tunneling through colliders)\")]\n        public bool CheckMovementInitialOverlaps = true;\n        /// <summary>\n        /// Sets the velocity to zero if exceed max movement iterations\n        /// </summary>\n        [Tooltip(\"Sets the velocity to zero if exceed max movement iterations\")]\n        public bool KillVelocityWhenExceedMaxMovementIterations = true;\n        /// <summary>\n        /// Sets the remaining movement to zero if exceed max movement iterations\n        /// </summary>\n        [Tooltip(\"Sets the remaining movement to zero if exceed max movement iterations\")]\n        public bool KillRemainingMovementWhenExceedMaxMovementIterations = true;\n\n        /// <summary>\n        /// Contains the current grounding information\n        /// </summary>\n        [System.NonSerialized]\n        public CharacterGroundingReport GroundingStatus = new CharacterGroundingReport();\n        /// <summary>\n        /// Contains the previous grounding information\n        /// </summary>\n        [System.NonSerialized]\n        public CharacterTransientGroundingReport LastGroundingStatus = new CharacterTransientGroundingReport();\n        /// <summary>\n        /// Specifies the LayerMask that the character's movement algorithm can detect collisions with. By default, this uses the rigidbody's layer's collision matrix\n        /// </summary>\n        [System.NonSerialized]\n        public LayerMask CollidableLayers = -1;\n\n        /// <summary>\n        /// The Transform of the character motor\n        /// </summary>\n        public Transform Transform { get { return _transform; } }\n        private Transform _transform;\n        /// <summary>\n        /// The character's goal position in its movement calculations (always up-to-date during the character update phase)\n        /// </summary>\n        public Vector3 TransientPosition { get { return _transientPosition; } }\n        private Vector3 _transientPosition;\n        /// <summary>\n        /// The character's up direction (always up-to-date during the character update phase)\n        /// </summary>\n        public Vector3 CharacterUp { get { return _characterUp; } }\n        private Vector3 _characterUp;\n        /// <summary>\n        /// The character's forward direction (always up-to-date during the character update phase)\n        /// </summary>\n        public Vector3 CharacterForward { get { return _characterForward; } }\n        private Vector3 _characterForward;\n        /// <summary>\n        /// The character's right direction (always up-to-date during the character update phase)\n        /// </summary>\n        public Vector3 CharacterRight { get { return _characterRight; } }\n        private Vector3 _characterRight;\n        /// <summary>\n        /// The character's position before the movement calculations began\n        /// </summary>\n        public Vector3 InitialSimulationPosition { get { return _initialSimulationPosition; } }\n        private Vector3 _initialSimulationPosition;\n        /// <summary>\n        /// The character's rotation before the movement calculations began\n        /// </summary>\n        public Quaternion InitialSimulationRotation { get { return _initialSimulationRotation; } }\n        private Quaternion _initialSimulationRotation;\n        /// <summary>\n        /// Represents the Rigidbody to stay attached to\n        /// </summary>\n        public Rigidbody AttachedRigidbody { get { return _attachedRigidbody; } }\n        private Rigidbody _attachedRigidbody;\n        /// <summary>\n        /// Vector3 from the character transform position to the capsule center\n        /// </summary>\n        public Vector3 CharacterTransformToCapsuleCenter { get { return _characterTransformToCapsuleCenter; } }\n        private Vector3 _characterTransformToCapsuleCenter;\n        /// <summary>\n        /// Vector3 from the character transform position to the capsule bottom\n        /// </summary>\n        public Vector3 CharacterTransformToCapsuleBottom { get { return _characterTransformToCapsuleBottom; } }\n        private Vector3 _characterTransformToCapsuleBottom;\n        /// <summary>\n        /// Vector3 from the character transform position to the capsule top\n        /// </summary>\n        public Vector3 CharacterTransformToCapsuleTop { get { return _characterTransformToCapsuleTop; } }\n        private Vector3 _characterTransformToCapsuleTop;\n        /// <summary>\n        /// Vector3 from the character transform position to the capsule bottom hemi center\n        /// </summary>\n        public Vector3 CharacterTransformToCapsuleBottomHemi { get { return _characterTransformToCapsuleBottomHemi; } }\n        private Vector3 _characterTransformToCapsuleBottomHemi;\n        /// <summary>\n        /// Vector3 from the character transform position to the capsule top hemi center\n        /// </summary>\n        public Vector3 CharacterTransformToCapsuleTopHemi { get { return _characterTransformToCapsuleTopHemi; } }\n        private Vector3 _characterTransformToCapsuleTopHemi;\n        /// <summary>\n        /// The character's velocity resulting from standing on rigidbodies or PhysicsMover\n        /// </summary>\n        public Vector3 AttachedRigidbodyVelocity { get { return _attachedRigidbodyVelocity; } }\n        private Vector3 _attachedRigidbodyVelocity;\n        /// <summary>\n        /// The number of overlaps detected so far during character update (is reset at the beginning of the update)\n        /// </summary>\n        public int OverlapsCount { get { return _overlapsCount; } }\n        private int _overlapsCount;\n        /// <summary>\n        /// The overlaps detected so far during character update\n        /// </summary>\n        public OverlapResult[] Overlaps { get { return _overlaps; } }\n        private OverlapResult[] _overlaps = new OverlapResult[MaxRigidbodyOverlapsCount];\n\n        /// <summary>\n        /// The motor's assigned controller\n        /// </summary>\n        [NonSerialized]\n        public ICharacterController CharacterController;\n        /// <summary>\n        /// Did the motor's last swept collision detection find a ground?\n        /// </summary>\n        [NonSerialized]\n        public bool LastMovementIterationFoundAnyGround;\n        /// <summary>\n        /// Index of this motor in KinematicCharacterSystem arrays\n        /// </summary>\n        [NonSerialized]\n        public int IndexInCharacterSystem;\n        /// <summary>\n        /// Remembers initial position before all simulation are done\n        /// </summary>\n        [NonSerialized]\n        public Vector3 InitialTickPosition;\n        /// <summary>\n        /// Remembers initial rotation before all simulation are done\n        /// </summary>\n        [NonSerialized]\n        public Quaternion InitialTickRotation;\n        /// <summary>\n        /// Specifies a Rigidbody to stay attached to\n        /// </summary>\n        [NonSerialized]\n        public Rigidbody AttachedRigidbodyOverride;\n        /// <summary>\n        /// The character's velocity resulting from direct movement\n        /// </summary>\n        [NonSerialized]\n        public Vector3 BaseVelocity;\n\n        // Private\n        private RaycastHit[] _internalCharacterHits = new RaycastHit[MaxHitsBudget];\n        private Collider[] _internalProbedColliders = new Collider[MaxCollisionBudget];\n        private List<Rigidbody> _rigidbodiesPushedThisMove = new List<Rigidbody>(16);\n        private RigidbodyProjectionHit[] _internalRigidbodyProjectionHits = new RigidbodyProjectionHit[MaxRigidbodyOverlapsCount];\n        private Rigidbody _lastAttachedRigidbody;\n        private bool _solveMovementCollisions = true;\n        private bool _solveGrounding = true;\n        private bool _movePositionDirty = false;\n        private Vector3 _movePositionTarget = Vector3.zero;\n        private bool _moveRotationDirty = false;\n        private Quaternion _moveRotationTarget = Quaternion.identity;\n        private bool _lastSolvedOverlapNormalDirty = false;\n        private Vector3 _lastSolvedOverlapNormal = Vector3.forward;\n        private int _rigidbodyProjectionHitCount = 0;\n        private bool _isMovingFromAttachedRigidbody = false;\n        private bool _mustUnground = false;\n        private float _mustUngroundTimeCounter = 0f;\n        private Vector3 _cachedWorldUp = Vector3.up;\n        private Vector3 _cachedWorldForward = Vector3.forward;\n        private Vector3 _cachedWorldRight = Vector3.right;\n        private Vector3 _cachedZeroVector = Vector3.zero;\n\n        private Quaternion _transientRotation;\n        /// <summary>\n        /// The character's goal rotation in its movement calculations (always up-to-date during the character update phase)\n        /// </summary>\n        public Quaternion TransientRotation\n        {\n            get\n            {\n                return _transientRotation;\n            }\n            private set\n            {\n                _transientRotation = value;\n                _characterUp = _transientRotation * _cachedWorldUp;\n                _characterForward = _transientRotation * _cachedWorldForward;\n                _characterRight = _transientRotation * _cachedWorldRight;\n            }\n        }\n\n        /// <summary>\n        /// The character's total velocity, including velocity from standing on rigidbodies or PhysicsMover\n        /// </summary>\n        public Vector3 Velocity\n        {\n            get\n            {\n                return BaseVelocity + _attachedRigidbodyVelocity;\n            }\n        }\n\n        // Warning: Don't touch these constants unless you know exactly what you're doing!\n        public const int MaxHitsBudget = 16;\n        public const int MaxCollisionBudget = 16;\n        public const int MaxGroundingSweepIterations = 2;\n        public const int MaxSteppingSweepIterations = 3;\n        public const int MaxRigidbodyOverlapsCount = 16;\n        public const float CollisionOffset = 0.01f;\n        public const float GroundProbeReboundDistance = 0.02f;\n        public const float MinimumGroundProbingDistance = 0.005f;\n        public const float GroundProbingBackstepDistance = 0.1f;\n        public const float SweepProbingBackstepDistance = 0.002f;\n        public const float SecondaryProbesVertical = 0.02f;\n        public const float SecondaryProbesHorizontal = 0.001f;\n        public const float MinVelocityMagnitude = 0.01f;\n        public const float SteppingForwardDistance = 0.03f;\n        public const float MinDistanceForLedge = 0.05f;\n        public const float CorrelationForVerticalObstruction = 0.01f;\n        public const float ExtraSteppingForwardDistance = 0.01f;\n        public const float ExtraStepHeightPadding = 0.01f;\n#pragma warning restore 0414 \n\n        private void OnEnable()\n        {\n            KinematicCharacterSystem.EnsureCreation();\n            KinematicCharacterSystem.RegisterCharacterMotor(this);\n        }\n\n        private void OnDisable()\n        {\n            KinematicCharacterSystem.UnregisterCharacterMotor(this);","numLines":540,"startLine":1,"totalLines":2689}}}
{"parentUuid":"faaaba7c-6cfd-4997-ab68-779e65aa379f","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BuaKcv2mNuYMLcb128YkmE","type":"tool_result","content":"   541→        }\n   542→\n   543→        private void Reset()\n   544→        {\n   545→            ValidateData();\n   546→        }\n   547→\n   548→        private void OnValidate()\n   549→        {\n   550→            ValidateData();\n   551→        }\n   552→\n   553→        [ContextMenu(\"Remove Component\")]\n   554→        private void HandleRemoveComponent()\n   555→        {\n   556→            CapsuleCollider tmpCapsule = gameObject.GetComponent<CapsuleCollider>();\n   557→            DestroyImmediate(this);\n   558→            DestroyImmediate(tmpCapsule);\n   559→        }\n   560→\n   561→        /// <summary>\n   562→        /// Handle validating all required values\n   563→        /// </summary>\n   564→        public void ValidateData()\n   565→        {\n   566→            Capsule = GetComponent<CapsuleCollider>();\n   567→            CapsuleRadius = Mathf.Clamp(CapsuleRadius, 0f, CapsuleHeight * 0.5f);\n   568→            Capsule.direction = 1;\n   569→            Capsule.sharedMaterial = CapsulePhysicsMaterial;\n   570→            SetCapsuleDimensions(CapsuleRadius, CapsuleHeight, CapsuleYOffset);\n   571→\n   572→            MaxStepHeight = Mathf.Clamp(MaxStepHeight, 0f, Mathf.Infinity);\n   573→            MinRequiredStepDepth = Mathf.Clamp(MinRequiredStepDepth, 0f, CapsuleRadius);\n   574→            MaxStableDistanceFromLedge = Mathf.Clamp(MaxStableDistanceFromLedge, 0f, CapsuleRadius);\n   575→\n   576→            transform.localScale = Vector3.one;\n   577→\n   578→#if UNITY_EDITOR\n   579→            Capsule.hideFlags = HideFlags.NotEditable;\n   580→            if (!Mathf.Approximately(transform.lossyScale.x, 1f) || !Mathf.Approximately(transform.lossyScale.y, 1f) || !Mathf.Approximately(transform.lossyScale.z, 1f))\n   581→            {\n   582→                Debug.LogError(\"Character's lossy scale is not (1,1,1). This is not allowed. Make sure the character's transform and all of its parents have a (1,1,1) scale.\", this.gameObject);\n   583→            }\n   584→#endif\n   585→        }\n   586→\n   587→        /// <summary>\n   588→        /// Sets whether or not the capsule collider will detect collisions\n   589→        /// </summary>\n   590→        public void SetCapsuleCollisionsActivation(bool collisionsActive)\n   591→        {\n   592→            Capsule.isTrigger = !collisionsActive;\n   593→        }\n   594→\n   595→        /// <summary>\n   596→        /// Sets whether or not the motor will solve collisions when moving (or moved onto)\n   597→        /// </summary>\n   598→        public void SetMovementCollisionsSolvingActivation(bool movementCollisionsSolvingActive)\n   599→        {\n   600→            _solveMovementCollisions = movementCollisionsSolvingActive;\n   601→        }\n   602→\n   603→        /// <summary>\n   604→        /// Sets whether or not grounding will be evaluated for all hits\n   605→        /// </summary>\n   606→        public void SetGroundSolvingActivation(bool stabilitySolvingActive)\n   607→        {\n   608→            _solveGrounding = stabilitySolvingActive;\n   609→        }\n   610→\n   611→        /// <summary>\n   612→        /// Sets the character's position directly\n   613→        /// </summary>\n   614→        public void SetPosition(Vector3 position, bool bypassInterpolation = true)\n   615→        {\n   616→            _transform.position = position;\n   617→            _initialSimulationPosition = position;\n   618→            _transientPosition = position;\n   619→\n   620→            if (bypassInterpolation)\n   621→            {\n   622→                InitialTickPosition = position;\n   623→            }\n   624→        }\n   625→\n   626→        /// <summary>\n   627→        /// Sets the character's rotation directly\n   628→        /// </summary>\n   629→        public void SetRotation(Quaternion rotation, bool bypassInterpolation = true)\n   630→        {\n   631→            _transform.rotation = rotation;\n   632→            _initialSimulationRotation = rotation;\n   633→            TransientRotation = rotation;\n   634→\n   635→            if (bypassInterpolation)\n   636→            {\n   637→                InitialTickRotation = rotation;\n   638→            }\n   639→        }\n   640→\n   641→        /// <summary>\n   642→        /// Sets the character's position and rotation directly\n   643→        /// </summary>\n   644→        public void SetPositionAndRotation(Vector3 position, Quaternion rotation, bool bypassInterpolation = true)\n   645→        {\n   646→            _transform.SetPositionAndRotation(position, rotation);\n   647→            _initialSimulationPosition = position;\n   648→            _initialSimulationRotation = rotation;\n   649→            _transientPosition = position;\n   650→            TransientRotation = rotation;\n   651→\n   652→            if (bypassInterpolation)\n   653→            {\n   654→                InitialTickPosition = position;\n   655→                InitialTickRotation = rotation;\n   656→            }\n   657→        }\n   658→\n   659→        /// <summary>\n   660→        /// Moves the character position, taking all movement collision solving int account. The actual move is done the next time the motor updates are called\n   661→        /// </summary>\n   662→        public void MoveCharacter(Vector3 toPosition)\n   663→        {\n   664→            _movePositionDirty = true;\n   665→            _movePositionTarget = toPosition;\n   666→        }\n   667→\n   668→        /// <summary>\n   669→        /// Moves the character rotation. The actual move is done the next time the motor updates are called\n   670→        /// </summary>\n   671→        public void RotateCharacter(Quaternion toRotation)\n   672→        {\n   673→            _moveRotationDirty = true;\n   674→            _moveRotationTarget = toRotation;\n   675→        }\n   676→\n   677→        /// <summary>\n   678→        /// Returns all the state information of the motor that is pertinent for simulation\n   679→        /// </summary>\n   680→        public KinematicCharacterMotorState GetState()\n   681→        {\n   682→            KinematicCharacterMotorState state = new KinematicCharacterMotorState();\n   683→\n   684→            state.Position = _transientPosition;\n   685→            state.Rotation = _transientRotation;\n   686→\n   687→            state.BaseVelocity = BaseVelocity;\n   688→            state.AttachedRigidbodyVelocity = _attachedRigidbodyVelocity;\n   689→\n   690→            state.MustUnground = _mustUnground;\n   691→            state.MustUngroundTime = _mustUngroundTimeCounter;\n   692→            state.LastMovementIterationFoundAnyGround = LastMovementIterationFoundAnyGround;\n   693→            state.GroundingStatus.CopyFrom(GroundingStatus);\n   694→            state.AttachedRigidbody = _attachedRigidbody;\n   695→\n   696→            return state;\n   697→        }\n   698→\n   699→        /// <summary>\n   700→        /// Applies a motor state instantly\n   701→        /// </summary>\n   702→        public void ApplyState(KinematicCharacterMotorState state, bool bypassInterpolation = true)\n   703→        {\n   704→            SetPositionAndRotation(state.Position, state.Rotation, bypassInterpolation);\n   705→\n   706→            BaseVelocity = state.BaseVelocity;\n   707→            _attachedRigidbodyVelocity = state.AttachedRigidbodyVelocity;\n   708→\n   709→            _mustUnground = state.MustUnground;\n   710→            _mustUngroundTimeCounter = state.MustUngroundTime;\n   711→            LastMovementIterationFoundAnyGround = state.LastMovementIterationFoundAnyGround;\n   712→            GroundingStatus.CopyFrom(state.GroundingStatus);\n   713→            _attachedRigidbody = state.AttachedRigidbody;\n   714→        }\n   715→\n   716→        /// <summary>\n   717→        /// Resizes capsule. ALso caches importand capsule size data\n   718→        /// </summary>\n   719→        public void SetCapsuleDimensions(float radius, float height, float yOffset)\n   720→        {\n   721→            height = Mathf.Max(height, (radius * 2f) + 0.01f); // Safety to prevent invalid capsule geometries\n   722→\n   723→            CapsuleRadius = radius;\n   724→            CapsuleHeight = height;\n   725→            CapsuleYOffset = yOffset;\n   726→\n   727→            Capsule.radius = CapsuleRadius;\n   728→            Capsule.height = Mathf.Clamp(CapsuleHeight, CapsuleRadius * 2f, CapsuleHeight);\n   729→            Capsule.center = new Vector3(0f, CapsuleYOffset, 0f);\n   730→\n   731→            _characterTransformToCapsuleCenter = Capsule.center;\n   732→            _characterTransformToCapsuleBottom = Capsule.center + (-_cachedWorldUp * (Capsule.height * 0.5f));\n   733→            _characterTransformToCapsuleTop = Capsule.center + (_cachedWorldUp * (Capsule.height * 0.5f));\n   734→            _characterTransformToCapsuleBottomHemi = Capsule.center + (-_cachedWorldUp * (Capsule.height * 0.5f)) + (_cachedWorldUp * Capsule.radius);\n   735→            _characterTransformToCapsuleTopHemi = Capsule.center + (_cachedWorldUp * (Capsule.height * 0.5f)) + (-_cachedWorldUp * Capsule.radius);\n   736→        }\n   737→\n   738→        private void Awake()\n   739→        {\n   740→            _transform = this.transform;\n   741→            ValidateData();\n   742→\n   743→            _transientPosition = _transform.position;\n   744→            TransientRotation = _transform.rotation;\n   745→\n   746→            // Build CollidableLayers mask\n   747→            CollidableLayers = 0;\n   748→            for (int i = 0; i < 32; i++)\n   749→            {\n   750→                if (!Physics.GetIgnoreLayerCollision(this.gameObject.layer, i))\n   751→                {\n   752→                    CollidableLayers |= (1 << i);\n   753→                }\n   754→            }\n   755→\n   756→            SetCapsuleDimensions(CapsuleRadius, CapsuleHeight, CapsuleYOffset);\n   757→        }\n   758→\n   759→        /// <summary>\n   760→        /// Update phase 1 is meant to be called after physics movers have calculated their velocities, but\n   761→        /// before they have simulated their goal positions/rotations. It is responsible for:\n   762→        /// - Initializing all values for update\n   763→        /// - Handling MovePosition calls\n   764→        /// - Solving initial collision overlaps\n   765→        /// - Ground probing\n   766→        /// - Handle detecting potential interactable rigidbodies\n   767→        /// </summary>\n   768→        public void UpdatePhase1(float deltaTime)\n   769→        {\n   770→            // NaN propagation safety stop\n   771→            if (float.IsNaN(BaseVelocity.x) || float.IsNaN(BaseVelocity.y) || float.IsNaN(BaseVelocity.z))\n   772→            {\n   773→                BaseVelocity = Vector3.zero;\n   774→            }\n   775→            if (float.IsNaN(_attachedRigidbodyVelocity.x) || float.IsNaN(_attachedRigidbodyVelocity.y) || float.IsNaN(_attachedRigidbodyVelocity.z))\n   776→            {\n   777→                _attachedRigidbodyVelocity = Vector3.zero;\n   778→            }\n   779→\n   780→#if UNITY_EDITOR\n   781→            if (!Mathf.Approximately(_transform.lossyScale.x, 1f) || !Mathf.Approximately(_transform.lossyScale.y, 1f) || !Mathf.Approximately(_transform.lossyScale.z, 1f))\n   782→            {\n   783→                Debug.LogError(\"Character's lossy scale is not (1,1,1). This is not allowed. Make sure the character's transform and all of its parents have a (1,1,1) scale.\", this.gameObject);\n   784→            }\n   785→#endif\n   786→\n   787→            _rigidbodiesPushedThisMove.Clear();\n   788→\n   789→            // Before update\n   790→            CharacterController.BeforeCharacterUpdate(deltaTime);\n   791→\n   792→            _transientPosition = _transform.position;\n   793→            TransientRotation = _transform.rotation;\n   794→            _initialSimulationPosition = _transientPosition;\n   795→            _initialSimulationRotation = _transientRotation;\n   796→            _rigidbodyProjectionHitCount = 0;\n   797→            _overlapsCount = 0;\n   798→            _lastSolvedOverlapNormalDirty = false;\n   799→\n   800→            #region Handle Move Position\n   801→            if (_movePositionDirty)\n   802→            {\n   803→                if (_solveMovementCollisions)\n   804→                {\n   805→                    Vector3 tmpVelocity = GetVelocityFromMovement(_movePositionTarget - _transientPosition, deltaTime);\n   806→                    if (InternalCharacterMove(ref tmpVelocity, deltaTime))\n   807→                    {\n   808→                        if (InteractiveRigidbodyHandling)\n   809→                        {\n   810→                            ProcessVelocityForRigidbodyHits(ref tmpVelocity, deltaTime);\n   811→                        }\n   812→                    }\n   813→                }\n   814→                else\n   815→                {\n   816→                    _transientPosition = _movePositionTarget;\n   817→                }\n   818→\n   819→                _movePositionDirty = false;\n   820→            }\n   821→            #endregion\n   822→\n   823→            LastGroundingStatus.CopyFrom(GroundingStatus);\n   824→            GroundingStatus = new CharacterGroundingReport();\n   825→            GroundingStatus.GroundNormal = _characterUp;\n   826→\n   827→            if (_solveMovementCollisions)\n   828→            {\n   829→                #region Resolve initial overlaps\n   830→                Vector3 resolutionDirection = _cachedWorldUp;\n   831→                float resolutionDistance = 0f;\n   832→                int iterationsMade = 0;\n   833→                bool overlapSolved = false;\n   834→                while (iterationsMade < MaxDecollisionIterations && !overlapSolved)\n   835→                {\n   836→                    int nbOverlaps = CharacterCollisionsOverlap(_transientPosition, _transientRotation, _internalProbedColliders);\n   837→\n   838→                    if (nbOverlaps > 0)\n   839→                    {\n   840→                        // Solve overlaps that aren't against dynamic rigidbodies or physics movers\n   841→                        for (int i = 0; i < nbOverlaps; i++)\n   842→                        {\n   843→                            if (GetInteractiveRigidbody(_internalProbedColliders[i]) == null)\n   844→                            {\n   845→                                // Process overlap\n   846→                                Transform overlappedTransform = _internalProbedColliders[i].GetComponent<Transform>();\n   847→                                if (Physics.ComputePenetration(\n   848→                                        Capsule,\n   849→                                        _transientPosition,\n   850→                                        _transientRotation,\n   851→                                        _internalProbedColliders[i],\n   852→                                        overlappedTransform.position,\n   853→                                        overlappedTransform.rotation,\n   854→                                        out resolutionDirection,\n   855→                                        out resolutionDistance))\n   856→                                {\n   857→                                    // Resolve along obstruction direction\n   858→                                    HitStabilityReport mockReport = new HitStabilityReport();\n   859→                                    mockReport.IsStable = IsStableOnNormal(resolutionDirection);\n   860→                                    resolutionDirection = GetObstructionNormal(resolutionDirection, mockReport.IsStable);\n   861→\n   862→                                    // Solve overlap\n   863→                                    Vector3 resolutionMovement = resolutionDirection * (resolutionDistance + CollisionOffset);\n   864→                                    _transientPosition += resolutionMovement;\n   865→\n   866→                                    // Remember overlaps\n   867→                                    if (_overlapsCount < _overlaps.Length)\n   868→                                    {\n   869→                                        _overlaps[_overlapsCount] = new OverlapResult(resolutionDirection, _internalProbedColliders[i]);\n   870→                                        _overlapsCount++;\n   871→                                    }\n   872→\n   873→                                    break;\n   874→                                }\n   875→                            }\n   876→                        }\n   877→                    }\n   878→                    else\n   879→                    {\n   880→                        overlapSolved = true;\n   881→                    }\n   882→\n   883→                    iterationsMade++;\n   884→                }\n   885→                #endregion\n   886→            }\n   887→\n   888→            #region Ground Probing and Snapping\n   889→            // Handle ungrounding\n   890→            if (_solveGrounding)\n   891→            {\n   892→                if (MustUnground())\n   893→                {\n   894→                    _transientPosition += _characterUp * (MinimumGroundProbingDistance * 1.5f);\n   895→                }\n   896→                else\n   897→                {\n   898→                    // Choose the appropriate ground probing distance\n   899→                    float selectedGroundProbingDistance = MinimumGroundProbingDistance;\n   900→                    if (!LastGroundingStatus.SnappingPrevented && (LastGroundingStatus.IsStableOnGround || LastMovementIterationFoundAnyGround))\n   901→                    {\n   902→                        if (StepHandling != StepHandlingMethod.None)\n   903→                        {\n   904→                            selectedGroundProbingDistance = Mathf.Max(CapsuleRadius, MaxStepHeight);\n   905→                        }\n   906→                        else\n   907→                        {\n   908→                            selectedGroundProbingDistance = CapsuleRadius;\n   909→                        }\n   910→\n   911→                        selectedGroundProbingDistance += GroundDetectionExtraDistance;\n   912→                    }\n   913→\n   914→                    ProbeGround(ref _transientPosition, _transientRotation, selectedGroundProbingDistance, ref GroundingStatus);\n   915→\n   916→                    if (!LastGroundingStatus.IsStableOnGround && GroundingStatus.IsStableOnGround)\n   917→                    {\n   918→                        // Handle stable landing\n   919→                        BaseVelocity = Vector3.ProjectOnPlane(BaseVelocity, CharacterUp);\n   920→                        BaseVelocity = GetDirectionTangentToSurface(BaseVelocity, GroundingStatus.GroundNormal) * BaseVelocity.magnitude;\n   921→                    }\n   922→                }\n   923→            }\n   924→\n   925→            LastMovementIterationFoundAnyGround = false;\n   926→\n   927→            if (_mustUngroundTimeCounter > 0f)\n   928→            {\n   929→                _mustUngroundTimeCounter -= deltaTime;\n   930→            }\n   931→            _mustUnground = false;\n   932→            #endregion\n   933→\n   934→            if (_solveGrounding)\n   935→            {\n   936→                CharacterController.PostGroundingUpdate(deltaTime);\n   937→            }\n   938→\n   939→            if (InteractiveRigidbodyHandling)\n   940→            {\n   941→                #region Interactive Rigidbody Handling \n   942→                _lastAttachedRigidbody = _attachedRigidbody;\n   943→                if (AttachedRigidbodyOverride)\n   944→                {\n   945→                    _attachedRigidbody = AttachedRigidbodyOverride;\n   946→                }\n   947→                else\n   948→                {\n   949→                    // Detect interactive rigidbodies from grounding\n   950→                    if (GroundingStatus.IsStableOnGround && GroundingStatus.GroundCollider.attachedRigidbody)\n   951→                    {\n   952→                        Rigidbody interactiveRigidbody = GetInteractiveRigidbody(GroundingStatus.GroundCollider);\n   953→                        if (interactiveRigidbody)\n   954→                        {\n   955→                            _attachedRigidbody = interactiveRigidbody;\n   956→                        }\n   957→                    }\n   958→                    else\n   959→                    {\n   960→                        _attachedRigidbody = null;\n   961→                    }\n   962→                }\n   963→\n   964→                Vector3 tmpVelocityFromCurrentAttachedRigidbody = Vector3.zero;\n   965→                Vector3 tmpAngularVelocityFromCurrentAttachedRigidbody = Vector3.zero;\n   966→                if (_attachedRigidbody)\n   967→                {\n   968→                    GetVelocityFromRigidbodyMovement(_attachedRigidbody, _transientPosition, deltaTime, out tmpVelocityFromCurrentAttachedRigidbody, out tmpAngularVelocityFromCurrentAttachedRigidbody);\n   969→                }\n   970→\n   971→                // Conserve momentum when de-stabilized from an attached rigidbody\n   972→                if (PreserveAttachedRigidbodyMomentum && _lastAttachedRigidbody != null && _attachedRigidbody != _lastAttachedRigidbody)\n   973→                {\n   974→                    BaseVelocity += _attachedRigidbodyVelocity;\n   975→                    BaseVelocity -= tmpVelocityFromCurrentAttachedRigidbody;\n   976→                }\n   977→\n   978→                // Process additionnal Velocity from attached rigidbody\n   979→                _attachedRigidbodyVelocity = _cachedZeroVector;\n   980→                if (_attachedRigidbody)\n   981→                {\n   982→                    _attachedRigidbodyVelocity = tmpVelocityFromCurrentAttachedRigidbody;\n   983→\n   984→                    // Rotation from attached rigidbody\n   985→                    Vector3 newForward = Vector3.ProjectOnPlane(Quaternion.Euler(Mathf.Rad2Deg * tmpAngularVelocityFromCurrentAttachedRigidbody * deltaTime) * _characterForward, _characterUp).normalized;\n   986→                    TransientRotation = Quaternion.LookRotation(newForward, _characterUp);\n   987→                }\n   988→\n   989→                // Cancel out horizontal velocity upon landing on an attached rigidbody\n   990→                if (GroundingStatus.GroundCollider &&\n   991→                    GroundingStatus.GroundCollider.attachedRigidbody &&\n   992→                    GroundingStatus.GroundCollider.attachedRigidbody == _attachedRigidbody &&\n   993→                    _attachedRigidbody != null &&\n   994→                    _lastAttachedRigidbody == null)\n   995→                {\n   996→                    BaseVelocity -= Vector3.ProjectOnPlane(_attachedRigidbodyVelocity, _characterUp);\n   997→                }\n   998→\n   999→                // Movement from Attached Rigidbody\n  1000→                if (_attachedRigidbodyVelocity.sqrMagnitude > 0f)\n  1001→                {\n  1002→                    _isMovingFromAttachedRigidbody = true;\n  1003→\n  1004→                    if (_solveMovementCollisions)\n  1005→                    {\n  1006→                        // Perform the move from rgdbdy velocity\n  1007→                        InternalCharacterMove(ref _attachedRigidbodyVelocity, deltaTime);\n  1008→                    }\n  1009→                    else\n  1010→                    {\n  1011→                        _transientPosition += _attachedRigidbodyVelocity * deltaTime;\n  1012→                    }\n  1013→\n  1014→                    _isMovingFromAttachedRigidbody = false;\n  1015→                }\n  1016→                #endregion\n  1017→            }\n  1018→        }\n  1019→\n  1020→        /// <summary>\n  1021→        /// Update phase 2 is meant to be called after physics movers have simulated their goal positions/rotations. \n  1022→        /// At the end of this, the TransientPosition/Rotation values will be up-to-date with where the motor should be at the end of its move. \n  1023→        /// It is responsible for:\n  1024→        /// - Solving Rotation\n  1025→        /// - Handle MoveRotation calls\n  1026→        /// - Solving potential attached rigidbody overlaps\n  1027→        /// - Solving Velocity\n  1028→        /// - Applying planar constraint\n  1029→        /// </summary>\n  1030→        public void UpdatePhase2(float deltaTime)\n  1031→        {\n  1032→            // Handle rotation\n  1033→            CharacterController.UpdateRotation(ref _transientRotation, deltaTime);\n  1034→            TransientRotation = _transientRotation;\n  1035→\n  1036→            // Handle move rotation\n  1037→            if (_moveRotationDirty)\n  1038→            {\n  1039→                TransientRotation = _moveRotationTarget;\n  1040→                _moveRotationDirty = false;\n  1041→            }\n  1042→\n  1043→            if (_solveMovementCollisions && InteractiveRigidbodyHandling)\n  1044→            {\n  1045→                if (InteractiveRigidbodyHandling)\n  1046→                {\n  1047→                    #region Solve potential attached rigidbody overlap\n  1048→                    if (_attachedRigidbody)\n  1049→                    {\n  1050→                        float upwardsOffset = Capsule.radius;\n  1051→\n  1052→                        RaycastHit closestHit;\n  1053→                        if (CharacterGroundSweep(\n  1054→                            _transientPosition + (_characterUp * upwardsOffset),\n  1055→                            _transientRotation,\n  1056→                            -_characterUp,\n  1057→                            upwardsOffset,\n  1058→                            out closestHit))\n  1059→                        {\n  1060→                            if (closestHit.collider.attachedRigidbody == _attachedRigidbody && IsStableOnNormal(closestHit.normal))\n  1061→                            {\n  1062→                                float distanceMovedUp = (upwardsOffset - closestHit.distance);\n  1063→                                _transientPosition = _transientPosition + (_characterUp * distanceMovedUp) + (_characterUp * CollisionOffset);\n  1064→                            }\n  1065→                        }\n  1066→                    }\n  1067→                    #endregion\n  1068→                }\n  1069→\n  1070→                if (InteractiveRigidbodyHandling)\n  1071→                {\n  1072→                    #region Resolve overlaps that could've been caused by rotation or physics movers simulation pushing the character\n  1073→                    Vector3 resolutionDirection = _cachedWorldUp;\n  1074→                    float resolutionDistance = 0f;\n  1075→                    int iterationsMade = 0;\n  1076→                    bool overlapSolved = false;\n  1077→                    while (iterationsMade < MaxDecollisionIterations && !overlapSolved)\n  1078→                    {\n  1079→                        int nbOverlaps = CharacterCollisionsOverlap(_transientPosition, _transientRotation, _internalProbedColliders);\n  1080→                        if (nbOverlaps > 0)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"33bb6f9c-94eb-4568-b69c-4dc141520c54","timestamp":"2025-12-19T10:13:12.951Z","toolUseResult":{"type":"text","file":{"filePath":"e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs","content":"        }\n\n        private void Reset()\n        {\n            ValidateData();\n        }\n\n        private void OnValidate()\n        {\n            ValidateData();\n        }\n\n        [ContextMenu(\"Remove Component\")]\n        private void HandleRemoveComponent()\n        {\n            CapsuleCollider tmpCapsule = gameObject.GetComponent<CapsuleCollider>();\n            DestroyImmediate(this);\n            DestroyImmediate(tmpCapsule);\n        }\n\n        /// <summary>\n        /// Handle validating all required values\n        /// </summary>\n        public void ValidateData()\n        {\n            Capsule = GetComponent<CapsuleCollider>();\n            CapsuleRadius = Mathf.Clamp(CapsuleRadius, 0f, CapsuleHeight * 0.5f);\n            Capsule.direction = 1;\n            Capsule.sharedMaterial = CapsulePhysicsMaterial;\n            SetCapsuleDimensions(CapsuleRadius, CapsuleHeight, CapsuleYOffset);\n\n            MaxStepHeight = Mathf.Clamp(MaxStepHeight, 0f, Mathf.Infinity);\n            MinRequiredStepDepth = Mathf.Clamp(MinRequiredStepDepth, 0f, CapsuleRadius);\n            MaxStableDistanceFromLedge = Mathf.Clamp(MaxStableDistanceFromLedge, 0f, CapsuleRadius);\n\n            transform.localScale = Vector3.one;\n\n#if UNITY_EDITOR\n            Capsule.hideFlags = HideFlags.NotEditable;\n            if (!Mathf.Approximately(transform.lossyScale.x, 1f) || !Mathf.Approximately(transform.lossyScale.y, 1f) || !Mathf.Approximately(transform.lossyScale.z, 1f))\n            {\n                Debug.LogError(\"Character's lossy scale is not (1,1,1). This is not allowed. Make sure the character's transform and all of its parents have a (1,1,1) scale.\", this.gameObject);\n            }\n#endif\n        }\n\n        /// <summary>\n        /// Sets whether or not the capsule collider will detect collisions\n        /// </summary>\n        public void SetCapsuleCollisionsActivation(bool collisionsActive)\n        {\n            Capsule.isTrigger = !collisionsActive;\n        }\n\n        /// <summary>\n        /// Sets whether or not the motor will solve collisions when moving (or moved onto)\n        /// </summary>\n        public void SetMovementCollisionsSolvingActivation(bool movementCollisionsSolvingActive)\n        {\n            _solveMovementCollisions = movementCollisionsSolvingActive;\n        }\n\n        /// <summary>\n        /// Sets whether or not grounding will be evaluated for all hits\n        /// </summary>\n        public void SetGroundSolvingActivation(bool stabilitySolvingActive)\n        {\n            _solveGrounding = stabilitySolvingActive;\n        }\n\n        /// <summary>\n        /// Sets the character's position directly\n        /// </summary>\n        public void SetPosition(Vector3 position, bool bypassInterpolation = true)\n        {\n            _transform.position = position;\n            _initialSimulationPosition = position;\n            _transientPosition = position;\n\n            if (bypassInterpolation)\n            {\n                InitialTickPosition = position;\n            }\n        }\n\n        /// <summary>\n        /// Sets the character's rotation directly\n        /// </summary>\n        public void SetRotation(Quaternion rotation, bool bypassInterpolation = true)\n        {\n            _transform.rotation = rotation;\n            _initialSimulationRotation = rotation;\n            TransientRotation = rotation;\n\n            if (bypassInterpolation)\n            {\n                InitialTickRotation = rotation;\n            }\n        }\n\n        /// <summary>\n        /// Sets the character's position and rotation directly\n        /// </summary>\n        public void SetPositionAndRotation(Vector3 position, Quaternion rotation, bool bypassInterpolation = true)\n        {\n            _transform.SetPositionAndRotation(position, rotation);\n            _initialSimulationPosition = position;\n            _initialSimulationRotation = rotation;\n            _transientPosition = position;\n            TransientRotation = rotation;\n\n            if (bypassInterpolation)\n            {\n                InitialTickPosition = position;\n                InitialTickRotation = rotation;\n            }\n        }\n\n        /// <summary>\n        /// Moves the character position, taking all movement collision solving int account. The actual move is done the next time the motor updates are called\n        /// </summary>\n        public void MoveCharacter(Vector3 toPosition)\n        {\n            _movePositionDirty = true;\n            _movePositionTarget = toPosition;\n        }\n\n        /// <summary>\n        /// Moves the character rotation. The actual move is done the next time the motor updates are called\n        /// </summary>\n        public void RotateCharacter(Quaternion toRotation)\n        {\n            _moveRotationDirty = true;\n            _moveRotationTarget = toRotation;\n        }\n\n        /// <summary>\n        /// Returns all the state information of the motor that is pertinent for simulation\n        /// </summary>\n        public KinematicCharacterMotorState GetState()\n        {\n            KinematicCharacterMotorState state = new KinematicCharacterMotorState();\n\n            state.Position = _transientPosition;\n            state.Rotation = _transientRotation;\n\n            state.BaseVelocity = BaseVelocity;\n            state.AttachedRigidbodyVelocity = _attachedRigidbodyVelocity;\n\n            state.MustUnground = _mustUnground;\n            state.MustUngroundTime = _mustUngroundTimeCounter;\n            state.LastMovementIterationFoundAnyGround = LastMovementIterationFoundAnyGround;\n            state.GroundingStatus.CopyFrom(GroundingStatus);\n            state.AttachedRigidbody = _attachedRigidbody;\n\n            return state;\n        }\n\n        /// <summary>\n        /// Applies a motor state instantly\n        /// </summary>\n        public void ApplyState(KinematicCharacterMotorState state, bool bypassInterpolation = true)\n        {\n            SetPositionAndRotation(state.Position, state.Rotation, bypassInterpolation);\n\n            BaseVelocity = state.BaseVelocity;\n            _attachedRigidbodyVelocity = state.AttachedRigidbodyVelocity;\n\n            _mustUnground = state.MustUnground;\n            _mustUngroundTimeCounter = state.MustUngroundTime;\n            LastMovementIterationFoundAnyGround = state.LastMovementIterationFoundAnyGround;\n            GroundingStatus.CopyFrom(state.GroundingStatus);\n            _attachedRigidbody = state.AttachedRigidbody;\n        }\n\n        /// <summary>\n        /// Resizes capsule. ALso caches importand capsule size data\n        /// </summary>\n        public void SetCapsuleDimensions(float radius, float height, float yOffset)\n        {\n            height = Mathf.Max(height, (radius * 2f) + 0.01f); // Safety to prevent invalid capsule geometries\n\n            CapsuleRadius = radius;\n            CapsuleHeight = height;\n            CapsuleYOffset = yOffset;\n\n            Capsule.radius = CapsuleRadius;\n            Capsule.height = Mathf.Clamp(CapsuleHeight, CapsuleRadius * 2f, CapsuleHeight);\n            Capsule.center = new Vector3(0f, CapsuleYOffset, 0f);\n\n            _characterTransformToCapsuleCenter = Capsule.center;\n            _characterTransformToCapsuleBottom = Capsule.center + (-_cachedWorldUp * (Capsule.height * 0.5f));\n            _characterTransformToCapsuleTop = Capsule.center + (_cachedWorldUp * (Capsule.height * 0.5f));\n            _characterTransformToCapsuleBottomHemi = Capsule.center + (-_cachedWorldUp * (Capsule.height * 0.5f)) + (_cachedWorldUp * Capsule.radius);\n            _characterTransformToCapsuleTopHemi = Capsule.center + (_cachedWorldUp * (Capsule.height * 0.5f)) + (-_cachedWorldUp * Capsule.radius);\n        }\n\n        private void Awake()\n        {\n            _transform = this.transform;\n            ValidateData();\n\n            _transientPosition = _transform.position;\n            TransientRotation = _transform.rotation;\n\n            // Build CollidableLayers mask\n            CollidableLayers = 0;\n            for (int i = 0; i < 32; i++)\n            {\n                if (!Physics.GetIgnoreLayerCollision(this.gameObject.layer, i))\n                {\n                    CollidableLayers |= (1 << i);\n                }\n            }\n\n            SetCapsuleDimensions(CapsuleRadius, CapsuleHeight, CapsuleYOffset);\n        }\n\n        /// <summary>\n        /// Update phase 1 is meant to be called after physics movers have calculated their velocities, but\n        /// before they have simulated their goal positions/rotations. It is responsible for:\n        /// - Initializing all values for update\n        /// - Handling MovePosition calls\n        /// - Solving initial collision overlaps\n        /// - Ground probing\n        /// - Handle detecting potential interactable rigidbodies\n        /// </summary>\n        public void UpdatePhase1(float deltaTime)\n        {\n            // NaN propagation safety stop\n            if (float.IsNaN(BaseVelocity.x) || float.IsNaN(BaseVelocity.y) || float.IsNaN(BaseVelocity.z))\n            {\n                BaseVelocity = Vector3.zero;\n            }\n            if (float.IsNaN(_attachedRigidbodyVelocity.x) || float.IsNaN(_attachedRigidbodyVelocity.y) || float.IsNaN(_attachedRigidbodyVelocity.z))\n            {\n                _attachedRigidbodyVelocity = Vector3.zero;\n            }\n\n#if UNITY_EDITOR\n            if (!Mathf.Approximately(_transform.lossyScale.x, 1f) || !Mathf.Approximately(_transform.lossyScale.y, 1f) || !Mathf.Approximately(_transform.lossyScale.z, 1f))\n            {\n                Debug.LogError(\"Character's lossy scale is not (1,1,1). This is not allowed. Make sure the character's transform and all of its parents have a (1,1,1) scale.\", this.gameObject);\n            }\n#endif\n\n            _rigidbodiesPushedThisMove.Clear();\n\n            // Before update\n            CharacterController.BeforeCharacterUpdate(deltaTime);\n\n            _transientPosition = _transform.position;\n            TransientRotation = _transform.rotation;\n            _initialSimulationPosition = _transientPosition;\n            _initialSimulationRotation = _transientRotation;\n            _rigidbodyProjectionHitCount = 0;\n            _overlapsCount = 0;\n            _lastSolvedOverlapNormalDirty = false;\n\n            #region Handle Move Position\n            if (_movePositionDirty)\n            {\n                if (_solveMovementCollisions)\n                {\n                    Vector3 tmpVelocity = GetVelocityFromMovement(_movePositionTarget - _transientPosition, deltaTime);\n                    if (InternalCharacterMove(ref tmpVelocity, deltaTime))\n                    {\n                        if (InteractiveRigidbodyHandling)\n                        {\n                            ProcessVelocityForRigidbodyHits(ref tmpVelocity, deltaTime);\n                        }\n                    }\n                }\n                else\n                {\n                    _transientPosition = _movePositionTarget;\n                }\n\n                _movePositionDirty = false;\n            }\n            #endregion\n\n            LastGroundingStatus.CopyFrom(GroundingStatus);\n            GroundingStatus = new CharacterGroundingReport();\n            GroundingStatus.GroundNormal = _characterUp;\n\n            if (_solveMovementCollisions)\n            {\n                #region Resolve initial overlaps\n                Vector3 resolutionDirection = _cachedWorldUp;\n                float resolutionDistance = 0f;\n                int iterationsMade = 0;\n                bool overlapSolved = false;\n                while (iterationsMade < MaxDecollisionIterations && !overlapSolved)\n                {\n                    int nbOverlaps = CharacterCollisionsOverlap(_transientPosition, _transientRotation, _internalProbedColliders);\n\n                    if (nbOverlaps > 0)\n                    {\n                        // Solve overlaps that aren't against dynamic rigidbodies or physics movers\n                        for (int i = 0; i < nbOverlaps; i++)\n                        {\n                            if (GetInteractiveRigidbody(_internalProbedColliders[i]) == null)\n                            {\n                                // Process overlap\n                                Transform overlappedTransform = _internalProbedColliders[i].GetComponent<Transform>();\n                                if (Physics.ComputePenetration(\n                                        Capsule,\n                                        _transientPosition,\n                                        _transientRotation,\n                                        _internalProbedColliders[i],\n                                        overlappedTransform.position,\n                                        overlappedTransform.rotation,\n                                        out resolutionDirection,\n                                        out resolutionDistance))\n                                {\n                                    // Resolve along obstruction direction\n                                    HitStabilityReport mockReport = new HitStabilityReport();\n                                    mockReport.IsStable = IsStableOnNormal(resolutionDirection);\n                                    resolutionDirection = GetObstructionNormal(resolutionDirection, mockReport.IsStable);\n\n                                    // Solve overlap\n                                    Vector3 resolutionMovement = resolutionDirection * (resolutionDistance + CollisionOffset);\n                                    _transientPosition += resolutionMovement;\n\n                                    // Remember overlaps\n                                    if (_overlapsCount < _overlaps.Length)\n                                    {\n                                        _overlaps[_overlapsCount] = new OverlapResult(resolutionDirection, _internalProbedColliders[i]);\n                                        _overlapsCount++;\n                                    }\n\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    else\n                    {\n                        overlapSolved = true;\n                    }\n\n                    iterationsMade++;\n                }\n                #endregion\n            }\n\n            #region Ground Probing and Snapping\n            // Handle ungrounding\n            if (_solveGrounding)\n            {\n                if (MustUnground())\n                {\n                    _transientPosition += _characterUp * (MinimumGroundProbingDistance * 1.5f);\n                }\n                else\n                {\n                    // Choose the appropriate ground probing distance\n                    float selectedGroundProbingDistance = MinimumGroundProbingDistance;\n                    if (!LastGroundingStatus.SnappingPrevented && (LastGroundingStatus.IsStableOnGround || LastMovementIterationFoundAnyGround))\n                    {\n                        if (StepHandling != StepHandlingMethod.None)\n                        {\n                            selectedGroundProbingDistance = Mathf.Max(CapsuleRadius, MaxStepHeight);\n                        }\n                        else\n                        {\n                            selectedGroundProbingDistance = CapsuleRadius;\n                        }\n\n                        selectedGroundProbingDistance += GroundDetectionExtraDistance;\n                    }\n\n                    ProbeGround(ref _transientPosition, _transientRotation, selectedGroundProbingDistance, ref GroundingStatus);\n\n                    if (!LastGroundingStatus.IsStableOnGround && GroundingStatus.IsStableOnGround)\n                    {\n                        // Handle stable landing\n                        BaseVelocity = Vector3.ProjectOnPlane(BaseVelocity, CharacterUp);\n                        BaseVelocity = GetDirectionTangentToSurface(BaseVelocity, GroundingStatus.GroundNormal) * BaseVelocity.magnitude;\n                    }\n                }\n            }\n\n            LastMovementIterationFoundAnyGround = false;\n\n            if (_mustUngroundTimeCounter > 0f)\n            {\n                _mustUngroundTimeCounter -= deltaTime;\n            }\n            _mustUnground = false;\n            #endregion\n\n            if (_solveGrounding)\n            {\n                CharacterController.PostGroundingUpdate(deltaTime);\n            }\n\n            if (InteractiveRigidbodyHandling)\n            {\n                #region Interactive Rigidbody Handling \n                _lastAttachedRigidbody = _attachedRigidbody;\n                if (AttachedRigidbodyOverride)\n                {\n                    _attachedRigidbody = AttachedRigidbodyOverride;\n                }\n                else\n                {\n                    // Detect interactive rigidbodies from grounding\n                    if (GroundingStatus.IsStableOnGround && GroundingStatus.GroundCollider.attachedRigidbody)\n                    {\n                        Rigidbody interactiveRigidbody = GetInteractiveRigidbody(GroundingStatus.GroundCollider);\n                        if (interactiveRigidbody)\n                        {\n                            _attachedRigidbody = interactiveRigidbody;\n                        }\n                    }\n                    else\n                    {\n                        _attachedRigidbody = null;\n                    }\n                }\n\n                Vector3 tmpVelocityFromCurrentAttachedRigidbody = Vector3.zero;\n                Vector3 tmpAngularVelocityFromCurrentAttachedRigidbody = Vector3.zero;\n                if (_attachedRigidbody)\n                {\n                    GetVelocityFromRigidbodyMovement(_attachedRigidbody, _transientPosition, deltaTime, out tmpVelocityFromCurrentAttachedRigidbody, out tmpAngularVelocityFromCurrentAttachedRigidbody);\n                }\n\n                // Conserve momentum when de-stabilized from an attached rigidbody\n                if (PreserveAttachedRigidbodyMomentum && _lastAttachedRigidbody != null && _attachedRigidbody != _lastAttachedRigidbody)\n                {\n                    BaseVelocity += _attachedRigidbodyVelocity;\n                    BaseVelocity -= tmpVelocityFromCurrentAttachedRigidbody;\n                }\n\n                // Process additionnal Velocity from attached rigidbody\n                _attachedRigidbodyVelocity = _cachedZeroVector;\n                if (_attachedRigidbody)\n                {\n                    _attachedRigidbodyVelocity = tmpVelocityFromCurrentAttachedRigidbody;\n\n                    // Rotation from attached rigidbody\n                    Vector3 newForward = Vector3.ProjectOnPlane(Quaternion.Euler(Mathf.Rad2Deg * tmpAngularVelocityFromCurrentAttachedRigidbody * deltaTime) * _characterForward, _characterUp).normalized;\n                    TransientRotation = Quaternion.LookRotation(newForward, _characterUp);\n                }\n\n                // Cancel out horizontal velocity upon landing on an attached rigidbody\n                if (GroundingStatus.GroundCollider &&\n                    GroundingStatus.GroundCollider.attachedRigidbody &&\n                    GroundingStatus.GroundCollider.attachedRigidbody == _attachedRigidbody &&\n                    _attachedRigidbody != null &&\n                    _lastAttachedRigidbody == null)\n                {\n                    BaseVelocity -= Vector3.ProjectOnPlane(_attachedRigidbodyVelocity, _characterUp);\n                }\n\n                // Movement from Attached Rigidbody\n                if (_attachedRigidbodyVelocity.sqrMagnitude > 0f)\n                {\n                    _isMovingFromAttachedRigidbody = true;\n\n                    if (_solveMovementCollisions)\n                    {\n                        // Perform the move from rgdbdy velocity\n                        InternalCharacterMove(ref _attachedRigidbodyVelocity, deltaTime);\n                    }\n                    else\n                    {\n                        _transientPosition += _attachedRigidbodyVelocity * deltaTime;\n                    }\n\n                    _isMovingFromAttachedRigidbody = false;\n                }\n                #endregion\n            }\n        }\n\n        /// <summary>\n        /// Update phase 2 is meant to be called after physics movers have simulated their goal positions/rotations. \n        /// At the end of this, the TransientPosition/Rotation values will be up-to-date with where the motor should be at the end of its move. \n        /// It is responsible for:\n        /// - Solving Rotation\n        /// - Handle MoveRotation calls\n        /// - Solving potential attached rigidbody overlaps\n        /// - Solving Velocity\n        /// - Applying planar constraint\n        /// </summary>\n        public void UpdatePhase2(float deltaTime)\n        {\n            // Handle rotation\n            CharacterController.UpdateRotation(ref _transientRotation, deltaTime);\n            TransientRotation = _transientRotation;\n\n            // Handle move rotation\n            if (_moveRotationDirty)\n            {\n                TransientRotation = _moveRotationTarget;\n                _moveRotationDirty = false;\n            }\n\n            if (_solveMovementCollisions && InteractiveRigidbodyHandling)\n            {\n                if (InteractiveRigidbodyHandling)\n                {\n                    #region Solve potential attached rigidbody overlap\n                    if (_attachedRigidbody)\n                    {\n                        float upwardsOffset = Capsule.radius;\n\n                        RaycastHit closestHit;\n                        if (CharacterGroundSweep(\n                            _transientPosition + (_characterUp * upwardsOffset),\n                            _transientRotation,\n                            -_characterUp,\n                            upwardsOffset,\n                            out closestHit))\n                        {\n                            if (closestHit.collider.attachedRigidbody == _attachedRigidbody && IsStableOnNormal(closestHit.normal))\n                            {\n                                float distanceMovedUp = (upwardsOffset - closestHit.distance);\n                                _transientPosition = _transientPosition + (_characterUp * distanceMovedUp) + (_characterUp * CollisionOffset);\n                            }\n                        }\n                    }\n                    #endregion\n                }\n\n                if (InteractiveRigidbodyHandling)\n                {\n                    #region Resolve overlaps that could've been caused by rotation or physics movers simulation pushing the character\n                    Vector3 resolutionDirection = _cachedWorldUp;\n                    float resolutionDistance = 0f;\n                    int iterationsMade = 0;\n                    bool overlapSolved = false;\n                    while (iterationsMade < MaxDecollisionIterations && !overlapSolved)\n                    {\n                        int nbOverlaps = CharacterCollisionsOverlap(_transientPosition, _transientRotation, _internalProbedColliders);\n                        if (nbOverlaps > 0)","numLines":540,"startLine":541,"totalLines":2689}}}
{"parentUuid":"33bb6f9c-94eb-4568-b69c-4dc141520c54","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NMGKjgvTp4onXa7Ur1h3ZH","type":"tool_result","content":"  2161→            }\n  2162→        }\n  2163→\n  2164→        private bool CheckStepValidity(int nbStepHits, Vector3 characterPosition, Quaternion characterRotation, Vector3 innerHitDirection, Vector3 stepCheckStartPos, out Collider hitCollider)\n  2165→        {\n  2166→            hitCollider = null;\n  2167→            Vector3 characterUp = characterRotation * Vector3.up;\n  2168→\n  2169→            // Find the farthest valid hit for stepping\n  2170→            bool foundValidStepPosition = false;\n  2171→\n  2172→            while (nbStepHits > 0 && !foundValidStepPosition)\n  2173→            {\n  2174→                // Get farthest hit among the remaining hits\n  2175→                RaycastHit farthestHit = new RaycastHit();\n  2176→                float farthestDistance = 0f;\n  2177→                int farthestIndex = 0;\n  2178→                for (int i = 0; i < nbStepHits; i++)\n  2179→                {\n  2180→                    float hitDistance = _internalCharacterHits[i].distance;\n  2181→                    if (hitDistance > farthestDistance)\n  2182→                    {\n  2183→                        farthestDistance = hitDistance;\n  2184→                        farthestHit = _internalCharacterHits[i];\n  2185→                        farthestIndex = i;\n  2186→                    }\n  2187→                }\n  2188→\n  2189→                Vector3 characterPositionAtHit = stepCheckStartPos + (-characterUp * (farthestHit.distance - CollisionOffset));\n  2190→\n  2191→                int atStepOverlaps = CharacterCollisionsOverlap(characterPositionAtHit, characterRotation, _internalProbedColliders);\n  2192→                if (atStepOverlaps <= 0)\n  2193→                {\n  2194→                    // Check for outer hit slope normal stability at the step position\n  2195→                    if (CharacterCollisionsRaycast(\n  2196→                            farthestHit.point + (characterUp * SecondaryProbesVertical) + (-innerHitDirection * SecondaryProbesHorizontal),\n  2197→                            -characterUp,\n  2198→                            MaxStepHeight + SecondaryProbesVertical,\n  2199→                            out RaycastHit outerSlopeHit,\n  2200→                            _internalCharacterHits,\n  2201→                            true) > 0)\n  2202→                    {\n  2203→                        if (IsStableOnNormal(outerSlopeHit.normal))\n  2204→                        {\n  2205→                            // Cast upward to detect any obstructions to moving there\n  2206→                            if (CharacterCollisionsSweep(\n  2207→                                                characterPosition, // position\n  2208→                                                characterRotation, // rotation\n  2209→                                                characterUp, // direction\n  2210→                                                MaxStepHeight - farthestHit.distance, // distance\n  2211→                                                out RaycastHit tmpUpObstructionHit, // closest hit\n  2212→                                                _internalCharacterHits) // all hits\n  2213→                                    <= 0)\n  2214→                            {\n  2215→                                // Do inner step check...\n  2216→                                bool innerStepValid = false;\n  2217→                                RaycastHit innerStepHit;\n  2218→\n  2219→                                if (AllowSteppingWithoutStableGrounding)\n  2220→                                {\n  2221→                                    innerStepValid = true;\n  2222→                                }\n  2223→                                else\n  2224→                                {\n  2225→                                    // At the capsule center at the step height\n  2226→                                    if (CharacterCollisionsRaycast(\n  2227→                                            characterPosition + Vector3.Project((characterPositionAtHit - characterPosition), characterUp),\n  2228→                                            -characterUp,\n  2229→                                            MaxStepHeight,\n  2230→                                            out innerStepHit,\n  2231→                                            _internalCharacterHits,\n  2232→                                            true) > 0)\n  2233→                                    {\n  2234→                                        if (IsStableOnNormal(innerStepHit.normal))\n  2235→                                        {\n  2236→                                            innerStepValid = true;\n  2237→                                        }\n  2238→                                    }\n  2239→                                }\n  2240→\n  2241→                                if (!innerStepValid)\n  2242→                                {\n  2243→                                    // At inner step of the step point\n  2244→                                    if (CharacterCollisionsRaycast(\n  2245→                                            farthestHit.point + (innerHitDirection * SecondaryProbesHorizontal),\n  2246→                                            -characterUp,\n  2247→                                            MaxStepHeight,\n  2248→                                            out innerStepHit,\n  2249→                                            _internalCharacterHits,\n  2250→                                            true) > 0)\n  2251→                                    {\n  2252→                                        if (IsStableOnNormal(innerStepHit.normal))\n  2253→                                        {\n  2254→                                            innerStepValid = true;\n  2255→                                        }\n  2256→                                    }\n  2257→                                }\n  2258→\n  2259→                                // Final validation of step\n  2260→                                if (innerStepValid)\n  2261→                                {\n  2262→                                    hitCollider = farthestHit.collider;\n  2263→                                    foundValidStepPosition = true;\n  2264→                                    return true;\n  2265→                                }\n  2266→                            }\n  2267→                        }\n  2268→                    }\n  2269→                }\n  2270→\n  2271→                // Discard hit if not valid step\n  2272→                if (!foundValidStepPosition)\n  2273→                {\n  2274→                    nbStepHits--;\n  2275→                    if (farthestIndex < nbStepHits)\n  2276→                    {\n  2277→                        _internalCharacterHits[farthestIndex] = _internalCharacterHits[nbStepHits];\n  2278→                    }\n  2279→                }\n  2280→            }\n  2281→\n  2282→            return false;\n  2283→        }\n  2284→\n  2285→        /// <summary>\n  2286→        /// Get true linear velocity (taking into account rotational velocity) on a given point of a rigidbody\n  2287→        /// </summary>\n  2288→        public void GetVelocityFromRigidbodyMovement(Rigidbody interactiveRigidbody, Vector3 atPoint, float deltaTime, out Vector3 linearVelocity, out Vector3 angularVelocity)\n  2289→        {\n  2290→            if (deltaTime > 0f)\n  2291→            {\n  2292→                linearVelocity = interactiveRigidbody.linearVelocity;\n  2293→                angularVelocity = interactiveRigidbody.angularVelocity;\n  2294→                if(interactiveRigidbody.isKinematic)\n  2295→                {\n  2296→                    PhysicsMover physicsMover = interactiveRigidbody.GetComponent<PhysicsMover>();\n  2297→                    if (physicsMover)\n  2298→                    {\n  2299→                        linearVelocity = physicsMover.Velocity;\n  2300→                        angularVelocity = physicsMover.AngularVelocity;\n  2301→                    }\n  2302→                }\n  2303→\n  2304→                if (angularVelocity != Vector3.zero)\n  2305→                {\n  2306→                    Vector3 centerOfRotation = interactiveRigidbody.transform.TransformPoint(interactiveRigidbody.centerOfMass);\n  2307→\n  2308→                    Vector3 centerOfRotationToPoint = atPoint - centerOfRotation;\n  2309→                    Quaternion rotationFromInteractiveRigidbody = Quaternion.Euler(Mathf.Rad2Deg * angularVelocity * deltaTime);\n  2310→                    Vector3 finalPointPosition = centerOfRotation + (rotationFromInteractiveRigidbody * centerOfRotationToPoint);\n  2311→                    linearVelocity += (finalPointPosition - atPoint) / deltaTime;\n  2312→                }\n  2313→            }\n  2314→            else\n  2315→            {\n  2316→                linearVelocity = default;\n  2317→                angularVelocity = default;\n  2318→                return;\n  2319→            }\n  2320→        }\n  2321→\n  2322→        /// <summary>\n  2323→        /// Determines if a collider has an attached interactive rigidbody\n  2324→        /// </summary>\n  2325→        private Rigidbody GetInteractiveRigidbody(Collider onCollider)\n  2326→        {\n  2327→            Rigidbody colliderAttachedRigidbody = onCollider.attachedRigidbody;\n  2328→            if (colliderAttachedRigidbody)\n  2329→            {\n  2330→                if (colliderAttachedRigidbody.gameObject.GetComponent<PhysicsMover>())\n  2331→                {\n  2332→                    return colliderAttachedRigidbody;\n  2333→                }\n  2334→\n  2335→                if (!colliderAttachedRigidbody.isKinematic)\n  2336→                {\n  2337→                    return colliderAttachedRigidbody;\n  2338→                }\n  2339→            }\n  2340→            return null;\n  2341→        }\n  2342→\n  2343→        /// <summary>\n  2344→        /// Calculates the velocity required to move the character to the target position over a specific deltaTime.\n  2345→        /// Useful for when you wish to work with positions rather than velocities in the UpdateVelocity callback \n  2346→        /// </summary>\n  2347→        public Vector3 GetVelocityForMovePosition(Vector3 fromPosition, Vector3 toPosition, float deltaTime)\n  2348→        {\n  2349→            return GetVelocityFromMovement(toPosition - fromPosition, deltaTime);\n  2350→        }\n  2351→\n  2352→        public Vector3 GetVelocityFromMovement(Vector3 movement, float deltaTime)\n  2353→        {\n  2354→            if (deltaTime <= 0f)\n  2355→                return Vector3.zero;\n  2356→\n  2357→            return movement / deltaTime;\n  2358→        }\n  2359→\n  2360→        /// <summary>\n  2361→        /// Trims a vector to make it restricted against a plane \n  2362→        /// </summary>\n  2363→        private void RestrictVectorToPlane(ref Vector3 vector, Vector3 toPlane)\n  2364→        {\n  2365→            if (vector.x > 0 != toPlane.x > 0)\n  2366→            {\n  2367→                vector.x = 0;\n  2368→            }\n  2369→            if (vector.y > 0 != toPlane.y > 0)\n  2370→            {\n  2371→                vector.y = 0;\n  2372→            }\n  2373→            if (vector.z > 0 != toPlane.z > 0)\n  2374→            {\n  2375→                vector.z = 0;\n  2376→            }\n  2377→        }\n  2378→\n  2379→        /// <summary>\n  2380→        /// Detect if the character capsule is overlapping with anything collidable\n  2381→        /// </summary>\n  2382→        /// <returns> Returns number of overlaps </returns>\n  2383→        public int CharacterCollisionsOverlap(Vector3 position, Quaternion rotation, Collider[] overlappedColliders, float inflate = 0f, bool acceptOnlyStableGroundLayer = false)\n  2384→        {\n  2385→            int queryLayers = CollidableLayers;\n  2386→            if (acceptOnlyStableGroundLayer)\n  2387→            {\n  2388→                queryLayers = CollidableLayers & StableGroundLayers;\n  2389→            }\n  2390→\n  2391→            Vector3 bottom = position + (rotation * _characterTransformToCapsuleBottomHemi);\n  2392→            Vector3 top = position + (rotation * _characterTransformToCapsuleTopHemi);\n  2393→            if (inflate != 0f)\n  2394→            {\n  2395→                bottom += (rotation * Vector3.down * inflate);\n  2396→                top += (rotation * Vector3.up * inflate);\n  2397→            }\n  2398→\n  2399→            int nbHits = 0;\n  2400→            int nbUnfilteredHits = Physics.OverlapCapsuleNonAlloc(\n  2401→                        bottom,\n  2402→                        top,\n  2403→                        Capsule.radius + inflate,\n  2404→                        overlappedColliders,\n  2405→                        queryLayers,\n  2406→                        QueryTriggerInteraction.Ignore);\n  2407→\n  2408→            // Filter out invalid colliders\n  2409→            nbHits = nbUnfilteredHits;\n  2410→            for (int i = nbUnfilteredHits - 1; i >= 0; i--)\n  2411→            {\n  2412→                if (!CheckIfColliderValidForCollisions(overlappedColliders[i]))\n  2413→                {\n  2414→                    nbHits--;\n  2415→                    if (i < nbHits)\n  2416→                    {\n  2417→                        overlappedColliders[i] = overlappedColliders[nbHits];\n  2418→                    }\n  2419→                }\n  2420→            }\n  2421→\n  2422→            return nbHits;\n  2423→        }\n  2424→\n  2425→        /// <summary>\n  2426→        /// Detect if the character capsule is overlapping with anything\n  2427→        /// </summary>\n  2428→        /// <returns> Returns number of overlaps </returns>\n  2429→        public int CharacterOverlap(Vector3 position, Quaternion rotation, Collider[] overlappedColliders, LayerMask layers, QueryTriggerInteraction triggerInteraction, float inflate = 0f)\n  2430→        {\n  2431→            Vector3 bottom = position + (rotation * _characterTransformToCapsuleBottomHemi);\n  2432→            Vector3 top = position + (rotation * _characterTransformToCapsuleTopHemi);\n  2433→            if (inflate != 0f)\n  2434→            {\n  2435→                bottom += (rotation * Vector3.down * inflate);\n  2436→                top += (rotation * Vector3.up * inflate);\n  2437→            }\n  2438→\n  2439→            int nbHits = 0;\n  2440→            int nbUnfilteredHits = Physics.OverlapCapsuleNonAlloc(\n  2441→                        bottom,\n  2442→                        top,\n  2443→                        Capsule.radius + inflate,\n  2444→                        overlappedColliders,\n  2445→                        layers,\n  2446→                        triggerInteraction);\n  2447→\n  2448→            // Filter out the character capsule itself\n  2449→            nbHits = nbUnfilteredHits;\n  2450→            for (int i = nbUnfilteredHits - 1; i >= 0; i--)\n  2451→            {\n  2452→                if (overlappedColliders[i] == Capsule)\n  2453→                {\n  2454→                    nbHits--;\n  2455→                    if (i < nbHits)\n  2456→                    {\n  2457→                        overlappedColliders[i] = overlappedColliders[nbHits];\n  2458→                    }\n  2459→                }\n  2460→            }\n  2461→\n  2462→            return nbHits;\n  2463→        }\n  2464→\n  2465→        /// <summary>\n  2466→        /// Sweeps the capsule's volume to detect collision hits\n  2467→        /// </summary>\n  2468→        /// <returns> Returns the number of hits </returns>\n  2469→        public int CharacterCollisionsSweep(Vector3 position, Quaternion rotation, Vector3 direction, float distance, out RaycastHit closestHit, RaycastHit[] hits, float inflate = 0f, bool acceptOnlyStableGroundLayer = false)\n  2470→        {\n  2471→            int queryLayers = CollidableLayers;\n  2472→            if (acceptOnlyStableGroundLayer)\n  2473→            {\n  2474→                queryLayers = CollidableLayers & StableGroundLayers;\n  2475→            }\n  2476→\n  2477→            Vector3 bottom = position + (rotation * _characterTransformToCapsuleBottomHemi) - (direction * SweepProbingBackstepDistance);\n  2478→            Vector3 top = position + (rotation * _characterTransformToCapsuleTopHemi) - (direction * SweepProbingBackstepDistance);\n  2479→            if (inflate != 0f)\n  2480→            {\n  2481→                bottom += (rotation * Vector3.down * inflate);\n  2482→                top += (rotation * Vector3.up * inflate);\n  2483→            }\n  2484→\n  2485→            // Capsule cast\n  2486→            int nbHits = 0;\n  2487→            int nbUnfilteredHits = Physics.CapsuleCastNonAlloc(\n  2488→                    bottom,\n  2489→                    top,\n  2490→                    Capsule.radius + inflate,\n  2491→                    direction,\n  2492→                    hits,\n  2493→                    distance + SweepProbingBackstepDistance,\n  2494→                    queryLayers,\n  2495→                    QueryTriggerInteraction.Ignore);\n  2496→\n  2497→            // Hits filter\n  2498→            closestHit = new RaycastHit();\n  2499→            float closestDistance = Mathf.Infinity;\n  2500→            nbHits = nbUnfilteredHits;\n  2501→            for (int i = nbUnfilteredHits - 1; i >= 0; i--)\n  2502→            {\n  2503→                hits[i].distance -= SweepProbingBackstepDistance;\n  2504→\n  2505→                RaycastHit hit = hits[i];\n  2506→                float hitDistance = hit.distance;\n  2507→\n  2508→                // Filter out the invalid hits\n  2509→                if (hitDistance <= 0f || !CheckIfColliderValidForCollisions(hit.collider))\n  2510→                {\n  2511→                    nbHits--;\n  2512→                    if (i < nbHits)\n  2513→                    {\n  2514→                        hits[i] = hits[nbHits];\n  2515→                    }\n  2516→                }\n  2517→                else\n  2518→                {\n  2519→                    // Remember closest valid hit\n  2520→                    if (hitDistance < closestDistance)\n  2521→                    {\n  2522→                        closestHit = hit;\n  2523→                        closestDistance = hitDistance;\n  2524→                    }\n  2525→                }\n  2526→            }\n  2527→\n  2528→            return nbHits;\n  2529→        }\n  2530→\n  2531→        /// <summary>\n  2532→        /// Sweeps the capsule's volume to detect hits\n  2533→        /// </summary>\n  2534→        /// <returns> Returns the number of hits </returns>\n  2535→        public int CharacterSweep(Vector3 position, Quaternion rotation, Vector3 direction, float distance, out RaycastHit closestHit, RaycastHit[] hits, LayerMask layers, QueryTriggerInteraction triggerInteraction, float inflate = 0f)\n  2536→        {\n  2537→            closestHit = new RaycastHit();\n  2538→\n  2539→            Vector3 bottom = position + (rotation * _characterTransformToCapsuleBottomHemi);\n  2540→            Vector3 top = position + (rotation * _characterTransformToCapsuleTopHemi);\n  2541→            if (inflate != 0f)\n  2542→            {\n  2543→                bottom += (rotation * Vector3.down * inflate);\n  2544→                top += (rotation * Vector3.up * inflate);\n  2545→            }\n  2546→\n  2547→            // Capsule cast\n  2548→            int nbHits = 0;\n  2549→            int nbUnfilteredHits = Physics.CapsuleCastNonAlloc(\n  2550→                bottom,\n  2551→                top,\n  2552→                Capsule.radius + inflate,\n  2553→                direction,\n  2554→                hits,\n  2555→                distance,\n  2556→                layers,\n  2557→                triggerInteraction);\n  2558→\n  2559→            // Hits filter\n  2560→            float closestDistance = Mathf.Infinity;\n  2561→            nbHits = nbUnfilteredHits;\n  2562→            for (int i = nbUnfilteredHits - 1; i >= 0; i--)\n  2563→            {\n  2564→                RaycastHit hit = hits[i];\n  2565→\n  2566→                // Filter out the character capsule\n  2567→                if (hit.distance <= 0f || hit.collider == Capsule)\n  2568→                {\n  2569→                    nbHits--;\n  2570→                    if (i < nbHits)\n  2571→                    {\n  2572→                        hits[i] = hits[nbHits];\n  2573→                    }\n  2574→                }\n  2575→                else\n  2576→                {\n  2577→                    // Remember closest valid hit\n  2578→                    float hitDistance = hit.distance;\n  2579→                    if (hitDistance < closestDistance)\n  2580→                    {\n  2581→                        closestHit = hit;\n  2582→                        closestDistance = hitDistance;\n  2583→                    }\n  2584→                }\n  2585→            }\n  2586→\n  2587→            return nbHits;\n  2588→        }\n  2589→\n  2590→        /// <summary>\n  2591→        /// Casts the character volume in the character's downward direction to detect ground\n  2592→        /// </summary>\n  2593→        /// <returns> Returns the number of hits </returns>\n  2594→        private bool CharacterGroundSweep(Vector3 position, Quaternion rotation, Vector3 direction, float distance, out RaycastHit closestHit)\n  2595→        {\n  2596→            closestHit = new RaycastHit();\n  2597→\n  2598→            // Capsule cast\n  2599→            int nbUnfilteredHits = Physics.CapsuleCastNonAlloc(\n  2600→                position + (rotation * _characterTransformToCapsuleBottomHemi) - (direction * GroundProbingBackstepDistance),\n  2601→                position + (rotation * _characterTransformToCapsuleTopHemi) - (direction * GroundProbingBackstepDistance),\n  2602→                Capsule.radius,\n  2603→                direction,\n  2604→                _internalCharacterHits,\n  2605→                distance + GroundProbingBackstepDistance,\n  2606→                CollidableLayers & StableGroundLayers,\n  2607→                QueryTriggerInteraction.Ignore);\n  2608→\n  2609→            // Hits filter\n  2610→            bool foundValidHit = false;\n  2611→            float closestDistance = Mathf.Infinity;\n  2612→            for (int i = 0; i < nbUnfilteredHits; i++)\n  2613→            {\n  2614→                RaycastHit hit = _internalCharacterHits[i];\n  2615→                float hitDistance = hit.distance;\n  2616→\n  2617→                // Find the closest valid hit\n  2618→                if (hitDistance > 0f && CheckIfColliderValidForCollisions(hit.collider))\n  2619→                {\n  2620→                    if (hitDistance < closestDistance)\n  2621→                    {\n  2622→                        closestHit = hit;\n  2623→                        closestHit.distance -= GroundProbingBackstepDistance;\n  2624→                        closestDistance = hitDistance;\n  2625→\n  2626→                        foundValidHit = true;\n  2627→                    }\n  2628→                }\n  2629→            }\n  2630→\n  2631→            return foundValidHit;\n  2632→        }\n  2633→\n  2634→        /// <summary>\n  2635→        /// Raycasts to detect collision hits\n  2636→        /// </summary>\n  2637→        /// <returns> Returns the number of hits </returns>\n  2638→        public int CharacterCollisionsRaycast(Vector3 position, Vector3 direction, float distance, out RaycastHit closestHit, RaycastHit[] hits, bool acceptOnlyStableGroundLayer = false)\n  2639→        {\n  2640→            int queryLayers = CollidableLayers;\n  2641→            if (acceptOnlyStableGroundLayer)\n  2642→            {\n  2643→                queryLayers = CollidableLayers & StableGroundLayers;\n  2644→            }\n  2645→\n  2646→            // Raycast\n  2647→            int nbHits = 0;\n  2648→            int nbUnfilteredHits = Physics.RaycastNonAlloc(\n  2649→                position,\n  2650→                direction,\n  2651→                hits,\n  2652→                distance,\n  2653→                queryLayers,\n  2654→                QueryTriggerInteraction.Ignore);\n  2655→\n  2656→            // Hits filter\n  2657→            closestHit = new RaycastHit();\n  2658→            float closestDistance = Mathf.Infinity;\n  2659→            nbHits = nbUnfilteredHits;\n  2660→            for (int i = nbUnfilteredHits - 1; i >= 0; i--)\n  2661→            {\n  2662→                RaycastHit hit = hits[i];\n  2663→                float hitDistance = hit.distance;\n  2664→\n  2665→                // Filter out the invalid hits\n  2666→                if (hitDistance <= 0f ||\n  2667→                    !CheckIfColliderValidForCollisions(hit.collider))\n  2668→                {\n  2669→                    nbHits--;\n  2670→                    if (i < nbHits)\n  2671→                    {\n  2672→                        hits[i] = hits[nbHits];\n  2673→                    }\n  2674→                }\n  2675→                else\n  2676→                {\n  2677→                    // Remember closest valid hit\n  2678→                    if (hitDistance < closestDistance)\n  2679→                    {\n  2680→                        closestHit = hit;\n  2681→                        closestDistance = hitDistance;\n  2682→                    }\n  2683→                }\n  2684→            }\n  2685→\n  2686→            return nbHits;\n  2687→        }\n  2688→    }\n  2689→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ac39eff1-e55d-46e2-9237-8686541d786c","timestamp":"2025-12-19T10:13:12.951Z","toolUseResult":{"type":"text","file":{"filePath":"e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs","content":"            }\n        }\n\n        private bool CheckStepValidity(int nbStepHits, Vector3 characterPosition, Quaternion characterRotation, Vector3 innerHitDirection, Vector3 stepCheckStartPos, out Collider hitCollider)\n        {\n            hitCollider = null;\n            Vector3 characterUp = characterRotation * Vector3.up;\n\n            // Find the farthest valid hit for stepping\n            bool foundValidStepPosition = false;\n\n            while (nbStepHits > 0 && !foundValidStepPosition)\n            {\n                // Get farthest hit among the remaining hits\n                RaycastHit farthestHit = new RaycastHit();\n                float farthestDistance = 0f;\n                int farthestIndex = 0;\n                for (int i = 0; i < nbStepHits; i++)\n                {\n                    float hitDistance = _internalCharacterHits[i].distance;\n                    if (hitDistance > farthestDistance)\n                    {\n                        farthestDistance = hitDistance;\n                        farthestHit = _internalCharacterHits[i];\n                        farthestIndex = i;\n                    }\n                }\n\n                Vector3 characterPositionAtHit = stepCheckStartPos + (-characterUp * (farthestHit.distance - CollisionOffset));\n\n                int atStepOverlaps = CharacterCollisionsOverlap(characterPositionAtHit, characterRotation, _internalProbedColliders);\n                if (atStepOverlaps <= 0)\n                {\n                    // Check for outer hit slope normal stability at the step position\n                    if (CharacterCollisionsRaycast(\n                            farthestHit.point + (characterUp * SecondaryProbesVertical) + (-innerHitDirection * SecondaryProbesHorizontal),\n                            -characterUp,\n                            MaxStepHeight + SecondaryProbesVertical,\n                            out RaycastHit outerSlopeHit,\n                            _internalCharacterHits,\n                            true) > 0)\n                    {\n                        if (IsStableOnNormal(outerSlopeHit.normal))\n                        {\n                            // Cast upward to detect any obstructions to moving there\n                            if (CharacterCollisionsSweep(\n                                                characterPosition, // position\n                                                characterRotation, // rotation\n                                                characterUp, // direction\n                                                MaxStepHeight - farthestHit.distance, // distance\n                                                out RaycastHit tmpUpObstructionHit, // closest hit\n                                                _internalCharacterHits) // all hits\n                                    <= 0)\n                            {\n                                // Do inner step check...\n                                bool innerStepValid = false;\n                                RaycastHit innerStepHit;\n\n                                if (AllowSteppingWithoutStableGrounding)\n                                {\n                                    innerStepValid = true;\n                                }\n                                else\n                                {\n                                    // At the capsule center at the step height\n                                    if (CharacterCollisionsRaycast(\n                                            characterPosition + Vector3.Project((characterPositionAtHit - characterPosition), characterUp),\n                                            -characterUp,\n                                            MaxStepHeight,\n                                            out innerStepHit,\n                                            _internalCharacterHits,\n                                            true) > 0)\n                                    {\n                                        if (IsStableOnNormal(innerStepHit.normal))\n                                        {\n                                            innerStepValid = true;\n                                        }\n                                    }\n                                }\n\n                                if (!innerStepValid)\n                                {\n                                    // At inner step of the step point\n                                    if (CharacterCollisionsRaycast(\n                                            farthestHit.point + (innerHitDirection * SecondaryProbesHorizontal),\n                                            -characterUp,\n                                            MaxStepHeight,\n                                            out innerStepHit,\n                                            _internalCharacterHits,\n                                            true) > 0)\n                                    {\n                                        if (IsStableOnNormal(innerStepHit.normal))\n                                        {\n                                            innerStepValid = true;\n                                        }\n                                    }\n                                }\n\n                                // Final validation of step\n                                if (innerStepValid)\n                                {\n                                    hitCollider = farthestHit.collider;\n                                    foundValidStepPosition = true;\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Discard hit if not valid step\n                if (!foundValidStepPosition)\n                {\n                    nbStepHits--;\n                    if (farthestIndex < nbStepHits)\n                    {\n                        _internalCharacterHits[farthestIndex] = _internalCharacterHits[nbStepHits];\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// Get true linear velocity (taking into account rotational velocity) on a given point of a rigidbody\n        /// </summary>\n        public void GetVelocityFromRigidbodyMovement(Rigidbody interactiveRigidbody, Vector3 atPoint, float deltaTime, out Vector3 linearVelocity, out Vector3 angularVelocity)\n        {\n            if (deltaTime > 0f)\n            {\n                linearVelocity = interactiveRigidbody.linearVelocity;\n                angularVelocity = interactiveRigidbody.angularVelocity;\n                if(interactiveRigidbody.isKinematic)\n                {\n                    PhysicsMover physicsMover = interactiveRigidbody.GetComponent<PhysicsMover>();\n                    if (physicsMover)\n                    {\n                        linearVelocity = physicsMover.Velocity;\n                        angularVelocity = physicsMover.AngularVelocity;\n                    }\n                }\n\n                if (angularVelocity != Vector3.zero)\n                {\n                    Vector3 centerOfRotation = interactiveRigidbody.transform.TransformPoint(interactiveRigidbody.centerOfMass);\n\n                    Vector3 centerOfRotationToPoint = atPoint - centerOfRotation;\n                    Quaternion rotationFromInteractiveRigidbody = Quaternion.Euler(Mathf.Rad2Deg * angularVelocity * deltaTime);\n                    Vector3 finalPointPosition = centerOfRotation + (rotationFromInteractiveRigidbody * centerOfRotationToPoint);\n                    linearVelocity += (finalPointPosition - atPoint) / deltaTime;\n                }\n            }\n            else\n            {\n                linearVelocity = default;\n                angularVelocity = default;\n                return;\n            }\n        }\n\n        /// <summary>\n        /// Determines if a collider has an attached interactive rigidbody\n        /// </summary>\n        private Rigidbody GetInteractiveRigidbody(Collider onCollider)\n        {\n            Rigidbody colliderAttachedRigidbody = onCollider.attachedRigidbody;\n            if (colliderAttachedRigidbody)\n            {\n                if (colliderAttachedRigidbody.gameObject.GetComponent<PhysicsMover>())\n                {\n                    return colliderAttachedRigidbody;\n                }\n\n                if (!colliderAttachedRigidbody.isKinematic)\n                {\n                    return colliderAttachedRigidbody;\n                }\n            }\n            return null;\n        }\n\n        /// <summary>\n        /// Calculates the velocity required to move the character to the target position over a specific deltaTime.\n        /// Useful for when you wish to work with positions rather than velocities in the UpdateVelocity callback \n        /// </summary>\n        public Vector3 GetVelocityForMovePosition(Vector3 fromPosition, Vector3 toPosition, float deltaTime)\n        {\n            return GetVelocityFromMovement(toPosition - fromPosition, deltaTime);\n        }\n\n        public Vector3 GetVelocityFromMovement(Vector3 movement, float deltaTime)\n        {\n            if (deltaTime <= 0f)\n                return Vector3.zero;\n\n            return movement / deltaTime;\n        }\n\n        /// <summary>\n        /// Trims a vector to make it restricted against a plane \n        /// </summary>\n        private void RestrictVectorToPlane(ref Vector3 vector, Vector3 toPlane)\n        {\n            if (vector.x > 0 != toPlane.x > 0)\n            {\n                vector.x = 0;\n            }\n            if (vector.y > 0 != toPlane.y > 0)\n            {\n                vector.y = 0;\n            }\n            if (vector.z > 0 != toPlane.z > 0)\n            {\n                vector.z = 0;\n            }\n        }\n\n        /// <summary>\n        /// Detect if the character capsule is overlapping with anything collidable\n        /// </summary>\n        /// <returns> Returns number of overlaps </returns>\n        public int CharacterCollisionsOverlap(Vector3 position, Quaternion rotation, Collider[] overlappedColliders, float inflate = 0f, bool acceptOnlyStableGroundLayer = false)\n        {\n            int queryLayers = CollidableLayers;\n            if (acceptOnlyStableGroundLayer)\n            {\n                queryLayers = CollidableLayers & StableGroundLayers;\n            }\n\n            Vector3 bottom = position + (rotation * _characterTransformToCapsuleBottomHemi);\n            Vector3 top = position + (rotation * _characterTransformToCapsuleTopHemi);\n            if (inflate != 0f)\n            {\n                bottom += (rotation * Vector3.down * inflate);\n                top += (rotation * Vector3.up * inflate);\n            }\n\n            int nbHits = 0;\n            int nbUnfilteredHits = Physics.OverlapCapsuleNonAlloc(\n                        bottom,\n                        top,\n                        Capsule.radius + inflate,\n                        overlappedColliders,\n                        queryLayers,\n                        QueryTriggerInteraction.Ignore);\n\n            // Filter out invalid colliders\n            nbHits = nbUnfilteredHits;\n            for (int i = nbUnfilteredHits - 1; i >= 0; i--)\n            {\n                if (!CheckIfColliderValidForCollisions(overlappedColliders[i]))\n                {\n                    nbHits--;\n                    if (i < nbHits)\n                    {\n                        overlappedColliders[i] = overlappedColliders[nbHits];\n                    }\n                }\n            }\n\n            return nbHits;\n        }\n\n        /// <summary>\n        /// Detect if the character capsule is overlapping with anything\n        /// </summary>\n        /// <returns> Returns number of overlaps </returns>\n        public int CharacterOverlap(Vector3 position, Quaternion rotation, Collider[] overlappedColliders, LayerMask layers, QueryTriggerInteraction triggerInteraction, float inflate = 0f)\n        {\n            Vector3 bottom = position + (rotation * _characterTransformToCapsuleBottomHemi);\n            Vector3 top = position + (rotation * _characterTransformToCapsuleTopHemi);\n            if (inflate != 0f)\n            {\n                bottom += (rotation * Vector3.down * inflate);\n                top += (rotation * Vector3.up * inflate);\n            }\n\n            int nbHits = 0;\n            int nbUnfilteredHits = Physics.OverlapCapsuleNonAlloc(\n                        bottom,\n                        top,\n                        Capsule.radius + inflate,\n                        overlappedColliders,\n                        layers,\n                        triggerInteraction);\n\n            // Filter out the character capsule itself\n            nbHits = nbUnfilteredHits;\n            for (int i = nbUnfilteredHits - 1; i >= 0; i--)\n            {\n                if (overlappedColliders[i] == Capsule)\n                {\n                    nbHits--;\n                    if (i < nbHits)\n                    {\n                        overlappedColliders[i] = overlappedColliders[nbHits];\n                    }\n                }\n            }\n\n            return nbHits;\n        }\n\n        /// <summary>\n        /// Sweeps the capsule's volume to detect collision hits\n        /// </summary>\n        /// <returns> Returns the number of hits </returns>\n        public int CharacterCollisionsSweep(Vector3 position, Quaternion rotation, Vector3 direction, float distance, out RaycastHit closestHit, RaycastHit[] hits, float inflate = 0f, bool acceptOnlyStableGroundLayer = false)\n        {\n            int queryLayers = CollidableLayers;\n            if (acceptOnlyStableGroundLayer)\n            {\n                queryLayers = CollidableLayers & StableGroundLayers;\n            }\n\n            Vector3 bottom = position + (rotation * _characterTransformToCapsuleBottomHemi) - (direction * SweepProbingBackstepDistance);\n            Vector3 top = position + (rotation * _characterTransformToCapsuleTopHemi) - (direction * SweepProbingBackstepDistance);\n            if (inflate != 0f)\n            {\n                bottom += (rotation * Vector3.down * inflate);\n                top += (rotation * Vector3.up * inflate);\n            }\n\n            // Capsule cast\n            int nbHits = 0;\n            int nbUnfilteredHits = Physics.CapsuleCastNonAlloc(\n                    bottom,\n                    top,\n                    Capsule.radius + inflate,\n                    direction,\n                    hits,\n                    distance + SweepProbingBackstepDistance,\n                    queryLayers,\n                    QueryTriggerInteraction.Ignore);\n\n            // Hits filter\n            closestHit = new RaycastHit();\n            float closestDistance = Mathf.Infinity;\n            nbHits = nbUnfilteredHits;\n            for (int i = nbUnfilteredHits - 1; i >= 0; i--)\n            {\n                hits[i].distance -= SweepProbingBackstepDistance;\n\n                RaycastHit hit = hits[i];\n                float hitDistance = hit.distance;\n\n                // Filter out the invalid hits\n                if (hitDistance <= 0f || !CheckIfColliderValidForCollisions(hit.collider))\n                {\n                    nbHits--;\n                    if (i < nbHits)\n                    {\n                        hits[i] = hits[nbHits];\n                    }\n                }\n                else\n                {\n                    // Remember closest valid hit\n                    if (hitDistance < closestDistance)\n                    {\n                        closestHit = hit;\n                        closestDistance = hitDistance;\n                    }\n                }\n            }\n\n            return nbHits;\n        }\n\n        /// <summary>\n        /// Sweeps the capsule's volume to detect hits\n        /// </summary>\n        /// <returns> Returns the number of hits </returns>\n        public int CharacterSweep(Vector3 position, Quaternion rotation, Vector3 direction, float distance, out RaycastHit closestHit, RaycastHit[] hits, LayerMask layers, QueryTriggerInteraction triggerInteraction, float inflate = 0f)\n        {\n            closestHit = new RaycastHit();\n\n            Vector3 bottom = position + (rotation * _characterTransformToCapsuleBottomHemi);\n            Vector3 top = position + (rotation * _characterTransformToCapsuleTopHemi);\n            if (inflate != 0f)\n            {\n                bottom += (rotation * Vector3.down * inflate);\n                top += (rotation * Vector3.up * inflate);\n            }\n\n            // Capsule cast\n            int nbHits = 0;\n            int nbUnfilteredHits = Physics.CapsuleCastNonAlloc(\n                bottom,\n                top,\n                Capsule.radius + inflate,\n                direction,\n                hits,\n                distance,\n                layers,\n                triggerInteraction);\n\n            // Hits filter\n            float closestDistance = Mathf.Infinity;\n            nbHits = nbUnfilteredHits;\n            for (int i = nbUnfilteredHits - 1; i >= 0; i--)\n            {\n                RaycastHit hit = hits[i];\n\n                // Filter out the character capsule\n                if (hit.distance <= 0f || hit.collider == Capsule)\n                {\n                    nbHits--;\n                    if (i < nbHits)\n                    {\n                        hits[i] = hits[nbHits];\n                    }\n                }\n                else\n                {\n                    // Remember closest valid hit\n                    float hitDistance = hit.distance;\n                    if (hitDistance < closestDistance)\n                    {\n                        closestHit = hit;\n                        closestDistance = hitDistance;\n                    }\n                }\n            }\n\n            return nbHits;\n        }\n\n        /// <summary>\n        /// Casts the character volume in the character's downward direction to detect ground\n        /// </summary>\n        /// <returns> Returns the number of hits </returns>\n        private bool CharacterGroundSweep(Vector3 position, Quaternion rotation, Vector3 direction, float distance, out RaycastHit closestHit)\n        {\n            closestHit = new RaycastHit();\n\n            // Capsule cast\n            int nbUnfilteredHits = Physics.CapsuleCastNonAlloc(\n                position + (rotation * _characterTransformToCapsuleBottomHemi) - (direction * GroundProbingBackstepDistance),\n                position + (rotation * _characterTransformToCapsuleTopHemi) - (direction * GroundProbingBackstepDistance),\n                Capsule.radius,\n                direction,\n                _internalCharacterHits,\n                distance + GroundProbingBackstepDistance,\n                CollidableLayers & StableGroundLayers,\n                QueryTriggerInteraction.Ignore);\n\n            // Hits filter\n            bool foundValidHit = false;\n            float closestDistance = Mathf.Infinity;\n            for (int i = 0; i < nbUnfilteredHits; i++)\n            {\n                RaycastHit hit = _internalCharacterHits[i];\n                float hitDistance = hit.distance;\n\n                // Find the closest valid hit\n                if (hitDistance > 0f && CheckIfColliderValidForCollisions(hit.collider))\n                {\n                    if (hitDistance < closestDistance)\n                    {\n                        closestHit = hit;\n                        closestHit.distance -= GroundProbingBackstepDistance;\n                        closestDistance = hitDistance;\n\n                        foundValidHit = true;\n                    }\n                }\n            }\n\n            return foundValidHit;\n        }\n\n        /// <summary>\n        /// Raycasts to detect collision hits\n        /// </summary>\n        /// <returns> Returns the number of hits </returns>\n        public int CharacterCollisionsRaycast(Vector3 position, Vector3 direction, float distance, out RaycastHit closestHit, RaycastHit[] hits, bool acceptOnlyStableGroundLayer = false)\n        {\n            int queryLayers = CollidableLayers;\n            if (acceptOnlyStableGroundLayer)\n            {\n                queryLayers = CollidableLayers & StableGroundLayers;\n            }\n\n            // Raycast\n            int nbHits = 0;\n            int nbUnfilteredHits = Physics.RaycastNonAlloc(\n                position,\n                direction,\n                hits,\n                distance,\n                queryLayers,\n                QueryTriggerInteraction.Ignore);\n\n            // Hits filter\n            closestHit = new RaycastHit();\n            float closestDistance = Mathf.Infinity;\n            nbHits = nbUnfilteredHits;\n            for (int i = nbUnfilteredHits - 1; i >= 0; i--)\n            {\n                RaycastHit hit = hits[i];\n                float hitDistance = hit.distance;\n\n                // Filter out the invalid hits\n                if (hitDistance <= 0f ||\n                    !CheckIfColliderValidForCollisions(hit.collider))\n                {\n                    nbHits--;\n                    if (i < nbHits)\n                    {\n                        hits[i] = hits[nbHits];\n                    }\n                }\n                else\n                {\n                    // Remember closest valid hit\n                    if (hitDistance < closestDistance)\n                    {\n                        closestHit = hit;\n                        closestDistance = hitDistance;\n                    }\n                }\n            }\n\n            return nbHits;\n        }\n    }\n}","numLines":529,"startLine":2161,"totalLines":2689}}}
{"parentUuid":"ac39eff1-e55d-46e2-9237-8686541d786c","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013F7y5PgBRkQY2o3XAvPcbJ","type":"tool_result","content":"  1621→            {\n  1622→                Vector3 obstructionLeftAlongGround = Vector3.Cross(GroundingStatus.GroundNormal, obstructionNormal).normalized;\n  1623→                obstructionNormal = Vector3.Cross(obstructionLeftAlongGround, _characterUp).normalized;\n  1624→            }\n  1625→\n  1626→            // Catch cases where cross product between parallel normals returned 0\n  1627→            if (obstructionNormal.sqrMagnitude == 0f)\n  1628→            {\n  1629→                obstructionNormal = hitNormal;\n  1630→            }\n  1631→\n  1632→            return obstructionNormal;\n  1633→        }\n  1634→\n  1635→        /// <summary>\n  1636→        /// Remembers a rigidbody hit for processing later\n  1637→        /// </summary>\n  1638→        private void StoreRigidbodyHit(Rigidbody hitRigidbody, Vector3 hitVelocity, Vector3 hitPoint, Vector3 obstructionNormal, HitStabilityReport hitStabilityReport)\n  1639→        {\n  1640→            if (_rigidbodyProjectionHitCount < _internalRigidbodyProjectionHits.Length)\n  1641→            {\n  1642→                if (!hitRigidbody.GetComponent<KinematicCharacterMotor>())\n  1643→                {\n  1644→                    RigidbodyProjectionHit rph = new RigidbodyProjectionHit();\n  1645→                    rph.Rigidbody = hitRigidbody;\n  1646→                    rph.HitPoint = hitPoint;\n  1647→                    rph.EffectiveHitNormal = obstructionNormal;\n  1648→                    rph.HitVelocity = hitVelocity;\n  1649→                    rph.StableOnHit = hitStabilityReport.IsStable;\n  1650→\n  1651→                    _internalRigidbodyProjectionHits[_rigidbodyProjectionHitCount] = rph;\n  1652→                    _rigidbodyProjectionHitCount++;\n  1653→                }\n  1654→            }\n  1655→        }\n  1656→\n  1657→        public void SetTransientPosition(Vector3 newPos)\n  1658→        {\n  1659→            _transientPosition = newPos;\n  1660→        }\n  1661→\n  1662→        /// <summary>\n  1663→        /// Processes movement projection upon detecting a hit\n  1664→        /// </summary>\n  1665→        private void InternalHandleVelocityProjection(bool stableOnHit, Vector3 hitNormal, Vector3 obstructionNormal, Vector3 originalDirection,\n  1666→            ref MovementSweepState sweepState, bool previousHitIsStable, Vector3 previousVelocity, Vector3 previousObstructionNormal,\n  1667→            ref Vector3 transientVelocity, ref float remainingMovementMagnitude, ref Vector3 remainingMovementDirection)\n  1668→        {\n  1669→            if (transientVelocity.sqrMagnitude <= 0f)\n  1670→            {\n  1671→                return;\n  1672→            }\n  1673→\n  1674→            Vector3 velocityBeforeProjection = transientVelocity;\n  1675→\n  1676→            if (stableOnHit)\n  1677→            {\n  1678→                LastMovementIterationFoundAnyGround = true;\n  1679→                HandleVelocityProjection(ref transientVelocity, obstructionNormal, stableOnHit);\n  1680→            }\n  1681→            else\n  1682→            {\n  1683→                // Handle projection\n  1684→                if (sweepState == MovementSweepState.Initial)\n  1685→                {\n  1686→                    HandleVelocityProjection(ref transientVelocity, obstructionNormal, stableOnHit);\n  1687→                    sweepState = MovementSweepState.AfterFirstHit;\n  1688→                }\n  1689→                // Blocking crease handling\n  1690→                else if (sweepState == MovementSweepState.AfterFirstHit)\n  1691→                {\n  1692→                    EvaluateCrease(\n  1693→                        transientVelocity,\n  1694→                        previousVelocity,\n  1695→                        obstructionNormal,\n  1696→                        previousObstructionNormal,\n  1697→                        stableOnHit,\n  1698→                        previousHitIsStable,\n  1699→                        GroundingStatus.IsStableOnGround && !MustUnground(),\n  1700→                        out bool foundCrease,\n  1701→                        out Vector3 creaseDirection);\n  1702→\n  1703→                    if (foundCrease)\n  1704→                    {\n  1705→                        if (GroundingStatus.IsStableOnGround && !MustUnground())\n  1706→                        {\n  1707→                            transientVelocity = Vector3.zero;\n  1708→                            sweepState = MovementSweepState.FoundBlockingCorner;\n  1709→                        }\n  1710→                        else\n  1711→                        {\n  1712→                            transientVelocity = Vector3.Project(transientVelocity, creaseDirection);\n  1713→                            sweepState = MovementSweepState.FoundBlockingCrease;\n  1714→                        }\n  1715→                    }\n  1716→                    else\n  1717→                    {\n  1718→                        HandleVelocityProjection(ref transientVelocity, obstructionNormal, stableOnHit);\n  1719→                    }\n  1720→                }\n  1721→                // Blocking corner handling\n  1722→                else if (sweepState == MovementSweepState.FoundBlockingCrease)\n  1723→                {\n  1724→                    transientVelocity = Vector3.zero;\n  1725→                    sweepState = MovementSweepState.FoundBlockingCorner;\n  1726→                }\n  1727→            }\n  1728→\n  1729→            if (HasPlanarConstraint)\n  1730→            {\n  1731→                transientVelocity = Vector3.ProjectOnPlane(transientVelocity, PlanarConstraintAxis.normalized);\n  1732→            }\n  1733→\n  1734→            float newVelocityFactor = transientVelocity.magnitude / velocityBeforeProjection.magnitude;\n  1735→            remainingMovementMagnitude *= newVelocityFactor;\n  1736→            remainingMovementDirection = transientVelocity.normalized;\n  1737→        }\n  1738→\n  1739→        private void EvaluateCrease(\n  1740→            Vector3 currentCharacterVelocity,\n  1741→            Vector3 previousCharacterVelocity,\n  1742→            Vector3 currentHitNormal,\n  1743→            Vector3 previousHitNormal,\n  1744→            bool currentHitIsStable,\n  1745→            bool previousHitIsStable,\n  1746→            bool characterIsStable,\n  1747→            out bool isValidCrease,\n  1748→            out Vector3 creaseDirection)\n  1749→        {\n  1750→            isValidCrease = false;\n  1751→            creaseDirection = default;\n  1752→\n  1753→            if (!characterIsStable || !currentHitIsStable || !previousHitIsStable)\n  1754→            {\n  1755→                Vector3 tmpBlockingCreaseDirection = Vector3.Cross(currentHitNormal, previousHitNormal).normalized;\n  1756→                float dotPlanes = Vector3.Dot(currentHitNormal, previousHitNormal);\n  1757→                bool isVelocityConstrainedByCrease = false;\n  1758→\n  1759→                // Avoid calculations if the two planes are the same\n  1760→                if (dotPlanes < 0.999f)\n  1761→                {\n  1762→                    // TODO: can this whole part be made simpler? (with 2d projections, etc)\n  1763→                    Vector3 normalAOnCreasePlane = Vector3.ProjectOnPlane(currentHitNormal, tmpBlockingCreaseDirection).normalized;\n  1764→                    Vector3 normalBOnCreasePlane = Vector3.ProjectOnPlane(previousHitNormal, tmpBlockingCreaseDirection).normalized;\n  1765→                    float dotPlanesOnCreasePlane = Vector3.Dot(normalAOnCreasePlane, normalBOnCreasePlane);\n  1766→\n  1767→                    Vector3 enteringVelocityDirectionOnCreasePlane = Vector3.ProjectOnPlane(previousCharacterVelocity, tmpBlockingCreaseDirection).normalized;\n  1768→\n  1769→                    if (dotPlanesOnCreasePlane <= (Vector3.Dot(-enteringVelocityDirectionOnCreasePlane, normalAOnCreasePlane) + 0.001f) &&\n  1770→                        dotPlanesOnCreasePlane <= (Vector3.Dot(-enteringVelocityDirectionOnCreasePlane, normalBOnCreasePlane) + 0.001f))\n  1771→                    {\n  1772→                        isVelocityConstrainedByCrease = true;\n  1773→                    }\n  1774→                }\n  1775→\n  1776→                if (isVelocityConstrainedByCrease)\n  1777→                {\n  1778→                    // Flip crease direction to make it representative of the real direction our velocity would be projected to\n  1779→                    if (Vector3.Dot(tmpBlockingCreaseDirection, currentCharacterVelocity) < 0f)\n  1780→                    {\n  1781→                        tmpBlockingCreaseDirection = -tmpBlockingCreaseDirection;\n  1782→                    }\n  1783→\n  1784→                    isValidCrease = true;\n  1785→                    creaseDirection = tmpBlockingCreaseDirection;\n  1786→                }\n  1787→            }\n  1788→        }\n  1789→\n  1790→        /// <summary>\n  1791→        /// Allows you to override the way velocity is projected on an obstruction\n  1792→        /// </summary>\n  1793→        public virtual void HandleVelocityProjection(ref Vector3 velocity, Vector3 obstructionNormal, bool stableOnHit)\n  1794→        {\n  1795→            if (GroundingStatus.IsStableOnGround && !MustUnground())\n  1796→            {\n  1797→                // On stable slopes, simply reorient the movement without any loss\n  1798→                if (stableOnHit)\n  1799→                {\n  1800→                    velocity = GetDirectionTangentToSurface(velocity, obstructionNormal) * velocity.magnitude;\n  1801→                }\n  1802→                // On blocking hits, project the movement on the obstruction while following the grounding plane\n  1803→                else\n  1804→                {\n  1805→                    Vector3 obstructionRightAlongGround = Vector3.Cross(obstructionNormal, GroundingStatus.GroundNormal).normalized;\n  1806→                    Vector3 obstructionUpAlongGround = Vector3.Cross(obstructionRightAlongGround, obstructionNormal).normalized;\n  1807→                    velocity = GetDirectionTangentToSurface(velocity, obstructionUpAlongGround) * velocity.magnitude;\n  1808→                    velocity = Vector3.ProjectOnPlane(velocity, obstructionNormal);\n  1809→                }\n  1810→            }\n  1811→            else\n  1812→            {\n  1813→                if (stableOnHit)\n  1814→                {\n  1815→                    // Handle stable landing\n  1816→                    velocity = Vector3.ProjectOnPlane(velocity, CharacterUp);\n  1817→                    velocity = GetDirectionTangentToSurface(velocity, obstructionNormal) * velocity.magnitude;\n  1818→                }\n  1819→                // Handle generic obstruction\n  1820→                else\n  1821→                {\n  1822→                    velocity = Vector3.ProjectOnPlane(velocity, obstructionNormal);\n  1823→                }\n  1824→            }\n  1825→        }\n  1826→\n  1827→        /// <summary>\n  1828→        /// Allows you to override the way hit rigidbodies are pushed / interacted with. \n  1829→        /// ProcessedVelocity is what must be modified if this interaction affects the character's velocity.\n  1830→        /// </summary>\n  1831→        public virtual void HandleSimulatedRigidbodyInteraction(ref Vector3 processedVelocity, RigidbodyProjectionHit hit, float deltaTime)\n  1832→        {\n  1833→        }\n  1834→\n  1835→        /// <summary>\n  1836→        /// Takes into account rigidbody hits for adding to the velocity\n  1837→        /// </summary>\n  1838→        private void ProcessVelocityForRigidbodyHits(ref Vector3 processedVelocity, float deltaTime)\n  1839→        {\n  1840→            for (int i = 0; i < _rigidbodyProjectionHitCount; i++)\n  1841→            {\n  1842→                RigidbodyProjectionHit bodyHit = _internalRigidbodyProjectionHits[i];\n  1843→\n  1844→                if (bodyHit.Rigidbody && !_rigidbodiesPushedThisMove.Contains(bodyHit.Rigidbody))\n  1845→                {\n  1846→                    if (_internalRigidbodyProjectionHits[i].Rigidbody != _attachedRigidbody)\n  1847→                    {\n  1848→                        // Remember we hit this rigidbody\n  1849→                        _rigidbodiesPushedThisMove.Add(bodyHit.Rigidbody);\n  1850→\n  1851→                        float characterMass = SimulatedCharacterMass;\n  1852→                        Vector3 characterVelocity = bodyHit.HitVelocity;\n  1853→\n  1854→                        KinematicCharacterMotor hitCharacterMotor = bodyHit.Rigidbody.GetComponent<KinematicCharacterMotor>();\n  1855→                        bool hitBodyIsCharacter = hitCharacterMotor != null;\n  1856→                        bool hitBodyIsDynamic = !bodyHit.Rigidbody.isKinematic;\n  1857→                        float hitBodyMass = bodyHit.Rigidbody.mass;\n  1858→                        float hitBodyMassAtPoint = bodyHit.Rigidbody.mass; // todo\n  1859→                        Vector3 hitBodyVelocity = bodyHit.Rigidbody.linearVelocity;\n  1860→                        if (hitBodyIsCharacter)\n  1861→                        {\n  1862→                            hitBodyMass = hitCharacterMotor.SimulatedCharacterMass;\n  1863→                            hitBodyMassAtPoint = hitCharacterMotor.SimulatedCharacterMass; // todo\n  1864→                            hitBodyVelocity = hitCharacterMotor.BaseVelocity;\n  1865→                        }\n  1866→                        else if (!hitBodyIsDynamic)\n  1867→                        {\n  1868→                            PhysicsMover physicsMover = bodyHit.Rigidbody.GetComponent<PhysicsMover>();\n  1869→                            if(physicsMover)\n  1870→                            {\n  1871→                                hitBodyVelocity = physicsMover.Velocity;\n  1872→                            }\n  1873→                        }\n  1874→\n  1875→                        // Calculate the ratio of the total mass that the character mass represents\n  1876→                        float characterToBodyMassRatio = 1f;\n  1877→                        {\n  1878→                            if (characterMass + hitBodyMassAtPoint > 0f)\n  1879→                            {\n  1880→                                characterToBodyMassRatio = characterMass / (characterMass + hitBodyMassAtPoint);\n  1881→                            }\n  1882→                            else\n  1883→                            {\n  1884→                                characterToBodyMassRatio = 0.5f;\n  1885→                            }\n  1886→\n  1887→                            // Hitting a non-dynamic body\n  1888→                            if (!hitBodyIsDynamic)\n  1889→                            {\n  1890→                                characterToBodyMassRatio = 0f;\n  1891→                            }\n  1892→                            // Emulate kinematic body interaction\n  1893→                            else if (RigidbodyInteractionType == RigidbodyInteractionType.Kinematic && !hitBodyIsCharacter)\n  1894→                            {\n  1895→                                characterToBodyMassRatio = 1f;\n  1896→                            }\n  1897→                        }\n  1898→\n  1899→                        ComputeCollisionResolutionForHitBody(\n  1900→                            bodyHit.EffectiveHitNormal,\n  1901→                            characterVelocity,\n  1902→                            hitBodyVelocity,\n  1903→                            characterToBodyMassRatio,\n  1904→                            out Vector3 velocityChangeOnCharacter,\n  1905→                            out Vector3 velocityChangeOnBody);\n  1906→\n  1907→                        processedVelocity += velocityChangeOnCharacter;\n  1908→\n  1909→                        if (hitBodyIsCharacter)\n  1910→                        {\n  1911→                            hitCharacterMotor.BaseVelocity += velocityChangeOnCharacter;\n  1912→                        }\n  1913→                        else if (hitBodyIsDynamic)\n  1914→                        {\n  1915→                            bodyHit.Rigidbody.AddForceAtPosition(velocityChangeOnBody, bodyHit.HitPoint, ForceMode.VelocityChange);\n  1916→                        }\n  1917→\n  1918→                        if (RigidbodyInteractionType == RigidbodyInteractionType.SimulatedDynamic)\n  1919→                        {\n  1920→                            HandleSimulatedRigidbodyInteraction(ref processedVelocity, bodyHit, deltaTime);\n  1921→                        }\n  1922→                    }\n  1923→                }\n  1924→            }\n  1925→\n  1926→        }\n  1927→\n  1928→        public void ComputeCollisionResolutionForHitBody(\n  1929→            Vector3 hitNormal,\n  1930→            Vector3 characterVelocity,\n  1931→            Vector3 bodyVelocity,\n  1932→            float characterToBodyMassRatio,\n  1933→            out Vector3 velocityChangeOnCharacter,\n  1934→            out Vector3 velocityChangeOnBody)\n  1935→        {\n  1936→            velocityChangeOnCharacter = default;\n  1937→            velocityChangeOnBody = default;\n  1938→\n  1939→            float bodyToCharacterMassRatio = 1f - characterToBodyMassRatio;\n  1940→            float characterVelocityMagnitudeOnHitNormal = Vector3.Dot(characterVelocity, hitNormal);\n  1941→            float bodyVelocityMagnitudeOnHitNormal = Vector3.Dot(bodyVelocity, hitNormal);\n  1942→\n  1943→            // if character velocity was going against the obstruction, restore the portion of the velocity that got projected during the movement phase\n  1944→            if (characterVelocityMagnitudeOnHitNormal < 0f)\n  1945→            {\n  1946→                Vector3 restoredCharacterVelocity = hitNormal * characterVelocityMagnitudeOnHitNormal;\n  1947→                velocityChangeOnCharacter += restoredCharacterVelocity;\n  1948→            }\n  1949→\n  1950→            // solve impulse velocities on both bodies, but only if the body velocity would be giving resistance to the character in any way\n  1951→            if (bodyVelocityMagnitudeOnHitNormal > characterVelocityMagnitudeOnHitNormal)\n  1952→            {\n  1953→                Vector3 relativeImpactVelocity = hitNormal * (bodyVelocityMagnitudeOnHitNormal - characterVelocityMagnitudeOnHitNormal);\n  1954→                velocityChangeOnCharacter += relativeImpactVelocity * bodyToCharacterMassRatio;\n  1955→                velocityChangeOnBody += -relativeImpactVelocity * characterToBodyMassRatio;\n  1956→            }\n  1957→        }\n  1958→\n  1959→        /// <summary>\n  1960→        /// Determines if the input collider is valid for collision processing\n  1961→        /// </summary>\n  1962→        /// <returns> Returns true if the collider is valid </returns>\n  1963→        private bool CheckIfColliderValidForCollisions(Collider coll)\n  1964→        {\n  1965→            // Ignore self\n  1966→            if (coll == Capsule)\n  1967→            {\n  1968→                return false;\n  1969→            }\n  1970→\n  1971→            if (!InternalIsColliderValidForCollisions(coll))\n  1972→            {\n  1973→                return false;\n  1974→            }\n  1975→\n  1976→            return true;\n  1977→        }\n  1978→\n  1979→        /// <summary>\n  1980→        /// Determines if the input collider is valid for collision processing\n  1981→        /// </summary>\n  1982→        private bool InternalIsColliderValidForCollisions(Collider coll)\n  1983→        {\n  1984→            Rigidbody colliderAttachedRigidbody = coll.attachedRigidbody;\n  1985→            if (colliderAttachedRigidbody)\n  1986→            {\n  1987→                bool isRigidbodyKinematic = colliderAttachedRigidbody.isKinematic;\n  1988→\n  1989→                // If movement is made from AttachedRigidbody, ignore the AttachedRigidbody\n  1990→                if (_isMovingFromAttachedRigidbody && (!isRigidbodyKinematic || colliderAttachedRigidbody == _attachedRigidbody))\n  1991→                {\n  1992→                    return false;\n  1993→                }\n  1994→\n  1995→                // don't collide with dynamic rigidbodies if our RigidbodyInteractionType is kinematic\n  1996→                if (RigidbodyInteractionType == RigidbodyInteractionType.Kinematic && !isRigidbodyKinematic)\n  1997→                {\n  1998→                    // wake up rigidbody\n  1999→                    if (coll.attachedRigidbody)\n  2000→                    {\n  2001→                        coll.attachedRigidbody.WakeUp();\n  2002→                    }\n  2003→\n  2004→                    return false;\n  2005→                }\n  2006→            }\n  2007→\n  2008→            // Custom checks\n  2009→            bool colliderValid = CharacterController.IsColliderValidForCollisions(coll);\n  2010→            if (!colliderValid)\n  2011→            {\n  2012→                return false;\n  2013→            }\n  2014→\n  2015→            return true;\n  2016→        }\n  2017→\n  2018→        /// <summary>\n  2019→        /// Determines if the motor is considered stable on a given hit\n  2020→        /// </summary>\n  2021→        public void EvaluateHitStability(Collider hitCollider, Vector3 hitNormal, Vector3 hitPoint, Vector3 atCharacterPosition, Quaternion atCharacterRotation, Vector3 withCharacterVelocity, ref HitStabilityReport stabilityReport)\n  2022→        {\n  2023→            if (!_solveGrounding)\n  2024→            {\n  2025→                stabilityReport.IsStable = false;\n  2026→                return;\n  2027→            }\n  2028→\n  2029→            Vector3 atCharacterUp = atCharacterRotation * _cachedWorldUp;\n  2030→            Vector3 innerHitDirection = Vector3.ProjectOnPlane(hitNormal, atCharacterUp).normalized;\n  2031→\n  2032→            stabilityReport.IsStable = this.IsStableOnNormal(hitNormal);\n  2033→\n  2034→            stabilityReport.FoundInnerNormal = false;\n  2035→            stabilityReport.FoundOuterNormal = false;\n  2036→            stabilityReport.InnerNormal = hitNormal;\n  2037→            stabilityReport.OuterNormal = hitNormal;\n  2038→\n  2039→            // Ledge handling\n  2040→            if (LedgeAndDenivelationHandling)\n  2041→            {\n  2042→                float ledgeCheckHeight = MinDistanceForLedge;\n  2043→                if (StepHandling != StepHandlingMethod.None)\n  2044→                {\n  2045→                    ledgeCheckHeight = MaxStepHeight;\n  2046→                }\n  2047→\n  2048→                bool isStableLedgeInner = false;\n  2049→                bool isStableLedgeOuter = false;\n  2050→\n  2051→                if (CharacterCollisionsRaycast(\n  2052→                        hitPoint + (atCharacterUp * SecondaryProbesVertical) + (innerHitDirection * SecondaryProbesHorizontal),\n  2053→                        -atCharacterUp,\n  2054→                        ledgeCheckHeight + SecondaryProbesVertical,\n  2055→                        out RaycastHit innerLedgeHit,\n  2056→                        _internalCharacterHits) > 0)\n  2057→                {\n  2058→                    Vector3 innerLedgeNormal = innerLedgeHit.normal;\n  2059→                    stabilityReport.InnerNormal = innerLedgeNormal;\n  2060→                    stabilityReport.FoundInnerNormal = true;\n  2061→                    isStableLedgeInner = IsStableOnNormal(innerLedgeNormal);\n  2062→                }\n  2063→\n  2064→                if (CharacterCollisionsRaycast(\n  2065→                        hitPoint + (atCharacterUp * SecondaryProbesVertical) + (-innerHitDirection * SecondaryProbesHorizontal),\n  2066→                        -atCharacterUp,\n  2067→                        ledgeCheckHeight + SecondaryProbesVertical,\n  2068→                        out RaycastHit outerLedgeHit,\n  2069→                        _internalCharacterHits) > 0)\n  2070→                {\n  2071→                    Vector3 outerLedgeNormal = outerLedgeHit.normal;\n  2072→                    stabilityReport.OuterNormal = outerLedgeNormal;\n  2073→                    stabilityReport.FoundOuterNormal = true;\n  2074→                    isStableLedgeOuter = IsStableOnNormal(outerLedgeNormal);\n  2075→                }\n  2076→\n  2077→                stabilityReport.LedgeDetected = (isStableLedgeInner != isStableLedgeOuter);\n  2078→                if (stabilityReport.LedgeDetected)\n  2079→                {\n  2080→                    stabilityReport.IsOnEmptySideOfLedge = isStableLedgeOuter && !isStableLedgeInner;\n  2081→                    stabilityReport.LedgeGroundNormal = isStableLedgeOuter ? stabilityReport.OuterNormal : stabilityReport.InnerNormal;\n  2082→                    stabilityReport.LedgeRightDirection = Vector3.Cross(hitNormal, stabilityReport.LedgeGroundNormal).normalized;\n  2083→                    stabilityReport.LedgeFacingDirection = Vector3.ProjectOnPlane(Vector3.Cross(stabilityReport.LedgeGroundNormal, stabilityReport.LedgeRightDirection), CharacterUp).normalized;\n  2084→                    stabilityReport.DistanceFromLedge = Vector3.ProjectOnPlane((hitPoint - (atCharacterPosition + (atCharacterRotation * _characterTransformToCapsuleBottom))), atCharacterUp).magnitude;\n  2085→                    stabilityReport.IsMovingTowardsEmptySideOfLedge = Vector3.Dot(withCharacterVelocity.normalized, stabilityReport.LedgeFacingDirection) > 0f;\n  2086→                }\n  2087→\n  2088→                if (stabilityReport.IsStable)\n  2089→                {\n  2090→                    stabilityReport.IsStable = IsStableWithSpecialCases(ref stabilityReport, withCharacterVelocity);\n  2091→                }\n  2092→            }\n  2093→\n  2094→            // Step handling\n  2095→            if (StepHandling != StepHandlingMethod.None && !stabilityReport.IsStable)\n  2096→            {\n  2097→                // Stepping not supported on dynamic rigidbodies\n  2098→                Rigidbody hitRigidbody = hitCollider.attachedRigidbody;\n  2099→                if (!(hitRigidbody && !hitRigidbody.isKinematic))\n  2100→                {\n  2101→                    DetectSteps(atCharacterPosition, atCharacterRotation, hitPoint, innerHitDirection, ref stabilityReport);\n  2102→\n  2103→                    if (stabilityReport.ValidStepDetected)\n  2104→                    {\n  2105→                        stabilityReport.IsStable = true;\n  2106→                    }\n  2107→                }\n  2108→            }\n  2109→\n  2110→            CharacterController.ProcessHitStabilityReport(hitCollider, hitNormal, hitPoint, atCharacterPosition, atCharacterRotation, ref stabilityReport);\n  2111→        }\n  2112→\n  2113→        private void DetectSteps(Vector3 characterPosition, Quaternion characterRotation, Vector3 hitPoint, Vector3 innerHitDirection, ref HitStabilityReport stabilityReport)\n  2114→        {\n  2115→            int nbStepHits = 0;\n  2116→            Collider tmpCollider;\n  2117→            RaycastHit outerStepHit;\n  2118→            Vector3 characterUp = characterRotation * _cachedWorldUp;\n  2119→            Vector3 verticalCharToHit = Vector3.Project((hitPoint - characterPosition), characterUp);\n  2120→            Vector3 horizontalCharToHitDirection = Vector3.ProjectOnPlane((hitPoint - characterPosition), characterUp).normalized;\n  2121→            Vector3 stepCheckStartPos = (hitPoint - verticalCharToHit) + (characterUp * MaxStepHeight) + (horizontalCharToHitDirection * CollisionOffset * 3f); \n  2122→\n  2123→            // Do outer step check with capsule cast on hit point\n  2124→            nbStepHits = CharacterCollisionsSweep(\n  2125→                            stepCheckStartPos,\n  2126→                            characterRotation,\n  2127→                            -characterUp,\n  2128→                            MaxStepHeight + CollisionOffset,\n  2129→                            out outerStepHit,\n  2130→                            _internalCharacterHits,\n  2131→                            0f,\n  2132→                            true);\n  2133→\n  2134→            // Check for overlaps and obstructions at the hit position\n  2135→            if (CheckStepValidity(nbStepHits, characterPosition, characterRotation, innerHitDirection, stepCheckStartPos, out tmpCollider))\n  2136→            {\n  2137→                stabilityReport.ValidStepDetected = true;\n  2138→                stabilityReport.SteppedCollider = tmpCollider;\n  2139→            }\n  2140→\n  2141→            if (StepHandling == StepHandlingMethod.Extra && !stabilityReport.ValidStepDetected)\n  2142→            {\n  2143→                // Do min reach step check with capsule cast on hit point\n  2144→                stepCheckStartPos = characterPosition + (characterUp * MaxStepHeight) + (-innerHitDirection * MinRequiredStepDepth);\n  2145→                nbStepHits = CharacterCollisionsSweep(\n  2146→                                stepCheckStartPos,\n  2147→                                characterRotation,\n  2148→                                -characterUp,\n  2149→                                MaxStepHeight - CollisionOffset,\n  2150→                                out outerStepHit,\n  2151→                                _internalCharacterHits,\n  2152→                                0f,\n  2153→                                true);\n  2154→\n  2155→                // Check for overlaps and obstructions at the hit position\n  2156→                if (CheckStepValidity(nbStepHits, characterPosition, characterRotation, innerHitDirection, stepCheckStartPos, out tmpCollider))\n  2157→                {\n  2158→                    stabilityReport.ValidStepDetected = true;\n  2159→                    stabilityReport.SteppedCollider = tmpCollider;\n  2160→                }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"404b785a-4b33-4655-b404-73d3001b9e54","timestamp":"2025-12-19T10:13:13.773Z","toolUseResult":{"type":"text","file":{"filePath":"e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs","content":"            {\n                Vector3 obstructionLeftAlongGround = Vector3.Cross(GroundingStatus.GroundNormal, obstructionNormal).normalized;\n                obstructionNormal = Vector3.Cross(obstructionLeftAlongGround, _characterUp).normalized;\n            }\n\n            // Catch cases where cross product between parallel normals returned 0\n            if (obstructionNormal.sqrMagnitude == 0f)\n            {\n                obstructionNormal = hitNormal;\n            }\n\n            return obstructionNormal;\n        }\n\n        /// <summary>\n        /// Remembers a rigidbody hit for processing later\n        /// </summary>\n        private void StoreRigidbodyHit(Rigidbody hitRigidbody, Vector3 hitVelocity, Vector3 hitPoint, Vector3 obstructionNormal, HitStabilityReport hitStabilityReport)\n        {\n            if (_rigidbodyProjectionHitCount < _internalRigidbodyProjectionHits.Length)\n            {\n                if (!hitRigidbody.GetComponent<KinematicCharacterMotor>())\n                {\n                    RigidbodyProjectionHit rph = new RigidbodyProjectionHit();\n                    rph.Rigidbody = hitRigidbody;\n                    rph.HitPoint = hitPoint;\n                    rph.EffectiveHitNormal = obstructionNormal;\n                    rph.HitVelocity = hitVelocity;\n                    rph.StableOnHit = hitStabilityReport.IsStable;\n\n                    _internalRigidbodyProjectionHits[_rigidbodyProjectionHitCount] = rph;\n                    _rigidbodyProjectionHitCount++;\n                }\n            }\n        }\n\n        public void SetTransientPosition(Vector3 newPos)\n        {\n            _transientPosition = newPos;\n        }\n\n        /// <summary>\n        /// Processes movement projection upon detecting a hit\n        /// </summary>\n        private void InternalHandleVelocityProjection(bool stableOnHit, Vector3 hitNormal, Vector3 obstructionNormal, Vector3 originalDirection,\n            ref MovementSweepState sweepState, bool previousHitIsStable, Vector3 previousVelocity, Vector3 previousObstructionNormal,\n            ref Vector3 transientVelocity, ref float remainingMovementMagnitude, ref Vector3 remainingMovementDirection)\n        {\n            if (transientVelocity.sqrMagnitude <= 0f)\n            {\n                return;\n            }\n\n            Vector3 velocityBeforeProjection = transientVelocity;\n\n            if (stableOnHit)\n            {\n                LastMovementIterationFoundAnyGround = true;\n                HandleVelocityProjection(ref transientVelocity, obstructionNormal, stableOnHit);\n            }\n            else\n            {\n                // Handle projection\n                if (sweepState == MovementSweepState.Initial)\n                {\n                    HandleVelocityProjection(ref transientVelocity, obstructionNormal, stableOnHit);\n                    sweepState = MovementSweepState.AfterFirstHit;\n                }\n                // Blocking crease handling\n                else if (sweepState == MovementSweepState.AfterFirstHit)\n                {\n                    EvaluateCrease(\n                        transientVelocity,\n                        previousVelocity,\n                        obstructionNormal,\n                        previousObstructionNormal,\n                        stableOnHit,\n                        previousHitIsStable,\n                        GroundingStatus.IsStableOnGround && !MustUnground(),\n                        out bool foundCrease,\n                        out Vector3 creaseDirection);\n\n                    if (foundCrease)\n                    {\n                        if (GroundingStatus.IsStableOnGround && !MustUnground())\n                        {\n                            transientVelocity = Vector3.zero;\n                            sweepState = MovementSweepState.FoundBlockingCorner;\n                        }\n                        else\n                        {\n                            transientVelocity = Vector3.Project(transientVelocity, creaseDirection);\n                            sweepState = MovementSweepState.FoundBlockingCrease;\n                        }\n                    }\n                    else\n                    {\n                        HandleVelocityProjection(ref transientVelocity, obstructionNormal, stableOnHit);\n                    }\n                }\n                // Blocking corner handling\n                else if (sweepState == MovementSweepState.FoundBlockingCrease)\n                {\n                    transientVelocity = Vector3.zero;\n                    sweepState = MovementSweepState.FoundBlockingCorner;\n                }\n            }\n\n            if (HasPlanarConstraint)\n            {\n                transientVelocity = Vector3.ProjectOnPlane(transientVelocity, PlanarConstraintAxis.normalized);\n            }\n\n            float newVelocityFactor = transientVelocity.magnitude / velocityBeforeProjection.magnitude;\n            remainingMovementMagnitude *= newVelocityFactor;\n            remainingMovementDirection = transientVelocity.normalized;\n        }\n\n        private void EvaluateCrease(\n            Vector3 currentCharacterVelocity,\n            Vector3 previousCharacterVelocity,\n            Vector3 currentHitNormal,\n            Vector3 previousHitNormal,\n            bool currentHitIsStable,\n            bool previousHitIsStable,\n            bool characterIsStable,\n            out bool isValidCrease,\n            out Vector3 creaseDirection)\n        {\n            isValidCrease = false;\n            creaseDirection = default;\n\n            if (!characterIsStable || !currentHitIsStable || !previousHitIsStable)\n            {\n                Vector3 tmpBlockingCreaseDirection = Vector3.Cross(currentHitNormal, previousHitNormal).normalized;\n                float dotPlanes = Vector3.Dot(currentHitNormal, previousHitNormal);\n                bool isVelocityConstrainedByCrease = false;\n\n                // Avoid calculations if the two planes are the same\n                if (dotPlanes < 0.999f)\n                {\n                    // TODO: can this whole part be made simpler? (with 2d projections, etc)\n                    Vector3 normalAOnCreasePlane = Vector3.ProjectOnPlane(currentHitNormal, tmpBlockingCreaseDirection).normalized;\n                    Vector3 normalBOnCreasePlane = Vector3.ProjectOnPlane(previousHitNormal, tmpBlockingCreaseDirection).normalized;\n                    float dotPlanesOnCreasePlane = Vector3.Dot(normalAOnCreasePlane, normalBOnCreasePlane);\n\n                    Vector3 enteringVelocityDirectionOnCreasePlane = Vector3.ProjectOnPlane(previousCharacterVelocity, tmpBlockingCreaseDirection).normalized;\n\n                    if (dotPlanesOnCreasePlane <= (Vector3.Dot(-enteringVelocityDirectionOnCreasePlane, normalAOnCreasePlane) + 0.001f) &&\n                        dotPlanesOnCreasePlane <= (Vector3.Dot(-enteringVelocityDirectionOnCreasePlane, normalBOnCreasePlane) + 0.001f))\n                    {\n                        isVelocityConstrainedByCrease = true;\n                    }\n                }\n\n                if (isVelocityConstrainedByCrease)\n                {\n                    // Flip crease direction to make it representative of the real direction our velocity would be projected to\n                    if (Vector3.Dot(tmpBlockingCreaseDirection, currentCharacterVelocity) < 0f)\n                    {\n                        tmpBlockingCreaseDirection = -tmpBlockingCreaseDirection;\n                    }\n\n                    isValidCrease = true;\n                    creaseDirection = tmpBlockingCreaseDirection;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Allows you to override the way velocity is projected on an obstruction\n        /// </summary>\n        public virtual void HandleVelocityProjection(ref Vector3 velocity, Vector3 obstructionNormal, bool stableOnHit)\n        {\n            if (GroundingStatus.IsStableOnGround && !MustUnground())\n            {\n                // On stable slopes, simply reorient the movement without any loss\n                if (stableOnHit)\n                {\n                    velocity = GetDirectionTangentToSurface(velocity, obstructionNormal) * velocity.magnitude;\n                }\n                // On blocking hits, project the movement on the obstruction while following the grounding plane\n                else\n                {\n                    Vector3 obstructionRightAlongGround = Vector3.Cross(obstructionNormal, GroundingStatus.GroundNormal).normalized;\n                    Vector3 obstructionUpAlongGround = Vector3.Cross(obstructionRightAlongGround, obstructionNormal).normalized;\n                    velocity = GetDirectionTangentToSurface(velocity, obstructionUpAlongGround) * velocity.magnitude;\n                    velocity = Vector3.ProjectOnPlane(velocity, obstructionNormal);\n                }\n            }\n            else\n            {\n                if (stableOnHit)\n                {\n                    // Handle stable landing\n                    velocity = Vector3.ProjectOnPlane(velocity, CharacterUp);\n                    velocity = GetDirectionTangentToSurface(velocity, obstructionNormal) * velocity.magnitude;\n                }\n                // Handle generic obstruction\n                else\n                {\n                    velocity = Vector3.ProjectOnPlane(velocity, obstructionNormal);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Allows you to override the way hit rigidbodies are pushed / interacted with. \n        /// ProcessedVelocity is what must be modified if this interaction affects the character's velocity.\n        /// </summary>\n        public virtual void HandleSimulatedRigidbodyInteraction(ref Vector3 processedVelocity, RigidbodyProjectionHit hit, float deltaTime)\n        {\n        }\n\n        /// <summary>\n        /// Takes into account rigidbody hits for adding to the velocity\n        /// </summary>\n        private void ProcessVelocityForRigidbodyHits(ref Vector3 processedVelocity, float deltaTime)\n        {\n            for (int i = 0; i < _rigidbodyProjectionHitCount; i++)\n            {\n                RigidbodyProjectionHit bodyHit = _internalRigidbodyProjectionHits[i];\n\n                if (bodyHit.Rigidbody && !_rigidbodiesPushedThisMove.Contains(bodyHit.Rigidbody))\n                {\n                    if (_internalRigidbodyProjectionHits[i].Rigidbody != _attachedRigidbody)\n                    {\n                        // Remember we hit this rigidbody\n                        _rigidbodiesPushedThisMove.Add(bodyHit.Rigidbody);\n\n                        float characterMass = SimulatedCharacterMass;\n                        Vector3 characterVelocity = bodyHit.HitVelocity;\n\n                        KinematicCharacterMotor hitCharacterMotor = bodyHit.Rigidbody.GetComponent<KinematicCharacterMotor>();\n                        bool hitBodyIsCharacter = hitCharacterMotor != null;\n                        bool hitBodyIsDynamic = !bodyHit.Rigidbody.isKinematic;\n                        float hitBodyMass = bodyHit.Rigidbody.mass;\n                        float hitBodyMassAtPoint = bodyHit.Rigidbody.mass; // todo\n                        Vector3 hitBodyVelocity = bodyHit.Rigidbody.linearVelocity;\n                        if (hitBodyIsCharacter)\n                        {\n                            hitBodyMass = hitCharacterMotor.SimulatedCharacterMass;\n                            hitBodyMassAtPoint = hitCharacterMotor.SimulatedCharacterMass; // todo\n                            hitBodyVelocity = hitCharacterMotor.BaseVelocity;\n                        }\n                        else if (!hitBodyIsDynamic)\n                        {\n                            PhysicsMover physicsMover = bodyHit.Rigidbody.GetComponent<PhysicsMover>();\n                            if(physicsMover)\n                            {\n                                hitBodyVelocity = physicsMover.Velocity;\n                            }\n                        }\n\n                        // Calculate the ratio of the total mass that the character mass represents\n                        float characterToBodyMassRatio = 1f;\n                        {\n                            if (characterMass + hitBodyMassAtPoint > 0f)\n                            {\n                                characterToBodyMassRatio = characterMass / (characterMass + hitBodyMassAtPoint);\n                            }\n                            else\n                            {\n                                characterToBodyMassRatio = 0.5f;\n                            }\n\n                            // Hitting a non-dynamic body\n                            if (!hitBodyIsDynamic)\n                            {\n                                characterToBodyMassRatio = 0f;\n                            }\n                            // Emulate kinematic body interaction\n                            else if (RigidbodyInteractionType == RigidbodyInteractionType.Kinematic && !hitBodyIsCharacter)\n                            {\n                                characterToBodyMassRatio = 1f;\n                            }\n                        }\n\n                        ComputeCollisionResolutionForHitBody(\n                            bodyHit.EffectiveHitNormal,\n                            characterVelocity,\n                            hitBodyVelocity,\n                            characterToBodyMassRatio,\n                            out Vector3 velocityChangeOnCharacter,\n                            out Vector3 velocityChangeOnBody);\n\n                        processedVelocity += velocityChangeOnCharacter;\n\n                        if (hitBodyIsCharacter)\n                        {\n                            hitCharacterMotor.BaseVelocity += velocityChangeOnCharacter;\n                        }\n                        else if (hitBodyIsDynamic)\n                        {\n                            bodyHit.Rigidbody.AddForceAtPosition(velocityChangeOnBody, bodyHit.HitPoint, ForceMode.VelocityChange);\n                        }\n\n                        if (RigidbodyInteractionType == RigidbodyInteractionType.SimulatedDynamic)\n                        {\n                            HandleSimulatedRigidbodyInteraction(ref processedVelocity, bodyHit, deltaTime);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        public void ComputeCollisionResolutionForHitBody(\n            Vector3 hitNormal,\n            Vector3 characterVelocity,\n            Vector3 bodyVelocity,\n            float characterToBodyMassRatio,\n            out Vector3 velocityChangeOnCharacter,\n            out Vector3 velocityChangeOnBody)\n        {\n            velocityChangeOnCharacter = default;\n            velocityChangeOnBody = default;\n\n            float bodyToCharacterMassRatio = 1f - characterToBodyMassRatio;\n            float characterVelocityMagnitudeOnHitNormal = Vector3.Dot(characterVelocity, hitNormal);\n            float bodyVelocityMagnitudeOnHitNormal = Vector3.Dot(bodyVelocity, hitNormal);\n\n            // if character velocity was going against the obstruction, restore the portion of the velocity that got projected during the movement phase\n            if (characterVelocityMagnitudeOnHitNormal < 0f)\n            {\n                Vector3 restoredCharacterVelocity = hitNormal * characterVelocityMagnitudeOnHitNormal;\n                velocityChangeOnCharacter += restoredCharacterVelocity;\n            }\n\n            // solve impulse velocities on both bodies, but only if the body velocity would be giving resistance to the character in any way\n            if (bodyVelocityMagnitudeOnHitNormal > characterVelocityMagnitudeOnHitNormal)\n            {\n                Vector3 relativeImpactVelocity = hitNormal * (bodyVelocityMagnitudeOnHitNormal - characterVelocityMagnitudeOnHitNormal);\n                velocityChangeOnCharacter += relativeImpactVelocity * bodyToCharacterMassRatio;\n                velocityChangeOnBody += -relativeImpactVelocity * characterToBodyMassRatio;\n            }\n        }\n\n        /// <summary>\n        /// Determines if the input collider is valid for collision processing\n        /// </summary>\n        /// <returns> Returns true if the collider is valid </returns>\n        private bool CheckIfColliderValidForCollisions(Collider coll)\n        {\n            // Ignore self\n            if (coll == Capsule)\n            {\n                return false;\n            }\n\n            if (!InternalIsColliderValidForCollisions(coll))\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Determines if the input collider is valid for collision processing\n        /// </summary>\n        private bool InternalIsColliderValidForCollisions(Collider coll)\n        {\n            Rigidbody colliderAttachedRigidbody = coll.attachedRigidbody;\n            if (colliderAttachedRigidbody)\n            {\n                bool isRigidbodyKinematic = colliderAttachedRigidbody.isKinematic;\n\n                // If movement is made from AttachedRigidbody, ignore the AttachedRigidbody\n                if (_isMovingFromAttachedRigidbody && (!isRigidbodyKinematic || colliderAttachedRigidbody == _attachedRigidbody))\n                {\n                    return false;\n                }\n\n                // don't collide with dynamic rigidbodies if our RigidbodyInteractionType is kinematic\n                if (RigidbodyInteractionType == RigidbodyInteractionType.Kinematic && !isRigidbodyKinematic)\n                {\n                    // wake up rigidbody\n                    if (coll.attachedRigidbody)\n                    {\n                        coll.attachedRigidbody.WakeUp();\n                    }\n\n                    return false;\n                }\n            }\n\n            // Custom checks\n            bool colliderValid = CharacterController.IsColliderValidForCollisions(coll);\n            if (!colliderValid)\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Determines if the motor is considered stable on a given hit\n        /// </summary>\n        public void EvaluateHitStability(Collider hitCollider, Vector3 hitNormal, Vector3 hitPoint, Vector3 atCharacterPosition, Quaternion atCharacterRotation, Vector3 withCharacterVelocity, ref HitStabilityReport stabilityReport)\n        {\n            if (!_solveGrounding)\n            {\n                stabilityReport.IsStable = false;\n                return;\n            }\n\n            Vector3 atCharacterUp = atCharacterRotation * _cachedWorldUp;\n            Vector3 innerHitDirection = Vector3.ProjectOnPlane(hitNormal, atCharacterUp).normalized;\n\n            stabilityReport.IsStable = this.IsStableOnNormal(hitNormal);\n\n            stabilityReport.FoundInnerNormal = false;\n            stabilityReport.FoundOuterNormal = false;\n            stabilityReport.InnerNormal = hitNormal;\n            stabilityReport.OuterNormal = hitNormal;\n\n            // Ledge handling\n            if (LedgeAndDenivelationHandling)\n            {\n                float ledgeCheckHeight = MinDistanceForLedge;\n                if (StepHandling != StepHandlingMethod.None)\n                {\n                    ledgeCheckHeight = MaxStepHeight;\n                }\n\n                bool isStableLedgeInner = false;\n                bool isStableLedgeOuter = false;\n\n                if (CharacterCollisionsRaycast(\n                        hitPoint + (atCharacterUp * SecondaryProbesVertical) + (innerHitDirection * SecondaryProbesHorizontal),\n                        -atCharacterUp,\n                        ledgeCheckHeight + SecondaryProbesVertical,\n                        out RaycastHit innerLedgeHit,\n                        _internalCharacterHits) > 0)\n                {\n                    Vector3 innerLedgeNormal = innerLedgeHit.normal;\n                    stabilityReport.InnerNormal = innerLedgeNormal;\n                    stabilityReport.FoundInnerNormal = true;\n                    isStableLedgeInner = IsStableOnNormal(innerLedgeNormal);\n                }\n\n                if (CharacterCollisionsRaycast(\n                        hitPoint + (atCharacterUp * SecondaryProbesVertical) + (-innerHitDirection * SecondaryProbesHorizontal),\n                        -atCharacterUp,\n                        ledgeCheckHeight + SecondaryProbesVertical,\n                        out RaycastHit outerLedgeHit,\n                        _internalCharacterHits) > 0)\n                {\n                    Vector3 outerLedgeNormal = outerLedgeHit.normal;\n                    stabilityReport.OuterNormal = outerLedgeNormal;\n                    stabilityReport.FoundOuterNormal = true;\n                    isStableLedgeOuter = IsStableOnNormal(outerLedgeNormal);\n                }\n\n                stabilityReport.LedgeDetected = (isStableLedgeInner != isStableLedgeOuter);\n                if (stabilityReport.LedgeDetected)\n                {\n                    stabilityReport.IsOnEmptySideOfLedge = isStableLedgeOuter && !isStableLedgeInner;\n                    stabilityReport.LedgeGroundNormal = isStableLedgeOuter ? stabilityReport.OuterNormal : stabilityReport.InnerNormal;\n                    stabilityReport.LedgeRightDirection = Vector3.Cross(hitNormal, stabilityReport.LedgeGroundNormal).normalized;\n                    stabilityReport.LedgeFacingDirection = Vector3.ProjectOnPlane(Vector3.Cross(stabilityReport.LedgeGroundNormal, stabilityReport.LedgeRightDirection), CharacterUp).normalized;\n                    stabilityReport.DistanceFromLedge = Vector3.ProjectOnPlane((hitPoint - (atCharacterPosition + (atCharacterRotation * _characterTransformToCapsuleBottom))), atCharacterUp).magnitude;\n                    stabilityReport.IsMovingTowardsEmptySideOfLedge = Vector3.Dot(withCharacterVelocity.normalized, stabilityReport.LedgeFacingDirection) > 0f;\n                }\n\n                if (stabilityReport.IsStable)\n                {\n                    stabilityReport.IsStable = IsStableWithSpecialCases(ref stabilityReport, withCharacterVelocity);\n                }\n            }\n\n            // Step handling\n            if (StepHandling != StepHandlingMethod.None && !stabilityReport.IsStable)\n            {\n                // Stepping not supported on dynamic rigidbodies\n                Rigidbody hitRigidbody = hitCollider.attachedRigidbody;\n                if (!(hitRigidbody && !hitRigidbody.isKinematic))\n                {\n                    DetectSteps(atCharacterPosition, atCharacterRotation, hitPoint, innerHitDirection, ref stabilityReport);\n\n                    if (stabilityReport.ValidStepDetected)\n                    {\n                        stabilityReport.IsStable = true;\n                    }\n                }\n            }\n\n            CharacterController.ProcessHitStabilityReport(hitCollider, hitNormal, hitPoint, atCharacterPosition, atCharacterRotation, ref stabilityReport);\n        }\n\n        private void DetectSteps(Vector3 characterPosition, Quaternion characterRotation, Vector3 hitPoint, Vector3 innerHitDirection, ref HitStabilityReport stabilityReport)\n        {\n            int nbStepHits = 0;\n            Collider tmpCollider;\n            RaycastHit outerStepHit;\n            Vector3 characterUp = characterRotation * _cachedWorldUp;\n            Vector3 verticalCharToHit = Vector3.Project((hitPoint - characterPosition), characterUp);\n            Vector3 horizontalCharToHitDirection = Vector3.ProjectOnPlane((hitPoint - characterPosition), characterUp).normalized;\n            Vector3 stepCheckStartPos = (hitPoint - verticalCharToHit) + (characterUp * MaxStepHeight) + (horizontalCharToHitDirection * CollisionOffset * 3f); \n\n            // Do outer step check with capsule cast on hit point\n            nbStepHits = CharacterCollisionsSweep(\n                            stepCheckStartPos,\n                            characterRotation,\n                            -characterUp,\n                            MaxStepHeight + CollisionOffset,\n                            out outerStepHit,\n                            _internalCharacterHits,\n                            0f,\n                            true);\n\n            // Check for overlaps and obstructions at the hit position\n            if (CheckStepValidity(nbStepHits, characterPosition, characterRotation, innerHitDirection, stepCheckStartPos, out tmpCollider))\n            {\n                stabilityReport.ValidStepDetected = true;\n                stabilityReport.SteppedCollider = tmpCollider;\n            }\n\n            if (StepHandling == StepHandlingMethod.Extra && !stabilityReport.ValidStepDetected)\n            {\n                // Do min reach step check with capsule cast on hit point\n                stepCheckStartPos = characterPosition + (characterUp * MaxStepHeight) + (-innerHitDirection * MinRequiredStepDepth);\n                nbStepHits = CharacterCollisionsSweep(\n                                stepCheckStartPos,\n                                characterRotation,\n                                -characterUp,\n                                MaxStepHeight - CollisionOffset,\n                                out outerStepHit,\n                                _internalCharacterHits,\n                                0f,\n                                true);\n\n                // Check for overlaps and obstructions at the hit position\n                if (CheckStepValidity(nbStepHits, characterPosition, characterRotation, innerHitDirection, stepCheckStartPos, out tmpCollider))\n                {\n                    stabilityReport.ValidStepDetected = true;\n                    stabilityReport.SteppedCollider = tmpCollider;\n                }","numLines":540,"startLine":1621,"totalLines":2689}}}
{"parentUuid":"404b785a-4b33-4655-b404-73d3001b9e54","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GwX3teoa25tnkbazHnLiTw","type":"tool_result","content":"  1081→                        {\n  1082→                            for (int i = 0; i < nbOverlaps; i++)\n  1083→                            {\n  1084→                                // Process overlap\n  1085→                                Transform overlappedTransform = _internalProbedColliders[i].GetComponent<Transform>();\n  1086→                                if (Physics.ComputePenetration(\n  1087→                                        Capsule,\n  1088→                                        _transientPosition,\n  1089→                                        _transientRotation,\n  1090→                                        _internalProbedColliders[i],\n  1091→                                        overlappedTransform.position,\n  1092→                                        overlappedTransform.rotation,\n  1093→                                        out resolutionDirection,\n  1094→                                        out resolutionDistance))\n  1095→                                {\n  1096→                                    // Resolve along obstruction direction\n  1097→                                    HitStabilityReport mockReport = new HitStabilityReport();\n  1098→                                    mockReport.IsStable = IsStableOnNormal(resolutionDirection);\n  1099→                                    resolutionDirection = GetObstructionNormal(resolutionDirection, mockReport.IsStable);\n  1100→\n  1101→                                    // Solve overlap\n  1102→                                    Vector3 resolutionMovement = resolutionDirection * (resolutionDistance + CollisionOffset);\n  1103→                                    _transientPosition += resolutionMovement;\n  1104→\n  1105→                                    // If interactiveRigidbody, register as rigidbody hit for velocity\n  1106→                                    if (InteractiveRigidbodyHandling)\n  1107→                                    {\n  1108→                                        Rigidbody probedRigidbody = GetInteractiveRigidbody(_internalProbedColliders[i]);\n  1109→                                        if (probedRigidbody != null)\n  1110→                                        {\n  1111→                                            HitStabilityReport tmpReport = new HitStabilityReport();\n  1112→                                            tmpReport.IsStable = IsStableOnNormal(resolutionDirection);\n  1113→                                            if (tmpReport.IsStable)\n  1114→                                            {\n  1115→                                                LastMovementIterationFoundAnyGround = tmpReport.IsStable;\n  1116→                                            }\n  1117→                                            if (probedRigidbody != _attachedRigidbody)\n  1118→                                            {\n  1119→                                                Vector3 characterCenter = _transientPosition + (_transientRotation * _characterTransformToCapsuleCenter);\n  1120→                                                Vector3 estimatedCollisionPoint = _transientPosition;\n  1121→\n  1122→\n  1123→                                                StoreRigidbodyHit(\n  1124→                                                    probedRigidbody,\n  1125→                                                    Velocity,\n  1126→                                                    estimatedCollisionPoint,\n  1127→                                                    resolutionDirection,\n  1128→                                                    tmpReport);\n  1129→                                            }\n  1130→                                        }\n  1131→                                    }\n  1132→\n  1133→                                    // Remember overlaps\n  1134→                                    if (_overlapsCount < _overlaps.Length)\n  1135→                                    {\n  1136→                                        _overlaps[_overlapsCount] = new OverlapResult(resolutionDirection, _internalProbedColliders[i]);\n  1137→                                        _overlapsCount++;\n  1138→                                    }\n  1139→\n  1140→                                    break;\n  1141→                                }\n  1142→                            }\n  1143→                        }\n  1144→                        else\n  1145→                        {\n  1146→                            overlapSolved = true;\n  1147→                        }\n  1148→\n  1149→                        iterationsMade++;\n  1150→                    }\n  1151→                    #endregion\n  1152→                }\n  1153→            }\n  1154→\n  1155→            // Handle velocity\n  1156→            CharacterController.UpdateVelocity(ref BaseVelocity, deltaTime);\n  1157→\n  1158→            //this.CharacterController.UpdateVelocity(ref BaseVelocity, deltaTime);\n  1159→            if (BaseVelocity.magnitude < MinVelocityMagnitude)\n  1160→            {\n  1161→                BaseVelocity = Vector3.zero;\n  1162→            }\n  1163→\n  1164→            #region Calculate Character movement from base velocity   \n  1165→            // Perform the move from base velocity\n  1166→            if (BaseVelocity.sqrMagnitude > 0f)\n  1167→            {\n  1168→                if (_solveMovementCollisions)\n  1169→                {\n  1170→                    InternalCharacterMove(ref BaseVelocity, deltaTime);\n  1171→                }\n  1172→                else\n  1173→                {\n  1174→                    _transientPosition += BaseVelocity * deltaTime;\n  1175→                }\n  1176→            }\n  1177→\n  1178→            // Process rigidbody hits/overlaps to affect velocity\n  1179→            if (InteractiveRigidbodyHandling)\n  1180→            {\n  1181→                ProcessVelocityForRigidbodyHits(ref BaseVelocity, deltaTime);\n  1182→            }\n  1183→            #endregion\n  1184→\n  1185→            // Handle planar constraint\n  1186→            if (HasPlanarConstraint)\n  1187→            {\n  1188→                _transientPosition = _initialSimulationPosition + Vector3.ProjectOnPlane(_transientPosition - _initialSimulationPosition, PlanarConstraintAxis.normalized);\n  1189→            }\n  1190→\n  1191→            // Discrete collision detection\n  1192→            if (DiscreteCollisionEvents)\n  1193→            {\n  1194→                int nbOverlaps = CharacterCollisionsOverlap(_transientPosition, _transientRotation, _internalProbedColliders, CollisionOffset * 2f);\n  1195→                for (int i = 0; i < nbOverlaps; i++)\n  1196→                {\n  1197→                    CharacterController.OnDiscreteCollisionDetected(_internalProbedColliders[i]);\n  1198→                }\n  1199→            }\n  1200→\n  1201→            CharacterController.AfterCharacterUpdate(deltaTime);\n  1202→        }\n  1203→\n  1204→        /// <summary>\n  1205→        /// Determines if motor can be considered stable on given slope normal\n  1206→        /// </summary>\n  1207→        private bool IsStableOnNormal(Vector3 normal)\n  1208→        {\n  1209→            return Vector3.Angle(_characterUp, normal) <= MaxStableSlopeAngle;\n  1210→        }\n  1211→\n  1212→        /// <summary>\n  1213→        /// Determines if motor can be considered stable on given slope normal\n  1214→        /// </summary>\n  1215→        private bool IsStableWithSpecialCases(ref HitStabilityReport stabilityReport, Vector3 velocity)\n  1216→        {\n  1217→            if (LedgeAndDenivelationHandling)\n  1218→            {\n  1219→                if (stabilityReport.LedgeDetected)\n  1220→                {\n  1221→                    if (stabilityReport.IsMovingTowardsEmptySideOfLedge)\n  1222→                    {\n  1223→                        // Max snap vel\n  1224→                        Vector3 velocityOnLedgeNormal = Vector3.Project(velocity, stabilityReport.LedgeFacingDirection);\n  1225→                        if (velocityOnLedgeNormal.magnitude >= MaxVelocityForLedgeSnap)\n  1226→                        {\n  1227→                            return false;\n  1228→                        }\n  1229→                    }\n  1230→\n  1231→                    // Distance from ledge\n  1232→                    if (stabilityReport.IsOnEmptySideOfLedge && stabilityReport.DistanceFromLedge > MaxStableDistanceFromLedge)\n  1233→                    {\n  1234→                        return false;\n  1235→                    }\n  1236→                }\n  1237→\n  1238→                // \"Launching\" off of slopes of a certain denivelation angle\n  1239→                if (LastGroundingStatus.FoundAnyGround && stabilityReport.InnerNormal.sqrMagnitude != 0f && stabilityReport.OuterNormal.sqrMagnitude != 0f)\n  1240→                {\n  1241→                    float denivelationAngle = Vector3.Angle(stabilityReport.InnerNormal, stabilityReport.OuterNormal);\n  1242→                    if (denivelationAngle > MaxStableDenivelationAngle)\n  1243→                    {\n  1244→                        return false;\n  1245→                    }\n  1246→                    else\n  1247→                    {\n  1248→                        denivelationAngle = Vector3.Angle(LastGroundingStatus.InnerGroundNormal, stabilityReport.OuterNormal);\n  1249→                        if (denivelationAngle > MaxStableDenivelationAngle)\n  1250→                        {\n  1251→                            return false;\n  1252→                        }\n  1253→                    }\n  1254→                }\n  1255→            }\n  1256→\n  1257→            return true;\n  1258→        }\n  1259→\n  1260→        /// <summary>\n  1261→        /// Probes for valid ground and midifies the input transientPosition if ground snapping occurs\n  1262→        /// </summary>\n  1263→        public void ProbeGround(ref Vector3 probingPosition, Quaternion atRotation, float probingDistance, ref CharacterGroundingReport groundingReport)\n  1264→        {\n  1265→            if (probingDistance < MinimumGroundProbingDistance)\n  1266→            {\n  1267→                probingDistance = MinimumGroundProbingDistance;\n  1268→            }\n  1269→\n  1270→            int groundSweepsMade = 0;\n  1271→            RaycastHit groundSweepHit = new RaycastHit();\n  1272→            bool groundSweepingIsOver = false;\n  1273→            Vector3 groundSweepPosition = probingPosition;\n  1274→            Vector3 groundSweepDirection = (atRotation * -_cachedWorldUp);\n  1275→            float groundProbeDistanceRemaining = probingDistance;\n  1276→            while (groundProbeDistanceRemaining > 0 && (groundSweepsMade <= MaxGroundingSweepIterations) && !groundSweepingIsOver)\n  1277→            {\n  1278→                // Sweep for ground detection\n  1279→                if (CharacterGroundSweep(\n  1280→                        groundSweepPosition, // position\n  1281→                        atRotation, // rotation\n  1282→                        groundSweepDirection, // direction\n  1283→                        groundProbeDistanceRemaining, // distance\n  1284→                        out groundSweepHit)) // hit\n  1285→                {\n  1286→                    Vector3 targetPosition = groundSweepPosition + (groundSweepDirection * groundSweepHit.distance);\n  1287→                    HitStabilityReport groundHitStabilityReport = new HitStabilityReport();\n  1288→                    EvaluateHitStability(groundSweepHit.collider, groundSweepHit.normal, groundSweepHit.point, targetPosition, _transientRotation, BaseVelocity, ref groundHitStabilityReport);\n  1289→\n  1290→                    groundingReport.FoundAnyGround = true;\n  1291→                    groundingReport.GroundNormal = groundSweepHit.normal;\n  1292→                    groundingReport.InnerGroundNormal = groundHitStabilityReport.InnerNormal;\n  1293→                    groundingReport.OuterGroundNormal = groundHitStabilityReport.OuterNormal;\n  1294→                    groundingReport.GroundCollider = groundSweepHit.collider;\n  1295→                    groundingReport.GroundPoint = groundSweepHit.point;\n  1296→                    groundingReport.SnappingPrevented = false;\n  1297→\n  1298→                    // Found stable ground\n  1299→                    if (groundHitStabilityReport.IsStable)\n  1300→                    {\n  1301→                        // Find all scenarios where ground snapping should be canceled\n  1302→                        groundingReport.SnappingPrevented = !IsStableWithSpecialCases(ref groundHitStabilityReport, BaseVelocity);\n  1303→\n  1304→                        groundingReport.IsStableOnGround = true;\n  1305→\n  1306→                        // Ground snapping\n  1307→                        if (!groundingReport.SnappingPrevented)\n  1308→                        {\n  1309→                            probingPosition = groundSweepPosition + (groundSweepDirection * (groundSweepHit.distance - CollisionOffset));\n  1310→                        }\n  1311→\n  1312→                        CharacterController.OnGroundHit(groundSweepHit.collider, groundSweepHit.normal, groundSweepHit.point, ref groundHitStabilityReport);\n  1313→                        groundSweepingIsOver = true;\n  1314→                    }\n  1315→                    else\n  1316→                    {\n  1317→                        // Calculate movement from this iteration and advance position\n  1318→                        Vector3 sweepMovement = (groundSweepDirection * groundSweepHit.distance) + ((atRotation * _cachedWorldUp) * Mathf.Max(CollisionOffset, groundSweepHit.distance));\n  1319→                        groundSweepPosition = groundSweepPosition + sweepMovement;\n  1320→\n  1321→                        // Set remaining distance\n  1322→                        groundProbeDistanceRemaining = Mathf.Min(GroundProbeReboundDistance, Mathf.Max(groundProbeDistanceRemaining - sweepMovement.magnitude, 0f));\n  1323→\n  1324→                        // Reorient direction\n  1325→                        groundSweepDirection = Vector3.ProjectOnPlane(groundSweepDirection, groundSweepHit.normal).normalized;\n  1326→                    }\n  1327→                }\n  1328→                else\n  1329→                {\n  1330→                    groundSweepingIsOver = true;\n  1331→                }\n  1332→\n  1333→                groundSweepsMade++;\n  1334→            }\n  1335→        }\n  1336→\n  1337→        /// <summary>\n  1338→        /// Forces the character to unground itself on its next grounding update\n  1339→        /// </summary>\n  1340→        public void ForceUnground(float time = 0.1f)\n  1341→        {\n  1342→            _mustUnground = true;\n  1343→            _mustUngroundTimeCounter = time;\n  1344→        }\n  1345→\n  1346→        public bool MustUnground()\n  1347→        {\n  1348→            return _mustUnground || _mustUngroundTimeCounter > 0f;\n  1349→        }\n  1350→\n  1351→        /// <summary>\n  1352→        /// Returns the direction adjusted to be tangent to a specified surface normal relatively to the character's up direction.\n  1353→        /// Useful for reorienting a direction on a slope without any lateral deviation in trajectory\n  1354→        /// </summary>\n  1355→        public Vector3 GetDirectionTangentToSurface(Vector3 direction, Vector3 surfaceNormal)\n  1356→        {\n  1357→            Vector3 directionRight = Vector3.Cross(direction, _characterUp);\n  1358→            return Vector3.Cross(surfaceNormal, directionRight).normalized;\n  1359→        }\n  1360→\n  1361→        /// <summary>\n  1362→        /// Moves the character's position by given movement while taking into account all physics simulation, step-handling and \n  1363→        /// velocity projection rules that affect the character motor\n  1364→        /// </summary>\n  1365→        /// <returns> Returns false if movement could not be solved until the end </returns>\n  1366→        private bool InternalCharacterMove(ref Vector3 transientVelocity, float deltaTime)\n  1367→        {\n  1368→            if (deltaTime <= 0f)\n  1369→                return false;\n  1370→\n  1371→            // Planar constraint\n  1372→            if (HasPlanarConstraint)\n  1373→            {\n  1374→                transientVelocity = Vector3.ProjectOnPlane(transientVelocity, PlanarConstraintAxis.normalized);\n  1375→            }\n  1376→\n  1377→            bool wasCompleted = true;\n  1378→            Vector3 remainingMovementDirection = transientVelocity.normalized;\n  1379→            float remainingMovementMagnitude = transientVelocity.magnitude * deltaTime;\n  1380→            Vector3 originalVelocityDirection = remainingMovementDirection;\n  1381→            int sweepsMade = 0;\n  1382→            bool hitSomethingThisSweepIteration = true;\n  1383→            Vector3 tmpMovedPosition = _transientPosition;\n  1384→            bool previousHitIsStable = false;\n  1385→            Vector3 previousVelocity = _cachedZeroVector;\n  1386→            Vector3 previousObstructionNormal = _cachedZeroVector;\n  1387→            MovementSweepState sweepState = MovementSweepState.Initial;\n  1388→\n  1389→            // Project movement against current overlaps before doing the sweeps\n  1390→            for (int i = 0; i < _overlapsCount; i++)\n  1391→            {\n  1392→                Vector3 overlapNormal = _overlaps[i].Normal;\n  1393→                if (Vector3.Dot(remainingMovementDirection, overlapNormal) < 0f)\n  1394→                {\n  1395→                    bool stableOnHit = IsStableOnNormal(overlapNormal) && !MustUnground();\n  1396→                    Vector3 velocityBeforeProjection = transientVelocity;\n  1397→                    Vector3 obstructionNormal = GetObstructionNormal(overlapNormal, stableOnHit);\n  1398→\n  1399→                    InternalHandleVelocityProjection(\n  1400→                        stableOnHit,\n  1401→                        overlapNormal,\n  1402→                        obstructionNormal,\n  1403→                        originalVelocityDirection,\n  1404→                        ref sweepState,\n  1405→                        previousHitIsStable,\n  1406→                        previousVelocity,\n  1407→                        previousObstructionNormal,\n  1408→                        ref transientVelocity,\n  1409→                        ref remainingMovementMagnitude,\n  1410→                        ref remainingMovementDirection);\n  1411→\n  1412→                    previousHitIsStable = stableOnHit;\n  1413→                    previousVelocity = velocityBeforeProjection;\n  1414→                    previousObstructionNormal = obstructionNormal;\n  1415→                }\n  1416→            }\n  1417→\n  1418→            // Sweep the desired movement to detect collisions\n  1419→            while (remainingMovementMagnitude > 0f &&\n  1420→                (sweepsMade <= MaxMovementIterations) &&\n  1421→                hitSomethingThisSweepIteration)\n  1422→            {\n  1423→                bool foundClosestHit = false;\n  1424→                Vector3 closestSweepHitPoint = default;\n  1425→                Vector3 closestSweepHitNormal = default;\n  1426→                float closestSweepHitDistance = 0f;\n  1427→                Collider closestSweepHitCollider = null;\n  1428→\n  1429→                if (CheckMovementInitialOverlaps)\n  1430→                {\n  1431→                    int numOverlaps = CharacterCollisionsOverlap(\n  1432→                                        tmpMovedPosition,\n  1433→                                        _transientRotation,\n  1434→                                        _internalProbedColliders,\n  1435→                                        0f,\n  1436→                                        false);\n  1437→                    if (numOverlaps > 0)\n  1438→                    {\n  1439→                        closestSweepHitDistance = 0f;\n  1440→\n  1441→                        float mostObstructingOverlapNormalDotProduct = 2f;\n  1442→\n  1443→                        for (int i = 0; i < numOverlaps; i++)\n  1444→                        {\n  1445→                            Collider tmpCollider = _internalProbedColliders[i];\n  1446→\n  1447→                            if (Physics.ComputePenetration(\n  1448→                                Capsule,\n  1449→                                tmpMovedPosition,\n  1450→                                _transientRotation,\n  1451→                                tmpCollider,\n  1452→                                tmpCollider.transform.position,\n  1453→                                tmpCollider.transform.rotation,\n  1454→                                out Vector3 resolutionDirection,\n  1455→                                out float resolutionDistance))\n  1456→                            {\n  1457→                                float dotProduct = Vector3.Dot(remainingMovementDirection, resolutionDirection);\n  1458→                                if (dotProduct < 0f && dotProduct < mostObstructingOverlapNormalDotProduct)\n  1459→                                {\n  1460→                                    mostObstructingOverlapNormalDotProduct = dotProduct;\n  1461→\n  1462→                                    closestSweepHitNormal = resolutionDirection;\n  1463→                                    closestSweepHitCollider = tmpCollider;\n  1464→                                    closestSweepHitPoint = tmpMovedPosition + (_transientRotation * CharacterTransformToCapsuleCenter) + (resolutionDirection * resolutionDistance);\n  1465→\n  1466→                                    foundClosestHit = true;\n  1467→                                }\n  1468→                            }\n  1469→                        }\n  1470→                    }\n  1471→                }\n  1472→\n  1473→                if (!foundClosestHit && CharacterCollisionsSweep(\n  1474→                        tmpMovedPosition, // position\n  1475→                        _transientRotation, // rotation\n  1476→                        remainingMovementDirection, // direction\n  1477→                        remainingMovementMagnitude + CollisionOffset, // distance\n  1478→                        out RaycastHit closestSweepHit, // closest hit\n  1479→                        _internalCharacterHits) // all hits\n  1480→                    > 0)\n  1481→                {\n  1482→                    closestSweepHitNormal = closestSweepHit.normal;\n  1483→                    closestSweepHitDistance = closestSweepHit.distance;\n  1484→                    closestSweepHitCollider = closestSweepHit.collider;\n  1485→                    closestSweepHitPoint = closestSweepHit.point;\n  1486→\n  1487→                    foundClosestHit = true;\n  1488→                }\n  1489→\n  1490→                if (foundClosestHit)\n  1491→                {\n  1492→                    // Calculate movement from this iteration\n  1493→                    Vector3 sweepMovement = (remainingMovementDirection * (Mathf.Max(0f, closestSweepHitDistance - CollisionOffset)));\n  1494→                    tmpMovedPosition += sweepMovement;\n  1495→                    remainingMovementMagnitude -= sweepMovement.magnitude;\n  1496→\n  1497→                    // Evaluate if hit is stable\n  1498→                    HitStabilityReport moveHitStabilityReport = new HitStabilityReport();\n  1499→                    EvaluateHitStability(closestSweepHitCollider, closestSweepHitNormal, closestSweepHitPoint, tmpMovedPosition, _transientRotation, transientVelocity, ref moveHitStabilityReport);\n  1500→\n  1501→                    // Handle stepping up steps points higher than bottom capsule radius\n  1502→                    bool foundValidStepHit = false;\n  1503→                    if (_solveGrounding && StepHandling != StepHandlingMethod.None && moveHitStabilityReport.ValidStepDetected)\n  1504→                    {\n  1505→                        float obstructionCorrelation = Mathf.Abs(Vector3.Dot(closestSweepHitNormal, _characterUp));\n  1506→                        if (obstructionCorrelation <= CorrelationForVerticalObstruction)\n  1507→                        {\n  1508→                            Vector3 stepForwardDirection = Vector3.ProjectOnPlane(-closestSweepHitNormal, _characterUp).normalized;\n  1509→                            Vector3 stepCastStartPoint = (tmpMovedPosition + (stepForwardDirection * SteppingForwardDistance)) +\n  1510→                                (_characterUp * MaxStepHeight);\n  1511→\n  1512→                            // Cast downward from the top of the stepping height\n  1513→                            int nbStepHits = CharacterCollisionsSweep(\n  1514→                                                stepCastStartPoint, // position\n  1515→                                                _transientRotation, // rotation\n  1516→                                                -_characterUp, // direction\n  1517→                                                MaxStepHeight, // distance\n  1518→                                                out RaycastHit closestStepHit, // closest hit\n  1519→                                                _internalCharacterHits,\n  1520→                                                0f,\n  1521→                                                true); // all hits \n  1522→\n  1523→                            // Check for hit corresponding to stepped collider\n  1524→                            for (int i = 0; i < nbStepHits; i++)\n  1525→                            {\n  1526→                                if (_internalCharacterHits[i].collider == moveHitStabilityReport.SteppedCollider)\n  1527→                                {\n  1528→                                    Vector3 endStepPosition = stepCastStartPoint + (-_characterUp * (_internalCharacterHits[i].distance - CollisionOffset));\n  1529→                                    tmpMovedPosition = endStepPosition;\n  1530→                                    foundValidStepHit = true;\n  1531→\n  1532→                                    // Project velocity on ground normal at step\n  1533→                                    transientVelocity = Vector3.ProjectOnPlane(transientVelocity, CharacterUp);\n  1534→                                    remainingMovementDirection = transientVelocity.normalized;\n  1535→\n  1536→                                    break;\n  1537→                                }\n  1538→                            }\n  1539→                        }\n  1540→                    }\n  1541→\n  1542→                    // Handle movement solving\n  1543→                    if (!foundValidStepHit)\n  1544→                    {\n  1545→                        Vector3 obstructionNormal = GetObstructionNormal(closestSweepHitNormal, moveHitStabilityReport.IsStable);\n  1546→\n  1547→                        // Movement hit callback\n  1548→                        CharacterController.OnMovementHit(closestSweepHitCollider, closestSweepHitNormal, closestSweepHitPoint, ref moveHitStabilityReport);\n  1549→\n  1550→                        // Handle remembering rigidbody hits\n  1551→                        if (InteractiveRigidbodyHandling && closestSweepHitCollider.attachedRigidbody)\n  1552→                        {\n  1553→                            StoreRigidbodyHit(\n  1554→                                closestSweepHitCollider.attachedRigidbody,\n  1555→                                transientVelocity,\n  1556→                                closestSweepHitPoint,\n  1557→                                obstructionNormal,\n  1558→                                moveHitStabilityReport);\n  1559→                        }\n  1560→\n  1561→                        bool stableOnHit = moveHitStabilityReport.IsStable && !MustUnground();\n  1562→                        Vector3 velocityBeforeProj = transientVelocity;\n  1563→\n  1564→                        // Project velocity for next iteration\n  1565→                        InternalHandleVelocityProjection(\n  1566→                            stableOnHit,\n  1567→                            closestSweepHitNormal,\n  1568→                            obstructionNormal,\n  1569→                            originalVelocityDirection,\n  1570→                            ref sweepState,\n  1571→                            previousHitIsStable,\n  1572→                            previousVelocity,\n  1573→                            previousObstructionNormal,\n  1574→                            ref transientVelocity,\n  1575→                            ref remainingMovementMagnitude,\n  1576→                            ref remainingMovementDirection);\n  1577→\n  1578→                        previousHitIsStable = stableOnHit;\n  1579→                        previousVelocity = velocityBeforeProj;\n  1580→                        previousObstructionNormal = obstructionNormal;\n  1581→                    }\n  1582→                }\n  1583→                // If we hit nothing...\n  1584→                else\n  1585→                {\n  1586→                    hitSomethingThisSweepIteration = false;\n  1587→                }\n  1588→\n  1589→                // Safety for exceeding max sweeps allowed\n  1590→                sweepsMade++;\n  1591→                if (sweepsMade > MaxMovementIterations)\n  1592→                {\n  1593→                    if (KillRemainingMovementWhenExceedMaxMovementIterations)\n  1594→                    {\n  1595→                        remainingMovementMagnitude = 0f;\n  1596→                    }\n  1597→\n  1598→                    if (KillVelocityWhenExceedMaxMovementIterations)\n  1599→                    {\n  1600→                        transientVelocity = Vector3.zero;\n  1601→                    }\n  1602→                    wasCompleted = false;\n  1603→                }\n  1604→            }\n  1605→\n  1606→            // Move position for the remainder of the movement\n  1607→            tmpMovedPosition += (remainingMovementDirection * remainingMovementMagnitude);\n  1608→            _transientPosition = tmpMovedPosition;\n  1609→\n  1610→            return wasCompleted;\n  1611→        }\n  1612→\n  1613→        /// <summary>\n  1614→        /// Gets the effective normal for movement obstruction depending on current grounding status\n  1615→        /// </summary>\n  1616→        private Vector3 GetObstructionNormal(Vector3 hitNormal, bool stableOnHit)\n  1617→        {\n  1618→            // Find hit/obstruction/offset normal\n  1619→            Vector3 obstructionNormal = hitNormal;\n  1620→            if (GroundingStatus.IsStableOnGround && !MustUnground() && !stableOnHit)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ce0006b6-4e92-4ed2-abac-2dc6b219fbe3","timestamp":"2025-12-19T10:13:13.856Z","toolUseResult":{"type":"text","file":{"filePath":"e:\\Project\\Demo\\MonsterHunter\\Assets\\_ThirdParty\\KinematicCharacterController\\Core\\KinematicCharacterMotor.cs","content":"                        {\n                            for (int i = 0; i < nbOverlaps; i++)\n                            {\n                                // Process overlap\n                                Transform overlappedTransform = _internalProbedColliders[i].GetComponent<Transform>();\n                                if (Physics.ComputePenetration(\n                                        Capsule,\n                                        _transientPosition,\n                                        _transientRotation,\n                                        _internalProbedColliders[i],\n                                        overlappedTransform.position,\n                                        overlappedTransform.rotation,\n                                        out resolutionDirection,\n                                        out resolutionDistance))\n                                {\n                                    // Resolve along obstruction direction\n                                    HitStabilityReport mockReport = new HitStabilityReport();\n                                    mockReport.IsStable = IsStableOnNormal(resolutionDirection);\n                                    resolutionDirection = GetObstructionNormal(resolutionDirection, mockReport.IsStable);\n\n                                    // Solve overlap\n                                    Vector3 resolutionMovement = resolutionDirection * (resolutionDistance + CollisionOffset);\n                                    _transientPosition += resolutionMovement;\n\n                                    // If interactiveRigidbody, register as rigidbody hit for velocity\n                                    if (InteractiveRigidbodyHandling)\n                                    {\n                                        Rigidbody probedRigidbody = GetInteractiveRigidbody(_internalProbedColliders[i]);\n                                        if (probedRigidbody != null)\n                                        {\n                                            HitStabilityReport tmpReport = new HitStabilityReport();\n                                            tmpReport.IsStable = IsStableOnNormal(resolutionDirection);\n                                            if (tmpReport.IsStable)\n                                            {\n                                                LastMovementIterationFoundAnyGround = tmpReport.IsStable;\n                                            }\n                                            if (probedRigidbody != _attachedRigidbody)\n                                            {\n                                                Vector3 characterCenter = _transientPosition + (_transientRotation * _characterTransformToCapsuleCenter);\n                                                Vector3 estimatedCollisionPoint = _transientPosition;\n\n\n                                                StoreRigidbodyHit(\n                                                    probedRigidbody,\n                                                    Velocity,\n                                                    estimatedCollisionPoint,\n                                                    resolutionDirection,\n                                                    tmpReport);\n                                            }\n                                        }\n                                    }\n\n                                    // Remember overlaps\n                                    if (_overlapsCount < _overlaps.Length)\n                                    {\n                                        _overlaps[_overlapsCount] = new OverlapResult(resolutionDirection, _internalProbedColliders[i]);\n                                        _overlapsCount++;\n                                    }\n\n                                    break;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            overlapSolved = true;\n                        }\n\n                        iterationsMade++;\n                    }\n                    #endregion\n                }\n            }\n\n            // Handle velocity\n            CharacterController.UpdateVelocity(ref BaseVelocity, deltaTime);\n\n            //this.CharacterController.UpdateVelocity(ref BaseVelocity, deltaTime);\n            if (BaseVelocity.magnitude < MinVelocityMagnitude)\n            {\n                BaseVelocity = Vector3.zero;\n            }\n\n            #region Calculate Character movement from base velocity   \n            // Perform the move from base velocity\n            if (BaseVelocity.sqrMagnitude > 0f)\n            {\n                if (_solveMovementCollisions)\n                {\n                    InternalCharacterMove(ref BaseVelocity, deltaTime);\n                }\n                else\n                {\n                    _transientPosition += BaseVelocity * deltaTime;\n                }\n            }\n\n            // Process rigidbody hits/overlaps to affect velocity\n            if (InteractiveRigidbodyHandling)\n            {\n                ProcessVelocityForRigidbodyHits(ref BaseVelocity, deltaTime);\n            }\n            #endregion\n\n            // Handle planar constraint\n            if (HasPlanarConstraint)\n            {\n                _transientPosition = _initialSimulationPosition + Vector3.ProjectOnPlane(_transientPosition - _initialSimulationPosition, PlanarConstraintAxis.normalized);\n            }\n\n            // Discrete collision detection\n            if (DiscreteCollisionEvents)\n            {\n                int nbOverlaps = CharacterCollisionsOverlap(_transientPosition, _transientRotation, _internalProbedColliders, CollisionOffset * 2f);\n                for (int i = 0; i < nbOverlaps; i++)\n                {\n                    CharacterController.OnDiscreteCollisionDetected(_internalProbedColliders[i]);\n                }\n            }\n\n            CharacterController.AfterCharacterUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// Determines if motor can be considered stable on given slope normal\n        /// </summary>\n        private bool IsStableOnNormal(Vector3 normal)\n        {\n            return Vector3.Angle(_characterUp, normal) <= MaxStableSlopeAngle;\n        }\n\n        /// <summary>\n        /// Determines if motor can be considered stable on given slope normal\n        /// </summary>\n        private bool IsStableWithSpecialCases(ref HitStabilityReport stabilityReport, Vector3 velocity)\n        {\n            if (LedgeAndDenivelationHandling)\n            {\n                if (stabilityReport.LedgeDetected)\n                {\n                    if (stabilityReport.IsMovingTowardsEmptySideOfLedge)\n                    {\n                        // Max snap vel\n                        Vector3 velocityOnLedgeNormal = Vector3.Project(velocity, stabilityReport.LedgeFacingDirection);\n                        if (velocityOnLedgeNormal.magnitude >= MaxVelocityForLedgeSnap)\n                        {\n                            return false;\n                        }\n                    }\n\n                    // Distance from ledge\n                    if (stabilityReport.IsOnEmptySideOfLedge && stabilityReport.DistanceFromLedge > MaxStableDistanceFromLedge)\n                    {\n                        return false;\n                    }\n                }\n\n                // \"Launching\" off of slopes of a certain denivelation angle\n                if (LastGroundingStatus.FoundAnyGround && stabilityReport.InnerNormal.sqrMagnitude != 0f && stabilityReport.OuterNormal.sqrMagnitude != 0f)\n                {\n                    float denivelationAngle = Vector3.Angle(stabilityReport.InnerNormal, stabilityReport.OuterNormal);\n                    if (denivelationAngle > MaxStableDenivelationAngle)\n                    {\n                        return false;\n                    }\n                    else\n                    {\n                        denivelationAngle = Vector3.Angle(LastGroundingStatus.InnerGroundNormal, stabilityReport.OuterNormal);\n                        if (denivelationAngle > MaxStableDenivelationAngle)\n                        {\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Probes for valid ground and midifies the input transientPosition if ground snapping occurs\n        /// </summary>\n        public void ProbeGround(ref Vector3 probingPosition, Quaternion atRotation, float probingDistance, ref CharacterGroundingReport groundingReport)\n        {\n            if (probingDistance < MinimumGroundProbingDistance)\n            {\n                probingDistance = MinimumGroundProbingDistance;\n            }\n\n            int groundSweepsMade = 0;\n            RaycastHit groundSweepHit = new RaycastHit();\n            bool groundSweepingIsOver = false;\n            Vector3 groundSweepPosition = probingPosition;\n            Vector3 groundSweepDirection = (atRotation * -_cachedWorldUp);\n            float groundProbeDistanceRemaining = probingDistance;\n            while (groundProbeDistanceRemaining > 0 && (groundSweepsMade <= MaxGroundingSweepIterations) && !groundSweepingIsOver)\n            {\n                // Sweep for ground detection\n                if (CharacterGroundSweep(\n                        groundSweepPosition, // position\n                        atRotation, // rotation\n                        groundSweepDirection, // direction\n                        groundProbeDistanceRemaining, // distance\n                        out groundSweepHit)) // hit\n                {\n                    Vector3 targetPosition = groundSweepPosition + (groundSweepDirection * groundSweepHit.distance);\n                    HitStabilityReport groundHitStabilityReport = new HitStabilityReport();\n                    EvaluateHitStability(groundSweepHit.collider, groundSweepHit.normal, groundSweepHit.point, targetPosition, _transientRotation, BaseVelocity, ref groundHitStabilityReport);\n\n                    groundingReport.FoundAnyGround = true;\n                    groundingReport.GroundNormal = groundSweepHit.normal;\n                    groundingReport.InnerGroundNormal = groundHitStabilityReport.InnerNormal;\n                    groundingReport.OuterGroundNormal = groundHitStabilityReport.OuterNormal;\n                    groundingReport.GroundCollider = groundSweepHit.collider;\n                    groundingReport.GroundPoint = groundSweepHit.point;\n                    groundingReport.SnappingPrevented = false;\n\n                    // Found stable ground\n                    if (groundHitStabilityReport.IsStable)\n                    {\n                        // Find all scenarios where ground snapping should be canceled\n                        groundingReport.SnappingPrevented = !IsStableWithSpecialCases(ref groundHitStabilityReport, BaseVelocity);\n\n                        groundingReport.IsStableOnGround = true;\n\n                        // Ground snapping\n                        if (!groundingReport.SnappingPrevented)\n                        {\n                            probingPosition = groundSweepPosition + (groundSweepDirection * (groundSweepHit.distance - CollisionOffset));\n                        }\n\n                        CharacterController.OnGroundHit(groundSweepHit.collider, groundSweepHit.normal, groundSweepHit.point, ref groundHitStabilityReport);\n                        groundSweepingIsOver = true;\n                    }\n                    else\n                    {\n                        // Calculate movement from this iteration and advance position\n                        Vector3 sweepMovement = (groundSweepDirection * groundSweepHit.distance) + ((atRotation * _cachedWorldUp) * Mathf.Max(CollisionOffset, groundSweepHit.distance));\n                        groundSweepPosition = groundSweepPosition + sweepMovement;\n\n                        // Set remaining distance\n                        groundProbeDistanceRemaining = Mathf.Min(GroundProbeReboundDistance, Mathf.Max(groundProbeDistanceRemaining - sweepMovement.magnitude, 0f));\n\n                        // Reorient direction\n                        groundSweepDirection = Vector3.ProjectOnPlane(groundSweepDirection, groundSweepHit.normal).normalized;\n                    }\n                }\n                else\n                {\n                    groundSweepingIsOver = true;\n                }\n\n                groundSweepsMade++;\n            }\n        }\n\n        /// <summary>\n        /// Forces the character to unground itself on its next grounding update\n        /// </summary>\n        public void ForceUnground(float time = 0.1f)\n        {\n            _mustUnground = true;\n            _mustUngroundTimeCounter = time;\n        }\n\n        public bool MustUnground()\n        {\n            return _mustUnground || _mustUngroundTimeCounter > 0f;\n        }\n\n        /// <summary>\n        /// Returns the direction adjusted to be tangent to a specified surface normal relatively to the character's up direction.\n        /// Useful for reorienting a direction on a slope without any lateral deviation in trajectory\n        /// </summary>\n        public Vector3 GetDirectionTangentToSurface(Vector3 direction, Vector3 surfaceNormal)\n        {\n            Vector3 directionRight = Vector3.Cross(direction, _characterUp);\n            return Vector3.Cross(surfaceNormal, directionRight).normalized;\n        }\n\n        /// <summary>\n        /// Moves the character's position by given movement while taking into account all physics simulation, step-handling and \n        /// velocity projection rules that affect the character motor\n        /// </summary>\n        /// <returns> Returns false if movement could not be solved until the end </returns>\n        private bool InternalCharacterMove(ref Vector3 transientVelocity, float deltaTime)\n        {\n            if (deltaTime <= 0f)\n                return false;\n\n            // Planar constraint\n            if (HasPlanarConstraint)\n            {\n                transientVelocity = Vector3.ProjectOnPlane(transientVelocity, PlanarConstraintAxis.normalized);\n            }\n\n            bool wasCompleted = true;\n            Vector3 remainingMovementDirection = transientVelocity.normalized;\n            float remainingMovementMagnitude = transientVelocity.magnitude * deltaTime;\n            Vector3 originalVelocityDirection = remainingMovementDirection;\n            int sweepsMade = 0;\n            bool hitSomethingThisSweepIteration = true;\n            Vector3 tmpMovedPosition = _transientPosition;\n            bool previousHitIsStable = false;\n            Vector3 previousVelocity = _cachedZeroVector;\n            Vector3 previousObstructionNormal = _cachedZeroVector;\n            MovementSweepState sweepState = MovementSweepState.Initial;\n\n            // Project movement against current overlaps before doing the sweeps\n            for (int i = 0; i < _overlapsCount; i++)\n            {\n                Vector3 overlapNormal = _overlaps[i].Normal;\n                if (Vector3.Dot(remainingMovementDirection, overlapNormal) < 0f)\n                {\n                    bool stableOnHit = IsStableOnNormal(overlapNormal) && !MustUnground();\n                    Vector3 velocityBeforeProjection = transientVelocity;\n                    Vector3 obstructionNormal = GetObstructionNormal(overlapNormal, stableOnHit);\n\n                    InternalHandleVelocityProjection(\n                        stableOnHit,\n                        overlapNormal,\n                        obstructionNormal,\n                        originalVelocityDirection,\n                        ref sweepState,\n                        previousHitIsStable,\n                        previousVelocity,\n                        previousObstructionNormal,\n                        ref transientVelocity,\n                        ref remainingMovementMagnitude,\n                        ref remainingMovementDirection);\n\n                    previousHitIsStable = stableOnHit;\n                    previousVelocity = velocityBeforeProjection;\n                    previousObstructionNormal = obstructionNormal;\n                }\n            }\n\n            // Sweep the desired movement to detect collisions\n            while (remainingMovementMagnitude > 0f &&\n                (sweepsMade <= MaxMovementIterations) &&\n                hitSomethingThisSweepIteration)\n            {\n                bool foundClosestHit = false;\n                Vector3 closestSweepHitPoint = default;\n                Vector3 closestSweepHitNormal = default;\n                float closestSweepHitDistance = 0f;\n                Collider closestSweepHitCollider = null;\n\n                if (CheckMovementInitialOverlaps)\n                {\n                    int numOverlaps = CharacterCollisionsOverlap(\n                                        tmpMovedPosition,\n                                        _transientRotation,\n                                        _internalProbedColliders,\n                                        0f,\n                                        false);\n                    if (numOverlaps > 0)\n                    {\n                        closestSweepHitDistance = 0f;\n\n                        float mostObstructingOverlapNormalDotProduct = 2f;\n\n                        for (int i = 0; i < numOverlaps; i++)\n                        {\n                            Collider tmpCollider = _internalProbedColliders[i];\n\n                            if (Physics.ComputePenetration(\n                                Capsule,\n                                tmpMovedPosition,\n                                _transientRotation,\n                                tmpCollider,\n                                tmpCollider.transform.position,\n                                tmpCollider.transform.rotation,\n                                out Vector3 resolutionDirection,\n                                out float resolutionDistance))\n                            {\n                                float dotProduct = Vector3.Dot(remainingMovementDirection, resolutionDirection);\n                                if (dotProduct < 0f && dotProduct < mostObstructingOverlapNormalDotProduct)\n                                {\n                                    mostObstructingOverlapNormalDotProduct = dotProduct;\n\n                                    closestSweepHitNormal = resolutionDirection;\n                                    closestSweepHitCollider = tmpCollider;\n                                    closestSweepHitPoint = tmpMovedPosition + (_transientRotation * CharacterTransformToCapsuleCenter) + (resolutionDirection * resolutionDistance);\n\n                                    foundClosestHit = true;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (!foundClosestHit && CharacterCollisionsSweep(\n                        tmpMovedPosition, // position\n                        _transientRotation, // rotation\n                        remainingMovementDirection, // direction\n                        remainingMovementMagnitude + CollisionOffset, // distance\n                        out RaycastHit closestSweepHit, // closest hit\n                        _internalCharacterHits) // all hits\n                    > 0)\n                {\n                    closestSweepHitNormal = closestSweepHit.normal;\n                    closestSweepHitDistance = closestSweepHit.distance;\n                    closestSweepHitCollider = closestSweepHit.collider;\n                    closestSweepHitPoint = closestSweepHit.point;\n\n                    foundClosestHit = true;\n                }\n\n                if (foundClosestHit)\n                {\n                    // Calculate movement from this iteration\n                    Vector3 sweepMovement = (remainingMovementDirection * (Mathf.Max(0f, closestSweepHitDistance - CollisionOffset)));\n                    tmpMovedPosition += sweepMovement;\n                    remainingMovementMagnitude -= sweepMovement.magnitude;\n\n                    // Evaluate if hit is stable\n                    HitStabilityReport moveHitStabilityReport = new HitStabilityReport();\n                    EvaluateHitStability(closestSweepHitCollider, closestSweepHitNormal, closestSweepHitPoint, tmpMovedPosition, _transientRotation, transientVelocity, ref moveHitStabilityReport);\n\n                    // Handle stepping up steps points higher than bottom capsule radius\n                    bool foundValidStepHit = false;\n                    if (_solveGrounding && StepHandling != StepHandlingMethod.None && moveHitStabilityReport.ValidStepDetected)\n                    {\n                        float obstructionCorrelation = Mathf.Abs(Vector3.Dot(closestSweepHitNormal, _characterUp));\n                        if (obstructionCorrelation <= CorrelationForVerticalObstruction)\n                        {\n                            Vector3 stepForwardDirection = Vector3.ProjectOnPlane(-closestSweepHitNormal, _characterUp).normalized;\n                            Vector3 stepCastStartPoint = (tmpMovedPosition + (stepForwardDirection * SteppingForwardDistance)) +\n                                (_characterUp * MaxStepHeight);\n\n                            // Cast downward from the top of the stepping height\n                            int nbStepHits = CharacterCollisionsSweep(\n                                                stepCastStartPoint, // position\n                                                _transientRotation, // rotation\n                                                -_characterUp, // direction\n                                                MaxStepHeight, // distance\n                                                out RaycastHit closestStepHit, // closest hit\n                                                _internalCharacterHits,\n                                                0f,\n                                                true); // all hits \n\n                            // Check for hit corresponding to stepped collider\n                            for (int i = 0; i < nbStepHits; i++)\n                            {\n                                if (_internalCharacterHits[i].collider == moveHitStabilityReport.SteppedCollider)\n                                {\n                                    Vector3 endStepPosition = stepCastStartPoint + (-_characterUp * (_internalCharacterHits[i].distance - CollisionOffset));\n                                    tmpMovedPosition = endStepPosition;\n                                    foundValidStepHit = true;\n\n                                    // Project velocity on ground normal at step\n                                    transientVelocity = Vector3.ProjectOnPlane(transientVelocity, CharacterUp);\n                                    remainingMovementDirection = transientVelocity.normalized;\n\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    // Handle movement solving\n                    if (!foundValidStepHit)\n                    {\n                        Vector3 obstructionNormal = GetObstructionNormal(closestSweepHitNormal, moveHitStabilityReport.IsStable);\n\n                        // Movement hit callback\n                        CharacterController.OnMovementHit(closestSweepHitCollider, closestSweepHitNormal, closestSweepHitPoint, ref moveHitStabilityReport);\n\n                        // Handle remembering rigidbody hits\n                        if (InteractiveRigidbodyHandling && closestSweepHitCollider.attachedRigidbody)\n                        {\n                            StoreRigidbodyHit(\n                                closestSweepHitCollider.attachedRigidbody,\n                                transientVelocity,\n                                closestSweepHitPoint,\n                                obstructionNormal,\n                                moveHitStabilityReport);\n                        }\n\n                        bool stableOnHit = moveHitStabilityReport.IsStable && !MustUnground();\n                        Vector3 velocityBeforeProj = transientVelocity;\n\n                        // Project velocity for next iteration\n                        InternalHandleVelocityProjection(\n                            stableOnHit,\n                            closestSweepHitNormal,\n                            obstructionNormal,\n                            originalVelocityDirection,\n                            ref sweepState,\n                            previousHitIsStable,\n                            previousVelocity,\n                            previousObstructionNormal,\n                            ref transientVelocity,\n                            ref remainingMovementMagnitude,\n                            ref remainingMovementDirection);\n\n                        previousHitIsStable = stableOnHit;\n                        previousVelocity = velocityBeforeProj;\n                        previousObstructionNormal = obstructionNormal;\n                    }\n                }\n                // If we hit nothing...\n                else\n                {\n                    hitSomethingThisSweepIteration = false;\n                }\n\n                // Safety for exceeding max sweeps allowed\n                sweepsMade++;\n                if (sweepsMade > MaxMovementIterations)\n                {\n                    if (KillRemainingMovementWhenExceedMaxMovementIterations)\n                    {\n                        remainingMovementMagnitude = 0f;\n                    }\n\n                    if (KillVelocityWhenExceedMaxMovementIterations)\n                    {\n                        transientVelocity = Vector3.zero;\n                    }\n                    wasCompleted = false;\n                }\n            }\n\n            // Move position for the remainder of the movement\n            tmpMovedPosition += (remainingMovementDirection * remainingMovementMagnitude);\n            _transientPosition = tmpMovedPosition;\n\n            return wasCompleted;\n        }\n\n        /// <summary>\n        /// Gets the effective normal for movement obstruction depending on current grounding status\n        /// </summary>\n        private Vector3 GetObstructionNormal(Vector3 hitNormal, bool stableOnHit)\n        {\n            // Find hit/obstruction/offset normal\n            Vector3 obstructionNormal = hitNormal;\n            if (GroundingStatus.IsStableOnGround && !MustUnground() && !stableOnHit)","numLines":540,"startLine":1081,"totalLines":2689}}}
{"parentUuid":"ce0006b6-4e92-4ed2-abac-2dc6b219fbe3","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01EvMyLiKKtqct7eGmshh6G1","type":"message","role":"assistant","content":[{"type":"text","text":"好的，我已经读取了完整的文件（2688行）。现在我将对这个文件进行完整的中文注释翻译和补充。由于文件很大，我将创建完整的翻译版本并写入原文件。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":16712,"cache_creation_input_tokens":25348,"cache_read_input_tokens":39311,"cache_creation":{"ephemeral_5m_input_tokens":25348,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"01d666e1-8c8e-497b-9bcd-f17f8390fde3","timestamp":"2025-12-19T10:13:21.344Z"}
{"parentUuid":"01d666e1-8c8e-497b-9bcd-f17f8390fde3","isSidechain":true,"userType":"external","cwd":"e:\\Project\\Demo\\MonsterHunter","sessionId":"ad011a4a-06b3-4c09-837f-9fa480ee9f04","version":"2.0.72","gitBranch":"master","agentId":"a7e3913","slug":"refactored-wiggling-glade","type":"assistant","uuid":"b3a05c83-0275-4bf0-adfd-58ea3d7515b1","timestamp":"2025-12-19T10:20:20.566Z","message":{"id":"5a24cedd-e046-42f3-9435-cc6369ee69c3","container":null,"model":"<synthetic>","role":"assistant","stop_reason":"stop_sequence","stop_sequence":"","type":"message","usage":{"input_tokens":0,"output_tokens":0,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":null,"cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":0}},"content":[{"type":"text","text":"API Error: Claude's response exceeded the 32000 output token maximum. To configure this behavior, set the CLAUDE_CODE_MAX_OUTPUT_TOKENS environment variable."}],"context_management":null},"isApiErrorMessage":true}
