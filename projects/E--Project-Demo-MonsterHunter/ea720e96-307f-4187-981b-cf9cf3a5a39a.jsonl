{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","type":"system","subtype":"local_command","content":"<command-name>/resume</command-name>\n            <command-message>resume</command-message>\n            <command-args></command-args>","level":"info","timestamp":"2025-12-15T09:53:07.102Z","uuid":"6c282748-736a-4137-93d5-5daf0a0e974b","isMeta":false}
{"parentUuid":"6c282748-736a-4137-93d5-5daf0a0e974b","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","type":"system","subtype":"local_command","content":"<local-command-stdout>Resume cancelled</local-command-stdout>","level":"info","timestamp":"2025-12-15T09:53:07.102Z","uuid":"ecc5477c-99a6-4c33-92f6-0d514f11efc1","isMeta":false}
{"type":"summary","summary":"Claude Code CLI Session Started","leafUuid":"9017613e-5b18-46e3-95d7-12ac0738ebc8"}
{"type":"file-history-snapshot","messageId":"21a29aad-1af9-47d3-86d4-eaa993a42dd7","snapshot":{"messageId":"21a29aad-1af9-47d3-86d4-eaa993a42dd7","trackedFileBackups":{},"timestamp":"2025-12-15T09:55:57.038Z"},"isSnapshotUpdate":false}
{"parentUuid":"ecc5477c-99a6-4c33-92f6-0d514f11efc1","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","type":"user","message":{"role":"user","content":"<command-message>init is analyzing your codebase…</command-message>\n<command-name>/init</command-name>"},"uuid":"21a29aad-1af9-47d3-86d4-eaa993a42dd7","timestamp":"2025-12-15T09:55:57.034Z"}
{"parentUuid":"21a29aad-1af9-47d3-86d4-eaa993a42dd7","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","type":"user","message":{"role":"user","content":[{"type":"text","text":"Please analyze this codebase and create a CLAUDE.md file, which will be given to future instances of Claude Code to operate in this repository.\n\nWhat to add:\n1. Commands that will be commonly used, such as how to build, lint, and run tests. Include the necessary commands to develop in this codebase, such as how to run a single test.\n2. High-level code architecture and structure so that future instances can be productive more quickly. Focus on the \"big picture\" architecture that requires reading multiple files to understand.\n\nUsage notes:\n- If there's already a CLAUDE.md, suggest improvements to it.\n- When you make the initial CLAUDE.md, do not repeat yourself and do not include obvious instructions like \"Provide helpful error messages to users\", \"Write unit tests for all new utilities\", \"Never include sensitive information (API keys, tokens) in code or commits\".\n- Avoid listing every component or file structure that can be easily discovered.\n- Don't include generic development practices.\n- If there are Cursor rules (in .cursor/rules/ or .cursorrules) or Copilot rules (in .github/copilot-instructions.md), make sure to include the important parts.\n- If there is a README.md, make sure to include the important parts.\n- Do not make up information such as \"Common Development Tasks\", \"Tips for Development\", \"Support and Documentation\" unless this is expressly included in other files that you read.\n- Be sure to prefix the file with the following text:\n\n```\n# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n```"}]},"isMeta":true,"uuid":"b5d104ab-d80a-4d02-b03f-4e9c03310f19","timestamp":"2025-12-15T09:55:57.034Z"}
{"parentUuid":"b5d104ab-d80a-4d02-b03f-4e9c03310f19","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UHHm72FvNM7CFwUeqySZxY","type":"message","role":"assistant","content":[{"type":"text","text":"I'll analyze the codebase to create a comprehensive CLAUDE.md file. Let me start by exploring the project structure and understanding the architecture."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":39356,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":39356,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"709bce01-c504-4faf-bfa1-bc6907f325c4","timestamp":"2025-12-15T09:56:03.037Z"}
{"parentUuid":"709bce01-c504-4faf-bfa1-bc6907f325c4","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UHHm72FvNM7CFwUeqySZxY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013ZFoftPGtEELMwi9SEfav3","name":"Task","input":{"description":"Explore MonsterHunter codebase","prompt":"Analyze this Unity project codebase to understand:\n1. The overall architecture and key systems\n2. Main entry points and code flow\n3. Important patterns and conventions used\n4. Dependencies and third-party integrations\n5. Build/development commands if any\n\nFocus on understanding the ActionMachine system, game architecture, and how different components interact. Look for:\n- Main game managers and controllers\n- State machine implementation\n- Input handling\n- Animation system integration\n- Configuration/data loading systems\n- Any build scripts or development tools\n\nProvide a comprehensive summary of the architecture that would help a new developer understand how to work with this codebase.","subagent_type":"Explore","model":"sonnet"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":39356,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":39356,"ephemeral_1h_input_tokens":0},"output_tokens":285,"service_tier":"standard"}},"type":"assistant","uuid":"2c22ef52-1c5b-4319-a268-16f68ea4b411","timestamp":"2025-12-15T09:56:09.191Z"}
{"parentUuid":"2c22ef52-1c5b-4319-a268-16f68ea4b411","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013ZFoftPGtEELMwi9SEfav3","type":"tool_result","content":[{"type":"text","text":"API Error: 504 <html>\r\n<head><title>504 Gateway Time-out</title></head>\r\n<body>\r\n<center><h1>504 Gateway Time-out</h1></center>\r\n</body>\r\n</html>\r\n"},{"type":"text","text":"agentId: a788659 (for resuming to continue this agent's work if needed)"}]}]},"uuid":"fe57ec97-5eea-4f7b-9671-f268d801b752","timestamp":"2025-12-15T10:12:25.632Z","toolUseResult":{"status":"completed","prompt":"Analyze this Unity project codebase to understand:\n1. The overall architecture and key systems\n2. Main entry points and code flow\n3. Important patterns and conventions used\n4. Dependencies and third-party integrations\n5. Build/development commands if any\n\nFocus on understanding the ActionMachine system, game architecture, and how different components interact. Look for:\n- Main game managers and controllers\n- State machine implementation\n- Input handling\n- Animation system integration\n- Configuration/data loading systems\n- Any build scripts or development tools\n\nProvide a comprehensive summary of the architecture that would help a new developer understand how to work with this codebase.","agentId":"a788659","content":[{"type":"text","text":"API Error: 504 <html>\r\n<head><title>504 Gateway Time-out</title></head>\r\n<body>\r\n<center><h1>504 Gateway Time-out</h1></center>\r\n</body>\r\n</html>\r\n"}],"totalDurationMs":976094,"totalTokens":0,"totalToolUseCount":26,"usage":{"input_tokens":0,"output_tokens":0,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":null,"cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":0}}}}
{"parentUuid":"fe57ec97-5eea-4f7b-9671-f268d801b752","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Sap4Jprc69PeYpodqPVzgG","type":"message","role":"assistant","content":[{"type":"text","text":"Let me try a more focused approach by reading the existing CLAUDE.md and key files:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":39729,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":39729,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"64d163c9-a2b1-4525-9591-4a835666f63a","timestamp":"2025-12-15T10:12:36.984Z"}
{"parentUuid":"64d163c9-a2b1-4525-9591-4a835666f63a","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Sap4Jprc69PeYpodqPVzgG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019junLzhZtG3f7Hp4unNGXT","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\claude.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":39729,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":39729,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"5b1f9c9b-f664-429f-bfcc-01e8ce9c9902","timestamp":"2025-12-15T10:12:37.773Z"}
{"parentUuid":"5b1f9c9b-f664-429f-bfcc-01e8ce9c9902","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Sap4Jprc69PeYpodqPVzgG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016dDt3ubQzjroTnEQxPDXNZ","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\README.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":39729,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":39729,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"2bf22082-6af4-4108-8a81-60e853d17832","timestamp":"2025-12-15T10:12:38.495Z"}
{"parentUuid":"2bf22082-6af4-4108-8a81-60e853d17832","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Sap4Jprc69PeYpodqPVzgG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y5drYfNR5iL42u5WGUukDH","name":"Glob","input":{"pattern":"**/.cursorrules"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":39729,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":39729,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"c9a11cee-909e-452b-befe-f06926963a00","timestamp":"2025-12-15T10:12:38.685Z"}
{"parentUuid":"c9a11cee-909e-452b-befe-f06926963a00","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Sap4Jprc69PeYpodqPVzgG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019si4VdhZV51VtkSrDhbw6e","name":"Glob","input":{"pattern":"**/.cursor/rules/*"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":39729,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":39729,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"2fa16dcf-cc62-4e8e-b15d-e8608f5f4b0d","timestamp":"2025-12-15T10:12:38.914Z"}
{"parentUuid":"2fa16dcf-cc62-4e8e-b15d-e8608f5f4b0d","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Sap4Jprc69PeYpodqPVzgG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YSNoxSr8K9iu9w8R9zxXUc","name":"Glob","input":{"pattern":"**/.github/copilot-instructions.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":39729,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":39729,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"58c47048-9b28-4dc5-8dea-42214fcfaeb5","timestamp":"2025-12-15T10:12:39.247Z"}
{"parentUuid":"58c47048-9b28-4dc5-8dea-42214fcfaeb5","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019junLzhZtG3f7Hp4unNGXT","type":"tool_result","content":"     1→# MonsterHunter 项目 - Claude AI 参考文档\n     2→\n     3→> 本文档专为 AI 助手设计，用于快速理解项目结构、查找代码和执行常见任务。\n     4→\n     5→## 快速索引\n     6→\n     7→- [核心架构](#核心架构)\n     8→- [重要类索引](#重要类索引)\n     9→- [文件路径快速查找](#文件路径快速查找)\n    10→- [设计模式与约定](#设计模式与约定)\n    11→- [常用操作指南](#常用操作指南)\n    12→- [API 参考](#api-参考)\n    13→\n    14→---\n    15→\n    16→## 核心架构\n    17→\n    18→### 系统层级结构\n    19→\n    20→```\n    21→GameManager (单例)\n    22→  └─> ActionController (每个角色一个)\n    23→      ├─> ActionMachine (状态机核心)\n    24→      │   ├─> AssetsHandler (动作资源处理器)\n    25→      │   │   └─> GroupHandler (轨道组处理器)\n    26→      │   │       └─> TrackHandler (轨道处理器)\n    27→      │   │           └─> ClipHandler (片段处理器)\n    28→      │   └─> GlobalAssetsHandlers (全局动作列表)\n    29→      ├─> AnimancerComponent (动画系统)\n    30→      └─> Kcc (运动控制器)\n    31→```\n    32→\n    33→### 数据流\n    34→\n    35→```\n    36→JSON配置文件\n    37→  → LocalModelManager.Load()\n    38→  → ActionMachineInitializeData\n    39→  → ActionMachine.Initialize()\n    40→  → AssetsHandler.Instantiate()\n    41→  → ClipHandler.Enter/LogicUpdate/Exit\n    42→```\n    43→\n    44→### 更新循环\n    45→\n    46→```\n    47→GameManager.Update()\n    48→  └─> RunLogicUpdate(deltaTime)\n    49→      └─> ActionController.LogicUpdate(deltaTime)\n    50→          ├─> ActionMachine.LogicUpdate(deltaTime)\n    51→          │   ├─> UpdateState() - 状态切换\n    52→          │   ├─> UpdateGlobalFrame() - 全局动作\n    53→          │   └─> UpdateFrame() - 当前状态动作\n    54→          └─> Kcc.LogicUpdate(deltaTime)\n    55→\n    56→ActionController.Update()\n    57→  └─> ActionMachine.RenderUpdate(deltaTime)\n    58→      └─> AssetsHandler.RenderUpdate()\n    59→```\n    60→\n    61→---\n    62→\n    63→## 重要类索引\n    64→\n    65→### 核心管理类\n    66→\n    67→#### GameManager\n    68→- **路径**: `Assets/_Game/Scripts/Runtime/GameManager.cs:38`\n    69→- **职责**: 游戏主管理器，单例模式\n    70→- **关键方法**:\n    71→  - `Start()` - 初始化 LocalModelManager 和加载配置\n    72→  - `Update()` - 处理输入和逻辑更新\n    73→  - `RunLogicUpdate(float)` - 执行所有角色的逻辑更新\n    74→  - `InitializeCharacterActionData(int)` - 初始化角色动作数据\n    75→\n    76→#### LocalModelManager\n    77→- **路径**: `Assets/_Game/Scripts/LocalModels/LocalModelManager.cs:22`\n    78→- **职责**: 配置数据管理，使用 Luban 系统\n    79→- **关键方法**:\n    80→  - `SetTableLoader(ITableLoader)` - 设置加载器\n    81→  - `LoadAll(Action<float>, Action)` - 加载所有配置\n    82→  - `Load(string, Action)` - 加载指定配置文件\n    83→\n    84→### ActionMachine 系统\n    85→\n    86→#### ActionMachine\n    87→- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Machine/ActionMachine.cs:12`\n    88→- **职责**: 动作状态机核心逻辑\n    89→- **关键属性**:\n    90→  - `_stateAssets: Dictionary<string, StateActionConfig>` - 状态动作映射\n    91→  - `_globalAssetsHandlers: List<IAssetsHandler>` - 全局动作列表\n    92→  - `_currentUseHandler: IAssetsHandler` - 当前激活的动作处理器\n    93→- **关键方法**:\n    94→  - `Initialize(ActionMachineInitializeData, ControllerType)` - 初始化状态机\n    95→  - `LogicUpdate(float)` - 逻辑更新（每逻辑帧调用）\n    96→  - `RenderUpdate(float)` - 渲染更新（每渲染帧调用）\n    97→  - `ChangeState(string, int)` - 切换状态，priority 控制优先级\n    98→  - `GetStateLoopCnt()` - 获取当前循环次数\n    99→\n   100→#### ActionController\n   101→- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Controller/ActionController.cs:12`\n   102→- **职责**: 角色动作控制器，连接 ActionMachine 和 Unity 组件\n   103→- **组件依赖**:\n   104→  - `AnimancerComponent animator` - 动画控制器\n   105→  - `Rigidbody _rigidbody` - 刚体组件\n   106→  - `Kcc _kcc` - 运动控制器\n   107→- **关键方法**:\n   108→  - `Initialized(ActionMachineInitializeData)` - 初始化\n   109→  - `LogicUpdate(float)` - 逻辑更新\n   110→  - `GetNodeTransform(CharacterNodeType)` - 获取角色节点 Transform\n   111→  - `UpdateRotation()` - 更新角色旋转（朝向移动方向）\n   112→\n   113→#### Kcc (Kinematic Character Controller)\n   114→- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs:18`\n   115→- **职责**: 高级角色运动控制器\n   116→- **关键特性**:\n   117→  - 支持重力、地面检测、斜坡滑动\n   118→  - 移动平台跟随\n   119→  - 逻辑帧与渲染帧分离\n   120→  - 零延迟响应（HorizontalAcceleration = 0）\n   121→- **更新模式**:\n   122→  - `UpdateMode.Auto` - Update 中自动执行\n   123→  - `UpdateMode.Manual` - 仅通过外部 LogicUpdate 调用\n   124→- **关键方法**:\n   125→  - `LogicUpdate(float)` - 外部逻辑更新入口\n   126→  - `SetMovement(Vector3)` - 设置移动向量（由输入系统调用）\n   127→  - `AddForce(Vector3)` - 添加外部力\n   128→  - `DetachFromGround()` - 从地面分离（跳跃）\n   129→- **关键属性**:\n   130→  - `Velocity` - 当前速度\n   131→  - `Grounded` - 是否在地面\n   132→  - `CurrentMovement` - 当前移动向量\n   133→\n   134→### Handler 系统\n   135→\n   136→#### AssetsHandler\n   137→- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Assets/AssetsHandler.cs:13`\n   138→- **职责**: 动作资源的顶层处理器\n   139→- **关键属性**:\n   140→  - `Length` - 动作总帧数\n   141→  - `EnableLoop` - 是否循环\n   142→  - `NextStateName` - 下一个状态名\n   143→  - `SerialID` - 动作唯一标识\n   144→- **关键方法**:\n   145→  - `Instantiate()` - 异步实例化所有子处理器\n   146→  - `LogicUpdate(float, int)` - 逻辑更新\n   147→  - `RenderUpdate(float)` - 渲染更新\n   148→  - `ManualExit()` - 手动退出（状态切换时调用）\n   149→\n   150→#### ClipHandlerBase<TData>\n   151→- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Clip/ClipHandler.cs:8`\n   152→- **职责**: Clip 处理器基类\n   153→- **生命周期**:\n   154→  1. `Initialize(ClipNode)` - 初始化\n   155→  2. `Instantiate(ClipNode)` - 实例化资源\n   156→  3. `Enter(ClipNode)` - 进入片段\n   157→  4. `LogicUpdate(ClipNode, float, int)` - 逻辑更新\n   158→  5. `RenderUpdate(ClipNode, float)` - 渲染更新\n   159→  6. `Exit(ClipNode)` - 退出片段\n   160→  7. `Dispose()` - 释放资源\n   161→\n   162→#### AttributeHandlerFactory\n   163→- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/HandlerFactory/AttributeHandlerFactory.cs:9`\n   164→- **职责**: 处理器工厂，通过特性自动注册\n   165→- **使用方式**:\n   166→  ```csharp\n   167→  [CustomHandler(typeof(PlayAnimation))]\n   168→  public class PlayAnimationClipHandler : ClipHandlerBase<PlayAnimation>\n   169→  {\n   170→      // 实现\n   171→  }\n   172→  ```\n   173→\n   174→### Directables 系统\n   175→\n   176→#### Clip (片段基类)\n   177→- **命名空间**: `NBC.ActionEditor`\n   178→- **常用子类**:\n   179→  - `PlayAnimation` - 动画播放\n   180→  - `PlayAudio` - 音频播放\n   181→  - `PlayParticle` - 特效播放\n   182→  - `MoveBy/MoveTo` - 移动\n   183→  - `RotateTo` - 旋转\n   184→  - `ScaleTo` - 缩放\n   185→  - `CreateHitBoxClip` - 创建碰撞盒\n   186→  - `TriggerEvent` - 触发事件\n   187→\n   188→#### PlayAnimation\n   189→- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Directables/Clips/Animation/PlayAnimation.cs:12`\n   190→- **职责**: 动画播放片段\n   191→- **关键属性**:\n   192→  - `resPath: string` - 动画资源路径\n   193→  - `playbackSpeed: float` - 播放速度\n   194→  - `clipOffset: float` - 偏移量\n   195→  - `ApplyRootMotion: bool` - 是否应用根运动\n   196→  - `blendIn/blendOut: float` - 淡入淡出时间\n   197→\n   198→#### Track (轨道基类)\n   199→- **常用子类**:\n   200→  - `AnimationTrack` - 动画轨道\n   201→  - `EffectTrack` - 特效轨道\n   202→  - `AudioTrack` - 音频轨道\n   203→  - `ActionTrack` - 动作轨道\n   204→  - `SignalTrack` - 信号轨道\n   205→\n   206→### 输入系统\n   207→\n   208→#### InputData\n   209→- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/InputData/InputData.cs:16`\n   210→- **职责**: 静态输入管理类\n   211→- **关键属性**:\n   212→  - `inputEvents: InputEvents` - 输入事件标志位\n   213→  - `axisValue: Vector2` - 轴向输入值\n   214→- **关键方法**:\n   215→  - `Update()` - 更新输入（在 GameManager.Update 中调用）\n   216→  - `Clear()` - 清除输入（在逻辑更新后调用）\n   217→  - `HasEvent(InputEvents, bool)` - 检查是否有指定事件\n   218→\n   219→---\n   220→\n   221→## 文件路径快速查找\n   222→\n   223→### 核心脚本路径\n   224→\n   225→```\n   226→Assets/_Game/Scripts/\n   227→├── Runtime/\n   228→│   ├── GameManager.cs                    # 游戏主管理器\n   229→│   └── SkillAssets.cs                    # 技能资源\n   230→├── LocalModels/\n   231→│   ├── LocalModelManager.cs              # 配置管理器\n   232→│   ├── Const.cs                          # 常量定义\n   233→│   └── ExternalTypeUtil.cs               # 类型工具\n   234→└── ActionMachine/\n   235→    ├── Runtime/\n   236→    │   ├── Controller/\n   237→    │   │   ├── ActionController.cs        # 动作控制器\n   238→    │   │   ├── CharacterNode.cs           # 角色节点\n   239→    │   │   ├── Kcc/Kcc.cs                 # 运动控制器\n   240→    │   │   └── Machine/\n   241→    │   │       ├── ActionMachine.cs       # 状态机\n   242→    │   │       └── IActionMachine.cs      # 状态机接口\n   243→    │   ├── Handlers/\n   244→    │   │   ├── Assets/AssetsHandler.cs    # 资源处理器\n   245→    │   │   ├── Clip/\n   246→    │   │   │   ├── ClipHandler.cs         # Clip处理器基类\n   247→    │   │   │   └── ClipHandlers/          # 各种Clip处理器实现\n   248→    │   │   ├── Groups/GroupHandler.cs     # 组处理器\n   249→    │   │   ├── Tracks/TrackHandler.cs     # 轨道处理器\n   250→    │   │   └── HandlerFactory/\n   251→    │   │       └── AttributeHandlerFactory.cs  # 工厂类\n   252→    │   ├── Directables/\n   253→    │   │   ├── Clips/                     # 所有Clip定义\n   254→    │   │   │   ├── Animation/             # 动画相关\n   255→    │   │   │   ├── Audio/                 # 音频相关\n   256→    │   │   │   ├── Effect/                # 特效相关\n   257→    │   │   │   ├── Transform/             # 变换相关\n   258→    │   │   │   ├── Instantiate/           # 实例化相关\n   259→    │   │   │   └── Event/                 # 事件相关\n   260→    │   │   └── Tracks/                    # 所有Track定义\n   261→    │   ├── ActionAssets/\n   262→    │   │   └── ActionAssetsBase.cs        # 动作资源基类\n   263→    │   ├── InputData/\n   264→    │   │   └── InputData.cs               # 输入管理\n   265→    │   ├── Helper/\n   266→    │   │   ├── ActionHandlerHelper.cs     # 处理器助手\n   267→    │   │   └── AssetsDeserializeHelper.cs # 反序列化助手\n   268→    │   ├── Tool/\n   269→    │   │   ├── FrameTool.cs               # 帧工具\n   270→    │   │   └── NodeFollower.cs            # 节点跟随器\n   271→    │   └── Attributes/\n   272→    │       ├── CustomHandlerAttribute.cs  # 处理器特性\n   273→    │       └── ReadOnlyAttribute.cs       # 只读特性\n   274→    └── Editor/\n   275→        ├── GUIS/\n   276→        │   └── ActionControllerWindow.cs  # 编辑器窗口\n   277→        ├── Contoller/\n   278→        │   └── ActionControllerEditor.cs  # Inspector扩展\n   279→        └── Preview/                       # 预览系统\n   280→```\n   281→\n   282→### 配置文件路径\n   283→\n   284→```\n   285→Assets/_Game/Assets/Settings/NBC/\n   286→├── character_10001_run.json              # 角色跑步动作配置\n   287→└── [其他角色动作配置]\n   288→```\n   289→\n   290→### 资源文件路径\n   291→\n   292→```\n   293→Assets/_Game/_Example/\n   294→├── Arts/                                  # 美术资源\n   295→│   └── BOSS/                              # BOSS模型\n   296→│       └── Bull/\n   297→│           ├── Animation/                 # 动画\n   298→│           ├── Materials/                 # 材质\n   299→│           └── Mesh/                      # 网格\n   300→└── ResRaw/                                # 原始资源\n   301→    ├── Effects/                           # 特效\n   302→    ├── Model/                             # 模型\n   303→    ├── Skill/                             # 技能\n   304→    └── Sound/                             # 音效\n   305→```\n   306→\n   307→---\n   308→\n   309→## 设计模式与约定\n   310→\n   311→### 1. 状态机模式\n   312→\n   313→ActionMachine 使用状态机模式管理角色动作：\n   314→\n   315→```csharp\n   316→// 状态切换\n   317→actionMachine.ChangeState(\"idle\", priority: 0);\n   318→actionMachine.ChangeState(\"attack\", priority: 10); // 高优先级可以打断\n   319→\n   320→// 状态配置\n   321→var stateConfig = new ActionConfig {\n   322→    EnableLoop = true,              // 是否循环\n   323→    NextActionId = \"idle\",          // 结束后切换的状态\n   324→    Json = actionJsonString,        // 动作配置JSON\n   325→    SerialID = \"character_run\"      // 唯一标识\n   326→};\n   327→```\n   328→\n   329→### 2. Handler 工厂模式\n   330→\n   331→使用特性自动注册处理器：\n   332→\n   333→```csharp\n   334→// 1. 定义Clip\n   335→[Name(\"我的动作\")]\n   336→[Attachable(typeof(MyTrack))]\n   337→public class MyClip : Clip {\n   338→    // 定义数据\n   339→}\n   340→\n   341→// 2. 实现Handler\n   342→[CustomHandler(typeof(MyClip))]\n   343→public class MyClipHandler : ClipHandlerBase<MyClip> {\n   344→    protected override void OnEnter(ClipNode clipNode) {\n   345→        // 进入时执行\n   346→    }\n   347→\n   348→    protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt) {\n   349→        // 每逻辑帧更新\n   350→    }\n   351→\n   352→    protected override void OnExit(ClipNode clipNode) {\n   353→        // 退出时执行\n   354→    }\n   355→}\n   356→```\n   357→\n   358→### 3. 对象池模式\n   359→\n   360→Handler 使用对象池复用：\n   361→\n   362→```csharp\n   363→// ActionHandlerHelper 提供池化功能\n   364→var handler = ActionHandlerHelper.GetAssetsHandler();\n   365→// 使用后回收\n   366→ActionHandlerHelper.RecycleAssetsHandler(handler);\n   367→```\n   368→\n   369→### 4. 组件模式\n   370→\n   371→ActionController 组合多个组件：\n   372→- ActionMachine - 动作逻辑\n   373→- AnimancerComponent - 动画播放\n   374→- Kcc - 运动控制\n   375→- Rigidbody - 物理模拟\n   376→\n   377→### 5. 数据驱动设计\n   378→\n   379→动作完全由 JSON 配置驱动：\n   380→\n   381→```json\n   382→{\n   383→  \"tracks\": [\n   384→    {\n   385→      \"type\": \"AnimationTrack\",\n   386→      \"clips\": [\n   387→        {\n   388→          \"type\": \"PlayAnimation\",\n   389→          \"startTime\": 0,\n   390→          \"length\": 1.5,\n   391→          \"resPath\": \"Assets/Animation/run.anim\"\n   392→        }\n   393→      ]\n   394→    }\n   395→  ]\n   396→}\n   397→```\n   398→\n   399→### 6. 逻辑与渲染分离\n   400→\n   401→- **LogicUpdate**: 固定或变帧率逻辑更新，处理游戏逻辑\n   402→- **RenderUpdate**: 渲染帧更新，处理视觉效果\n   403→\n   404→```csharp\n   405→// GameManager.Update()\n   406→RunLogicUpdate(Time.deltaTime);  // 逻辑更新\n   407→\n   408→// ActionController.Update()\n   409→_actionMachine.RenderUpdate(Time.deltaTime);  // 渲染更新\n   410→```\n   411→\n   412→---\n   413→\n   414→## 常用操作指南\n   415→\n   416→### 1. 添加新的角色\n   417→\n   418→```csharp\n   419→// 在 GameManager 中添加新的 ActionControllerWrapper\n   420→[SerializeField] protected List<ActionControllerWrapper> controllers;\n   421→\n   422→// 配置角色ID和Controller\n   423→var newController = new ActionControllerWrapper {\n   424→    CharacterID = 10002,  // 新角色ID\n   425→    Controller = GetComponent<ActionController>()\n   426→};\n   427→controllers.Add(newController);\n   428→```\n   429→\n   430→### 2. 创建新的 Clip 类型\n   431→\n   432→**步骤 1**: 创建 Clip 定义\n   433→\n   434→```csharp\n   435→// Assets/_Game/Scripts/ActionMachine/Runtime/Directables/Clips/MyClip.cs\n   436→[Name(\"我的片段\")]\n   437→[Description(\"执行某个特定操作\")]\n   438→[Color(1f, 0.5f, 0f)]\n   439→[Attachable(typeof(ActionTrack))]\n   440→public class MyClip : Clip {\n   441→    [MenuName(\"参数1\")] public float parameter1;\n   442→    [MenuName(\"参数2\")] public string parameter2;\n   443→\n   444→    public override bool IsValid => !string.IsNullOrEmpty(parameter2);\n   445→}\n   446→```\n   447→\n   448→**步骤 2**: 创建 Handler 实现\n   449→\n   450→```csharp\n   451→// Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Clip/ClipHandlers/MyClipHandler.cs\n   452→[CustomHandler(typeof(MyClip))]\n   453→public class MyClipHandler : ClipHandlerBase<MyClip> {\n   454→    protected override void OnEnter(ClipNode clipNode) {\n   455→        Debug.Log($\"开始执行: {BindData.parameter2}\");\n   456→    }\n   457→\n   458→    protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt) {\n   459→        // 每帧更新逻辑\n   460→        float progress = (float)updateCnt / clipNode.BindClip.Length;\n   461→    }\n   462→\n   463→    protected override void OnExit(ClipNode clipNode) {\n   464→        Debug.Log(\"执行完成\");\n   465→    }\n   466→}\n   467→```\n   468→\n   469→**步骤 3**: （可选）创建预览系统\n   470→\n   471→```csharp\n   472→// Assets/_Game/Scripts/ActionMachine/Editor/Preview/Clips/MyClipPreview.cs\n   473→public class MyClipPreview : IClipPreview {\n   474→    public void OnPreview(ClipNode clipNode, float time) {\n   475→        // 编辑器预览逻辑\n   476→    }\n   477→}\n   478→```\n   479→\n   480→### 3. 修改角色移动速度\n   481→\n   482→```csharp\n   483→// 在 ActionController 或其他地方\n   484→var kcc = GetComponent<Kcc>();\n   485→\n   486→// 方法1: 直接设置移动向量（推荐）\n   487→Vector3 movement = new Vector3(horizontal, 0, vertical) * moveSpeed;\n   488→kcc.SetMovement(movement);\n   489→\n   490→// 方法2: 添加外部力\n   491→kcc.AddForce(Vector3.forward * jumpForce);\n   492→\n   493→// 方法3: 施加冲击力\n   494→kcc.Impact(Vector3.up, impactForce);\n   495→```\n   496→\n   497→### 4. 切换角色动作状态\n   498→\n   499→```csharp\n   500→// 在 ActionController 中\n   501→_actionMachine.ChangeState(\"run\", priority: 5);\n   502→\n   503→// 优先级说明：\n   504→// - priority 越高，越能打断当前动作\n   505→// - priority 相同或更低，无法打断当前动作\n   506→```\n   507→\n   508→### 5. 处理输入\n   509→\n   510→```csharp\n   511→// 在 Update 中\n   512→InputData.Update();  // 更新输入\n   513→\n   514→// 检查输入\n   515→if (InputData.HasEvent(InputEvents.Attack)) {\n   516→    // 处理攻击\n   517→}\n   518→\n   519→if (InputData.HasEvent(InputEvents.Moving)) {\n   520→    Vector2 axis = InputData.axisValue;\n   521→    // 处理移动\n   522→}\n   523→\n   524→// 在逻辑更新后清除\n   525→InputData.Clear();\n   526→```\n   527→\n   528→### 6. 读取配置数据\n   529→\n   530→```csharp\n   531→// 在 GameManager 中\n   532→_localModelManager.LoadAll(null, () => {\n   533→    // 加载完成回调\n   534→    var characterData = _localModelManager.GetCharacterDataItem(characterId);\n   535→    var actionData = _localModelManager.GetActionDataItem(actionId);\n   536→});\n   537→```\n   538→\n   539→### 7. 调试状态机\n   540→\n   541→```csharp\n   542→// 在 ActionMachine.cs 中已有调试日志\n   543→#if UNITY_EDITOR\n   544→Debug.Log($\"ChangeState {_currentStateName}=>{_nextStateName}\");\n   545→Debug.Log($\"当前状态 {_currentStateName} 帧序号 {index}\");\n   546→#endif\n   547→\n   548→// 查看 Kcc 状态\n   549→Debug.Log($\"Grounded: {kcc.Grounded}\");\n   550→Debug.Log($\"Velocity: {kcc.Velocity}\");\n   551→Debug.Log($\"Speed: {kcc.Speed}\");\n   552→```\n   553→\n   554→---\n   555→\n   556→## API 参考\n   557→\n   558→### ActionMachine API\n   559→\n   560→```csharp\n   561→public interface IActionMachine {\n   562→    // 初始化\n   563→    Task Initialize(ActionMachineInitializeData initData, ControllerType controller);\n   564→\n   565→    // 更新\n   566→    void LogicUpdate(float deltaTime);\n   567→    void RenderUpdate(float deltaTime);\n   568→\n   569→    // 状态控制\n   570→    void ChangeState(string stateName, int priority = 0);\n   571→    int GetStateLoopCnt();\n   572→\n   573→    // 位置和旋转\n   574→    void GetWorldPosition(out Vector3 position, out Quaternion rotation);\n   575→\n   576→    // 访问器\n   577→    GameObject Actor { get; }\n   578→    ActionController Controller { get; }\n   579→}\n   580→```\n   581→\n   582→### ActionController API\n   583→\n   584→```csharp\n   585→public interface IActionController {\n   586→    // 初始化\n   587→    void Initialized(ActionMachineInitializeData data);\n   588→\n   589→    // 更新\n   590→    void LogicUpdate(float deltaTime);\n   591→\n   592→    // 节点访问\n   593→    Transform GetNodeTransform(CharacterNodeType type);\n   594→\n   595→    // 组件访问\n   596→    AnimancerComponent Animator { get; }\n   597→    Rigidbody GetRigidbody();\n   598→    Kcc Kcc { get; }\n   599→}\n   600→```\n   601→\n   602→### Kcc API\n   603→\n   604→```csharp\n   605→public class Kcc : MonoBehaviour {\n   606→    // 更新模式\n   607→    public UpdateMode UpdateModeType { get; set; }\n   608→\n   609→    // 移动控制\n   610→    public void LogicUpdate(float deltaTime);\n   611→    public void SetMovement(Vector3 movement);\n   612→    public void AddForce(Vector3 force);\n   613→    public void Impact(Vector3 direction, float force);\n   614→\n   615→    // 状态访问\n   616→    public Vector3 Velocity { get; }\n   617→    public Vector3 Speed { get; }\n   618→    public bool Grounded { get; }\n   619→    public bool JustGotGrounded { get; }\n   620→\n   621→    // 高级功能\n   622→    public void DetachFromGround();\n   623→    public void DetachFromMovingPlatform();\n   624→    public void SetGravityActive(bool status);\n   625→    public void ResizeColliderHeight(float newHeight, bool translateCenter);\n   626→    public bool CanGoBackToOriginalSize();\n   627→\n   628→    // 碰撞控制\n   629→    public void CollisionsOn();\n   630→    public void CollisionsOff();\n   631→    public void SetFreeMovement(bool state);\n   632→}\n   633→```\n   634→\n   635→### InputData API\n   636→\n   637→```csharp\n   638→public static class InputData {\n   639→    // 属性\n   640→    public static InputEvents inputEvents { get; set; }\n   641→    public static Vector2 axisValue { get; set; }\n   642→\n   643→    // 方法\n   644→    public static bool HasEvent(InputEvents e, bool fullMatch = false);\n   645→    public static void Clear();\n   646→    public static void Update();\n   647→}\n   648→\n   649→[Flags]\n   650→public enum InputEvents {\n   651→    None = 0b0000,\n   652→    Moving = 0b0001,\n   653→    Attack = 0b0010,\n   654→    Jump = 0b0100,\n   655→    Jumping = 0b1000,\n   656→}\n   657→```\n   658→\n   659→### LocalModelManager API\n   660→\n   661→```csharp\n   662→public partial class LocalModelManager {\n   663→    // 单例\n   664→    public static LocalModelManager Instance { get; }\n   665→\n   666→    // 加载\n   667→    public void SetTableLoader(ITableLoader loader);\n   668→    public Task Load(string fileName, Action callBack);\n   669→    public void LoadAll(Action<float> progressCallBack, Action callBack);\n   670→\n   671→    // 卸载\n   672→    public void UnLoad(string fileName);\n   673→    public void UnLoadAll();\n   674→\n   675→    // 访问数据（在生成的部分类中定义）\n   676→    // public CharacterDataItem GetCharacterDataItem(int id);\n   677→    // public ActionDataItem GetActionDataItem(string id);\n   678→}\n   679→```\n   680→\n   681→---\n   682→\n   683→## 帧率与更新系统说明\n   684→\n   685→### 更新模式对比\n   686→\n   687→| 特性 | 固定逻辑帧 (旧) | 变帧率 (当前) |\n   688→|------|-----------------|---------------|\n   689→| 逻辑更新 | 30/60 FPS 固定 | 与渲染帧同步 |\n   690→| 视觉流畅度 | 需要插值 | 直接流畅 |\n   691→| 物理模拟 | 稳定 | 依赖 deltaTime |\n   692→| 复杂度 | 高（需要插值） | 低（直接更新） |\n   693→\n   694→### 当前实现\n   695→\n   696→```csharp\n   697→// GameManager.Update() - 每渲染帧调用\n   698→private void Update() {\n   699→    InputData.Update();\n   700→    RunLogicUpdate(Time.deltaTime);  // 直接使用渲染帧 deltaTime\n   701→}\n   702→\n   703→// Kcc 支持两种模式\n   704→public enum UpdateMode {\n   705→    Auto,    // Update 中自动执行（独立使用）\n   706→    Manual   // 由外部 LogicUpdate 调用（集成到 GameManager）\n   707→}\n   708→```\n   709→\n   710→---\n   711→\n   712→## 命名约定\n   713→\n   714→### 文件命名\n   715→- **类文件**: PascalCase，如 `ActionController.cs`\n   716→- **接口文件**: IPascalCase，如 `IActionMachine.cs`\n   717→- **配置文件**: snake_case，如 `character_10001_run.json`\n   718→\n   719→### 代码命名\n   720→- **公共成员**: PascalCase\n   721→- **私有字段**: _camelCase（下划线前缀）\n   722→- **局部变量**: camelCase\n   723→- **常量**: PascalCase 或 UPPER_CASE\n   724→\n   725→### 目录命名\n   726→- **核心模块**: PascalCase，如 `ActionMachine/`\n   727→- **资源目录**: PascalCase，如 `ResRaw/`\n   728→- **示例目录**: _PascalCase（下划线前缀），如 `_Example/`\n   729→\n   730→---\n   731→\n   732→## 常见问题与解决方案\n   733→\n   734→### 1. 角色移动卡顿\n   735→\n   736→**原因**: 固定逻辑帧与渲染帧不同步\n   737→**解决**:\n   738→- 已切换为变帧率更新（直接使用 Time.deltaTime）\n   739→- Kcc 的 `HorizontalAcceleration` 和 `HorizontalDeceleration` 设为 0，实现零延迟响应\n   740→\n   741→### 2. 动作无法切换\n   742→\n   743→**原因**: 优先级不足\n   744→**解决**:\n   745→```csharp\n   746→// 使用更高的优先级\n   747→actionMachine.ChangeState(\"newState\", priority: 999);\n   748→```\n   749→\n   750→### 3. 配置文件加载失败\n   751→\n   752→**原因**: 路径错误或格式不正确\n   753→**解决**:\n   754→```csharp\n   755→// 检查路径是否正确\n   756→Debug.LogError($\"LoadActionConfig {path}\");\n   757→// 确保 JSON 文件放在 Resources/LocalModel/ 目录下\n   758→```\n   759→\n   760→### 4. Handler 未被调用\n   761→\n   762→**原因**: 未注册 CustomHandler 特性\n   763→**解决**:\n   764→```csharp\n   765→[CustomHandler(typeof(YourClip))]\n   766→public class YourClipHandler : ClipHandlerBase<YourClip> {\n   767→    // ...\n   768→}\n   769→```\n   770→\n   771→---\n   772→\n   773→## 快速搜索关键词\n   774→\n   775→### 查找特定功能\n   776→\n   777→| 功能 | 关键词 | 位置 |\n   778→|------|--------|------|\n   779→| 状态切换 | `ChangeState` | ActionMachine.cs:95 |\n   780→| 移动控制 | `SetMovement` | Kcc.cs:920 |\n   781→| 输入处理 | `InputData.Update` | InputData.cs:33 |\n   782→| 动画播放 | `PlayAnimation` | PlayAnimation.cs:12 |\n   783→| 碰撞检测 | `CreateHitBoxClip` | CreateHitBoxClip.cs |\n   784→| 配置加载 | `LoadAll` | LocalModelManager.cs:58 |\n   785→| Handler工厂 | `AttributeHandlerFactory` | AttributeHandlerFactory.cs:9 |\n   786→| 帧工具 | `FrameTool` | FrameTool.cs |\n   787→\n   788→### 查找设计模式实现\n   789→\n   790→| 模式 | 位置 |\n   791→|------|------|\n   792→| 状态机 | ActionMachine.cs |\n   793→| 工厂模式 | AttributeHandlerFactory.cs |\n   794→| 对象池 | ActionHandlerHelper.cs |\n   795→| 组件模式 | ActionController.cs |\n   796→| 观察者模式 | OnInstantiateHandlerComplete 事件 |\n   797→\n   798→---\n   799→\n   800→## 扩展资源\n   801→\n   802→### 依赖插件\n   803→\n   804→1. **Animancer** - 动画系统\n   805→   - 官网: https://kybernetik.com.au/animancer/\n   806→   - 用途: 动画混合和状态管理\n   807→\n   808→2. **Luban** - 配置表系统\n   809→   - 用途: 数据表加载和管理\n   810→\n   811→3. **Coplay** - Unity MCP 服务器\n   812→   - 用途: 开发工具集成\n   813→\n   814→### 相关文档\n   815→\n   816→- `README.md` - 项目概述和使用说明\n   817→- `error_json.json` - 错误日志（如果存在）\n   818→- `Assets/CoplayPlan.md` - Coplay 计划文档\n   819→\n   820→---\n   821→\n   822→## 版本信息\n   823→\n   824→- **Unity 版本**: 2020.3+\n   825→- **文档生成时间**: 2025-12-15\n   826→- **最后更新**: 提交 46208fe\n   827→\n   828→---\n   829→\n   830→**注意**: 本文档由 Claude Code 自动生成，基于项目当前状态。如有更新，请重新生成此文档。\n   831→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3e7b86f7-ba7a-4488-8f60-3c2ec7f8378e","timestamp":"2025-12-15T10:12:43.382Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\claude.md","content":"# MonsterHunter 项目 - Claude AI 参考文档\n\n> 本文档专为 AI 助手设计，用于快速理解项目结构、查找代码和执行常见任务。\n\n## 快速索引\n\n- [核心架构](#核心架构)\n- [重要类索引](#重要类索引)\n- [文件路径快速查找](#文件路径快速查找)\n- [设计模式与约定](#设计模式与约定)\n- [常用操作指南](#常用操作指南)\n- [API 参考](#api-参考)\n\n---\n\n## 核心架构\n\n### 系统层级结构\n\n```\nGameManager (单例)\n  └─> ActionController (每个角色一个)\n      ├─> ActionMachine (状态机核心)\n      │   ├─> AssetsHandler (动作资源处理器)\n      │   │   └─> GroupHandler (轨道组处理器)\n      │   │       └─> TrackHandler (轨道处理器)\n      │   │           └─> ClipHandler (片段处理器)\n      │   └─> GlobalAssetsHandlers (全局动作列表)\n      ├─> AnimancerComponent (动画系统)\n      └─> Kcc (运动控制器)\n```\n\n### 数据流\n\n```\nJSON配置文件\n  → LocalModelManager.Load()\n  → ActionMachineInitializeData\n  → ActionMachine.Initialize()\n  → AssetsHandler.Instantiate()\n  → ClipHandler.Enter/LogicUpdate/Exit\n```\n\n### 更新循环\n\n```\nGameManager.Update()\n  └─> RunLogicUpdate(deltaTime)\n      └─> ActionController.LogicUpdate(deltaTime)\n          ├─> ActionMachine.LogicUpdate(deltaTime)\n          │   ├─> UpdateState() - 状态切换\n          │   ├─> UpdateGlobalFrame() - 全局动作\n          │   └─> UpdateFrame() - 当前状态动作\n          └─> Kcc.LogicUpdate(deltaTime)\n\nActionController.Update()\n  └─> ActionMachine.RenderUpdate(deltaTime)\n      └─> AssetsHandler.RenderUpdate()\n```\n\n---\n\n## 重要类索引\n\n### 核心管理类\n\n#### GameManager\n- **路径**: `Assets/_Game/Scripts/Runtime/GameManager.cs:38`\n- **职责**: 游戏主管理器，单例模式\n- **关键方法**:\n  - `Start()` - 初始化 LocalModelManager 和加载配置\n  - `Update()` - 处理输入和逻辑更新\n  - `RunLogicUpdate(float)` - 执行所有角色的逻辑更新\n  - `InitializeCharacterActionData(int)` - 初始化角色动作数据\n\n#### LocalModelManager\n- **路径**: `Assets/_Game/Scripts/LocalModels/LocalModelManager.cs:22`\n- **职责**: 配置数据管理，使用 Luban 系统\n- **关键方法**:\n  - `SetTableLoader(ITableLoader)` - 设置加载器\n  - `LoadAll(Action<float>, Action)` - 加载所有配置\n  - `Load(string, Action)` - 加载指定配置文件\n\n### ActionMachine 系统\n\n#### ActionMachine\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Machine/ActionMachine.cs:12`\n- **职责**: 动作状态机核心逻辑\n- **关键属性**:\n  - `_stateAssets: Dictionary<string, StateActionConfig>` - 状态动作映射\n  - `_globalAssetsHandlers: List<IAssetsHandler>` - 全局动作列表\n  - `_currentUseHandler: IAssetsHandler` - 当前激活的动作处理器\n- **关键方法**:\n  - `Initialize(ActionMachineInitializeData, ControllerType)` - 初始化状态机\n  - `LogicUpdate(float)` - 逻辑更新（每逻辑帧调用）\n  - `RenderUpdate(float)` - 渲染更新（每渲染帧调用）\n  - `ChangeState(string, int)` - 切换状态，priority 控制优先级\n  - `GetStateLoopCnt()` - 获取当前循环次数\n\n#### ActionController\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Controller/ActionController.cs:12`\n- **职责**: 角色动作控制器，连接 ActionMachine 和 Unity 组件\n- **组件依赖**:\n  - `AnimancerComponent animator` - 动画控制器\n  - `Rigidbody _rigidbody` - 刚体组件\n  - `Kcc _kcc` - 运动控制器\n- **关键方法**:\n  - `Initialized(ActionMachineInitializeData)` - 初始化\n  - `LogicUpdate(float)` - 逻辑更新\n  - `GetNodeTransform(CharacterNodeType)` - 获取角色节点 Transform\n  - `UpdateRotation()` - 更新角色旋转（朝向移动方向）\n\n#### Kcc (Kinematic Character Controller)\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs:18`\n- **职责**: 高级角色运动控制器\n- **关键特性**:\n  - 支持重力、地面检测、斜坡滑动\n  - 移动平台跟随\n  - 逻辑帧与渲染帧分离\n  - 零延迟响应（HorizontalAcceleration = 0）\n- **更新模式**:\n  - `UpdateMode.Auto` - Update 中自动执行\n  - `UpdateMode.Manual` - 仅通过外部 LogicUpdate 调用\n- **关键方法**:\n  - `LogicUpdate(float)` - 外部逻辑更新入口\n  - `SetMovement(Vector3)` - 设置移动向量（由输入系统调用）\n  - `AddForce(Vector3)` - 添加外部力\n  - `DetachFromGround()` - 从地面分离（跳跃）\n- **关键属性**:\n  - `Velocity` - 当前速度\n  - `Grounded` - 是否在地面\n  - `CurrentMovement` - 当前移动向量\n\n### Handler 系统\n\n#### AssetsHandler\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Assets/AssetsHandler.cs:13`\n- **职责**: 动作资源的顶层处理器\n- **关键属性**:\n  - `Length` - 动作总帧数\n  - `EnableLoop` - 是否循环\n  - `NextStateName` - 下一个状态名\n  - `SerialID` - 动作唯一标识\n- **关键方法**:\n  - `Instantiate()` - 异步实例化所有子处理器\n  - `LogicUpdate(float, int)` - 逻辑更新\n  - `RenderUpdate(float)` - 渲染更新\n  - `ManualExit()` - 手动退出（状态切换时调用）\n\n#### ClipHandlerBase<TData>\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Clip/ClipHandler.cs:8`\n- **职责**: Clip 处理器基类\n- **生命周期**:\n  1. `Initialize(ClipNode)` - 初始化\n  2. `Instantiate(ClipNode)` - 实例化资源\n  3. `Enter(ClipNode)` - 进入片段\n  4. `LogicUpdate(ClipNode, float, int)` - 逻辑更新\n  5. `RenderUpdate(ClipNode, float)` - 渲染更新\n  6. `Exit(ClipNode)` - 退出片段\n  7. `Dispose()` - 释放资源\n\n#### AttributeHandlerFactory\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/HandlerFactory/AttributeHandlerFactory.cs:9`\n- **职责**: 处理器工厂，通过特性自动注册\n- **使用方式**:\n  ```csharp\n  [CustomHandler(typeof(PlayAnimation))]\n  public class PlayAnimationClipHandler : ClipHandlerBase<PlayAnimation>\n  {\n      // 实现\n  }\n  ```\n\n### Directables 系统\n\n#### Clip (片段基类)\n- **命名空间**: `NBC.ActionEditor`\n- **常用子类**:\n  - `PlayAnimation` - 动画播放\n  - `PlayAudio` - 音频播放\n  - `PlayParticle` - 特效播放\n  - `MoveBy/MoveTo` - 移动\n  - `RotateTo` - 旋转\n  - `ScaleTo` - 缩放\n  - `CreateHitBoxClip` - 创建碰撞盒\n  - `TriggerEvent` - 触发事件\n\n#### PlayAnimation\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Directables/Clips/Animation/PlayAnimation.cs:12`\n- **职责**: 动画播放片段\n- **关键属性**:\n  - `resPath: string` - 动画资源路径\n  - `playbackSpeed: float` - 播放速度\n  - `clipOffset: float` - 偏移量\n  - `ApplyRootMotion: bool` - 是否应用根运动\n  - `blendIn/blendOut: float` - 淡入淡出时间\n\n#### Track (轨道基类)\n- **常用子类**:\n  - `AnimationTrack` - 动画轨道\n  - `EffectTrack` - 特效轨道\n  - `AudioTrack` - 音频轨道\n  - `ActionTrack` - 动作轨道\n  - `SignalTrack` - 信号轨道\n\n### 输入系统\n\n#### InputData\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/InputData/InputData.cs:16`\n- **职责**: 静态输入管理类\n- **关键属性**:\n  - `inputEvents: InputEvents` - 输入事件标志位\n  - `axisValue: Vector2` - 轴向输入值\n- **关键方法**:\n  - `Update()` - 更新输入（在 GameManager.Update 中调用）\n  - `Clear()` - 清除输入（在逻辑更新后调用）\n  - `HasEvent(InputEvents, bool)` - 检查是否有指定事件\n\n---\n\n## 文件路径快速查找\n\n### 核心脚本路径\n\n```\nAssets/_Game/Scripts/\n├── Runtime/\n│   ├── GameManager.cs                    # 游戏主管理器\n│   └── SkillAssets.cs                    # 技能资源\n├── LocalModels/\n│   ├── LocalModelManager.cs              # 配置管理器\n│   ├── Const.cs                          # 常量定义\n│   └── ExternalTypeUtil.cs               # 类型工具\n└── ActionMachine/\n    ├── Runtime/\n    │   ├── Controller/\n    │   │   ├── ActionController.cs        # 动作控制器\n    │   │   ├── CharacterNode.cs           # 角色节点\n    │   │   ├── Kcc/Kcc.cs                 # 运动控制器\n    │   │   └── Machine/\n    │   │       ├── ActionMachine.cs       # 状态机\n    │   │       └── IActionMachine.cs      # 状态机接口\n    │   ├── Handlers/\n    │   │   ├── Assets/AssetsHandler.cs    # 资源处理器\n    │   │   ├── Clip/\n    │   │   │   ├── ClipHandler.cs         # Clip处理器基类\n    │   │   │   └── ClipHandlers/          # 各种Clip处理器实现\n    │   │   ├── Groups/GroupHandler.cs     # 组处理器\n    │   │   ├── Tracks/TrackHandler.cs     # 轨道处理器\n    │   │   └── HandlerFactory/\n    │   │       └── AttributeHandlerFactory.cs  # 工厂类\n    │   ├── Directables/\n    │   │   ├── Clips/                     # 所有Clip定义\n    │   │   │   ├── Animation/             # 动画相关\n    │   │   │   ├── Audio/                 # 音频相关\n    │   │   │   ├── Effect/                # 特效相关\n    │   │   │   ├── Transform/             # 变换相关\n    │   │   │   ├── Instantiate/           # 实例化相关\n    │   │   │   └── Event/                 # 事件相关\n    │   │   └── Tracks/                    # 所有Track定义\n    │   ├── ActionAssets/\n    │   │   └── ActionAssetsBase.cs        # 动作资源基类\n    │   ├── InputData/\n    │   │   └── InputData.cs               # 输入管理\n    │   ├── Helper/\n    │   │   ├── ActionHandlerHelper.cs     # 处理器助手\n    │   │   └── AssetsDeserializeHelper.cs # 反序列化助手\n    │   ├── Tool/\n    │   │   ├── FrameTool.cs               # 帧工具\n    │   │   └── NodeFollower.cs            # 节点跟随器\n    │   └── Attributes/\n    │       ├── CustomHandlerAttribute.cs  # 处理器特性\n    │       └── ReadOnlyAttribute.cs       # 只读特性\n    └── Editor/\n        ├── GUIS/\n        │   └── ActionControllerWindow.cs  # 编辑器窗口\n        ├── Contoller/\n        │   └── ActionControllerEditor.cs  # Inspector扩展\n        └── Preview/                       # 预览系统\n```\n\n### 配置文件路径\n\n```\nAssets/_Game/Assets/Settings/NBC/\n├── character_10001_run.json              # 角色跑步动作配置\n└── [其他角色动作配置]\n```\n\n### 资源文件路径\n\n```\nAssets/_Game/_Example/\n├── Arts/                                  # 美术资源\n│   └── BOSS/                              # BOSS模型\n│       └── Bull/\n│           ├── Animation/                 # 动画\n│           ├── Materials/                 # 材质\n│           └── Mesh/                      # 网格\n└── ResRaw/                                # 原始资源\n    ├── Effects/                           # 特效\n    ├── Model/                             # 模型\n    ├── Skill/                             # 技能\n    └── Sound/                             # 音效\n```\n\n---\n\n## 设计模式与约定\n\n### 1. 状态机模式\n\nActionMachine 使用状态机模式管理角色动作：\n\n```csharp\n// 状态切换\nactionMachine.ChangeState(\"idle\", priority: 0);\nactionMachine.ChangeState(\"attack\", priority: 10); // 高优先级可以打断\n\n// 状态配置\nvar stateConfig = new ActionConfig {\n    EnableLoop = true,              // 是否循环\n    NextActionId = \"idle\",          // 结束后切换的状态\n    Json = actionJsonString,        // 动作配置JSON\n    SerialID = \"character_run\"      // 唯一标识\n};\n```\n\n### 2. Handler 工厂模式\n\n使用特性自动注册处理器：\n\n```csharp\n// 1. 定义Clip\n[Name(\"我的动作\")]\n[Attachable(typeof(MyTrack))]\npublic class MyClip : Clip {\n    // 定义数据\n}\n\n// 2. 实现Handler\n[CustomHandler(typeof(MyClip))]\npublic class MyClipHandler : ClipHandlerBase<MyClip> {\n    protected override void OnEnter(ClipNode clipNode) {\n        // 进入时执行\n    }\n\n    protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt) {\n        // 每逻辑帧更新\n    }\n\n    protected override void OnExit(ClipNode clipNode) {\n        // 退出时执行\n    }\n}\n```\n\n### 3. 对象池模式\n\nHandler 使用对象池复用：\n\n```csharp\n// ActionHandlerHelper 提供池化功能\nvar handler = ActionHandlerHelper.GetAssetsHandler();\n// 使用后回收\nActionHandlerHelper.RecycleAssetsHandler(handler);\n```\n\n### 4. 组件模式\n\nActionController 组合多个组件：\n- ActionMachine - 动作逻辑\n- AnimancerComponent - 动画播放\n- Kcc - 运动控制\n- Rigidbody - 物理模拟\n\n### 5. 数据驱动设计\n\n动作完全由 JSON 配置驱动：\n\n```json\n{\n  \"tracks\": [\n    {\n      \"type\": \"AnimationTrack\",\n      \"clips\": [\n        {\n          \"type\": \"PlayAnimation\",\n          \"startTime\": 0,\n          \"length\": 1.5,\n          \"resPath\": \"Assets/Animation/run.anim\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### 6. 逻辑与渲染分离\n\n- **LogicUpdate**: 固定或变帧率逻辑更新，处理游戏逻辑\n- **RenderUpdate**: 渲染帧更新，处理视觉效果\n\n```csharp\n// GameManager.Update()\nRunLogicUpdate(Time.deltaTime);  // 逻辑更新\n\n// ActionController.Update()\n_actionMachine.RenderUpdate(Time.deltaTime);  // 渲染更新\n```\n\n---\n\n## 常用操作指南\n\n### 1. 添加新的角色\n\n```csharp\n// 在 GameManager 中添加新的 ActionControllerWrapper\n[SerializeField] protected List<ActionControllerWrapper> controllers;\n\n// 配置角色ID和Controller\nvar newController = new ActionControllerWrapper {\n    CharacterID = 10002,  // 新角色ID\n    Controller = GetComponent<ActionController>()\n};\ncontrollers.Add(newController);\n```\n\n### 2. 创建新的 Clip 类型\n\n**步骤 1**: 创建 Clip 定义\n\n```csharp\n// Assets/_Game/Scripts/ActionMachine/Runtime/Directables/Clips/MyClip.cs\n[Name(\"我的片段\")]\n[Description(\"执行某个特定操作\")]\n[Color(1f, 0.5f, 0f)]\n[Attachable(typeof(ActionTrack))]\npublic class MyClip : Clip {\n    [MenuName(\"参数1\")] public float parameter1;\n    [MenuName(\"参数2\")] public string parameter2;\n\n    public override bool IsValid => !string.IsNullOrEmpty(parameter2);\n}\n```\n\n**步骤 2**: 创建 Handler 实现\n\n```csharp\n// Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Clip/ClipHandlers/MyClipHandler.cs\n[CustomHandler(typeof(MyClip))]\npublic class MyClipHandler : ClipHandlerBase<MyClip> {\n    protected override void OnEnter(ClipNode clipNode) {\n        Debug.Log($\"开始执行: {BindData.parameter2}\");\n    }\n\n    protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt) {\n        // 每帧更新逻辑\n        float progress = (float)updateCnt / clipNode.BindClip.Length;\n    }\n\n    protected override void OnExit(ClipNode clipNode) {\n        Debug.Log(\"执行完成\");\n    }\n}\n```\n\n**步骤 3**: （可选）创建预览系统\n\n```csharp\n// Assets/_Game/Scripts/ActionMachine/Editor/Preview/Clips/MyClipPreview.cs\npublic class MyClipPreview : IClipPreview {\n    public void OnPreview(ClipNode clipNode, float time) {\n        // 编辑器预览逻辑\n    }\n}\n```\n\n### 3. 修改角色移动速度\n\n```csharp\n// 在 ActionController 或其他地方\nvar kcc = GetComponent<Kcc>();\n\n// 方法1: 直接设置移动向量（推荐）\nVector3 movement = new Vector3(horizontal, 0, vertical) * moveSpeed;\nkcc.SetMovement(movement);\n\n// 方法2: 添加外部力\nkcc.AddForce(Vector3.forward * jumpForce);\n\n// 方法3: 施加冲击力\nkcc.Impact(Vector3.up, impactForce);\n```\n\n### 4. 切换角色动作状态\n\n```csharp\n// 在 ActionController 中\n_actionMachine.ChangeState(\"run\", priority: 5);\n\n// 优先级说明：\n// - priority 越高，越能打断当前动作\n// - priority 相同或更低，无法打断当前动作\n```\n\n### 5. 处理输入\n\n```csharp\n// 在 Update 中\nInputData.Update();  // 更新输入\n\n// 检查输入\nif (InputData.HasEvent(InputEvents.Attack)) {\n    // 处理攻击\n}\n\nif (InputData.HasEvent(InputEvents.Moving)) {\n    Vector2 axis = InputData.axisValue;\n    // 处理移动\n}\n\n// 在逻辑更新后清除\nInputData.Clear();\n```\n\n### 6. 读取配置数据\n\n```csharp\n// 在 GameManager 中\n_localModelManager.LoadAll(null, () => {\n    // 加载完成回调\n    var characterData = _localModelManager.GetCharacterDataItem(characterId);\n    var actionData = _localModelManager.GetActionDataItem(actionId);\n});\n```\n\n### 7. 调试状态机\n\n```csharp\n// 在 ActionMachine.cs 中已有调试日志\n#if UNITY_EDITOR\nDebug.Log($\"ChangeState {_currentStateName}=>{_nextStateName}\");\nDebug.Log($\"当前状态 {_currentStateName} 帧序号 {index}\");\n#endif\n\n// 查看 Kcc 状态\nDebug.Log($\"Grounded: {kcc.Grounded}\");\nDebug.Log($\"Velocity: {kcc.Velocity}\");\nDebug.Log($\"Speed: {kcc.Speed}\");\n```\n\n---\n\n## API 参考\n\n### ActionMachine API\n\n```csharp\npublic interface IActionMachine {\n    // 初始化\n    Task Initialize(ActionMachineInitializeData initData, ControllerType controller);\n\n    // 更新\n    void LogicUpdate(float deltaTime);\n    void RenderUpdate(float deltaTime);\n\n    // 状态控制\n    void ChangeState(string stateName, int priority = 0);\n    int GetStateLoopCnt();\n\n    // 位置和旋转\n    void GetWorldPosition(out Vector3 position, out Quaternion rotation);\n\n    // 访问器\n    GameObject Actor { get; }\n    ActionController Controller { get; }\n}\n```\n\n### ActionController API\n\n```csharp\npublic interface IActionController {\n    // 初始化\n    void Initialized(ActionMachineInitializeData data);\n\n    // 更新\n    void LogicUpdate(float deltaTime);\n\n    // 节点访问\n    Transform GetNodeTransform(CharacterNodeType type);\n\n    // 组件访问\n    AnimancerComponent Animator { get; }\n    Rigidbody GetRigidbody();\n    Kcc Kcc { get; }\n}\n```\n\n### Kcc API\n\n```csharp\npublic class Kcc : MonoBehaviour {\n    // 更新模式\n    public UpdateMode UpdateModeType { get; set; }\n\n    // 移动控制\n    public void LogicUpdate(float deltaTime);\n    public void SetMovement(Vector3 movement);\n    public void AddForce(Vector3 force);\n    public void Impact(Vector3 direction, float force);\n\n    // 状态访问\n    public Vector3 Velocity { get; }\n    public Vector3 Speed { get; }\n    public bool Grounded { get; }\n    public bool JustGotGrounded { get; }\n\n    // 高级功能\n    public void DetachFromGround();\n    public void DetachFromMovingPlatform();\n    public void SetGravityActive(bool status);\n    public void ResizeColliderHeight(float newHeight, bool translateCenter);\n    public bool CanGoBackToOriginalSize();\n\n    // 碰撞控制\n    public void CollisionsOn();\n    public void CollisionsOff();\n    public void SetFreeMovement(bool state);\n}\n```\n\n### InputData API\n\n```csharp\npublic static class InputData {\n    // 属性\n    public static InputEvents inputEvents { get; set; }\n    public static Vector2 axisValue { get; set; }\n\n    // 方法\n    public static bool HasEvent(InputEvents e, bool fullMatch = false);\n    public static void Clear();\n    public static void Update();\n}\n\n[Flags]\npublic enum InputEvents {\n    None = 0b0000,\n    Moving = 0b0001,\n    Attack = 0b0010,\n    Jump = 0b0100,\n    Jumping = 0b1000,\n}\n```\n\n### LocalModelManager API\n\n```csharp\npublic partial class LocalModelManager {\n    // 单例\n    public static LocalModelManager Instance { get; }\n\n    // 加载\n    public void SetTableLoader(ITableLoader loader);\n    public Task Load(string fileName, Action callBack);\n    public void LoadAll(Action<float> progressCallBack, Action callBack);\n\n    // 卸载\n    public void UnLoad(string fileName);\n    public void UnLoadAll();\n\n    // 访问数据（在生成的部分类中定义）\n    // public CharacterDataItem GetCharacterDataItem(int id);\n    // public ActionDataItem GetActionDataItem(string id);\n}\n```\n\n---\n\n## 帧率与更新系统说明\n\n### 更新模式对比\n\n| 特性 | 固定逻辑帧 (旧) | 变帧率 (当前) |\n|------|-----------------|---------------|\n| 逻辑更新 | 30/60 FPS 固定 | 与渲染帧同步 |\n| 视觉流畅度 | 需要插值 | 直接流畅 |\n| 物理模拟 | 稳定 | 依赖 deltaTime |\n| 复杂度 | 高（需要插值） | 低（直接更新） |\n\n### 当前实现\n\n```csharp\n// GameManager.Update() - 每渲染帧调用\nprivate void Update() {\n    InputData.Update();\n    RunLogicUpdate(Time.deltaTime);  // 直接使用渲染帧 deltaTime\n}\n\n// Kcc 支持两种模式\npublic enum UpdateMode {\n    Auto,    // Update 中自动执行（独立使用）\n    Manual   // 由外部 LogicUpdate 调用（集成到 GameManager）\n}\n```\n\n---\n\n## 命名约定\n\n### 文件命名\n- **类文件**: PascalCase，如 `ActionController.cs`\n- **接口文件**: IPascalCase，如 `IActionMachine.cs`\n- **配置文件**: snake_case，如 `character_10001_run.json`\n\n### 代码命名\n- **公共成员**: PascalCase\n- **私有字段**: _camelCase（下划线前缀）\n- **局部变量**: camelCase\n- **常量**: PascalCase 或 UPPER_CASE\n\n### 目录命名\n- **核心模块**: PascalCase，如 `ActionMachine/`\n- **资源目录**: PascalCase，如 `ResRaw/`\n- **示例目录**: _PascalCase（下划线前缀），如 `_Example/`\n\n---\n\n## 常见问题与解决方案\n\n### 1. 角色移动卡顿\n\n**原因**: 固定逻辑帧与渲染帧不同步\n**解决**:\n- 已切换为变帧率更新（直接使用 Time.deltaTime）\n- Kcc 的 `HorizontalAcceleration` 和 `HorizontalDeceleration` 设为 0，实现零延迟响应\n\n### 2. 动作无法切换\n\n**原因**: 优先级不足\n**解决**:\n```csharp\n// 使用更高的优先级\nactionMachine.ChangeState(\"newState\", priority: 999);\n```\n\n### 3. 配置文件加载失败\n\n**原因**: 路径错误或格式不正确\n**解决**:\n```csharp\n// 检查路径是否正确\nDebug.LogError($\"LoadActionConfig {path}\");\n// 确保 JSON 文件放在 Resources/LocalModel/ 目录下\n```\n\n### 4. Handler 未被调用\n\n**原因**: 未注册 CustomHandler 特性\n**解决**:\n```csharp\n[CustomHandler(typeof(YourClip))]\npublic class YourClipHandler : ClipHandlerBase<YourClip> {\n    // ...\n}\n```\n\n---\n\n## 快速搜索关键词\n\n### 查找特定功能\n\n| 功能 | 关键词 | 位置 |\n|------|--------|------|\n| 状态切换 | `ChangeState` | ActionMachine.cs:95 |\n| 移动控制 | `SetMovement` | Kcc.cs:920 |\n| 输入处理 | `InputData.Update` | InputData.cs:33 |\n| 动画播放 | `PlayAnimation` | PlayAnimation.cs:12 |\n| 碰撞检测 | `CreateHitBoxClip` | CreateHitBoxClip.cs |\n| 配置加载 | `LoadAll` | LocalModelManager.cs:58 |\n| Handler工厂 | `AttributeHandlerFactory` | AttributeHandlerFactory.cs:9 |\n| 帧工具 | `FrameTool` | FrameTool.cs |\n\n### 查找设计模式实现\n\n| 模式 | 位置 |\n|------|------|\n| 状态机 | ActionMachine.cs |\n| 工厂模式 | AttributeHandlerFactory.cs |\n| 对象池 | ActionHandlerHelper.cs |\n| 组件模式 | ActionController.cs |\n| 观察者模式 | OnInstantiateHandlerComplete 事件 |\n\n---\n\n## 扩展资源\n\n### 依赖插件\n\n1. **Animancer** - 动画系统\n   - 官网: https://kybernetik.com.au/animancer/\n   - 用途: 动画混合和状态管理\n\n2. **Luban** - 配置表系统\n   - 用途: 数据表加载和管理\n\n3. **Coplay** - Unity MCP 服务器\n   - 用途: 开发工具集成\n\n### 相关文档\n\n- `README.md` - 项目概述和使用说明\n- `error_json.json` - 错误日志（如果存在）\n- `Assets/CoplayPlan.md` - Coplay 计划文档\n\n---\n\n## 版本信息\n\n- **Unity 版本**: 2020.3+\n- **文档生成时间**: 2025-12-15\n- **最后更新**: 提交 46208fe\n\n---\n\n**注意**: 本文档由 Claude Code 自动生成，基于项目当前状态。如有更新，请重新生成此文档。\n","numLines":831,"startLine":1,"totalLines":831}}}
{"parentUuid":"3e7b86f7-ba7a-4488-8f60-3c2ec7f8378e","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016dDt3ubQzjroTnEQxPDXNZ","type":"tool_result","content":"     1→# MonsterHunter Unity Project\n     2→\n     3→## 项目概述\n     4→\n     5→MonsterHunter 是一个基于 Unity 的动作游戏项目，采用自定义的 ActionMachine 系统来管理角色动作和技能。项目使用 Animancer 动画系统和自定义的运动控制器（KCC）来实现流畅的角色控制。\n     6→\n     7→## 项目结构\n     8→\n     9→```\n    10→MonsterHunter/\n    11→├── Assets/\n    12→│   ├── Scenes/\n    13→│   │   └── SampleScene.unity              # 主场景\n    14→│   └── _Game/                              # 游戏核心资源\n    15→│       ├── _Example/                       # 示例资源\n    16→│       │   ├── Arts/                       # 美术资源（BOSS模型、动画等）\n    17→│       │   ├── ResRaw/                     # 原始资源（特效、音效、模型）\n    18→│       │   ├── Scenes/                     # 示例场景\n    19→│       │   └── Scripts/                    # 示例脚本\n    20→│       ├── Assets/\n    21→│       │   └── Settings/                   # 配置文件\n    22→│       │       └── NBC/                    # 角色配置（JSON格式）\n    23→│       └── Scripts/                        # 核心脚本\n    24→│           ├── ActionMachine/              # 动作机器系统\n    25→│           ├── LocalModels/                # 本地数据模型\n    26→│           └── Runtime/                    # 运行时脚本\n    27→└── Packages/\n    28→    └── com.kybernetik.animancer/           # Animancer 动画插件\n    29→```\n    30→\n    31→## 核心系统\n    32→\n    33→### 1. ActionMachine 系统\n    34→\n    35→ActionMachine 是本项目的核心系统，负责管理角色的动作状态机和技能系统。\n    36→\n    37→#### 主要组件：\n    38→\n    39→- **ActionMachine** (`ActionMachine/Runtime/Controller/Machine/ActionMachine.cs`)\n    40→  - 状态机核心逻辑\n    41→  - 管理状态切换和帧更新\n    42→  - 支持逻辑帧和渲染帧分离更新\n    43→\n    44→- **ActionController** (`ActionMachine/Runtime/Controller/ActionController.cs`)\n    45→  - 角色动作控制器\n    46→  - 连接 ActionMachine 和 Unity 组件\n    47→  - 处理角色旋转和移动\n    48→\n    49→- **CharacterNode** (`ActionMachine/Runtime/Controller/CharacterNode.cs`)\n    50→  - 定义角色身体节点（如：武器挂点、特效挂点）\n    51→\n    52→#### 系统特性：\n    53→\n    54→- 基于时间轴的动作编辑系统\n    55→- 支持动作循环和状态转换\n    56→- 全局动作和状态动作分离管理\n    57→- 自定义 Clip 和 Track 系统\n    58→- 支持动画、特效、音频、碰撞等多种轨道类型\n    59→\n    60→### 2. Directables 系统（动作元素）\n    61→\n    62→位于 `ActionMachine/Runtime/Directables/`，定义了各种可编辑的动作元素：\n    63→\n    64→#### Clips（片段）：\n    65→- **Animation**: 动画播放（支持 Animancer）\n    66→- **Audio**: 音频播放\n    67→- **Effect**: 特效播放（粒子系统）\n    68→- **Transform**: 位置/旋转/缩放变换\n    69→- **Instantiate**: 对象实例化（包括碰撞盒创建）\n    70→- **Event**: 事件触发（日志、震动等）\n    71→- **GameObject**: 游戏对象控制（显示/隐藏）\n    72→- **Rigidbody**: 物理移动\n    73→- **Conditions**: 条件判断\n    74→\n    75→#### Tracks（轨道）：\n    76→- AnimationTrack: 动画轨道\n    77→- EffectTrack: 特效轨道\n    78→- AudioTrack: 音频轨道\n    79→- ActionTrack: 动作轨道\n    80→- SignalTrack: 信号轨道\n    81→- ConditionTrack: 条件轨道\n    82→\n    83→### 3. Handler 系统\n    84→\n    85→位于 `ActionMachine/Runtime/Handlers/`，负责执行 Directables 定义的内容：\n    86→\n    87→- **AssetsHandler**: 资源处理器基类\n    88→- **ClipHandler**: Clip 处理器\n    89→- **TrackHandler**: Track 处理器\n    90→- **GroupHandler**: 组处理器\n    91→- **HandlerFactory**: 处理器工厂（支持特性注册）\n    92→\n    93→### 4. KCC（Kinematic Character Controller）\n    94→\n    95→位于 `ActionMachine/Runtime/Controller/Kcc/Kcc.cs`，提供角色运动控制：\n    96→\n    97→- 自定义运动控制器\n    98→- 处理角色速度和移动\n    99→- 与 ActionMachine 集成\n   100→\n   101→### 5. LocalModelManager（本地数据管理）\n   102→\n   103→位于 `Scripts/LocalModels/`，负责游戏配置数据的加载和管理：\n   104→\n   105→- 使用 Luban 配置系统\n   106→- 支持异步加载\n   107→- 管理角色数据和动作数据\n   108→- 数据表系统（ActionData、CharacterData 等）\n   109→\n   110→### 6. GameManager\n   111→\n   112→位于 `Scripts/Runtime/GameManager.cs`，游戏主管理器：\n   113→\n   114→- 单例模式\n   115→- 管理所有 ActionController\n   116→- 处理逻辑更新（LogicUpdate）\n   117→- 加载和初始化角色数据\n   118→- 输入管理\n   119→\n   120→## 技术特点\n   121→\n   122→### 逻辑与渲染分离\n   123→\n   124→- **LogicUpdate**: 固定帧率逻辑更新（可配置为变帧率）\n   125→- **RenderUpdate**: 渲染帧更新\n   126→- 支持物理模拟和插值\n   127→\n   128→### 动画系统\n   129→\n   130→- 集成 Animancer 插件\n   131→- 支持动画融合和状态机\n   132→- 自定义 AnimancerClip 扩展\n   133→\n   134→### 编辑器扩展\n   135→\n   136→位于 `ActionMachine/Editor/`：\n   137→\n   138→- **ActionControllerWindow**: 动作编辑器窗口\n   139→- **ActionControllerEditor**: Inspector 面板扩展\n   140→- **Preview System**: 预览系统\n   141→  - 动画预览\n   142→  - 特效预览\n   143→  - 碰撞盒预览\n   144→  - Transform 变换预览\n   145→\n   146→### 配置系统\n   147→\n   148→- JSON 格式配置文件\n   149→- 位于 `Assets/_Game/Assets/Settings/NBC/`\n   150→- 包含角色动作配置（如 character_10001_run.json）\n   151→\n   152→## 主要工作流\n   153→\n   154→### 1. 角色初始化流程\n   155→\n   156→```\n   157→GameManager.Start()\n   158→  └─> LocalModelManager.LoadAll()\n   159→      └─> OnLoadTableCallback()\n   160→          └─> InitializeCharacterActionData()\n   161→              └─> ActionController.Initialized()\n   162→                  └─> ActionMachine.Initialize()\n   163→```\n   164→\n   165→### 2. 游戏循环\n   166→\n   167→```\n   168→GameManager.Update()\n   169→  ├─> InputData.Update()           # 更新输入\n   170→  └─> RunLogicUpdate()\n   171→      ├─> ActionController.LogicUpdate()\n   172→      │   ├─> ActionMachine.LogicUpdate()\n   173→      │   └─> Kcc.LogicUpdate()\n   174→      └─> InputData.Clear()\n   175→\n   176→ActionController.Update()\n   177→  ├─> ActionMachine.RenderUpdate()  # 渲染更新\n   178→  └─> UpdateRotation()              # 更新角色旋转\n   179→```\n   180→\n   181→### 3. 动作状态切换\n   182→\n   183→```\n   184→Trigger Action\n   185→  └─> ActionMachine.ChangeState()\n   186→      └─> UpdateState()\n   187→          ├─> Exit Current State\n   188→          ├─> Enter Next State\n   189→          └─> Fire Events (StateChanged, AnimChanged)\n   190→```\n   191→\n   192→## 依赖项\n   193→\n   194→- **Unity**: 2020.3 或更高版本\n   195→- **Animancer**: 商业动画插件\n   196→- **Luban**: 配置表系统\n   197→- **Coplay**: Unity MCP 服务器（开发工具）\n   198→\n   199→## 开发指南\n   200→\n   201→### 添加新的动作 Clip\n   202→\n   203→1. 在 `ActionMachine/Runtime/Directables/Clips/` 创建新的 Clip 类\n   204→2. 继承自对应的基类\n   205→3. 在 `ActionMachine/Runtime/Handlers/Clip/ClipHandlers/` 创建对应的 Handler\n   206→4. 使用 `[CustomHandler]` 特性注册\n   207→\n   208→### 添加新的角色动作\n   209→\n   210→1. 在配置表中定义动作数据\n   211→2. 创建动作 JSON 配置文件\n   212→3. 使用 ActionControllerWindow 编辑动作时间轴\n   213→4. 配置角色的动作列表\n   214→\n   215→### 编辑器预览\n   216→\n   217→1. 打开 ActionControllerWindow\n   218→2. 选择要编辑的 ActionController\n   219→3. 使用时间轴编辑器添加 Track 和 Clip\n   220→4. 使用预览功能实时查看效果\n   221→\n   222→## 性能优化\n   223→\n   224→- 使用对象池管理 Handler\n   225→- 支持变帧率更新（已禁用固定帧率逻辑）\n   226→- 资源异步加载\n   227→- Handler 复用机制\n   228→\n   229→## Git 状态\n   230→\n   231→当前分支: `master`\n   232→\n   233→最近修改:\n   234→- 场景文件更新\n   235→- 角色跑步动作配置调整\n   236→- KCC 运动控制器优化\n   237→- 游戏管理器更新\n   238→- Animancer Lite 相关文件移除\n   239→\n   240→## 作者与维护\n   241→\n   242→项目路径: `E:\\Project\\Demo\\MonsterHunter`\n   243→\n   244→## 许可证\n   245→\n   246→[待添加许可证信息]\n   247→\n   248→---\n   249→\n   250→**注意**: 本文档由 Claude Code 自动生成，基于项目当前状态。\n   251→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"caf30a56-ca93-4bec-8ddf-5f80904930fc","timestamp":"2025-12-15T10:12:43.382Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\README.md","content":"# MonsterHunter Unity Project\n\n## 项目概述\n\nMonsterHunter 是一个基于 Unity 的动作游戏项目，采用自定义的 ActionMachine 系统来管理角色动作和技能。项目使用 Animancer 动画系统和自定义的运动控制器（KCC）来实现流畅的角色控制。\n\n## 项目结构\n\n```\nMonsterHunter/\n├── Assets/\n│   ├── Scenes/\n│   │   └── SampleScene.unity              # 主场景\n│   └── _Game/                              # 游戏核心资源\n│       ├── _Example/                       # 示例资源\n│       │   ├── Arts/                       # 美术资源（BOSS模型、动画等）\n│       │   ├── ResRaw/                     # 原始资源（特效、音效、模型）\n│       │   ├── Scenes/                     # 示例场景\n│       │   └── Scripts/                    # 示例脚本\n│       ├── Assets/\n│       │   └── Settings/                   # 配置文件\n│       │       └── NBC/                    # 角色配置（JSON格式）\n│       └── Scripts/                        # 核心脚本\n│           ├── ActionMachine/              # 动作机器系统\n│           ├── LocalModels/                # 本地数据模型\n│           └── Runtime/                    # 运行时脚本\n└── Packages/\n    └── com.kybernetik.animancer/           # Animancer 动画插件\n```\n\n## 核心系统\n\n### 1. ActionMachine 系统\n\nActionMachine 是本项目的核心系统，负责管理角色的动作状态机和技能系统。\n\n#### 主要组件：\n\n- **ActionMachine** (`ActionMachine/Runtime/Controller/Machine/ActionMachine.cs`)\n  - 状态机核心逻辑\n  - 管理状态切换和帧更新\n  - 支持逻辑帧和渲染帧分离更新\n\n- **ActionController** (`ActionMachine/Runtime/Controller/ActionController.cs`)\n  - 角色动作控制器\n  - 连接 ActionMachine 和 Unity 组件\n  - 处理角色旋转和移动\n\n- **CharacterNode** (`ActionMachine/Runtime/Controller/CharacterNode.cs`)\n  - 定义角色身体节点（如：武器挂点、特效挂点）\n\n#### 系统特性：\n\n- 基于时间轴的动作编辑系统\n- 支持动作循环和状态转换\n- 全局动作和状态动作分离管理\n- 自定义 Clip 和 Track 系统\n- 支持动画、特效、音频、碰撞等多种轨道类型\n\n### 2. Directables 系统（动作元素）\n\n位于 `ActionMachine/Runtime/Directables/`，定义了各种可编辑的动作元素：\n\n#### Clips（片段）：\n- **Animation**: 动画播放（支持 Animancer）\n- **Audio**: 音频播放\n- **Effect**: 特效播放（粒子系统）\n- **Transform**: 位置/旋转/缩放变换\n- **Instantiate**: 对象实例化（包括碰撞盒创建）\n- **Event**: 事件触发（日志、震动等）\n- **GameObject**: 游戏对象控制（显示/隐藏）\n- **Rigidbody**: 物理移动\n- **Conditions**: 条件判断\n\n#### Tracks（轨道）：\n- AnimationTrack: 动画轨道\n- EffectTrack: 特效轨道\n- AudioTrack: 音频轨道\n- ActionTrack: 动作轨道\n- SignalTrack: 信号轨道\n- ConditionTrack: 条件轨道\n\n### 3. Handler 系统\n\n位于 `ActionMachine/Runtime/Handlers/`，负责执行 Directables 定义的内容：\n\n- **AssetsHandler**: 资源处理器基类\n- **ClipHandler**: Clip 处理器\n- **TrackHandler**: Track 处理器\n- **GroupHandler**: 组处理器\n- **HandlerFactory**: 处理器工厂（支持特性注册）\n\n### 4. KCC（Kinematic Character Controller）\n\n位于 `ActionMachine/Runtime/Controller/Kcc/Kcc.cs`，提供角色运动控制：\n\n- 自定义运动控制器\n- 处理角色速度和移动\n- 与 ActionMachine 集成\n\n### 5. LocalModelManager（本地数据管理）\n\n位于 `Scripts/LocalModels/`，负责游戏配置数据的加载和管理：\n\n- 使用 Luban 配置系统\n- 支持异步加载\n- 管理角色数据和动作数据\n- 数据表系统（ActionData、CharacterData 等）\n\n### 6. GameManager\n\n位于 `Scripts/Runtime/GameManager.cs`，游戏主管理器：\n\n- 单例模式\n- 管理所有 ActionController\n- 处理逻辑更新（LogicUpdate）\n- 加载和初始化角色数据\n- 输入管理\n\n## 技术特点\n\n### 逻辑与渲染分离\n\n- **LogicUpdate**: 固定帧率逻辑更新（可配置为变帧率）\n- **RenderUpdate**: 渲染帧更新\n- 支持物理模拟和插值\n\n### 动画系统\n\n- 集成 Animancer 插件\n- 支持动画融合和状态机\n- 自定义 AnimancerClip 扩展\n\n### 编辑器扩展\n\n位于 `ActionMachine/Editor/`：\n\n- **ActionControllerWindow**: 动作编辑器窗口\n- **ActionControllerEditor**: Inspector 面板扩展\n- **Preview System**: 预览系统\n  - 动画预览\n  - 特效预览\n  - 碰撞盒预览\n  - Transform 变换预览\n\n### 配置系统\n\n- JSON 格式配置文件\n- 位于 `Assets/_Game/Assets/Settings/NBC/`\n- 包含角色动作配置（如 character_10001_run.json）\n\n## 主要工作流\n\n### 1. 角色初始化流程\n\n```\nGameManager.Start()\n  └─> LocalModelManager.LoadAll()\n      └─> OnLoadTableCallback()\n          └─> InitializeCharacterActionData()\n              └─> ActionController.Initialized()\n                  └─> ActionMachine.Initialize()\n```\n\n### 2. 游戏循环\n\n```\nGameManager.Update()\n  ├─> InputData.Update()           # 更新输入\n  └─> RunLogicUpdate()\n      ├─> ActionController.LogicUpdate()\n      │   ├─> ActionMachine.LogicUpdate()\n      │   └─> Kcc.LogicUpdate()\n      └─> InputData.Clear()\n\nActionController.Update()\n  ├─> ActionMachine.RenderUpdate()  # 渲染更新\n  └─> UpdateRotation()              # 更新角色旋转\n```\n\n### 3. 动作状态切换\n\n```\nTrigger Action\n  └─> ActionMachine.ChangeState()\n      └─> UpdateState()\n          ├─> Exit Current State\n          ├─> Enter Next State\n          └─> Fire Events (StateChanged, AnimChanged)\n```\n\n## 依赖项\n\n- **Unity**: 2020.3 或更高版本\n- **Animancer**: 商业动画插件\n- **Luban**: 配置表系统\n- **Coplay**: Unity MCP 服务器（开发工具）\n\n## 开发指南\n\n### 添加新的动作 Clip\n\n1. 在 `ActionMachine/Runtime/Directables/Clips/` 创建新的 Clip 类\n2. 继承自对应的基类\n3. 在 `ActionMachine/Runtime/Handlers/Clip/ClipHandlers/` 创建对应的 Handler\n4. 使用 `[CustomHandler]` 特性注册\n\n### 添加新的角色动作\n\n1. 在配置表中定义动作数据\n2. 创建动作 JSON 配置文件\n3. 使用 ActionControllerWindow 编辑动作时间轴\n4. 配置角色的动作列表\n\n### 编辑器预览\n\n1. 打开 ActionControllerWindow\n2. 选择要编辑的 ActionController\n3. 使用时间轴编辑器添加 Track 和 Clip\n4. 使用预览功能实时查看效果\n\n## 性能优化\n\n- 使用对象池管理 Handler\n- 支持变帧率更新（已禁用固定帧率逻辑）\n- 资源异步加载\n- Handler 复用机制\n\n## Git 状态\n\n当前分支: `master`\n\n最近修改:\n- 场景文件更新\n- 角色跑步动作配置调整\n- KCC 运动控制器优化\n- 游戏管理器更新\n- Animancer Lite 相关文件移除\n\n## 作者与维护\n\n项目路径: `E:\\Project\\Demo\\MonsterHunter`\n\n## 许可证\n\n[待添加许可证信息]\n\n---\n\n**注意**: 本文档由 Claude Code 自动生成，基于项目当前状态。\n","numLines":251,"startLine":1,"totalLines":251}}}
{"parentUuid":"caf30a56-ca93-4bec-8ddf-5f80904930fc","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y5drYfNR5iL42u5WGUukDH","type":"tool_result","content":"No files found"}]},"uuid":"ab8a200a-c5b6-47b1-878c-61074a4f7d15","timestamp":"2025-12-15T10:12:43.792Z","toolUseResult":{"filenames":[],"durationMs":427,"numFiles":0,"truncated":false}}
{"parentUuid":"ab8a200a-c5b6-47b1-878c-61074a4f7d15","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019si4VdhZV51VtkSrDhbw6e","type":"tool_result","content":"No files found"}]},"uuid":"095eacb7-c1a0-4db5-87c9-43e691deedf6","timestamp":"2025-12-15T10:12:43.798Z","toolUseResult":{"filenames":[],"durationMs":433,"numFiles":0,"truncated":false}}
{"parentUuid":"095eacb7-c1a0-4db5-87c9-43e691deedf6","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YSNoxSr8K9iu9w8R9zxXUc","type":"tool_result","content":"No files found"}]},"uuid":"d04774d9-77e5-4181-8441-6c3b9fa349eb","timestamp":"2025-12-15T10:12:43.809Z","toolUseResult":{"filenames":[],"durationMs":444,"numFiles":0,"truncated":false}}
{"parentUuid":"d04774d9-77e5-4181-8441-6c3b9fa349eb","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017CPDQyis81hacXaxj8vxNX","type":"message","role":"assistant","content":[{"type":"text","text":"I can see there's already a comprehensive `claude.md` file (in Chinese) that serves as a detailed reference document. The `/init` command is asking me to create a `CLAUDE.md` file (note the uppercase naming convention) that follows Claude Code's standard format. \n\nSince there's already extensive documentation in `claude.md`, I should create a new `CLAUDE.md` file that:\n1. Follows the standard Claude Code format\n2. Focuses on essential architecture and commands\n3. Avoids repeating information that's easily discoverable\n4. Incorporates key insights from the existing documentation\n5. Is written in a clear, concise manner\n\nLet me create the CLAUDE.md file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":15350,"cache_read_input_tokens":52590,"cache_creation":{"ephemeral_5m_input_tokens":15350,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"35265656-7b88-48b4-b990-0ca79ac94b14","timestamp":"2025-12-15T10:12:59.817Z"}
{"parentUuid":"35265656-7b88-48b4-b990-0ca79ac94b14","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017CPDQyis81hacXaxj8vxNX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MvSwAPY6Q4FVEcy7s65h68","name":"Write","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\CLAUDE.md","content":"# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Project Overview\n\nMonsterHunter is a Unity action game project featuring a custom ActionMachine system for managing character actions and skills. It uses Animancer for animation blending and a custom KCC (Kinematic Character Controller) for character movement.\n\n## Build and Development\n\n### Unity Version\n- Unity 2020.3 or higher\n\n### Opening the Project\n1. Open Unity Hub\n2. Add project from: `E:\\Project\\Demo\\MonsterHunter`\n3. Open the main scene: `Assets/Scenes/SampleScene.unity`\n\n### Testing\n- Use Unity's Play mode to test character actions\n- Main test scene contains character with ActionController component\n\n## Core Architecture\n\n### System Hierarchy\n\nThe project follows a hierarchical architecture:\n\n```\nGameManager (singleton)\n  └─> ActionController (per character)\n      ├─> ActionMachine (state machine core)\n      │   ├─> AssetsHandler (action resource processor)\n      │   │   └─> GroupHandler → TrackHandler → ClipHandler\n      │   └─> GlobalAssetsHandlers (global action list)\n      ├─> AnimancerComponent (animation system)\n      └─> Kcc (movement controller)\n```\n\n### Key Design Patterns\n\n1. **State Machine Pattern**: ActionMachine manages character states with priority-based transitions\n2. **Handler Factory Pattern**: Uses attributes for automatic handler registration via `[CustomHandler(typeof(YourClip))]`\n3. **Object Pooling**: Handlers are pooled and reused via `ActionHandlerHelper`\n4. **Component Composition**: ActionController combines ActionMachine, Animancer, and Kcc\n5. **Data-Driven Design**: Actions are fully defined by JSON configuration files\n\n### Update Loop Architecture\n\nThe system separates logic and rendering updates:\n\n- **LogicUpdate**: Variable frame rate logic updates (processes game logic)\n- **RenderUpdate**: Render frame updates (handles visual effects)\n\n```csharp\n// In GameManager.Update()\nInputData.Update();\nRunLogicUpdate(Time.deltaTime);  // Logic update\n\n// In ActionController.Update()\n_actionMachine.RenderUpdate(Time.deltaTime);  // Render update\n```\n\n### Key Systems\n\n**ActionMachine** (`Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Machine/ActionMachine.cs:12`)\n- Core state machine managing character actions\n- Handles state transitions with priority system\n- Key method: `ChangeState(string stateName, int priority)` - higher priority can interrupt current actions\n\n**Kcc** (`Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs:18`)\n- Custom kinematic character controller\n- Two update modes: `Auto` (independent) and `Manual` (integrated with GameManager)\n- Zero-delay response (HorizontalAcceleration = 0 for instant movement)\n- Key methods:\n  - `SetMovement(Vector3)` - Set movement vector (recommended)\n  - `AddForce(Vector3)` - Add external forces\n  - `LogicUpdate(float)` - External logic update\n\n**LocalModelManager** (`Assets/_Game/Scripts/LocalModels/LocalModelManager.cs:22`)\n- Manages configuration data using Luban system\n- Loads JSON configs from `Assets/_Game/Assets/Settings/NBC/`\n- Async loading support\n\n## File Structure\n\n### Critical Paths\n\n```\nAssets/_Game/Scripts/\n├── Runtime/\n│   ├── GameManager.cs              # Main game manager (singleton)\n│   └── SkillAssets.cs              # Skill resources\n├── LocalModels/\n│   └── LocalModelManager.cs        # Config data manager\n└── ActionMachine/\n    ├── Runtime/\n    │   ├── Controller/\n    │   │   ├── ActionController.cs  # Character action controller\n    │   │   ├── Kcc/Kcc.cs          # Movement controller\n    │   │   └── Machine/\n    │   │       └── ActionMachine.cs # State machine core\n    │   ├── Handlers/               # Handler implementations\n    │   │   ├── Assets/AssetsHandler.cs\n    │   │   ├── Clip/ClipHandler.cs\n    │   │   └── HandlerFactory/AttributeHandlerFactory.cs\n    │   ├── Directables/            # Action element definitions\n    │   │   ├── Clips/              # Clip types (Animation, Audio, Effect, etc.)\n    │   │   └── Tracks/             # Track types\n    │   └── InputData/\n    │       └── InputData.cs        # Static input manager\n    └── Editor/\n        ├── GUIS/ActionControllerWindow.cs   # Action editor window\n        └── Preview/                # Preview system for editor\n```\n\n### Configuration Files\n\nAction configs are located in: `Assets/_Game/Assets/Settings/NBC/`\n- Format: JSON\n- Example: `character_10001_run.json`\n\n## Common Workflows\n\n### Adding a New Clip Type\n\n1. **Define the Clip** (in `Directables/Clips/`):\n```csharp\n[Name(\"My Clip\")]\n[Description(\"Does something specific\")]\n[Attachable(typeof(ActionTrack))]\npublic class MyClip : Clip {\n    [MenuName(\"Parameter\")] public float parameter;\n    public override bool IsValid => parameter > 0;\n}\n```\n\n2. **Implement the Handler** (in `Handlers/Clip/ClipHandlers/`):\n```csharp\n[CustomHandler(typeof(MyClip))]\npublic class MyClipHandler : ClipHandlerBase<MyClip> {\n    protected override void OnEnter(ClipNode clipNode) {\n        // Enter logic\n    }\n\n    protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt) {\n        // Per-frame update logic\n    }\n\n    protected override void OnExit(ClipNode clipNode) {\n        // Exit logic\n    }\n}\n```\n\n### Changing Character States\n\n```csharp\n// In ActionController or related code\n_actionMachine.ChangeState(\"run\", priority: 5);\n\n// Priority system:\n// - Higher priority can interrupt lower priority actions\n// - Same or lower priority cannot interrupt current action\n```\n\n### Handling Input\n\n```csharp\n// In Update loop\nInputData.Update();  // Update input state\n\n// Check for input events\nif (InputData.HasEvent(InputEvents.Attack)) {\n    // Handle attack\n}\n\nif (InputData.HasEvent(InputEvents.Moving)) {\n    Vector2 axis = InputData.axisValue;\n    // Handle movement\n}\n\n// Clear after logic update\nInputData.Clear();\n```\n\n### Modifying Character Movement\n\n```csharp\nvar kcc = GetComponent<Kcc>();\n\n// Direct movement (recommended)\nVector3 movement = new Vector3(horizontal, 0, vertical) * moveSpeed;\nkcc.SetMovement(movement);\n\n// Add external forces\nkcc.AddForce(Vector3.forward * jumpForce);\n\n// Apply impact\nkcc.Impact(Vector3.up, impactForce);\n```\n\n## Code Conventions\n\n### Naming\n\n- **Public members**: PascalCase\n- **Private fields**: _camelCase (underscore prefix)\n- **Local variables**: camelCase\n- **Interfaces**: IPascalCase\n- **Constants**: PascalCase or UPPER_CASE\n\n### File Naming\n\n- **Classes**: PascalCase (e.g., `ActionController.cs`)\n- **Interfaces**: IPascalCase (e.g., `IActionMachine.cs`)\n- **Configs**: snake_case (e.g., `character_10001_run.json`)\n\n## Dependencies\n\n- **Animancer** (commercial plugin) - Animation blending and state management\n- **Luban** - Configuration table system\n- **Coplay** - Unity MCP server for development tools\n\n## Important Notes\n\n### State Machine Priority System\n\nWhen calling `ChangeState(stateName, priority)`, the priority determines if the state change can interrupt:\n- Higher priority → Can interrupt current action\n- Same/lower priority → Cannot interrupt\n\n### Kcc Update Modes\n\n- **UpdateMode.Auto**: Kcc updates itself in Unity's Update (for standalone use)\n- **UpdateMode.Manual**: External control via LogicUpdate calls (integrated with GameManager)\n\nCurrent implementation uses Manual mode with GameManager controlling all updates.\n\n### Handler Lifecycle\n\nHandlers follow this lifecycle:\n1. `Initialize(ClipNode)` - Setup\n2. `Instantiate(ClipNode)` - Load resources\n3. `Enter(ClipNode)` - Enter clip\n4. `LogicUpdate(ClipNode, float, int)` - Per-frame logic\n5. `RenderUpdate(ClipNode, float)` - Per-frame rendering\n6. `Exit(ClipNode)` - Exit clip\n7. `Dispose()` - Cleanup\n\n### Debugging\n\nEnable debug logs in ActionMachine by keeping `#if UNITY_EDITOR` blocks:\n- State changes: `Debug.Log($\"ChangeState {_currentStateName}=>{_nextStateName}\")`\n- Frame updates: `Debug.Log($\"当前状态 {_currentStateName} 帧序号 {index}\")`\n\n## Reference Documentation\n\nFor detailed API references and troubleshooting, see `claude.md` (Chinese documentation with comprehensive API listings and examples).\n"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":15350,"cache_read_input_tokens":52590,"cache_creation":{"ephemeral_5m_input_tokens":15350,"ephemeral_1h_input_tokens":0},"output_tokens":2535,"service_tier":"standard"}},"type":"assistant","uuid":"575b3029-1fbc-4214-9132-0ecea9c33f55","timestamp":"2025-12-15T10:13:44.743Z"}
{"type":"file-history-snapshot","messageId":"575b3029-1fbc-4214-9132-0ecea9c33f55","snapshot":{"messageId":"21a29aad-1af9-47d3-86d4-eaa993a42dd7","trackedFileBackups":{"CLAUDE.md":{"backupFileName":"0b5c4e3350b32821@v1","version":1,"backupTime":"2025-12-15T10:47:54.941Z"}},"timestamp":"2025-12-15T09:55:57.038Z"},"isSnapshotUpdate":true}
{"parentUuid":"575b3029-1fbc-4214-9132-0ecea9c33f55","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MvSwAPY6Q4FVEcy7s65h68","type":"tool_result","content":"The file E:\\Project\\Demo\\MonsterHunter\\CLAUDE.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→# CLAUDE.md\n     2→\n     3→This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n     4→\n     5→## Project Overview\n     6→\n     7→MonsterHunter is a Unity action game project featuring a custom ActionMachine system for managing character actions and skills. It uses Animancer for animation blending and a custom KCC (Kinematic Character Controller) for character movement.\n     8→\n     9→## Build and Development\n    10→\n    11→### Unity Version\n    12→- Unity 2020.3 or higher\n    13→\n    14→### Opening the Project\n    15→1. Open Unity Hub\n    16→2. Add project from: `E:\\Project\\Demo\\MonsterHunter`\n    17→3. Open the main scene: `Assets/Scenes/SampleScene.unity`\n    18→\n    19→### Testing\n    20→- Use Unity's Play mode to test character actions\n    21→- Main test scene contains character with ActionController component\n    22→\n    23→## Core Architecture\n    24→\n    25→### System Hierarchy\n    26→\n    27→The project follows a hierarchical architecture:\n    28→\n    29→```\n    30→GameManager (singleton)\n    31→  └─> ActionController (per character)\n    32→      ├─> ActionMachine (state machine core)\n    33→      │   ├─> AssetsHandler (action resource processor)\n    34→      │   │   └─> GroupHandler → TrackHandler → ClipHandler\n    35→      │   └─> GlobalAssetsHandlers (global action list)\n    36→      ├─> AnimancerComponent (animation system)\n    37→      └─> Kcc (movement controller)\n    38→```\n    39→\n    40→### Key Design Patterns\n    41→\n    42→1. **State Machine Pattern**: ActionMachine manages character states with priority-based transitions\n    43→2. **Handler Factory Pattern**: Uses attributes for automatic handler registration via `[CustomHandler(typeof(YourClip))]`\n    44→3. **Object Pooling**: Handlers are pooled and reused via `ActionHandlerHelper`\n    45→4. **Component Composition**: ActionController combines ActionMachine, Animancer, and Kcc\n    46→5. **Data-Driven Design**: Actions are fully defined by JSON configuration files\n    47→\n    48→### Update Loop Architecture\n    49→\n    50→The system separates logic and rendering updates:\n    51→\n    52→- **LogicUpdate**: Variable frame rate logic updates (processes game logic)\n    53→- **RenderUpdate**: Render frame updates (handles visual effects)\n    54→\n    55→```csharp\n    56→// In GameManager.Update()\n    57→InputData.Update();\n    58→RunLogicUpdate(Time.deltaTime);  // Logic update\n    59→\n    60→// In ActionController.Update()\n    61→_actionMachine.RenderUpdate(Time.deltaTime);  // Render update\n    62→```\n    63→\n    64→### Key Systems\n    65→\n    66→**ActionMachine** (`Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Machine/ActionMachine.cs:12`)\n    67→- Core state machine managing character actions\n    68→- Handles state transitions with priority system\n    69→- Key method: `ChangeState(string stateName, int priority)` - higher priority can interrupt current actions\n    70→\n    71→**Kcc** (`Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs:18`)\n    72→- Custom kinematic character controller\n    73→- Two update modes: `Auto` (independent) and `Manual` (integrated with GameManager)\n    74→- Zero-delay response (HorizontalAcceleration = 0 for instant movement)\n    75→- Key methods:\n    76→  - `SetMovement(Vector3)` - Set movement vector (recommended)\n    77→  - `AddForce(Vector3)` - Add external forces\n    78→  - `LogicUpdate(float)` - External logic update\n    79→\n    80→**LocalModelManager** (`Assets/_Game/Scripts/LocalModels/LocalModelManager.cs:22`)\n    81→- Manages configuration data using Luban system\n    82→- Loads JSON configs from `Assets/_Game/Assets/Settings/NBC/`\n    83→- Async loading support\n    84→\n    85→## File Structure\n    86→\n    87→### Critical Paths\n    88→\n    89→```\n    90→Assets/_Game/Scripts/\n    91→├── Runtime/\n    92→│   ├── GameManager.cs              # Main game manager (singleton)\n    93→│   └── SkillAssets.cs              # Skill resources\n    94→├── LocalModels/\n    95→│   └── LocalModelManager.cs        # Config data manager\n    96→└── ActionMachine/\n    97→    ├── Runtime/\n    98→    │   ├── Controller/\n    99→    │   │   ├── ActionController.cs  # Character action controller\n   100→    │   │   ├── Kcc/Kcc.cs          # Movement controller\n   101→    │   │   └── Machine/\n   102→    │   │       └── ActionMachine.cs # State machine core\n   103→    │   ├── Handlers/               # Handler implementations\n   104→    │   │   ├── Assets/AssetsHandler.cs\n   105→    │   │   ├── Clip/ClipHandler.cs\n   106→    │   │   └── HandlerFactory/AttributeHandlerFactory.cs\n   107→    │   ├── Directables/            # Action element definitions\n   108→    │   │   ├── Clips/              # Clip types (Animation, Audio, Effect, etc.)\n   109→    │   │   └── Tracks/             # Track types\n   110→    │   └── InputData/\n   111→    │       └── InputData.cs        # Static input manager\n   112→    └── Editor/\n   113→        ├── GUIS/ActionControllerWindow.cs   # Action editor window\n   114→        └── Preview/                # Preview system for editor\n   115→```\n   116→\n   117→### Configuration Files\n   118→\n   119→Action configs are located in: `Assets/_Game/Assets/Settings/NBC/`\n   120→- Format: JSON\n   121→- Example: `character_10001_run.json`\n   122→\n   123→## Common Workflows\n   124→\n   125→### Adding a New Clip Type\n   126→\n   127→1. **Define the Clip** (in `Directables/Clips/`):\n   128→```csharp\n   129→[Name(\"My Clip\")]\n   130→[Description(\"Does something specific\")]\n   131→[Attachable(typeof(ActionTrack))]\n   132→public class MyClip : Clip {\n   133→    [MenuName(\"Parameter\")] public float parameter;\n   134→    public override bool IsValid => parameter > 0;\n   135→}\n   136→```\n   137→\n   138→2. **Implement the Handler** (in `Handlers/Clip/ClipHandlers/`):\n   139→```csharp\n   140→[CustomHandler(typeof(MyClip))]\n   141→public class MyClipHandler : ClipHandlerBase<MyClip> {\n   142→    protected override void OnEnter(ClipNode clipNode) {\n   143→        // Enter logic\n   144→    }\n   145→\n   146→    protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt) {\n   147→        // Per-frame update logic\n   148→    }\n   149→\n   150→    protected override void OnExit(ClipNode clipNode) {\n   151→        // Exit logic\n   152→    }\n   153→}\n   154→```\n   155→\n   156→### Changing Character States\n   157→\n   158→```csharp\n   159→// In ActionController or related code\n   160→_actionMachine.ChangeState(\"run\", priority: 5);\n   161→\n   162→// Priority system:\n   163→// - Higher priority can interrupt lower priority actions\n   164→// - Same or lower priority cannot interrupt current action\n   165→```\n   166→\n   167→### Handling Input\n   168→\n   169→```csharp\n   170→// In Update loop\n   171→InputData.Update();  // Update input state\n   172→\n   173→// Check for input events\n   174→if (InputData.HasEvent(InputEvents.Attack)) {\n   175→    // Handle attack\n   176→}\n   177→\n   178→if (InputData.HasEvent(InputEvents.Moving)) {\n   179→    Vector2 axis = InputData.axisValue;\n   180→    // Handle movement\n   181→}\n   182→\n   183→// Clear after logic update\n   184→InputData.Clear();\n   185→```\n   186→\n   187→### Modifying Character Movement\n   188→\n   189→```csharp\n   190→var kcc = GetComponent<Kcc>();\n   191→\n   192→// Direct movement (recommended)\n   193→Vector3 movement = new Vector3(horizontal, 0, vertical) * moveSpeed;\n   194→kcc.SetMovement(movement);\n   195→\n   196→// Add external forces\n   197→kcc.AddForce(Vector3.forward * jumpForce);\n   198→\n   199→// Apply impact\n   200→kcc.Impact(Vector3.up, impactForce);\n   201→```\n   202→\n   203→## Code Conventions\n   204→\n   205→### Naming\n   206→\n   207→- **Public members**: PascalCase\n   208→- **Private fields**: _camelCase (underscore prefix)\n   209→- **Local variables**: camelCase\n   210→- **Interfaces**: IPascalCase\n   211→- **Constants**: PascalCase or UPPER_CASE\n   212→\n   213→### File Naming\n   214→\n   215→- **Classes**: PascalCase (e.g., `ActionController.cs`)\n   216→- **Interfaces**: IPascalCase (e.g., `IActionMachine.cs`)\n   217→- **Configs**: snake_case (e.g., `character_10001_run.json`)\n   218→\n   219→## Dependencies\n   220→\n   221→- **Animancer** (commercial plugin) - Animation blending and state management\n   222→- **Luban** - Configuration table system\n   223→- **Coplay** - Unity MCP server for development tools\n   224→\n   225→## Important Notes\n   226→\n   227→### State Machine Priority System\n   228→\n   229→When calling `ChangeState(stateName, priority)`, the priority determines if the state change can interrupt:\n   230→- Higher priority → Can interrupt current action\n   231→- Same/lower priority → Cannot interrupt\n   232→\n   233→### Kcc Update Modes\n   234→\n   235→- **UpdateMode.Auto**: Kcc updates itself in Unity's Update (for standalone use)\n   236→- **UpdateMode.Manual**: External control via LogicUpdate calls (integrated with GameManager)\n   237→\n   238→Current implementation uses Manual mode with GameManager controlling all updates.\n   239→\n   240→### Handler Lifecycle\n   241→\n   242→Handlers follow this lifecycle:\n   243→1. `Initialize(ClipNode)` - Setup\n   244→2. `Instantiate(ClipNode)` - Load resources\n   245→3. `Enter(ClipNode)` - Enter clip\n   246→4. `LogicUpdate(ClipNode, float, int)` - Per-frame logic\n   247→5. `RenderUpdate(ClipNode, float)` - Per-frame rendering\n   248→6. `Exit(ClipNode)` - Exit clip\n   249→7. `Dispose()` - Cleanup\n   250→\n   251→### Debugging\n   252→\n   253→Enable debug logs in ActionMachine by keeping `#if UNITY_EDITOR` blocks:\n   254→- State changes: `Debug.Log($\"ChangeState {_currentStateName}=>{_nextStateName}\")`\n   255→- Frame updates: `Debug.Log($\"当前状态 {_currentStateName} 帧序号 {index}\")`\n   256→\n   257→## Reference Documentation\n   258→\n   259→For detailed API references and troubleshooting, see `claude.md` (Chinese documentation with comprehensive API listings and examples)."}]},"uuid":"ca34f7e4-b9b6-4200-90b4-ea9d799b3ff9","timestamp":"2025-12-15T10:47:54.958Z","toolUseResult":{"type":"update","filePath":"E:\\Project\\Demo\\MonsterHunter\\CLAUDE.md","content":"# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Project Overview\n\nMonsterHunter is a Unity action game project featuring a custom ActionMachine system for managing character actions and skills. It uses Animancer for animation blending and a custom KCC (Kinematic Character Controller) for character movement.\n\n## Build and Development\n\n### Unity Version\n- Unity 2020.3 or higher\n\n### Opening the Project\n1. Open Unity Hub\n2. Add project from: `E:\\Project\\Demo\\MonsterHunter`\n3. Open the main scene: `Assets/Scenes/SampleScene.unity`\n\n### Testing\n- Use Unity's Play mode to test character actions\n- Main test scene contains character with ActionController component\n\n## Core Architecture\n\n### System Hierarchy\n\nThe project follows a hierarchical architecture:\n\n```\nGameManager (singleton)\n  └─> ActionController (per character)\n      ├─> ActionMachine (state machine core)\n      │   ├─> AssetsHandler (action resource processor)\n      │   │   └─> GroupHandler → TrackHandler → ClipHandler\n      │   └─> GlobalAssetsHandlers (global action list)\n      ├─> AnimancerComponent (animation system)\n      └─> Kcc (movement controller)\n```\n\n### Key Design Patterns\n\n1. **State Machine Pattern**: ActionMachine manages character states with priority-based transitions\n2. **Handler Factory Pattern**: Uses attributes for automatic handler registration via `[CustomHandler(typeof(YourClip))]`\n3. **Object Pooling**: Handlers are pooled and reused via `ActionHandlerHelper`\n4. **Component Composition**: ActionController combines ActionMachine, Animancer, and Kcc\n5. **Data-Driven Design**: Actions are fully defined by JSON configuration files\n\n### Update Loop Architecture\n\nThe system separates logic and rendering updates:\n\n- **LogicUpdate**: Variable frame rate logic updates (processes game logic)\n- **RenderUpdate**: Render frame updates (handles visual effects)\n\n```csharp\n// In GameManager.Update()\nInputData.Update();\nRunLogicUpdate(Time.deltaTime);  // Logic update\n\n// In ActionController.Update()\n_actionMachine.RenderUpdate(Time.deltaTime);  // Render update\n```\n\n### Key Systems\n\n**ActionMachine** (`Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Machine/ActionMachine.cs:12`)\n- Core state machine managing character actions\n- Handles state transitions with priority system\n- Key method: `ChangeState(string stateName, int priority)` - higher priority can interrupt current actions\n\n**Kcc** (`Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs:18`)\n- Custom kinematic character controller\n- Two update modes: `Auto` (independent) and `Manual` (integrated with GameManager)\n- Zero-delay response (HorizontalAcceleration = 0 for instant movement)\n- Key methods:\n  - `SetMovement(Vector3)` - Set movement vector (recommended)\n  - `AddForce(Vector3)` - Add external forces\n  - `LogicUpdate(float)` - External logic update\n\n**LocalModelManager** (`Assets/_Game/Scripts/LocalModels/LocalModelManager.cs:22`)\n- Manages configuration data using Luban system\n- Loads JSON configs from `Assets/_Game/Assets/Settings/NBC/`\n- Async loading support\n\n## File Structure\n\n### Critical Paths\n\n```\nAssets/_Game/Scripts/\n├── Runtime/\n│   ├── GameManager.cs              # Main game manager (singleton)\n│   └── SkillAssets.cs              # Skill resources\n├── LocalModels/\n│   └── LocalModelManager.cs        # Config data manager\n└── ActionMachine/\n    ├── Runtime/\n    │   ├── Controller/\n    │   │   ├── ActionController.cs  # Character action controller\n    │   │   ├── Kcc/Kcc.cs          # Movement controller\n    │   │   └── Machine/\n    │   │       └── ActionMachine.cs # State machine core\n    │   ├── Handlers/               # Handler implementations\n    │   │   ├── Assets/AssetsHandler.cs\n    │   │   ├── Clip/ClipHandler.cs\n    │   │   └── HandlerFactory/AttributeHandlerFactory.cs\n    │   ├── Directables/            # Action element definitions\n    │   │   ├── Clips/              # Clip types (Animation, Audio, Effect, etc.)\n    │   │   └── Tracks/             # Track types\n    │   └── InputData/\n    │       └── InputData.cs        # Static input manager\n    └── Editor/\n        ├── GUIS/ActionControllerWindow.cs   # Action editor window\n        └── Preview/                # Preview system for editor\n```\n\n### Configuration Files\n\nAction configs are located in: `Assets/_Game/Assets/Settings/NBC/`\n- Format: JSON\n- Example: `character_10001_run.json`\n\n## Common Workflows\n\n### Adding a New Clip Type\n\n1. **Define the Clip** (in `Directables/Clips/`):\n```csharp\n[Name(\"My Clip\")]\n[Description(\"Does something specific\")]\n[Attachable(typeof(ActionTrack))]\npublic class MyClip : Clip {\n    [MenuName(\"Parameter\")] public float parameter;\n    public override bool IsValid => parameter > 0;\n}\n```\n\n2. **Implement the Handler** (in `Handlers/Clip/ClipHandlers/`):\n```csharp\n[CustomHandler(typeof(MyClip))]\npublic class MyClipHandler : ClipHandlerBase<MyClip> {\n    protected override void OnEnter(ClipNode clipNode) {\n        // Enter logic\n    }\n\n    protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt) {\n        // Per-frame update logic\n    }\n\n    protected override void OnExit(ClipNode clipNode) {\n        // Exit logic\n    }\n}\n```\n\n### Changing Character States\n\n```csharp\n// In ActionController or related code\n_actionMachine.ChangeState(\"run\", priority: 5);\n\n// Priority system:\n// - Higher priority can interrupt lower priority actions\n// - Same or lower priority cannot interrupt current action\n```\n\n### Handling Input\n\n```csharp\n// In Update loop\nInputData.Update();  // Update input state\n\n// Check for input events\nif (InputData.HasEvent(InputEvents.Attack)) {\n    // Handle attack\n}\n\nif (InputData.HasEvent(InputEvents.Moving)) {\n    Vector2 axis = InputData.axisValue;\n    // Handle movement\n}\n\n// Clear after logic update\nInputData.Clear();\n```\n\n### Modifying Character Movement\n\n```csharp\nvar kcc = GetComponent<Kcc>();\n\n// Direct movement (recommended)\nVector3 movement = new Vector3(horizontal, 0, vertical) * moveSpeed;\nkcc.SetMovement(movement);\n\n// Add external forces\nkcc.AddForce(Vector3.forward * jumpForce);\n\n// Apply impact\nkcc.Impact(Vector3.up, impactForce);\n```\n\n## Code Conventions\n\n### Naming\n\n- **Public members**: PascalCase\n- **Private fields**: _camelCase (underscore prefix)\n- **Local variables**: camelCase\n- **Interfaces**: IPascalCase\n- **Constants**: PascalCase or UPPER_CASE\n\n### File Naming\n\n- **Classes**: PascalCase (e.g., `ActionController.cs`)\n- **Interfaces**: IPascalCase (e.g., `IActionMachine.cs`)\n- **Configs**: snake_case (e.g., `character_10001_run.json`)\n\n## Dependencies\n\n- **Animancer** (commercial plugin) - Animation blending and state management\n- **Luban** - Configuration table system\n- **Coplay** - Unity MCP server for development tools\n\n## Important Notes\n\n### State Machine Priority System\n\nWhen calling `ChangeState(stateName, priority)`, the priority determines if the state change can interrupt:\n- Higher priority → Can interrupt current action\n- Same/lower priority → Cannot interrupt\n\n### Kcc Update Modes\n\n- **UpdateMode.Auto**: Kcc updates itself in Unity's Update (for standalone use)\n- **UpdateMode.Manual**: External control via LogicUpdate calls (integrated with GameManager)\n\nCurrent implementation uses Manual mode with GameManager controlling all updates.\n\n### Handler Lifecycle\n\nHandlers follow this lifecycle:\n1. `Initialize(ClipNode)` - Setup\n2. `Instantiate(ClipNode)` - Load resources\n3. `Enter(ClipNode)` - Enter clip\n4. `LogicUpdate(ClipNode, float, int)` - Per-frame logic\n5. `RenderUpdate(ClipNode, float)` - Per-frame rendering\n6. `Exit(ClipNode)` - Exit clip\n7. `Dispose()` - Cleanup\n\n### Debugging\n\nEnable debug logs in ActionMachine by keeping `#if UNITY_EDITOR` blocks:\n- State changes: `Debug.Log($\"ChangeState {_currentStateName}=>{_nextStateName}\")`\n- Frame updates: `Debug.Log($\"当前状态 {_currentStateName} 帧序号 {index}\")`\n\n## Reference Documentation\n\nFor detailed API references and troubleshooting, see `claude.md` (Chinese documentation with comprehensive API listings and examples).","structuredPatch":[{"oldStart":1,"oldLines":830,"newStart":1,"newLines":259,"lines":["-# MonsterHunter 项目 - Claude AI 参考文档","+# CLAUDE.md"," ","-> 本文档专为 AI 助手设计，用于快速理解项目结构、查找代码和执行常见任务。","+This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository."," ","-## 快速索引","+## Project Overview"," ","-- [核心架构](#核心架构)","-- [重要类索引](#重要类索引)","-- [文件路径快速查找](#文件路径快速查找)","-- [设计模式与约定](#设计模式与约定)","-- [常用操作指南](#常用操作指南)","-- [API 参考](#api-参考)","+MonsterHunter is a Unity action game project featuring a custom ActionMachine system for managing character actions and skills. It uses Animancer for animation blending and a custom KCC (Kinematic Character Controller) for character movement."," ","----","+## Build and Development"," ","-## 核心架构","+### Unity Version","+- Unity 2020.3 or higher"," ","-### 系统层级结构","+### Opening the Project","+1. Open Unity Hub","+2. Add project from: `E:\\Project\\Demo\\MonsterHunter`","+3. Open the main scene: `Assets/Scenes/SampleScene.unity`"," ","-```","-GameManager (单例)","-  └─> ActionController (每个角色一个)","-      ├─> ActionMachine (状态机核心)","-      │   ├─> AssetsHandler (动作资源处理器)","-      │   │   └─> GroupHandler (轨道组处理器)","-      │   │       └─> TrackHandler (轨道处理器)","-      │   │           └─> ClipHandler (片段处理器)","-      │   └─> GlobalAssetsHandlers (全局动作列表)","-      ├─> AnimancerComponent (动画系统)","-      └─> Kcc (运动控制器)","-```","+### Testing","+- Use Unity's Play mode to test character actions","+- Main test scene contains character with ActionController component"," ","-### 数据流","+## Core Architecture"," ","-```","-JSON配置文件","-  → LocalModelManager.Load()","-  → ActionMachineInitializeData","-  → ActionMachine.Initialize()","-  → AssetsHandler.Instantiate()","-  → ClipHandler.Enter/LogicUpdate/Exit","-```","+### System Hierarchy"," ","-### 更新循环","+The project follows a hierarchical architecture:"," "," ```","-GameManager.Update()","-  └─> RunLogicUpdate(deltaTime)","-      └─> ActionController.LogicUpdate(deltaTime)","-          ├─> ActionMachine.LogicUpdate(deltaTime)","-          │   ├─> UpdateState() - 状态切换","-          │   ├─> UpdateGlobalFrame() - 全局动作","-          │   └─> UpdateFrame() - 当前状态动作","-          └─> Kcc.LogicUpdate(deltaTime)","-","-ActionController.Update()","-  └─> ActionMachine.RenderUpdate(deltaTime)","-      └─> AssetsHandler.RenderUpdate()","+GameManager (singleton)","+  └─> ActionController (per character)","+      ├─> ActionMachine (state machine core)","+      │   ├─> AssetsHandler (action resource processor)","+      │   │   └─> GroupHandler → TrackHandler → ClipHandler","+      │   └─> GlobalAssetsHandlers (global action list)","+      ├─> AnimancerComponent (animation system)","+      └─> Kcc (movement controller)"," ```"," ","----","+### Key Design Patterns"," ","-## 重要类索引","+1. **State Machine Pattern**: ActionMachine manages character states with priority-based transitions","+2. **Handler Factory Pattern**: Uses attributes for automatic handler registration via `[CustomHandler(typeof(YourClip))]`","+3. **Object Pooling**: Handlers are pooled and reused via `ActionHandlerHelper`","+4. **Component Composition**: ActionController combines ActionMachine, Animancer, and Kcc","+5. **Data-Driven Design**: Actions are fully defined by JSON configuration files"," ","-### 核心管理类","+### Update Loop Architecture"," ","-#### GameManager","-- **路径**: `Assets/_Game/Scripts/Runtime/GameManager.cs:38`","-- **职责**: 游戏主管理器，单例模式","-- **关键方法**:","-  - `Start()` - 初始化 LocalModelManager 和加载配置","-  - `Update()` - 处理输入和逻辑更新","-  - `RunLogicUpdate(float)` - 执行所有角色的逻辑更新","-  - `InitializeCharacterActionData(int)` - 初始化角色动作数据","+The system separates logic and rendering updates:"," ","-#### LocalModelManager","-- **路径**: `Assets/_Game/Scripts/LocalModels/LocalModelManager.cs:22`","-- **职责**: 配置数据管理，使用 Luban 系统","-- **关键方法**:","-  - `SetTableLoader(ITableLoader)` - 设置加载器","-  - `LoadAll(Action<float>, Action)` - 加载所有配置","-  - `Load(string, Action)` - 加载指定配置文件","+- **LogicUpdate**: Variable frame rate logic updates (processes game logic)","+- **RenderUpdate**: Render frame updates (handles visual effects)"," ","-### ActionMachine 系统","+```csharp","+// In GameManager.Update()","+InputData.Update();","+RunLogicUpdate(Time.deltaTime);  // Logic update"," ","-#### ActionMachine","-- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Machine/ActionMachine.cs:12`","-- **职责**: 动作状态机核心逻辑","-- **关键属性**:","-  - `_stateAssets: Dictionary<string, StateActionConfig>` - 状态动作映射","-  - `_globalAssetsHandlers: List<IAssetsHandler>` - 全局动作列表","-  - `_currentUseHandler: IAssetsHandler` - 当前激活的动作处理器","-- **关键方法**:","-  - `Initialize(ActionMachineInitializeData, ControllerType)` - 初始化状态机","-  - `LogicUpdate(float)` - 逻辑更新（每逻辑帧调用）","-  - `RenderUpdate(float)` - 渲染更新（每渲染帧调用）","-  - `ChangeState(string, int)` - 切换状态，priority 控制优先级","-  - `GetStateLoopCnt()` - 获取当前循环次数","+// In ActionController.Update()","+_actionMachine.RenderUpdate(Time.deltaTime);  // Render update","+```"," ","-#### ActionController","-- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Controller/ActionController.cs:12`","-- **职责**: 角色动作控制器，连接 ActionMachine 和 Unity 组件","-- **组件依赖**:","-  - `AnimancerComponent animator` - 动画控制器","-  - `Rigidbody _rigidbody` - 刚体组件","-  - `Kcc _kcc` - 运动控制器","-- **关键方法**:","-  - `Initialized(ActionMachineInitializeData)` - 初始化","-  - `LogicUpdate(float)` - 逻辑更新","-  - `GetNodeTransform(CharacterNodeType)` - 获取角色节点 Transform","-  - `UpdateRotation()` - 更新角色旋转（朝向移动方向）","+### Key Systems"," ","-#### Kcc (Kinematic Character Controller)","-- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs:18`","-- **职责**: 高级角色运动控制器","-- **关键特性**:","-  - 支持重力、地面检测、斜坡滑动","-  - 移动平台跟随","-  - 逻辑帧与渲染帧分离","-  - 零延迟响应（HorizontalAcceleration = 0）","-- **更新模式**:","-  - `UpdateMode.Auto` - Update 中自动执行","-  - `UpdateMode.Manual` - 仅通过外部 LogicUpdate 调用","-- **关键方法**:","-  - `LogicUpdate(float)` - 外部逻辑更新入口","-  - `SetMovement(Vector3)` - 设置移动向量（由输入系统调用）","-  - `AddForce(Vector3)` - 添加外部力","-  - `DetachFromGround()` - 从地面分离（跳跃）","-- **关键属性**:","-  - `Velocity` - 当前速度","-  - `Grounded` - 是否在地面","-  - `CurrentMovement` - 当前移动向量","+**ActionMachine** (`Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Machine/ActionMachine.cs:12`)","+- Core state machine managing character actions","+- Handles state transitions with priority system","+- Key method: `ChangeState(string stateName, int priority)` - higher priority can interrupt current actions"," ","-### Handler 系统","+**Kcc** (`Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs:18`)","+- Custom kinematic character controller","+- Two update modes: `Auto` (independent) and `Manual` (integrated with GameManager)","+- Zero-delay response (HorizontalAcceleration = 0 for instant movement)","+- Key methods:","+  - `SetMovement(Vector3)` - Set movement vector (recommended)","+  - `AddForce(Vector3)` - Add external forces","+  - `LogicUpdate(float)` - External logic update"," ","-#### AssetsHandler","-- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Assets/AssetsHandler.cs:13`","-- **职责**: 动作资源的顶层处理器","-- **关键属性**:","-  - `Length` - 动作总帧数","-  - `EnableLoop` - 是否循环","-  - `NextStateName` - 下一个状态名","-  - `SerialID` - 动作唯一标识","-- **关键方法**:","-  - `Instantiate()` - 异步实例化所有子处理器","-  - `LogicUpdate(float, int)` - 逻辑更新","-  - `RenderUpdate(float)` - 渲染更新","-  - `ManualExit()` - 手动退出（状态切换时调用）","+**LocalModelManager** (`Assets/_Game/Scripts/LocalModels/LocalModelManager.cs:22`)","+- Manages configuration data using Luban system","+- Loads JSON configs from `Assets/_Game/Assets/Settings/NBC/`","+- Async loading support"," ","-#### ClipHandlerBase<TData>","-- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Clip/ClipHandler.cs:8`","-- **职责**: Clip 处理器基类","-- **生命周期**:","-  1. `Initialize(ClipNode)` - 初始化","-  2. `Instantiate(ClipNode)` - 实例化资源","-  3. `Enter(ClipNode)` - 进入片段","-  4. `LogicUpdate(ClipNode, float, int)` - 逻辑更新","-  5. `RenderUpdate(ClipNode, float)` - 渲染更新","-  6. `Exit(ClipNode)` - 退出片段","-  7. `Dispose()` - 释放资源","+## File Structure"," ","-#### AttributeHandlerFactory","-- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/HandlerFactory/AttributeHandlerFactory.cs:9`","-- **职责**: 处理器工厂，通过特性自动注册","-- **使用方式**:","-  ```csharp","-  [CustomHandler(typeof(PlayAnimation))]","-  public class PlayAnimationClipHandler : ClipHandlerBase<PlayAnimation>","-  {","-      // 实现","-  }","-  ```","+### Critical Paths"," ","-### Directables 系统","-","-#### Clip (片段基类)","-- **命名空间**: `NBC.ActionEditor`","-- **常用子类**:","-  - `PlayAnimation` - 动画播放","-  - `PlayAudio` - 音频播放","-  - `PlayParticle` - 特效播放","-  - `MoveBy/MoveTo` - 移动","-  - `RotateTo` - 旋转","-  - `ScaleTo` - 缩放","-  - `CreateHitBoxClip` - 创建碰撞盒","-  - `TriggerEvent` - 触发事件","-","-#### PlayAnimation","-- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Directables/Clips/Animation/PlayAnimation.cs:12`","-- **职责**: 动画播放片段","-- **关键属性**:","-  - `resPath: string` - 动画资源路径","-  - `playbackSpeed: float` - 播放速度","-  - `clipOffset: float` - 偏移量","-  - `ApplyRootMotion: bool` - 是否应用根运动","-  - `blendIn/blendOut: float` - 淡入淡出时间","-","-#### Track (轨道基类)","-- **常用子类**:","-  - `AnimationTrack` - 动画轨道","-  - `EffectTrack` - 特效轨道","-  - `AudioTrack` - 音频轨道","-  - `ActionTrack` - 动作轨道","-  - `SignalTrack` - 信号轨道","-","-### 输入系统","-","-#### InputData","-- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/InputData/InputData.cs:16`","-- **职责**: 静态输入管理类","-- **关键属性**:","-  - `inputEvents: InputEvents` - 输入事件标志位","-  - `axisValue: Vector2` - 轴向输入值","-- **关键方法**:","-  - `Update()` - 更新输入（在 GameManager.Update 中调用）","-  - `Clear()` - 清除输入（在逻辑更新后调用）","-  - `HasEvent(InputEvents, bool)` - 检查是否有指定事件","-","----","-","-## 文件路径快速查找","-","-### 核心脚本路径","-"," ```"," Assets/_Game/Scripts/"," ├── Runtime/","-│   ├── GameManager.cs                    # 游戏主管理器","-│   └── SkillAssets.cs                    # 技能资源","+│   ├── GameManager.cs              # Main game manager (singleton)","+│   └── SkillAssets.cs              # Skill resources"," ├── LocalModels/","-│   ├── LocalModelManager.cs              # 配置管理器","-│   ├── Const.cs                          # 常量定义","-│   └── ExternalTypeUtil.cs               # 类型工具","+│   └── LocalModelManager.cs        # Config data manager"," └── ActionMachine/","     ├── Runtime/","     │   ├── Controller/","-    │   │   ├── ActionController.cs        # 动作控制器","-    │   │   ├── CharacterNode.cs           # 角色节点","-    │   │   ├── Kcc/Kcc.cs                 # 运动控制器","+    │   │   ├── ActionController.cs  # Character action controller","+    │   │   ├── Kcc/Kcc.cs          # Movement controller","     │   │   └── Machine/","-    │   │       ├── ActionMachine.cs       # 状态机","-    │   │       └── IActionMachine.cs      # 状态机接口","-    │   ├── Handlers/","-    │   │   ├── Assets/AssetsHandler.cs    # 资源处理器","-    │   │   ├── Clip/","-    │   │   │   ├── ClipHandler.cs         # Clip处理器基类","-    │   │   │   └── ClipHandlers/          # 各种Clip处理器实现","-    │   │   ├── Groups/GroupHandler.cs     # 组处理器","-    │   │   ├── Tracks/TrackHandler.cs     # 轨道处理器","-    │   │   └── HandlerFactory/","-    │   │       └── AttributeHandlerFactory.cs  # 工厂类","-    │   ├── Directables/","-    │   │   ├── Clips/                     # 所有Clip定义","-    │   │   │   ├── Animation/             # 动画相关","-    │   │   │   ├── Audio/                 # 音频相关","-    │   │   │   ├── Effect/                # 特效相关","-    │   │   │   ├── Transform/             # 变换相关","-    │   │   │   ├── Instantiate/           # 实例化相关","-    │   │   │   └── Event/                 # 事件相关","-    │   │   └── Tracks/                    # 所有Track定义","-    │   ├── ActionAssets/","-    │   │   └── ActionAssetsBase.cs        # 动作资源基类","-    │   ├── InputData/","-    │   │   └── InputData.cs               # 输入管理","-    │   ├── Helper/","-    │   │   ├── ActionHandlerHelper.cs     # 处理器助手","-    │   │   └── AssetsDeserializeHelper.cs # 反序列化助手","-    │   ├── Tool/","-    │   │   ├── FrameTool.cs               # 帧工具","-    │   │   └── NodeFollower.cs            # 节点跟随器","-    │   └── Attributes/","-    │       ├── CustomHandlerAttribute.cs  # 处理器特性","-    │       └── ReadOnlyAttribute.cs       # 只读特性","+    │   │       └── ActionMachine.cs # State machine core","+    │   ├── Handlers/               # Handler implementations","+    │   │   ├── Assets/AssetsHandler.cs","+    │   │   ├── Clip/ClipHandler.cs","+    │   │   └── HandlerFactory/AttributeHandlerFactory.cs","+    │   ├── Directables/            # Action element definitions","+    │   │   ├── Clips/              # Clip types (Animation, Audio, Effect, etc.)","+    │   │   └── Tracks/             # Track types","+    │   └── InputData/","+    │       └── InputData.cs        # Static input manager","     └── Editor/","-        ├── GUIS/","-        │   └── ActionControllerWindow.cs  # 编辑器窗口","-        ├── Contoller/","-        │   └── ActionControllerEditor.cs  # Inspector扩展","-        └── Preview/                       # 预览系统","+        ├── GUIS/ActionControllerWindow.cs   # Action editor window","+        └── Preview/                # Preview system for editor"," ```"," ","-### 配置文件路径","+### Configuration Files"," ","-```","-Assets/_Game/Assets/Settings/NBC/","-├── character_10001_run.json              # 角色跑步动作配置","-└── [其他角色动作配置]","-```","+Action configs are located in: `Assets/_Game/Assets/Settings/NBC/`","+- Format: JSON","+- Example: `character_10001_run.json`"," ","-### 资源文件路径","+## Common Workflows"," ","-```","-Assets/_Game/_Example/","-├── Arts/                                  # 美术资源","-│   └── BOSS/                              # BOSS模型","-│       └── Bull/","-│           ├── Animation/                 # 动画","-│           ├── Materials/                 # 材质","-│           └── Mesh/                      # 网格","-└── ResRaw/                                # 原始资源","-    ├── Effects/                           # 特效","-    ├── Model/                             # 模型","-    ├── Skill/                             # 技能","-    └── Sound/                             # 音效","-```","+### Adding a New Clip Type"," ","----","-","-## 设计模式与约定","-","-### 1. 状态机模式","-","-ActionMachine 使用状态机模式管理角色动作：","-","+1. **Define the Clip** (in `Directables/Clips/`):"," ```csharp","-// 状态切换","-actionMachine.ChangeState(\"idle\", priority: 0);","-actionMachine.ChangeState(\"attack\", priority: 10); // 高优先级可以打断","-","-// 状态配置","-var stateConfig = new ActionConfig {","-    EnableLoop = true,              // 是否循环","-    NextActionId = \"idle\",          // 结束后切换的状态","-    Json = actionJsonString,        // 动作配置JSON","-    SerialID = \"character_run\"      // 唯一标识","-};","-```","-","-### 2. Handler 工厂模式","-","-使用特性自动注册处理器：","-","-```csharp","-// 1. 定义Clip","-[Name(\"我的动作\")]","-[Attachable(typeof(MyTrack))]","-public class MyClip : Clip {","-    // 定义数据","-}","-","-// 2. 实现Handler","-[CustomHandler(typeof(MyClip))]","-public class MyClipHandler : ClipHandlerBase<MyClip> {","-    protected override void OnEnter(ClipNode clipNode) {","-        // 进入时执行","-    }","-","-    protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt) {","-        // 每逻辑帧更新","-    }","-","-    protected override void OnExit(ClipNode clipNode) {","-        // 退出时执行","-    }","-}","-```","-","-### 3. 对象池模式","-","-Handler 使用对象池复用：","-","-```csharp","-// ActionHandlerHelper 提供池化功能","-var handler = ActionHandlerHelper.GetAssetsHandler();","-// 使用后回收","-ActionHandlerHelper.RecycleAssetsHandler(handler);","-```","-","-### 4. 组件模式","-","-ActionController 组合多个组件：","-- ActionMachine - 动作逻辑","-- AnimancerComponent - 动画播放","-- Kcc - 运动控制","-- Rigidbody - 物理模拟","-","-### 5. 数据驱动设计","-","-动作完全由 JSON 配置驱动：","-","-```json","-{","-  \"tracks\": [","-    {","-      \"type\": \"AnimationTrack\",","-      \"clips\": [","-        {","-          \"type\": \"PlayAnimation\",","-          \"startTime\": 0,","-          \"length\": 1.5,","-          \"resPath\": \"Assets/Animation/run.anim\"","-        }","-      ]","-    }","-  ]","-}","-```","-","-### 6. 逻辑与渲染分离","-","-- **LogicUpdate**: 固定或变帧率逻辑更新，处理游戏逻辑","-- **RenderUpdate**: 渲染帧更新，处理视觉效果","-","-```csharp","-// GameManager.Update()","-RunLogicUpdate(Time.deltaTime);  // 逻辑更新","-","-// ActionController.Update()","-_actionMachine.RenderUpdate(Time.deltaTime);  // 渲染更新","-```","-","----","-","-## 常用操作指南","-","-### 1. 添加新的角色","-","-```csharp","-// 在 GameManager 中添加新的 ActionControllerWrapper","-[SerializeField] protected List<ActionControllerWrapper> controllers;","-","-// 配置角色ID和Controller","-var newController = new ActionControllerWrapper {","-    CharacterID = 10002,  // 新角色ID","-    Controller = GetComponent<ActionController>()","-};","-controllers.Add(newController);","-```","-","-### 2. 创建新的 Clip 类型","-","-**步骤 1**: 创建 Clip 定义","-","-```csharp","-// Assets/_Game/Scripts/ActionMachine/Runtime/Directables/Clips/MyClip.cs","-[Name(\"我的片段\")]","-[Description(\"执行某个特定操作\")]","-[Color(1f, 0.5f, 0f)]","+[Name(\"My Clip\")]","+[Description(\"Does something specific\")]"," [Attachable(typeof(ActionTrack))]"," public class MyClip : Clip {","-    [MenuName(\"参数1\")] public float parameter1;","-    [MenuName(\"参数2\")] public string parameter2;","-","-    public override bool IsValid => !string.IsNullOrEmpty(parameter2);","+    [MenuName(\"Parameter\")] public float parameter;","+    public override bool IsValid => parameter > 0;"," }"," ```"," ","-**步骤 2**: 创建 Handler 实现","-","+2. **Implement the Handler** (in `Handlers/Clip/ClipHandlers/`):"," ```csharp","-// Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Clip/ClipHandlers/MyClipHandler.cs"," [CustomHandler(typeof(MyClip))]"," public class MyClipHandler : ClipHandlerBase<MyClip> {","     protected override void OnEnter(ClipNode clipNode) {","-        Debug.Log($\"开始执行: {BindData.parameter2}\");","+        // Enter logic","     }"," ","     protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt) {","-        // 每帧更新逻辑","-        float progress = (float)updateCnt / clipNode.BindClip.Length;","+        // Per-frame update logic","     }"," ","     protected override void OnExit(ClipNode clipNode) {","-        Debug.Log(\"执行完成\");","+        // Exit logic","     }"," }"," ```"," ","-**步骤 3**: （可选）创建预览系统","+### Changing Character States"," "," ```csharp","-// Assets/_Game/Scripts/ActionMachine/Editor/Preview/Clips/MyClipPreview.cs","-public class MyClipPreview : IClipPreview {","-    public void OnPreview(ClipNode clipNode, float time) {","-        // 编辑器预览逻辑","-    }","-}","-```","-","-### 3. 修改角色移动速度","-","-```csharp","-// 在 ActionController 或其他地方","-var kcc = GetComponent<Kcc>();","-","-// 方法1: 直接设置移动向量（推荐）","-Vector3 movement = new Vector3(horizontal, 0, vertical) * moveSpeed;","-kcc.SetMovement(movement);","-","-// 方法2: 添加外部力","-kcc.AddForce(Vector3.forward * jumpForce);","-","-// 方法3: 施加冲击力","-kcc.Impact(Vector3.up, impactForce);","-```","-","-### 4. 切换角色动作状态","-","-```csharp","-// 在 ActionController 中","+// In ActionController or related code"," _actionMachine.ChangeState(\"run\", priority: 5);"," ","-// 优先级说明：","-// - priority 越高，越能打断当前动作","-// - priority 相同或更低，无法打断当前动作","+// Priority system:","+// - Higher priority can interrupt lower priority actions","+// - Same or lower priority cannot interrupt current action"," ```"," ","-### 5. 处理输入","+### Handling Input"," "," ```csharp","-// 在 Update 中","-InputData.Update();  // 更新输入","+// In Update loop","+InputData.Update();  // Update input state"," ","-// 检查输入","+// Check for input events"," if (InputData.HasEvent(InputEvents.Attack)) {","-    // 处理攻击","+    // Handle attack"," }"," "," if (InputData.HasEvent(InputEvents.Moving)) {","     Vector2 axis = InputData.axisValue;","-    // 处理移动","+    // Handle movement"," }"," ","-// 在逻辑更新后清除","+// Clear after logic update"," InputData.Clear();"," ```"," ","-### 6. 读取配置数据","+### Modifying Character Movement"," "," ```csharp","-// 在 GameManager 中","-_localModelManager.LoadAll(null, () => {","-    // 加载完成回调","-    var characterData = _localModelManager.GetCharacterDataItem(characterId);","-    var actionData = _localModelManager.GetActionDataItem(actionId);","-});","-```","+var kcc = GetComponent<Kcc>();"," ","-### 7. 调试状态机","+// Direct movement (recommended)","+Vector3 movement = new Vector3(horizontal, 0, vertical) * moveSpeed;","+kcc.SetMovement(movement);"," ","-```csharp","-// 在 ActionMachine.cs 中已有调试日志","-#if UNITY_EDITOR","-Debug.Log($\"ChangeState {_currentStateName}=>{_nextStateName}\");","-Debug.Log($\"当前状态 {_currentStateName} 帧序号 {index}\");","-#endif","+// Add external forces","+kcc.AddForce(Vector3.forward * jumpForce);"," ","-// 查看 Kcc 状态","-Debug.Log($\"Grounded: {kcc.Grounded}\");","-Debug.Log($\"Velocity: {kcc.Velocity}\");","-Debug.Log($\"Speed: {kcc.Speed}\");","+// Apply impact","+kcc.Impact(Vector3.up, impactForce);"," ```"," ","----","+## Code Conventions"," ","-## API 参考","+### Naming"," ","-### ActionMachine API","+- **Public members**: PascalCase","+- **Private fields**: _camelCase (underscore prefix)","+- **Local variables**: camelCase","+- **Interfaces**: IPascalCase","+- **Constants**: PascalCase or UPPER_CASE"," ","-```csharp","-public interface IActionMachine {","-    // 初始化","-    Task Initialize(ActionMachineInitializeData initData, ControllerType controller);","+### File Naming"," ","-    // 更新","-    void LogicUpdate(float deltaTime);","-    void RenderUpdate(float deltaTime);","+- **Classes**: PascalCase (e.g., `ActionController.cs`)","+- **Interfaces**: IPascalCase (e.g., `IActionMachine.cs`)","+- **Configs**: snake_case (e.g., `character_10001_run.json`)"," ","-    // 状态控制","-    void ChangeState(string stateName, int priority = 0);","-    int GetStateLoopCnt();","+## Dependencies"," ","-    // 位置和旋转","-    void GetWorldPosition(out Vector3 position, out Quaternion rotation);","+- **Animancer** (commercial plugin) - Animation blending and state management","+- **Luban** - Configuration table system","+- **Coplay** - Unity MCP server for development tools"," ","-    // 访问器","-    GameObject Actor { get; }","-    ActionController Controller { get; }","-}","-```","+## Important Notes"," ","-### ActionController API","+### State Machine Priority System"," ","-```csharp","-public interface IActionController {","-    // 初始化","-    void Initialized(ActionMachineInitializeData data);","+When calling `ChangeState(stateName, priority)`, the priority determines if the state change can interrupt:","+- Higher priority → Can interrupt current action","+- Same/lower priority → Cannot interrupt"," ","-    // 更新","-    void LogicUpdate(float deltaTime);","+### Kcc Update Modes"," ","-    // 节点访问","-    Transform GetNodeTransform(CharacterNodeType type);","+- **UpdateMode.Auto**: Kcc updates itself in Unity's Update (for standalone use)","+- **UpdateMode.Manual**: External control via LogicUpdate calls (integrated with GameManager)"," ","-    // 组件访问","-    AnimancerComponent Animator { get; }","-    Rigidbody GetRigidbody();","-    Kcc Kcc { get; }","-}","-```","+Current implementation uses Manual mode with GameManager controlling all updates."," ","-### Kcc API","+### Handler Lifecycle"," ","-```csharp","-public class Kcc : MonoBehaviour {","-    // 更新模式","-    public UpdateMode UpdateModeType { get; set; }","+Handlers follow this lifecycle:","+1. `Initialize(ClipNode)` - Setup","+2. `Instantiate(ClipNode)` - Load resources","+3. `Enter(ClipNode)` - Enter clip","+4. `LogicUpdate(ClipNode, float, int)` - Per-frame logic","+5. `RenderUpdate(ClipNode, float)` - Per-frame rendering","+6. `Exit(ClipNode)` - Exit clip","+7. `Dispose()` - Cleanup"," ","-    // 移动控制","-    public void LogicUpdate(float deltaTime);","-    public void SetMovement(Vector3 movement);","-    public void AddForce(Vector3 force);","-    public void Impact(Vector3 direction, float force);","+### Debugging"," ","-    // 状态访问","-    public Vector3 Velocity { get; }","-    public Vector3 Speed { get; }","-    public bool Grounded { get; }","-    public bool JustGotGrounded { get; }","+Enable debug logs in ActionMachine by keeping `#if UNITY_EDITOR` blocks:","+- State changes: `Debug.Log($\"ChangeState {_currentStateName}=>{_nextStateName}\")`","+- Frame updates: `Debug.Log($\"当前状态 {_currentStateName} 帧序号 {index}\")`"," ","-    // 高级功能","-    public void DetachFromGround();","-    public void DetachFromMovingPlatform();","-    public void SetGravityActive(bool status);","-    public void ResizeColliderHeight(float newHeight, bool translateCenter);","-    public bool CanGoBackToOriginalSize();","+## Reference Documentation"," ","-    // 碰撞控制","-    public void CollisionsOn();","-    public void CollisionsOff();","-    public void SetFreeMovement(bool state);","-}","-```","-","-### InputData API","-","-```csharp","-public static class InputData {","-    // 属性","-    public static InputEvents inputEvents { get; set; }","-    public static Vector2 axisValue { get; set; }","-","-    // 方法","-    public static bool HasEvent(InputEvents e, bool fullMatch = false);","-    public static void Clear();","-    public static void Update();","-}","-","-[Flags]","-public enum InputEvents {","-    None = 0b0000,","-    Moving = 0b0001,","-    Attack = 0b0010,","-    Jump = 0b0100,","-    Jumping = 0b1000,","-}","-```","-","-### LocalModelManager API","-","-```csharp","-public partial class LocalModelManager {","-    // 单例","-    public static LocalModelManager Instance { get; }","-","-    // 加载","-    public void SetTableLoader(ITableLoader loader);","-    public Task Load(string fileName, Action callBack);","-    public void LoadAll(Action<float> progressCallBack, Action callBack);","-","-    // 卸载","-    public void UnLoad(string fileName);","-    public void UnLoadAll();","-","-    // 访问数据（在生成的部分类中定义）","-    // public CharacterDataItem GetCharacterDataItem(int id);","-    // public ActionDataItem GetActionDataItem(string id);","-}","-```","-","----","-","-## 帧率与更新系统说明","-","-### 更新模式对比","-","-| 特性 | 固定逻辑帧 (旧) | 变帧率 (当前) |","-|------|-----------------|---------------|","-| 逻辑更新 | 30/60 FPS 固定 | 与渲染帧同步 |","-| 视觉流畅度 | 需要插值 | 直接流畅 |","-| 物理模拟 | 稳定 | 依赖 deltaTime |","-| 复杂度 | 高（需要插值） | 低（直接更新） |","-","-### 当前实现","-","-```csharp","-// GameManager.Update() - 每渲染帧调用","-private void Update() {","-    InputData.Update();","-    RunLogicUpdate(Time.deltaTime);  // 直接使用渲染帧 deltaTime","-}","-","-// Kcc 支持两种模式","-public enum UpdateMode {","-    Auto,    // Update 中自动执行（独立使用）","-    Manual   // 由外部 LogicUpdate 调用（集成到 GameManager）","-}","-```","-","----","-","-## 命名约定","-","-### 文件命名","-- **类文件**: PascalCase，如 `ActionController.cs`","-- **接口文件**: IPascalCase，如 `IActionMachine.cs`","-- **配置文件**: snake_case，如 `character_10001_run.json`","-","-### 代码命名","-- **公共成员**: PascalCase","-- **私有字段**: _camelCase（下划线前缀）","-- **局部变量**: camelCase","-- **常量**: PascalCase 或 UPPER_CASE","-","-### 目录命名","-- **核心模块**: PascalCase，如 `ActionMachine/`","-- **资源目录**: PascalCase，如 `ResRaw/`","-- **示例目录**: _PascalCase（下划线前缀），如 `_Example/`","-","----","-","-## 常见问题与解决方案","-","-### 1. 角色移动卡顿","-","-**原因**: 固定逻辑帧与渲染帧不同步","-**解决**:","-- 已切换为变帧率更新（直接使用 Time.deltaTime）","-- Kcc 的 `HorizontalAcceleration` 和 `HorizontalDeceleration` 设为 0，实现零延迟响应","-","-### 2. 动作无法切换","-","-**原因**: 优先级不足","-**解决**:","-```csharp","-// 使用更高的优先级","-actionMachine.ChangeState(\"newState\", priority: 999);","-```","-","-### 3. 配置文件加载失败","-","-**原因**: 路径错误或格式不正确","-**解决**:","-```csharp","-// 检查路径是否正确","-Debug.LogError($\"LoadActionConfig {path}\");","-// 确保 JSON 文件放在 Resources/LocalModel/ 目录下","-```","-","-### 4. Handler 未被调用","-","-**原因**: 未注册 CustomHandler 特性","-**解决**:","-```csharp","-[CustomHandler(typeof(YourClip))]","-public class YourClipHandler : ClipHandlerBase<YourClip> {","-    // ...","-}","-```","-","----","-","-## 快速搜索关键词","-","-### 查找特定功能","-","-| 功能 | 关键词 | 位置 |","-|------|--------|------|","-| 状态切换 | `ChangeState` | ActionMachine.cs:95 |","-| 移动控制 | `SetMovement` | Kcc.cs:920 |","-| 输入处理 | `InputData.Update` | InputData.cs:33 |","-| 动画播放 | `PlayAnimation` | PlayAnimation.cs:12 |","-| 碰撞检测 | `CreateHitBoxClip` | CreateHitBoxClip.cs |","-| 配置加载 | `LoadAll` | LocalModelManager.cs:58 |","-| Handler工厂 | `AttributeHandlerFactory` | AttributeHandlerFactory.cs:9 |","-| 帧工具 | `FrameTool` | FrameTool.cs |","-","-### 查找设计模式实现","-","-| 模式 | 位置 |","-|------|------|","-| 状态机 | ActionMachine.cs |","-| 工厂模式 | AttributeHandlerFactory.cs |","-| 对象池 | ActionHandlerHelper.cs |","-| 组件模式 | ActionController.cs |","-| 观察者模式 | OnInstantiateHandlerComplete 事件 |","-","----","-","-## 扩展资源","-","-### 依赖插件","-","-1. **Animancer** - 动画系统","-   - 官网: https://kybernetik.com.au/animancer/","-   - 用途: 动画混合和状态管理","-","-2. **Luban** - 配置表系统","-   - 用途: 数据表加载和管理","-","-3. **Coplay** - Unity MCP 服务器","-   - 用途: 开发工具集成","-","-### 相关文档","-","-- `README.md` - 项目概述和使用说明","-- `error_json.json` - 错误日志（如果存在）","-- `Assets/CoplayPlan.md` - Coplay 计划文档","-","----","-","-## 版本信息","-","-- **Unity 版本**: 2020.3+","-- **文档生成时间**: 2025-12-15","-- **最后更新**: 提交 46208fe","-","----","-","-**注意**: 本文档由 Claude Code 自动生成，基于项目当前状态。如有更新，请重新生成此文档。","+For detailed API references and troubleshooting, see `claude.md` (Chinese documentation with comprehensive API listings and examples).","\\ No newline at end of file"]}],"originalFile":"# MonsterHunter 项目 - Claude AI 参考文档\n\n> 本文档专为 AI 助手设计，用于快速理解项目结构、查找代码和执行常见任务。\n\n## 快速索引\n\n- [核心架构](#核心架构)\n- [重要类索引](#重要类索引)\n- [文件路径快速查找](#文件路径快速查找)\n- [设计模式与约定](#设计模式与约定)\n- [常用操作指南](#常用操作指南)\n- [API 参考](#api-参考)\n\n---\n\n## 核心架构\n\n### 系统层级结构\n\n```\nGameManager (单例)\n  └─> ActionController (每个角色一个)\n      ├─> ActionMachine (状态机核心)\n      │   ├─> AssetsHandler (动作资源处理器)\n      │   │   └─> GroupHandler (轨道组处理器)\n      │   │       └─> TrackHandler (轨道处理器)\n      │   │           └─> ClipHandler (片段处理器)\n      │   └─> GlobalAssetsHandlers (全局动作列表)\n      ├─> AnimancerComponent (动画系统)\n      └─> Kcc (运动控制器)\n```\n\n### 数据流\n\n```\nJSON配置文件\n  → LocalModelManager.Load()\n  → ActionMachineInitializeData\n  → ActionMachine.Initialize()\n  → AssetsHandler.Instantiate()\n  → ClipHandler.Enter/LogicUpdate/Exit\n```\n\n### 更新循环\n\n```\nGameManager.Update()\n  └─> RunLogicUpdate(deltaTime)\n      └─> ActionController.LogicUpdate(deltaTime)\n          ├─> ActionMachine.LogicUpdate(deltaTime)\n          │   ├─> UpdateState() - 状态切换\n          │   ├─> UpdateGlobalFrame() - 全局动作\n          │   └─> UpdateFrame() - 当前状态动作\n          └─> Kcc.LogicUpdate(deltaTime)\n\nActionController.Update()\n  └─> ActionMachine.RenderUpdate(deltaTime)\n      └─> AssetsHandler.RenderUpdate()\n```\n\n---\n\n## 重要类索引\n\n### 核心管理类\n\n#### GameManager\n- **路径**: `Assets/_Game/Scripts/Runtime/GameManager.cs:38`\n- **职责**: 游戏主管理器，单例模式\n- **关键方法**:\n  - `Start()` - 初始化 LocalModelManager 和加载配置\n  - `Update()` - 处理输入和逻辑更新\n  - `RunLogicUpdate(float)` - 执行所有角色的逻辑更新\n  - `InitializeCharacterActionData(int)` - 初始化角色动作数据\n\n#### LocalModelManager\n- **路径**: `Assets/_Game/Scripts/LocalModels/LocalModelManager.cs:22`\n- **职责**: 配置数据管理，使用 Luban 系统\n- **关键方法**:\n  - `SetTableLoader(ITableLoader)` - 设置加载器\n  - `LoadAll(Action<float>, Action)` - 加载所有配置\n  - `Load(string, Action)` - 加载指定配置文件\n\n### ActionMachine 系统\n\n#### ActionMachine\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Machine/ActionMachine.cs:12`\n- **职责**: 动作状态机核心逻辑\n- **关键属性**:\n  - `_stateAssets: Dictionary<string, StateActionConfig>` - 状态动作映射\n  - `_globalAssetsHandlers: List<IAssetsHandler>` - 全局动作列表\n  - `_currentUseHandler: IAssetsHandler` - 当前激活的动作处理器\n- **关键方法**:\n  - `Initialize(ActionMachineInitializeData, ControllerType)` - 初始化状态机\n  - `LogicUpdate(float)` - 逻辑更新（每逻辑帧调用）\n  - `RenderUpdate(float)` - 渲染更新（每渲染帧调用）\n  - `ChangeState(string, int)` - 切换状态，priority 控制优先级\n  - `GetStateLoopCnt()` - 获取当前循环次数\n\n#### ActionController\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Controller/ActionController.cs:12`\n- **职责**: 角色动作控制器，连接 ActionMachine 和 Unity 组件\n- **组件依赖**:\n  - `AnimancerComponent animator` - 动画控制器\n  - `Rigidbody _rigidbody` - 刚体组件\n  - `Kcc _kcc` - 运动控制器\n- **关键方法**:\n  - `Initialized(ActionMachineInitializeData)` - 初始化\n  - `LogicUpdate(float)` - 逻辑更新\n  - `GetNodeTransform(CharacterNodeType)` - 获取角色节点 Transform\n  - `UpdateRotation()` - 更新角色旋转（朝向移动方向）\n\n#### Kcc (Kinematic Character Controller)\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs:18`\n- **职责**: 高级角色运动控制器\n- **关键特性**:\n  - 支持重力、地面检测、斜坡滑动\n  - 移动平台跟随\n  - 逻辑帧与渲染帧分离\n  - 零延迟响应（HorizontalAcceleration = 0）\n- **更新模式**:\n  - `UpdateMode.Auto` - Update 中自动执行\n  - `UpdateMode.Manual` - 仅通过外部 LogicUpdate 调用\n- **关键方法**:\n  - `LogicUpdate(float)` - 外部逻辑更新入口\n  - `SetMovement(Vector3)` - 设置移动向量（由输入系统调用）\n  - `AddForce(Vector3)` - 添加外部力\n  - `DetachFromGround()` - 从地面分离（跳跃）\n- **关键属性**:\n  - `Velocity` - 当前速度\n  - `Grounded` - 是否在地面\n  - `CurrentMovement` - 当前移动向量\n\n### Handler 系统\n\n#### AssetsHandler\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Assets/AssetsHandler.cs:13`\n- **职责**: 动作资源的顶层处理器\n- **关键属性**:\n  - `Length` - 动作总帧数\n  - `EnableLoop` - 是否循环\n  - `NextStateName` - 下一个状态名\n  - `SerialID` - 动作唯一标识\n- **关键方法**:\n  - `Instantiate()` - 异步实例化所有子处理器\n  - `LogicUpdate(float, int)` - 逻辑更新\n  - `RenderUpdate(float)` - 渲染更新\n  - `ManualExit()` - 手动退出（状态切换时调用）\n\n#### ClipHandlerBase<TData>\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Clip/ClipHandler.cs:8`\n- **职责**: Clip 处理器基类\n- **生命周期**:\n  1. `Initialize(ClipNode)` - 初始化\n  2. `Instantiate(ClipNode)` - 实例化资源\n  3. `Enter(ClipNode)` - 进入片段\n  4. `LogicUpdate(ClipNode, float, int)` - 逻辑更新\n  5. `RenderUpdate(ClipNode, float)` - 渲染更新\n  6. `Exit(ClipNode)` - 退出片段\n  7. `Dispose()` - 释放资源\n\n#### AttributeHandlerFactory\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/HandlerFactory/AttributeHandlerFactory.cs:9`\n- **职责**: 处理器工厂，通过特性自动注册\n- **使用方式**:\n  ```csharp\n  [CustomHandler(typeof(PlayAnimation))]\n  public class PlayAnimationClipHandler : ClipHandlerBase<PlayAnimation>\n  {\n      // 实现\n  }\n  ```\n\n### Directables 系统\n\n#### Clip (片段基类)\n- **命名空间**: `NBC.ActionEditor`\n- **常用子类**:\n  - `PlayAnimation` - 动画播放\n  - `PlayAudio` - 音频播放\n  - `PlayParticle` - 特效播放\n  - `MoveBy/MoveTo` - 移动\n  - `RotateTo` - 旋转\n  - `ScaleTo` - 缩放\n  - `CreateHitBoxClip` - 创建碰撞盒\n  - `TriggerEvent` - 触发事件\n\n#### PlayAnimation\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/Directables/Clips/Animation/PlayAnimation.cs:12`\n- **职责**: 动画播放片段\n- **关键属性**:\n  - `resPath: string` - 动画资源路径\n  - `playbackSpeed: float` - 播放速度\n  - `clipOffset: float` - 偏移量\n  - `ApplyRootMotion: bool` - 是否应用根运动\n  - `blendIn/blendOut: float` - 淡入淡出时间\n\n#### Track (轨道基类)\n- **常用子类**:\n  - `AnimationTrack` - 动画轨道\n  - `EffectTrack` - 特效轨道\n  - `AudioTrack` - 音频轨道\n  - `ActionTrack` - 动作轨道\n  - `SignalTrack` - 信号轨道\n\n### 输入系统\n\n#### InputData\n- **路径**: `Assets/_Game/Scripts/ActionMachine/Runtime/InputData/InputData.cs:16`\n- **职责**: 静态输入管理类\n- **关键属性**:\n  - `inputEvents: InputEvents` - 输入事件标志位\n  - `axisValue: Vector2` - 轴向输入值\n- **关键方法**:\n  - `Update()` - 更新输入（在 GameManager.Update 中调用）\n  - `Clear()` - 清除输入（在逻辑更新后调用）\n  - `HasEvent(InputEvents, bool)` - 检查是否有指定事件\n\n---\n\n## 文件路径快速查找\n\n### 核心脚本路径\n\n```\nAssets/_Game/Scripts/\n├── Runtime/\n│   ├── GameManager.cs                    # 游戏主管理器\n│   └── SkillAssets.cs                    # 技能资源\n├── LocalModels/\n│   ├── LocalModelManager.cs              # 配置管理器\n│   ├── Const.cs                          # 常量定义\n│   └── ExternalTypeUtil.cs               # 类型工具\n└── ActionMachine/\n    ├── Runtime/\n    │   ├── Controller/\n    │   │   ├── ActionController.cs        # 动作控制器\n    │   │   ├── CharacterNode.cs           # 角色节点\n    │   │   ├── Kcc/Kcc.cs                 # 运动控制器\n    │   │   └── Machine/\n    │   │       ├── ActionMachine.cs       # 状态机\n    │   │       └── IActionMachine.cs      # 状态机接口\n    │   ├── Handlers/\n    │   │   ├── Assets/AssetsHandler.cs    # 资源处理器\n    │   │   ├── Clip/\n    │   │   │   ├── ClipHandler.cs         # Clip处理器基类\n    │   │   │   └── ClipHandlers/          # 各种Clip处理器实现\n    │   │   ├── Groups/GroupHandler.cs     # 组处理器\n    │   │   ├── Tracks/TrackHandler.cs     # 轨道处理器\n    │   │   └── HandlerFactory/\n    │   │       └── AttributeHandlerFactory.cs  # 工厂类\n    │   ├── Directables/\n    │   │   ├── Clips/                     # 所有Clip定义\n    │   │   │   ├── Animation/             # 动画相关\n    │   │   │   ├── Audio/                 # 音频相关\n    │   │   │   ├── Effect/                # 特效相关\n    │   │   │   ├── Transform/             # 变换相关\n    │   │   │   ├── Instantiate/           # 实例化相关\n    │   │   │   └── Event/                 # 事件相关\n    │   │   └── Tracks/                    # 所有Track定义\n    │   ├── ActionAssets/\n    │   │   └── ActionAssetsBase.cs        # 动作资源基类\n    │   ├── InputData/\n    │   │   └── InputData.cs               # 输入管理\n    │   ├── Helper/\n    │   │   ├── ActionHandlerHelper.cs     # 处理器助手\n    │   │   └── AssetsDeserializeHelper.cs # 反序列化助手\n    │   ├── Tool/\n    │   │   ├── FrameTool.cs               # 帧工具\n    │   │   └── NodeFollower.cs            # 节点跟随器\n    │   └── Attributes/\n    │       ├── CustomHandlerAttribute.cs  # 处理器特性\n    │       └── ReadOnlyAttribute.cs       # 只读特性\n    └── Editor/\n        ├── GUIS/\n        │   └── ActionControllerWindow.cs  # 编辑器窗口\n        ├── Contoller/\n        │   └── ActionControllerEditor.cs  # Inspector扩展\n        └── Preview/                       # 预览系统\n```\n\n### 配置文件路径\n\n```\nAssets/_Game/Assets/Settings/NBC/\n├── character_10001_run.json              # 角色跑步动作配置\n└── [其他角色动作配置]\n```\n\n### 资源文件路径\n\n```\nAssets/_Game/_Example/\n├── Arts/                                  # 美术资源\n│   └── BOSS/                              # BOSS模型\n│       └── Bull/\n│           ├── Animation/                 # 动画\n│           ├── Materials/                 # 材质\n│           └── Mesh/                      # 网格\n└── ResRaw/                                # 原始资源\n    ├── Effects/                           # 特效\n    ├── Model/                             # 模型\n    ├── Skill/                             # 技能\n    └── Sound/                             # 音效\n```\n\n---\n\n## 设计模式与约定\n\n### 1. 状态机模式\n\nActionMachine 使用状态机模式管理角色动作：\n\n```csharp\n// 状态切换\nactionMachine.ChangeState(\"idle\", priority: 0);\nactionMachine.ChangeState(\"attack\", priority: 10); // 高优先级可以打断\n\n// 状态配置\nvar stateConfig = new ActionConfig {\n    EnableLoop = true,              // 是否循环\n    NextActionId = \"idle\",          // 结束后切换的状态\n    Json = actionJsonString,        // 动作配置JSON\n    SerialID = \"character_run\"      // 唯一标识\n};\n```\n\n### 2. Handler 工厂模式\n\n使用特性自动注册处理器：\n\n```csharp\n// 1. 定义Clip\n[Name(\"我的动作\")]\n[Attachable(typeof(MyTrack))]\npublic class MyClip : Clip {\n    // 定义数据\n}\n\n// 2. 实现Handler\n[CustomHandler(typeof(MyClip))]\npublic class MyClipHandler : ClipHandlerBase<MyClip> {\n    protected override void OnEnter(ClipNode clipNode) {\n        // 进入时执行\n    }\n\n    protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt) {\n        // 每逻辑帧更新\n    }\n\n    protected override void OnExit(ClipNode clipNode) {\n        // 退出时执行\n    }\n}\n```\n\n### 3. 对象池模式\n\nHandler 使用对象池复用：\n\n```csharp\n// ActionHandlerHelper 提供池化功能\nvar handler = ActionHandlerHelper.GetAssetsHandler();\n// 使用后回收\nActionHandlerHelper.RecycleAssetsHandler(handler);\n```\n\n### 4. 组件模式\n\nActionController 组合多个组件：\n- ActionMachine - 动作逻辑\n- AnimancerComponent - 动画播放\n- Kcc - 运动控制\n- Rigidbody - 物理模拟\n\n### 5. 数据驱动设计\n\n动作完全由 JSON 配置驱动：\n\n```json\n{\n  \"tracks\": [\n    {\n      \"type\": \"AnimationTrack\",\n      \"clips\": [\n        {\n          \"type\": \"PlayAnimation\",\n          \"startTime\": 0,\n          \"length\": 1.5,\n          \"resPath\": \"Assets/Animation/run.anim\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### 6. 逻辑与渲染分离\n\n- **LogicUpdate**: 固定或变帧率逻辑更新，处理游戏逻辑\n- **RenderUpdate**: 渲染帧更新，处理视觉效果\n\n```csharp\n// GameManager.Update()\nRunLogicUpdate(Time.deltaTime);  // 逻辑更新\n\n// ActionController.Update()\n_actionMachine.RenderUpdate(Time.deltaTime);  // 渲染更新\n```\n\n---\n\n## 常用操作指南\n\n### 1. 添加新的角色\n\n```csharp\n// 在 GameManager 中添加新的 ActionControllerWrapper\n[SerializeField] protected List<ActionControllerWrapper> controllers;\n\n// 配置角色ID和Controller\nvar newController = new ActionControllerWrapper {\n    CharacterID = 10002,  // 新角色ID\n    Controller = GetComponent<ActionController>()\n};\ncontrollers.Add(newController);\n```\n\n### 2. 创建新的 Clip 类型\n\n**步骤 1**: 创建 Clip 定义\n\n```csharp\n// Assets/_Game/Scripts/ActionMachine/Runtime/Directables/Clips/MyClip.cs\n[Name(\"我的片段\")]\n[Description(\"执行某个特定操作\")]\n[Color(1f, 0.5f, 0f)]\n[Attachable(typeof(ActionTrack))]\npublic class MyClip : Clip {\n    [MenuName(\"参数1\")] public float parameter1;\n    [MenuName(\"参数2\")] public string parameter2;\n\n    public override bool IsValid => !string.IsNullOrEmpty(parameter2);\n}\n```\n\n**步骤 2**: 创建 Handler 实现\n\n```csharp\n// Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Clip/ClipHandlers/MyClipHandler.cs\n[CustomHandler(typeof(MyClip))]\npublic class MyClipHandler : ClipHandlerBase<MyClip> {\n    protected override void OnEnter(ClipNode clipNode) {\n        Debug.Log($\"开始执行: {BindData.parameter2}\");\n    }\n\n    protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt) {\n        // 每帧更新逻辑\n        float progress = (float)updateCnt / clipNode.BindClip.Length;\n    }\n\n    protected override void OnExit(ClipNode clipNode) {\n        Debug.Log(\"执行完成\");\n    }\n}\n```\n\n**步骤 3**: （可选）创建预览系统\n\n```csharp\n// Assets/_Game/Scripts/ActionMachine/Editor/Preview/Clips/MyClipPreview.cs\npublic class MyClipPreview : IClipPreview {\n    public void OnPreview(ClipNode clipNode, float time) {\n        // 编辑器预览逻辑\n    }\n}\n```\n\n### 3. 修改角色移动速度\n\n```csharp\n// 在 ActionController 或其他地方\nvar kcc = GetComponent<Kcc>();\n\n// 方法1: 直接设置移动向量（推荐）\nVector3 movement = new Vector3(horizontal, 0, vertical) * moveSpeed;\nkcc.SetMovement(movement);\n\n// 方法2: 添加外部力\nkcc.AddForce(Vector3.forward * jumpForce);\n\n// 方法3: 施加冲击力\nkcc.Impact(Vector3.up, impactForce);\n```\n\n### 4. 切换角色动作状态\n\n```csharp\n// 在 ActionController 中\n_actionMachine.ChangeState(\"run\", priority: 5);\n\n// 优先级说明：\n// - priority 越高，越能打断当前动作\n// - priority 相同或更低，无法打断当前动作\n```\n\n### 5. 处理输入\n\n```csharp\n// 在 Update 中\nInputData.Update();  // 更新输入\n\n// 检查输入\nif (InputData.HasEvent(InputEvents.Attack)) {\n    // 处理攻击\n}\n\nif (InputData.HasEvent(InputEvents.Moving)) {\n    Vector2 axis = InputData.axisValue;\n    // 处理移动\n}\n\n// 在逻辑更新后清除\nInputData.Clear();\n```\n\n### 6. 读取配置数据\n\n```csharp\n// 在 GameManager 中\n_localModelManager.LoadAll(null, () => {\n    // 加载完成回调\n    var characterData = _localModelManager.GetCharacterDataItem(characterId);\n    var actionData = _localModelManager.GetActionDataItem(actionId);\n});\n```\n\n### 7. 调试状态机\n\n```csharp\n// 在 ActionMachine.cs 中已有调试日志\n#if UNITY_EDITOR\nDebug.Log($\"ChangeState {_currentStateName}=>{_nextStateName}\");\nDebug.Log($\"当前状态 {_currentStateName} 帧序号 {index}\");\n#endif\n\n// 查看 Kcc 状态\nDebug.Log($\"Grounded: {kcc.Grounded}\");\nDebug.Log($\"Velocity: {kcc.Velocity}\");\nDebug.Log($\"Speed: {kcc.Speed}\");\n```\n\n---\n\n## API 参考\n\n### ActionMachine API\n\n```csharp\npublic interface IActionMachine {\n    // 初始化\n    Task Initialize(ActionMachineInitializeData initData, ControllerType controller);\n\n    // 更新\n    void LogicUpdate(float deltaTime);\n    void RenderUpdate(float deltaTime);\n\n    // 状态控制\n    void ChangeState(string stateName, int priority = 0);\n    int GetStateLoopCnt();\n\n    // 位置和旋转\n    void GetWorldPosition(out Vector3 position, out Quaternion rotation);\n\n    // 访问器\n    GameObject Actor { get; }\n    ActionController Controller { get; }\n}\n```\n\n### ActionController API\n\n```csharp\npublic interface IActionController {\n    // 初始化\n    void Initialized(ActionMachineInitializeData data);\n\n    // 更新\n    void LogicUpdate(float deltaTime);\n\n    // 节点访问\n    Transform GetNodeTransform(CharacterNodeType type);\n\n    // 组件访问\n    AnimancerComponent Animator { get; }\n    Rigidbody GetRigidbody();\n    Kcc Kcc { get; }\n}\n```\n\n### Kcc API\n\n```csharp\npublic class Kcc : MonoBehaviour {\n    // 更新模式\n    public UpdateMode UpdateModeType { get; set; }\n\n    // 移动控制\n    public void LogicUpdate(float deltaTime);\n    public void SetMovement(Vector3 movement);\n    public void AddForce(Vector3 force);\n    public void Impact(Vector3 direction, float force);\n\n    // 状态访问\n    public Vector3 Velocity { get; }\n    public Vector3 Speed { get; }\n    public bool Grounded { get; }\n    public bool JustGotGrounded { get; }\n\n    // 高级功能\n    public void DetachFromGround();\n    public void DetachFromMovingPlatform();\n    public void SetGravityActive(bool status);\n    public void ResizeColliderHeight(float newHeight, bool translateCenter);\n    public bool CanGoBackToOriginalSize();\n\n    // 碰撞控制\n    public void CollisionsOn();\n    public void CollisionsOff();\n    public void SetFreeMovement(bool state);\n}\n```\n\n### InputData API\n\n```csharp\npublic static class InputData {\n    // 属性\n    public static InputEvents inputEvents { get; set; }\n    public static Vector2 axisValue { get; set; }\n\n    // 方法\n    public static bool HasEvent(InputEvents e, bool fullMatch = false);\n    public static void Clear();\n    public static void Update();\n}\n\n[Flags]\npublic enum InputEvents {\n    None = 0b0000,\n    Moving = 0b0001,\n    Attack = 0b0010,\n    Jump = 0b0100,\n    Jumping = 0b1000,\n}\n```\n\n### LocalModelManager API\n\n```csharp\npublic partial class LocalModelManager {\n    // 单例\n    public static LocalModelManager Instance { get; }\n\n    // 加载\n    public void SetTableLoader(ITableLoader loader);\n    public Task Load(string fileName, Action callBack);\n    public void LoadAll(Action<float> progressCallBack, Action callBack);\n\n    // 卸载\n    public void UnLoad(string fileName);\n    public void UnLoadAll();\n\n    // 访问数据（在生成的部分类中定义）\n    // public CharacterDataItem GetCharacterDataItem(int id);\n    // public ActionDataItem GetActionDataItem(string id);\n}\n```\n\n---\n\n## 帧率与更新系统说明\n\n### 更新模式对比\n\n| 特性 | 固定逻辑帧 (旧) | 变帧率 (当前) |\n|------|-----------------|---------------|\n| 逻辑更新 | 30/60 FPS 固定 | 与渲染帧同步 |\n| 视觉流畅度 | 需要插值 | 直接流畅 |\n| 物理模拟 | 稳定 | 依赖 deltaTime |\n| 复杂度 | 高（需要插值） | 低（直接更新） |\n\n### 当前实现\n\n```csharp\n// GameManager.Update() - 每渲染帧调用\nprivate void Update() {\n    InputData.Update();\n    RunLogicUpdate(Time.deltaTime);  // 直接使用渲染帧 deltaTime\n}\n\n// Kcc 支持两种模式\npublic enum UpdateMode {\n    Auto,    // Update 中自动执行（独立使用）\n    Manual   // 由外部 LogicUpdate 调用（集成到 GameManager）\n}\n```\n\n---\n\n## 命名约定\n\n### 文件命名\n- **类文件**: PascalCase，如 `ActionController.cs`\n- **接口文件**: IPascalCase，如 `IActionMachine.cs`\n- **配置文件**: snake_case，如 `character_10001_run.json`\n\n### 代码命名\n- **公共成员**: PascalCase\n- **私有字段**: _camelCase（下划线前缀）\n- **局部变量**: camelCase\n- **常量**: PascalCase 或 UPPER_CASE\n\n### 目录命名\n- **核心模块**: PascalCase，如 `ActionMachine/`\n- **资源目录**: PascalCase，如 `ResRaw/`\n- **示例目录**: _PascalCase（下划线前缀），如 `_Example/`\n\n---\n\n## 常见问题与解决方案\n\n### 1. 角色移动卡顿\n\n**原因**: 固定逻辑帧与渲染帧不同步\n**解决**:\n- 已切换为变帧率更新（直接使用 Time.deltaTime）\n- Kcc 的 `HorizontalAcceleration` 和 `HorizontalDeceleration` 设为 0，实现零延迟响应\n\n### 2. 动作无法切换\n\n**原因**: 优先级不足\n**解决**:\n```csharp\n// 使用更高的优先级\nactionMachine.ChangeState(\"newState\", priority: 999);\n```\n\n### 3. 配置文件加载失败\n\n**原因**: 路径错误或格式不正确\n**解决**:\n```csharp\n// 检查路径是否正确\nDebug.LogError($\"LoadActionConfig {path}\");\n// 确保 JSON 文件放在 Resources/LocalModel/ 目录下\n```\n\n### 4. Handler 未被调用\n\n**原因**: 未注册 CustomHandler 特性\n**解决**:\n```csharp\n[CustomHandler(typeof(YourClip))]\npublic class YourClipHandler : ClipHandlerBase<YourClip> {\n    // ...\n}\n```\n\n---\n\n## 快速搜索关键词\n\n### 查找特定功能\n\n| 功能 | 关键词 | 位置 |\n|------|--------|------|\n| 状态切换 | `ChangeState` | ActionMachine.cs:95 |\n| 移动控制 | `SetMovement` | Kcc.cs:920 |\n| 输入处理 | `InputData.Update` | InputData.cs:33 |\n| 动画播放 | `PlayAnimation` | PlayAnimation.cs:12 |\n| 碰撞检测 | `CreateHitBoxClip` | CreateHitBoxClip.cs |\n| 配置加载 | `LoadAll` | LocalModelManager.cs:58 |\n| Handler工厂 | `AttributeHandlerFactory` | AttributeHandlerFactory.cs:9 |\n| 帧工具 | `FrameTool` | FrameTool.cs |\n\n### 查找设计模式实现\n\n| 模式 | 位置 |\n|------|------|\n| 状态机 | ActionMachine.cs |\n| 工厂模式 | AttributeHandlerFactory.cs |\n| 对象池 | ActionHandlerHelper.cs |\n| 组件模式 | ActionController.cs |\n| 观察者模式 | OnInstantiateHandlerComplete 事件 |\n\n---\n\n## 扩展资源\n\n### 依赖插件\n\n1. **Animancer** - 动画系统\n   - 官网: https://kybernetik.com.au/animancer/\n   - 用途: 动画混合和状态管理\n\n2. **Luban** - 配置表系统\n   - 用途: 数据表加载和管理\n\n3. **Coplay** - Unity MCP 服务器\n   - 用途: 开发工具集成\n\n### 相关文档\n\n- `README.md` - 项目概述和使用说明\n- `error_json.json` - 错误日志（如果存在）\n- `Assets/CoplayPlan.md` - Coplay 计划文档\n\n---\n\n## 版本信息\n\n- **Unity 版本**: 2020.3+\n- **文档生成时间**: 2025-12-15\n- **最后更新**: 提交 46208fe\n\n---\n\n**注意**: 本文档由 Claude Code 自动生成，基于项目当前状态。如有更新，请重新生成此文档。\n"}}
{"parentUuid":"ca34f7e4-b9b6-4200-90b4-ea9d799b3ff9","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_014rCyY4zjVXR1B7ctJq8jkm","type":"message","role":"assistant","content":[{"type":"text","text":"I've successfully created a `CLAUDE.md` file for your MonsterHunter Unity project. The file includes:\n\n## Key Sections:\n\n1. **Build and Development** - Unity version requirements and how to open/test the project\n\n2. **Core Architecture** - The hierarchical system structure showing how GameManager, ActionController, ActionMachine, and Kcc interact\n\n3. **Key Design Patterns** - State machine, handler factory, object pooling, component composition, and data-driven design\n\n4. **File Structure** - Critical paths to important scripts, handlers, and configuration files\n\n5. **Common Workflows** - Practical examples for:\n   - Adding new Clip types (with complete code examples)\n   - Changing character states\n   - Handling input\n   - Modifying character movement\n\n6. **Code Conventions** - Naming patterns for members, files, and interfaces\n\n7. **Important Notes** - Critical information about:\n   - State machine priority system\n   - Kcc update modes\n   - Handler lifecycle\n   - Debugging tips\n\nThe document is concise, focuses on architecture that requires reading multiple files to understand, and provides practical workflows without repeating obvious information. It also references the existing detailed Chinese documentation (`claude.md`) for comprehensive API details."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":60795,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":60795,"ephemeral_1h_input_tokens":0},"output_tokens":284,"service_tier":"standard"}},"type":"assistant","uuid":"aca47a70-4694-4cd5-8222-4bfa3e1edc9c","timestamp":"2025-12-15T10:48:08.418Z"}
{"type":"file-history-snapshot","messageId":"914f6acc-1402-4804-a642-2a6ef5386e36","snapshot":{"messageId":"914f6acc-1402-4804-a642-2a6ef5386e36","trackedFileBackups":{"CLAUDE.md":{"backupFileName":"0b5c4e3350b32821@v2","version":2,"backupTime":"2025-12-15T10:53:40.569Z"}},"timestamp":"2025-12-15T10:53:40.568Z"},"isSnapshotUpdate":false}
{"parentUuid":"aca47a70-4694-4cd5-8222-4bfa3e1edc9c","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":"好的 现在看一下 @Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs 这个类 为什么还是抖动"},"uuid":"914f6acc-1402-4804-a642-2a6ef5386e36","timestamp":"2025-12-15T10:53:40.567Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]},"todos":[]}
{"parentUuid":"914f6acc-1402-4804-a642-2a6ef5386e36","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017Xnu7iQRPktGutPubJ8qw5","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"用户说现在角色移动还是有抖动问题，让我看一下 Kcc.cs 这个类。从文件内容来看，这是一个运动学角色控制器，用于处理角色移动、重力、地面检测等。\n\n让我分析一下可能导致抖动的原因：\n\n1. **逻辑帧与渲染帧的问题**：\n   - 代码注释提到\"修复：添加逻辑帧与渲染帧之间的插值，解决 30fps 逻辑更新导致的卡顿\"\n   - 但是从代码看，插值相关的变量被标记为\"已废弃\"（lines 231-250）\n   - 现在使用的是直接的变帧率更新\n\n2. **Update 和 LogicUpdate 的调用**：\n   - Update() 方法中会检查 UpdateModeType\n   - 如果是 Auto 模式，会在 Update 中调用 ProcessLogicUpdate\n   - 如果是 Manual 模式，则只由外部的 LogicUpdate 调用\n   - 有防止同一帧重复移动的机制（_lastLogicUpdateFrame）\n\n3. **地面粘附问题**：\n   - Line 552-562 注释掉了地面粘附逻辑（sticky offset）\n   - 注释说：\"临时禁用地面粘附，测试是否是它导致的抖动\"\n   \n4. **速度计算**：\n   - Line 309-314 在 Update 中计算速度（_speed）用于显示\n   - 这只是用于调试显示，不应该影响实际移动\n   \n加速度设置可能是抖动的关键。水平加速度和减速度都设为 0，意味着角色移动没有平滑过渡，可能导致瞬间速度变化。这种零延迟响应可能引起视觉上的不稳定。\n\n更深层次的问题在于可能存在双重更新风险。即便有机制防止同一帧重复处理，但 GameManager 调用 LogicUpdate 时，如果 UpdateModeType 设置为 Auto，仍可能出现重复更新的情况。\n\n移动控制器的多次调用也是潜在问题。不同方法如 ProcessLogicUpdate、MoveWithPlatform 可能重复触发移动指令，增加了系统不稳定性。缺乏帧率插值更加剧了这种抖动效果。\n\n平台速度计算存在风险，特别是在每帧调用 GetMovingPlatformVelocity() 时。速度显示计算依赖 _renderPositionLastFrame，可能暴露了底层移动机制的不一致性。这种计算方式虽不直接影响移动，但反映了系统潜在的性能和同步问题。","signature":"EvkTCkYIChgCKkA9nq2E4oEjhNreSpqhzjzgc8QJuB7OBvQny46lQ7iSxmkzSqKFqnneGlfVeaVPwS74M5jgETnY5mChEQFnOGnLEgzDXIn6o1EhkD3aQEAaDNVWgvZuCJVlQeYwliIwIcgjcOGFRDJWcO90Sd155Z1ADtvWX/JiIL9ZfL9oRPht+Kb0YSt3JB3l6V+YqZIVKuASjHHumDkoPWtKj9N2Mq5MCj6KAlLffr2lWT6aWkcPM4dtifNFFo+bKibH2+SLAkvEnETiTHCJgc5aeEO+JWg+WsCS/aD1fiJqBS6jyG62lbyWrlg6Bun1SKZWBWbseWMe2KLx+Xqx7p6+K+ylrnCXPAXt9+f6I1kpMOiM18TAjzxrTr3p4wVOmynOxh0TBcTTEZmJ17WLbjYiAySzD7s5w4C0nT0AUK7uvWIbfieCjje419FcNK2RUrAaed30UhjglhR77nMGq4DYU3XXBe4tB/0TiT/T7z+WtcOQEaalN0TDKkWvAIbNH8NHuTLXJ5F4xFROEzkeRERC7YXxu0xUk7PXM8d/mFKHcWk0RBR4HbVGDRg/IwCdw/dxlxKhnbLUYid/D5icyFapUjrhnjS3RmPafTnvp8o42I/jwkU4b7jtQIAMPYd+KDKj8zNz+cDuo5FRFvr0+ijQ5h0c1toTvKdOUC5jzTr1csSpukWOz3vDDtz72sdmsEFV6PSFcn1DQur8HrekX+BuXL3TyYZIoiruFCzs1eoCx0FCV+s4i84Iwp3njIFDrJq2TRUeGKBV5HOMyHVSUFo1GBtsKhlCtxbkYMDpbfs7nHZBh3OqsxYkXMWcJZJ48VC1YbqObBy1n+pTFmbaB7WDsFxucTHzadrE5es0IpcCjXA+cQNTUm5P0V/gXfkFh/zRiGf9gsrmVnBLl9vEZmAe4+5VFhIO+0CDH/4mUGXJsfuXV9gCPUDUhiJrmPqTr6rwc/3yyulUWQ/z00GD5OHLs/jBUVfv8OV7IeN/OPT1lSgDKCFmnyRfXxLGvbSt2fj88CQd7wgJyaJUhntDqB+sbIqMwKc2pRpCTfvta3TAjTDqv2bVirLRCLAvVc1geglG+TMxbnpXI2efToR5JFQyY7QKL22bYuz8l93O98O0spTXImhoscEe9nHrSZyorfD1lZpwvWUw2i3och0DDhXdI8KCg/wJME1ZKpGalcqy99XbKiQTQMPanxHqg0CcaeTpjWNuBFbGVkBv8k3JKIiQNKQTa3mP4iTPOMwi7mAbbtXM92tjAFE6BonEyYJJ4UZEQ731NTDsoEtjUL5QQSTVj8u4Zu3Ym2XgWITVAeu6ABLLc516U4+MqYwvhxfVh+U5/dN4hzGwMnvtDcsG87tZl64loTgZaJnrk+jBgeRl/WaliCxGzJCaB5ngMeMP5aoXtb/ZROOWiiUApJFgJMON1kRVhtQrOZ9iQhF9GX3R25qUT3GSqJhoL1z3YdAElad7BDlctYLF3dcpR6zJKHnHwmpT6KhldPlXx+OVOwWcpCmgVQa0kbtjHLpgQEPKI5S3zeLMKA0PS/xcte7WonMKE+Wpfno1fl/yd49LjkMdZIMb+I07/o5WFVrtciH7AkrASZ2iFprOJuqKbXDbA5J3jE1UEYXgTtRlW3gHn9h3BefGusslTqAku9ZLHGqfWe/1bLQFNuB8zf6BBVZq5lvGcYinhOF0Jz8C+7fkHVbEPAdHvwiPq6ZBgjYr7WXvyaNtqce1e3ID0LKfIvRQAAGAOWZpw6ZwIv9zGCN81UYmwEFaDeRI2+o+gM5ZQE13jTG74drFDx+NCNrE5qcNmPKjgCMt7TeWjKTC/vMy/pTO3+QzxdPyPGgyb0psvFLB2g2qPyk6JLdxf6Uiy2JxyCJm0DoiLFyNim2OYHbXzhv9VxtCiFyuMX7wrjLanvHWYoI4CEfGEWVVNKX29KUHGBq8G0ouzT5pC20aep1T44soR36phBDjaQJAtVhtI1OtCX5xj0F3VjYVM/pScfqQXkCOQ42EAW35BhONbIUHTqtXuxTKhC7K7DQqk8g/XycFM1hrkPfryiXHTZdhE7fE2/LeZWJ78Rbduhdqov1YSFaknVs4pMYTRK6peGNZkp/PaRkqv67+9tyedREA4wFlUkBwDnvv++H+sxXD4Odnvr0any/sAA7qtbtjv6etXm9eGUkOxYpDydVNbv1HUZ1UCx5lN/x5nmq9In3pL8TLaf/+GAp/IZgb5Z4vuxpQ7iNkMgtkFWfy0iSoi7SiFtscn5FaZOvNzV1tTFOuSNfqUMpW7gCkrxAczRzPP4M4xCfAWc6qaCJtPGhVJh3gMQZzCfptIFq7mfAtDCWgQFo66MnqKzarI/GrrTC9grtwnTupZnWP+Dx90Vgd6VqzSXtetoVY9G9t+pLZqUBPcGvBE6sAkHKPxkLFXyFUPfba9+oz2pyx9AMLv6eEpxKbl2oEb/Jfj38L73Fu5tGsPFzF6atk4JKzKIlMRvlW1fBLtSOGQEog8iPo+bqvsTt625H1PBha9a41NXgKW1b4iJHco231lgSFes4FkUnvP5yMYPgXlQ8i4YAwDwEePOheY0UTvSUKTN3eywE9lgn14VgFRIFzWDWBvrP4gHDDsqwQlrTGva4Is+FjQw0+ueSTrmT1kr9IcJ0ur+KdbHGKJCDUae7tOeU0IDmgFgveRb0syAwq02aZjQrRrfINIa3JU8kfYPcZFi9ShKLzsym9dd0gbjeB1/tOPUH+yCHxJuU1wJjXqVlVfZ1gnt2sEw70SNfHnkAe5OvrzjOdhnD66cihTdtURx18Bf/2s1RkZwc6zc92l7fFoXNMWks1VwbUp/wdg1A9cH1JSPpEGLM4R2TUmrBjOgBx7XLtx4BzpECi094r8Or6yP4FxHsUQgDpi7qBaac+nr/Vt2Pz0cGSaT/vpvVBN6QqVv4CSPMp+vZJaGuT33ojBk+SR/2gpjLH0bmMjB1zT5kbTKZLBqtPr8kJsSaUO8goOukDCjYVv3ZTXbufoR3FUqLd12aHDDdGuvHC3jlDaQ6qzcuTp3dDSMZn+1ZSHn8kNe77ZEqsr3jWUemWhm7F/o0tJYC+iFfLNrFa9WjRq2EtQ96e/vxwtgcqAgXi7nVVz3VgsO5AdjrEx58sb+xoAIOUiPCbUi7/O4qYF5YZgzbhrVKUfOU2bKnPuKXMH2RVPJO17Akr/+aSheW9jvGqNHCJchWIzYmJW13uMhUNLIqTikidu44K8WaE3j51WGOflADo7G4WQQa8Kf6ZDEcn6Eiioqdz385L2IyiczKydJy1HOs6vrbzc/2rHjoM99HqiwhwihE5GklebdEGHn/H9C/w21ad70EFBWNC0uS/q6z0FcEPlQTLhDzs14At/L/4kdKovKzacexUn/Hc6bl7SlBqIOwQGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":79361,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":79361},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"582e0d19-2529-443c-a3c2-cd7c5e0111cb","timestamp":"2025-12-15T10:54:07.361Z"}
{"parentUuid":"582e0d19-2529-443c-a3c2-cd7c5e0111cb","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017Xnu7iQRPktGutPubJ8qw5","type":"message","role":"assistant","content":[{"type":"text","text":"我来分析一下 Kcc.cs 中可能导致抖动的问题。让我先看一下当前的 GameManager 如何调用 Kcc："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":79361,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":79361},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"6871c90b-3abc-4351-8e0d-55b572b5e9d9","timestamp":"2025-12-15T10:54:07.517Z"}
{"parentUuid":"6871c90b-3abc-4351-8e0d-55b572b5e9d9","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017Xnu7iQRPktGutPubJ8qw5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RQfJfcCNSiZtVU5SjhfDtV","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\Runtime\\GameManager.cs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":79361,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":79361},"output_tokens":1049,"service_tier":"standard"}},"type":"assistant","uuid":"ceb1afdb-1d50-4c3b-951e-347bde4bfeee","timestamp":"2025-12-15T10:54:07.574Z"}
{"parentUuid":"ceb1afdb-1d50-4c3b-951e-347bde4bfeee","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RQfJfcCNSiZtVU5SjhfDtV","type":"tool_result","content":"     1→using System;\n     2→using System.Collections.Generic;\n     3→using System.Threading.Tasks;\n     4→using ActionMachine.Runtime;\n     5→using ActionMachine.Runtime.Controller;\n     6→using LocalModels;\n     7→using UnityEditor;\n     8→using UnityEngine;\n     9→using UnityEngine.Rendering;\n    10→\n    11→namespace Runtime\n    12→{\n    13→    public class TableLoad : ITableLoader\n    14→    {\n    15→        public Task<byte[]> LoadBytesAsync(string fileName)\n    16→        {\n    17→            byte[] result = null;\n    18→            try\n    19→            {\n    20→                result = Resources.Load<TextAsset>($\"LocalModel/{fileName}\").bytes;\n    21→            }\n    22→            catch (Exception e)\n    23→            {\n    24→                throw new Exception($\"Load {fileName} failed\", e);\n    25→            }\n    26→\n    27→            return Task.FromResult(result);\n    28→        }\n    29→    }\n    30→\n    31→    [System.Serializable]\n    32→    public class ActionControllerWrapper\n    33→    {\n    34→        public int CharacterID;\n    35→        public ActionController Controller;\n    36→    }\n    37→\n    38→    public class GameManager : MonoBehaviour\n    39→    {\n    40→        [SerializeField] protected List<ActionControllerWrapper> controllers;\n    41→\n    42→\n    43→        protected float logicTimer = 0f;\n    44→        protected const float logicDeltaTime = 1 / 60f; // 提高到 60fps，减少卡顿\n    45→        public LocalModelManager _localModelManager;\n    46→\n    47→        public static GameManager Instance;\n    48→\n    49→        private void Start()\n    50→        {\n    51→            Instance = this;\n    52→            _localModelManager = new LocalModelManager();\n    53→            _localModelManager.InitialiseLocalModels();\n    54→            _localModelManager.SetTableLoader(new TableLoad());\n    55→            _localModelManager.LoadAll(null, OnLoadTableCallback);\n    56→        }\n    57→\n    58→        private void OnLoadTableCallback()\n    59→        {\n    60→            _localModelManager.GetTbActionDataInstance().DataList.ForEach(item => Debug.Log(item.Id));\n    61→            foreach (var kPair in controllers)\n    62→            {\n    63→                var data = InitializeCharacterActionData(kPair.CharacterID);\n    64→                kPair.Controller.Initialized(data);\n    65→            }\n    66→        }\n    67→\n    68→        private void Update()\n    69→        {\n    70→            InputData.Update();\n    71→\n    72→            // 直接使用渲染帧的 deltaTime，每帧都执行逻辑更新\n    73→            // 这样可以彻底消除固定逻辑帧率导致的卡顿\n    74→            RunLogicUpdate(Time.deltaTime);\n    75→        }\n    76→\n    77→        // 旧的固定帧率逻辑更新（已禁用）\n    78→        /*\n    79→        private void LogicUpdate()\n    80→        {\n    81→            logicTimer += Time.deltaTime;\n    82→            if (logicTimer >= logicDeltaTime)\n    83→            {\n    84→                logicTimer -= logicDeltaTime;\n    85→\n    86→                RunLogicUpdate(logicDeltaTime);\n    87→            }\n    88→        }\n    89→        */\n    90→\n    91→        private void RunLogicUpdate(float logicDeltaTime)\n    92→        {\n    93→            foreach (var item in controllers)\n    94→            {\n    95→                item.Controller.LogicUpdate(logicDeltaTime);\n    96→            }\n    97→            //Physics.Simulate(logicDeltaTime);\n    98→            InputData.Clear();\n    99→        }\n   100→\n   101→\n   102→        private ActionMachineInitializeData InitializeCharacterActionData(int characterId)\n   103→        {\n   104→            var characterData = _localModelManager.GetCharacterDataItem(characterId);\n   105→            var result = new ActionMachineInitializeData\n   106→            {\n   107→                InitialStateName = characterData.FirstAction,\n   108→                StateActions = new Dictionary<string, ActionConfig>()\n   109→            };\n   110→            foreach (var action in characterData.Actions)\n   111→            {\n   112→                var actionData = _localModelManager.GetActionDataItem(action);\n   113→                result.StateActions.Add(actionData.Id, new ActionConfig()\n   114→                {\n   115→                    EnableLoop = actionData.Loop,\n   116→                    NextActionId = actionData.NextActionId,\n   117→                    Json = LoadActionConfig(actionData.AssetsPath),\n   118→                    SerialID = actionData.Id\n   119→                });\n   120→            }\n   121→\n   122→            result.GlobalActions = new List<ActionConfig>();\n   123→            foreach (var action in characterData.GlobalActions)\n   124→            {\n   125→                var actionData = _localModelManager.GetActionDataItem(action);\n   126→                result.GlobalActions.Add(new ActionConfig()\n   127→                {\n   128→                    EnableLoop = actionData.Loop,\n   129→                    NextActionId = null,\n   130→                    Json = LoadActionConfig(actionData.AssetsPath),\n   131→                    SerialID = actionData.Id\n   132→                });\n   133→            }\n   134→\n   135→            return result;\n   136→        }\n   137→\n   138→        private string LoadActionConfig(string path)\n   139→        {\n   140→            Debug.LogError($\"LoadActionConfig {path}\");\n   141→            return AssetDatabase.LoadAssetAtPath<TextAsset>(path + \".json\").text;\n   142→        }\n   143→    }\n   144→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"9b08fa29-5464-4861-a1d0-f2bf6269e110","timestamp":"2025-12-15T10:54:08.570Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\Runtime\\GameManager.cs","content":"using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing ActionMachine.Runtime;\nusing ActionMachine.Runtime.Controller;\nusing LocalModels;\nusing UnityEditor;\nusing UnityEngine;\nusing UnityEngine.Rendering;\n\nnamespace Runtime\n{\n    public class TableLoad : ITableLoader\n    {\n        public Task<byte[]> LoadBytesAsync(string fileName)\n        {\n            byte[] result = null;\n            try\n            {\n                result = Resources.Load<TextAsset>($\"LocalModel/{fileName}\").bytes;\n            }\n            catch (Exception e)\n            {\n                throw new Exception($\"Load {fileName} failed\", e);\n            }\n\n            return Task.FromResult(result);\n        }\n    }\n\n    [System.Serializable]\n    public class ActionControllerWrapper\n    {\n        public int CharacterID;\n        public ActionController Controller;\n    }\n\n    public class GameManager : MonoBehaviour\n    {\n        [SerializeField] protected List<ActionControllerWrapper> controllers;\n\n\n        protected float logicTimer = 0f;\n        protected const float logicDeltaTime = 1 / 60f; // 提高到 60fps，减少卡顿\n        public LocalModelManager _localModelManager;\n\n        public static GameManager Instance;\n\n        private void Start()\n        {\n            Instance = this;\n            _localModelManager = new LocalModelManager();\n            _localModelManager.InitialiseLocalModels();\n            _localModelManager.SetTableLoader(new TableLoad());\n            _localModelManager.LoadAll(null, OnLoadTableCallback);\n        }\n\n        private void OnLoadTableCallback()\n        {\n            _localModelManager.GetTbActionDataInstance().DataList.ForEach(item => Debug.Log(item.Id));\n            foreach (var kPair in controllers)\n            {\n                var data = InitializeCharacterActionData(kPair.CharacterID);\n                kPair.Controller.Initialized(data);\n            }\n        }\n\n        private void Update()\n        {\n            InputData.Update();\n\n            // 直接使用渲染帧的 deltaTime，每帧都执行逻辑更新\n            // 这样可以彻底消除固定逻辑帧率导致的卡顿\n            RunLogicUpdate(Time.deltaTime);\n        }\n\n        // 旧的固定帧率逻辑更新（已禁用）\n        /*\n        private void LogicUpdate()\n        {\n            logicTimer += Time.deltaTime;\n            if (logicTimer >= logicDeltaTime)\n            {\n                logicTimer -= logicDeltaTime;\n\n                RunLogicUpdate(logicDeltaTime);\n            }\n        }\n        */\n\n        private void RunLogicUpdate(float logicDeltaTime)\n        {\n            foreach (var item in controllers)\n            {\n                item.Controller.LogicUpdate(logicDeltaTime);\n            }\n            //Physics.Simulate(logicDeltaTime);\n            InputData.Clear();\n        }\n\n\n        private ActionMachineInitializeData InitializeCharacterActionData(int characterId)\n        {\n            var characterData = _localModelManager.GetCharacterDataItem(characterId);\n            var result = new ActionMachineInitializeData\n            {\n                InitialStateName = characterData.FirstAction,\n                StateActions = new Dictionary<string, ActionConfig>()\n            };\n            foreach (var action in characterData.Actions)\n            {\n                var actionData = _localModelManager.GetActionDataItem(action);\n                result.StateActions.Add(actionData.Id, new ActionConfig()\n                {\n                    EnableLoop = actionData.Loop,\n                    NextActionId = actionData.NextActionId,\n                    Json = LoadActionConfig(actionData.AssetsPath),\n                    SerialID = actionData.Id\n                });\n            }\n\n            result.GlobalActions = new List<ActionConfig>();\n            foreach (var action in characterData.GlobalActions)\n            {\n                var actionData = _localModelManager.GetActionDataItem(action);\n                result.GlobalActions.Add(new ActionConfig()\n                {\n                    EnableLoop = actionData.Loop,\n                    NextActionId = null,\n                    Json = LoadActionConfig(actionData.AssetsPath),\n                    SerialID = actionData.Id\n                });\n            }\n\n            return result;\n        }\n\n        private string LoadActionConfig(string path)\n        {\n            Debug.LogError($\"LoadActionConfig {path}\");\n            return AssetDatabase.LoadAssetAtPath<TextAsset>(path + \".json\").text;\n        }\n    }\n}","numLines":144,"startLine":1,"totalLines":144}}}
{"parentUuid":"9b08fa29-5464-4861-a1d0-f2bf6269e110","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UqAdbbWs26Rbfmq8qU3Qfi","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，现在我看到了调用流程：\n\nGameManager.Update() -> RunLogicUpdate(Time.deltaTime) -> ActionController.LogicUpdate(deltaTime) -> Kcc.LogicUpdate(deltaTime)\n\n现在让我看看 ActionController 是怎么调用 Kcc 的：","signature":"EpIDCkYIChgCKkChyPiDrOPlMM/m5BvSZN5oEmJzJsvIGgHQQJrzvfmxSv4YdR6eGV8Y4KCCwHa+jPL6OrVh/E7Nkzft3QBLYMEZEgxoK6buoMWnyuZxwxYaDGZX56I9uTycqOTCxSIw50Abc+E1ozRDMYhnPNrMfrLDUHutUdMfAeSNgKSvXXqn5Hf81g8TMrAii8ef9StoKvkBHJCSWD+jPJBuLQdZvL5VIvARTTmiolkITvgDyM//Mn1hLQaVYYBwE5C8A98vCQXLynp9poCwEWLgAdz/ru9Zg7nWQedt52vGQadaj99Vvwf0DQa0ZQ6qiwyJz6ULT3CU5bC8MhDwEjqrEGtvWdGRv61KnOaytnaFyrvyKJeWeLgcX/8CHMtSlapr3mMs9QR7O262hutkgJzmeWmSMQfm6P0VhGo4MZXP4CyCT18/B5nsc0yGfGTfR82E/tfB+jPz8t2ELNWcw+z+Dv3LKlF5rBpf5eieGYX80o5cJXoYzuAAEg8p2U77ebJN8zif5yO8/vxo9XRqIKBqGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":2732,"cache_read_input_tokens":92222,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2732},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"e49bae81-1c38-4a82-9309-0f86db2884d8","timestamp":"2025-12-15T10:54:20.809Z"}
{"parentUuid":"e49bae81-1c38-4a82-9309-0f86db2884d8","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UqAdbbWs26Rbfmq8qU3Qfi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014JfQkUj1f2AbFCVAaxqzjz","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\ActionController.cs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":2732,"cache_read_input_tokens":92222,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2732},"output_tokens":168,"service_tier":"standard"}},"type":"assistant","uuid":"ad1c8ec7-646a-40ad-955c-1f7c2a89c95e","timestamp":"2025-12-15T10:54:21.338Z"}
{"parentUuid":"ad1c8ec7-646a-40ad-955c-1f7c2a89c95e","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014JfQkUj1f2AbFCVAaxqzjz","type":"tool_result","content":"     1→using System;\n     2→using System.Collections.Generic;\n     3→using Animancer;\n     4→using NBC.ActionEditor;\n     5→using UnityEngine;\n     6→\n     7→namespace ActionMachine.Runtime.Controller\n     8→{\n     9→    /// <summary>\n    10→    /// 角色动作控制器\n    11→    /// </summary>\n    12→    public sealed partial class ActionController : MonoBehaviour, IActionController\n    13→    {\n    14→        [SerializeField] [HideInInspector] private AnimancerComponent animator;\n    15→        [SerializeField] [HideInInspector] private List<CharacterNode> characterNodes;\n    16→\n    17→\n    18→        /// <summary>\n    19→        /// 动作控制器\n    20→        /// </summary>\n    21→        private IActionMachine _actionMachine;\n    22→\n    23→        private Rigidbody _rigidbody;\n    24→        private Quaternion _modelRotation;\n    25→        private Kcc _kcc;\n    26→\n    27→        public AnimancerComponent Animator => animator;\n    28→\n    29→        public Quaternion ModelRotation => _modelRotation;\n    30→\n    31→        public Kcc Kcc => _kcc;\n    32→\n    33→        private void Awake()\n    34→        {\n    35→            _rigidbody = this.GetComponent<Rigidbody>();\n    36→            _kcc = this.GetComponent<Kcc>();\n    37→        }\n    38→\n    39→        private void Update()\n    40→        {\n    41→            if (_actionMachine == null)\n    42→            {\n    43→                return;\n    44→            }\n    45→\n    46→            _actionMachine.RenderUpdate(Time.deltaTime);\n    47→            UpdateRotation();\n    48→        }\n    49→\n    50→        public void LogicUpdate(float deltaTime)\n    51→        {\n    52→            if (_actionMachine == null)\n    53→            {\n    54→                return;\n    55→            }\n    56→\n    57→            _actionMachine.LogicUpdate(deltaTime);\n    58→            _kcc.LogicUpdate(deltaTime);\n    59→        }\n    60→\n    61→        /// <summary>\n    62→        /// 获取NodeTransform\n    63→        /// </summary>\n    64→        /// <param name=\"type\"></param>\n    65→        /// <returns></returns>\n    66→        public Transform GetNodeTransform(CharacterNodeType type)\n    67→        {\n    68→            if (type == CharacterNodeType.Animator)\n    69→            {\n    70→                if (animator != null)\n    71→                {\n    72→                    return animator.transform;\n    73→                }\n    74→\n    75→                return transform;\n    76→            }\n    77→\n    78→            for (int i = 0; i < characterNodes.Count; i++)\n    79→            {\n    80→                if (characterNodes[i].type == type)\n    81→                {\n    82→                    if (characterNodes[i].bindTransform == null)\n    83→                    {\n    84→                        return animator.transform;\n    85→                    }\n    86→\n    87→                    return characterNodes[i].bindTransform;\n    88→                }\n    89→            }\n    90→\n    91→            return animator.transform;\n    92→        }\n    93→\n    94→        public void Initialized(ActionMachineInitializeData data)\n    95→        {\n    96→            _actionMachine = new ActionMachine();\n    97→            _ = _actionMachine.Initialize(data, this);\n    98→        }\n    99→\n   100→        public Rigidbody GetRigidbody()\n   101→        {\n   102→            return _rigidbody;\n   103→        }\n   104→\n   105→        private void UpdateRotation()\n   106→        {\n   107→            Vector3 velocity = _kcc.Velocity;\n   108→            velocity.y = 0f;\n   109→            if (velocity.magnitude > 0.0001f)\n   110→            {\n   111→                _modelRotation = Quaternion.LookRotation(velocity);\n   112→            }\n   113→\n   114→            var modelRoot = GetNodeTransform(CharacterNodeType.Animator);\n   115→            modelRoot.rotation = Quaternion.Lerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 10);\n   116→        }\n   117→    }\n   118→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"094e7d7e-9ab6-4900-a588-5490d72a2f70","timestamp":"2025-12-15T10:54:22.188Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\ActionController.cs","content":"using System;\nusing System.Collections.Generic;\nusing Animancer;\nusing NBC.ActionEditor;\nusing UnityEngine;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 角色动作控制器\n    /// </summary>\n    public sealed partial class ActionController : MonoBehaviour, IActionController\n    {\n        [SerializeField] [HideInInspector] private AnimancerComponent animator;\n        [SerializeField] [HideInInspector] private List<CharacterNode> characterNodes;\n\n\n        /// <summary>\n        /// 动作控制器\n        /// </summary>\n        private IActionMachine _actionMachine;\n\n        private Rigidbody _rigidbody;\n        private Quaternion _modelRotation;\n        private Kcc _kcc;\n\n        public AnimancerComponent Animator => animator;\n\n        public Quaternion ModelRotation => _modelRotation;\n\n        public Kcc Kcc => _kcc;\n\n        private void Awake()\n        {\n            _rigidbody = this.GetComponent<Rigidbody>();\n            _kcc = this.GetComponent<Kcc>();\n        }\n\n        private void Update()\n        {\n            if (_actionMachine == null)\n            {\n                return;\n            }\n\n            _actionMachine.RenderUpdate(Time.deltaTime);\n            UpdateRotation();\n        }\n\n        public void LogicUpdate(float deltaTime)\n        {\n            if (_actionMachine == null)\n            {\n                return;\n            }\n\n            _actionMachine.LogicUpdate(deltaTime);\n            _kcc.LogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 获取NodeTransform\n        /// </summary>\n        /// <param name=\"type\"></param>\n        /// <returns></returns>\n        public Transform GetNodeTransform(CharacterNodeType type)\n        {\n            if (type == CharacterNodeType.Animator)\n            {\n                if (animator != null)\n                {\n                    return animator.transform;\n                }\n\n                return transform;\n            }\n\n            for (int i = 0; i < characterNodes.Count; i++)\n            {\n                if (characterNodes[i].type == type)\n                {\n                    if (characterNodes[i].bindTransform == null)\n                    {\n                        return animator.transform;\n                    }\n\n                    return characterNodes[i].bindTransform;\n                }\n            }\n\n            return animator.transform;\n        }\n\n        public void Initialized(ActionMachineInitializeData data)\n        {\n            _actionMachine = new ActionMachine();\n            _ = _actionMachine.Initialize(data, this);\n        }\n\n        public Rigidbody GetRigidbody()\n        {\n            return _rigidbody;\n        }\n\n        private void UpdateRotation()\n        {\n            Vector3 velocity = _kcc.Velocity;\n            velocity.y = 0f;\n            if (velocity.magnitude > 0.0001f)\n            {\n                _modelRotation = Quaternion.LookRotation(velocity);\n            }\n\n            var modelRoot = GetNodeTransform(CharacterNodeType.Animator);\n            modelRoot.rotation = Quaternion.Lerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 10);\n        }\n    }\n}","numLines":118,"startLine":1,"totalLines":118}}}
{"parentUuid":"094e7d7e-9ab6-4900-a588-5490d72a2f70","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Uir6UgA28Bsm7KRZD171ty","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"现在我明白调用链了：\n\n1. GameManager.Update() \n   - 调用 RunLogicUpdate(Time.deltaTime)\n   - 内部调用 ActionController.LogicUpdate(deltaTime)\n   \n2. ActionController.LogicUpdate(deltaTime)\n   - Line 57: _actionMachine.LogicUpdate(deltaTime)\n   - Line 58: _kcc.LogicUpdate(deltaTime)\n\n3. ActionController.Update()\n   - Line 46: _actionMachine.RenderUpdate(Time.deltaTime)\n   - Line 47: UpdateRotation()\n\n4. Kcc 的更新：\n   - Kcc.LogicUpdate(deltaTime) 被 ActionController 调用\n   - Kcc.Update() 也会执行，但应该跳过（因为 UpdateModeType = Manual）\n\n现在让我分析问题：\n\n**可能的抖动原因：**\n\n1. **Kcc.Update() 中的 GetMovingPlatformVelocity()**\n   - Line 291 in Kcc.cs: 每帧都调用 `GetMovingPlatformVelocity()`\n   - 即使在 Manual 模式下，这个方法也会被调用\n   - 这可能导致平台速度计算不准确\n\n2. **UpdateRotation() 在 ActionController.Update() 中执行**\n   - Line 115 in ActionController.cs: 使用 `Time.deltaTime * 10` 做插值\n   - 这是在渲染帧更新，跟逻辑帧可能不同步\n\n3. **Kcc 的防重复机制**\n   - Kcc.Update() 中有检查 `_lastLogicUpdateFrame`（line 298）\n   - 但 GetMovingPlatformVelocity() 在这个检查之前就执行了\n\n4. **帧率同步问题**\n   - 逻辑更新和渲染更新不一致可能引起抖动\n   - 缺乏有效的插值机制会导致不平滑的移动\n\n我会仔细研究这些潜在问题，找出可能的解决方案。关键是要确保平台速度计算和旋转更新的一致性和准确性。","signature":"EscMCkYIChgCKkCHAEtjU+lG0zTfZsYp8hTxk51FJTJvbIB+/+M0Qd9hlrlsfKHN4mUa07dsRznDMut1uGMG47Ux6/Vape9hf0UmEgzbnjPYgSrb9asgDFEaDC2q9Q8vks3Z40pIoSIwifj7M8dRhV/WQoNPLTMnI04LkxZrU/1mXNtzS5H5LW7RYqh6hcYI3zt7voIfwY68Kq4LXUCC+V7wEqXCsO8fmCBPLxLaUCilKcQ8IwiRn3MDpKAAlrjulHj8CUkCzF/VjJB1VoXtbyEYObhYIj5aJfY6N1vYqbxHDU7lV47ssY2j6AlGGIlXxE2bbKyAKiSZDkQtZsHkZ2lSEeOSE67Ltp5eEoatWytc2QQs9IvR2vsvmCcL5AZ22xFd9LIccp+6oQsKE7NpAyWsJvAy+Mp6G7Uq+Bxq2hC2sSISG6Og2gWSsAJnvVqBb1Xh0cZpmBbEIrbP6JMkDapUqbgTAe0RHjZ0KgseZN5UY5sJ6k2uHyRmguuKwTIVGnCoE9vda4/+pVwhQlEvRpPBdzwdqon2sHRdtX90GsJquP6p9O6KW1w0Z2lp8DboJWdD3c1PjfwABZvCImqd+jFNLTLv09olVIE9fmvvRVcdO9stNIa+/hy4L1DHBF7Y2XZma4SDxgB6w61qEqbOMomKqAfgFfzQdyvJ/d2NbnO9LP3EEb8X1jL+PxbT+QvMZarictThFFap5VRwinaV7+8y/oxGLIPxFTbYooKJCV1b9lvksOa1JSp8jdS47Dp/ojELlRLiZXm70dYPpLUPKEG4R8Acw4yY503ktP4eOrr1tyurht6HQItrts0w2vYDcO/q1gEmc1egNPQ8XFUqdXiYjb95qxQC1D5b5bvseOn20X9JU8C1Biq1LE4DhwH9PMxWBF19wxtg4QAycRlSOsYJJJZr6dOT1MtPjUq6I6lH+H5aC9hEVSIqGP/1kXWld61CZzaWJohZ59m+f+azE/5GwBRYiN8htV3E5EjFbyiMQSH2t5zeCp7FooWnAKOot30KZW6SVWh25IivMT1xWEongnLmCzHdNxHOiWW/wRZBNOJfcP9PkKoX09By08Kq8rpIhG4Iwxc9oBW6WnLpXzeNUhbzgknvRDrr89L/VlEABTlfl1/iZCDO0eDB38+23kZOvX1nVfaqtAN3MzbL8TWuQu5s6R/d657lYRwhb1kk4cLg+N/Fz7UXhGNvkp6ecHE2IRl80+990zuuOdBe56tclv+ZVqip1WFBYZdKB9vY3mlMVqwu38TYj22ZCO1wocNaCQwrZFd3V4Z5MiDG86BIDYaYnzDxG7BRZ0FBy3ew4zDXbiJYoS67EUpYzn/vwWFMZcgcDMbaqoJ090c8VGG9VhLuLQ0ScLh0XotaanEhAkK2Mdn5fXtBPzG7jb3RIm3TeMhAw4/mXu3q7R47lbOHH1jyyui1XP1szzjGN2odhCyvsKK9BJ+4af4fkMbSIjW+/UaxLzVGVdKWKkkVSLXJxjHj1OpmTkZw2q8RcmEMl8gi0hFz5IUjXErt7za88D3AhUnrIRHE3MBBrUaZtRVMOfNLwYveGH8D3DmkjQcuaX7iCyGfTpqR0fexzQw6NCoFzOBVrgX/NIKHhG8yD/ZH3NIbW3kA8p6jwqzB9umFYqrNvQX2JzKbrEIXeCqy+Laq15QeVPqPBw6RQU4XHFxLzSp/d06tYMV85be4sHjvmc57XNLVA27lwNWLJJK5ZTszI9Vq/QF/XqbUw/GhBTWesQQnPNWahrd0sNVmfABE4cAUmURBbH9Hfn5RnSIZ75LVJ+eqc68bN0N+dT+B9w3nBANZ9yDHYZWi3hXGJeV+CD6KOknlWddqofbq34veIcf3rM4Jj4sY0ZkBB1bes4oTXAYZPlyfxU5dmHuoJ4InWRipcxWT/kcUIOBXTxT6xLwFVfuPsJOB0tSooaR5aDFJ2kRLXTER4scVklpCDIvLflmMmQeiW3fvVIoi++pw8hCbY9kGKilvaLHa3wAP/8s6BG33MrAAFJdeOXsEX8j9iQVSZSIZ4S+U9vx4Gd0BGdpBzS/QsPlD1Y5SDZbZKZ9kIl2bh2T1+X0jwiigVi60SnsEMZwdNpwLf1d47OU9wS2+NQSiY3K1s1v8bjYlrgUfi4rkhQHoTU0YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1566,"cache_read_input_tokens":94954,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1566},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"5ab91b47-546c-4a65-a674-c7f14f641a69","timestamp":"2025-12-15T10:54:45.841Z"}
{"parentUuid":"5ab91b47-546c-4a65-a674-c7f14f641a69","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Uir6UgA28Bsm7KRZD171ty","type":"message","role":"assistant","content":[{"type":"text","text":"现在我明白问题了。分析代码后，我发现了几个可能导致抖动的问题：\n\n## 问题诊断\n\n### 1. **Kcc.Update() 中的 GetMovingPlatformVelocity() 每帧都在执行**\n```csharp:Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs\n// Line 286-315\nprotected virtual void Update()\n{\n    float deltaTime = Time.deltaTime;\n    _currentDeltaTime = deltaTime;\n\n    GetMovingPlatformVelocity();  // ⚠️ 这个每帧都调用，即使在 Manual 模式\n\n    if (UpdateModeType == UpdateMode.Auto)\n    {\n        // ...\n    }\n    \n    // 速度显示更新也每帧执行\n    if (deltaTime > SMALL_VALUE)\n    {\n        _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n        // ...\n    }\n}\n```\n\n### 2. **UpdateRotation() 使用不同的时间插值**\n```csharp:Assets/_Game/Scripts/ActionMachine/Runtime/Controller/ActionController.cs\n// Line 105-116\nprivate void UpdateRotation()\n{\n    Vector3 velocity = _kcc.Velocity;\n    velocity.y = 0f;\n    if (velocity.magnitude > 0.0001f)\n    {\n        _modelRotation = Quaternion.LookRotation(velocity);\n    }\n\n    var modelRoot = GetNodeTransform(CharacterNodeType.Animator);\n    modelRoot.rotation = Quaternion.Lerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 10);\n    // ⚠️ 这里用的是渲染帧的 Time.deltaTime\n}\n```\n\n### 3. **可能的双重更新**\n虽然有 `_lastLogicUpdateFrame` 防护，但速度计算和平台速度更新仍然每帧执行。\n\n## 修复方案\n\n让我创建一个修复版本："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1566,"cache_read_input_tokens":94954,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1566},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"127d565e-15d6-4c09-ac8c-8e2095c9e917","timestamp":"2025-12-15T10:54:51.432Z"}
{"parentUuid":"127d565e-15d6-4c09-ac8c-8e2095c9e917","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Uir6UgA28Bsm7KRZD171ty","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EtrS7SaqPF1NBF3hbpoeNZ","name":"Edit","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","old_string":"        /// <summary>\n        /// 每帧更新（渲染帧）\n        /// 根据 UpdateModeType 决定是否在此执行物理计算\n        /// </summary>\n        protected virtual void Update()\n        {\n            float deltaTime = Time.deltaTime;\n            _currentDeltaTime = deltaTime;\n\n            GetMovingPlatformVelocity();\n\n            // 只在 Auto 模式下自动执行物理计算\n            // Manual 模式下，物理计算由外部 LogicUpdate 调用控制\n            if (UpdateModeType == UpdateMode.Auto)\n            {\n                // 检查是否已经在 LogicUpdate 中处理过这一帧（防止双重移动）\n                bool alreadyProcessedThisFrame = (Time.frameCount == _lastLogicUpdateFrame);\n\n                if (!alreadyProcessedThisFrame && _freeMovement)\n                {\n                    ProcessLogicUpdate(deltaTime);\n                }\n            }\n\n            // 更新速度显示（仅用于调试）\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n                _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                _renderPositionLastFrame = _transform.position;\n            }\n        }","new_string":"        /// <summary>\n        /// 每帧更新（渲染帧）\n        /// 根据 UpdateModeType 决定是否在此执行物理计算\n        /// </summary>\n        protected virtual void Update()\n        {\n            float deltaTime = Time.deltaTime;\n            _currentDeltaTime = deltaTime;\n\n            // 只在 Auto 模式下自动执行物理计算\n            // Manual 模式下，物理计算由外部 LogicUpdate 调用控制\n            if (UpdateModeType == UpdateMode.Auto)\n            {\n                // 在 Auto 模式下才更新平台速度\n                GetMovingPlatformVelocity();\n\n                // 检查是否已经在 LogicUpdate 中处理过这一帧（防止双重移动）\n                bool alreadyProcessedThisFrame = (Time.frameCount == _lastLogicUpdateFrame);\n\n                if (!alreadyProcessedThisFrame && _freeMovement)\n                {\n                    ProcessLogicUpdate(deltaTime);\n                }\n\n                // 更新速度显示（仅用于调试）\n                if (deltaTime > SMALL_VALUE)\n                {\n                    _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n                    _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _renderPositionLastFrame = _transform.position;\n                }\n            }\n        }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1566,"cache_read_input_tokens":94954,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1566},"output_tokens":2162,"service_tier":"standard"}},"type":"assistant","uuid":"c0f33af9-431a-4b9a-a5da-eff6a0af2e71","timestamp":"2025-12-15T10:55:02.098Z"}
{"type":"file-history-snapshot","messageId":"c0f33af9-431a-4b9a-a5da-eff6a0af2e71","snapshot":{"messageId":"914f6acc-1402-4804-a642-2a6ef5386e36","trackedFileBackups":{"CLAUDE.md":{"backupFileName":"0b5c4e3350b32821@v2","version":2,"backupTime":"2025-12-15T10:53:40.569Z"},"Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs":{"backupFileName":"b1c9467c2d2e4b63@v1","version":1,"backupTime":"2025-12-15T10:55:11.661Z"}},"timestamp":"2025-12-15T10:53:40.568Z"},"isSnapshotUpdate":true}
{"parentUuid":"c0f33af9-431a-4b9a-a5da-eff6a0af2e71","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EtrS7SaqPF1NBF3hbpoeNZ","type":"tool_result","content":"The file E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→using System;\n     2→using UnityEngine;\n     3→using System.Collections;\n     4→using System.Collections.Generic;\n     5→using ActionMachine.Runtime.Attributes;\n     6→\n     7→namespace ActionMachine.Runtime.Controller\n     8→{\n     9→    /// <summary>\n    10→    /// 运动学角色控制器（Kinematic Character Controller）\n    11→    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    12→    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    13→    /// \n    14→    /// 修复：添加逻辑帧与渲染帧之间的插值，解决 30fps 逻辑更新导致的卡顿\n    15→    /// </summary>\n    16→    [RequireComponent(typeof(CharacterController))]\n    17→    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    18→    public partial class Kcc : MonoBehaviour\n    19→    {\n    20→        private const float SMALL_VALUE = 0.0001f;\n    21→        private const float SPEED_ROUNDING_PRECISION = 100f;\n    22→        private const float IMPACT_THRESHOLD = 0.2f;\n    23→\n    24→        public enum GroundedComputationMode\n    25→        {\n    26→            Simple,\n    27→            Advanced\n    28→        }\n    29→\n    30→        public enum VelocityTransferMode\n    31→        {\n    32→            NoTransfer,\n    33→            InitialVelocity,\n    34→            FloorVelocity,\n    35→            Relative\n    36→        }\n    37→\n    38→        [Header(\"Update Mode Settings\")]\n    39→        [Tooltip(\"更新模式：Auto = Update 中自动执行（用于无外部 LogicUpdate 调用）, Manual = 仅通过外部 LogicUpdate 调用执行\")]\n    40→        public UpdateMode UpdateModeType = UpdateMode.Manual;\n    41→\n    42→        public enum UpdateMode\n    43→        {\n    44→            Auto,    // Update 中自动执行物理计算\n    45→            Manual   // 仅通过外部 LogicUpdate 调用执行\n    46→        }\n    47→\n    48→        [Header(\"Gravity Settings\")]\n    49→        [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n    50→        public float Gravity = 40f;\n    51→        [Tooltip(\"是否激活重力\")]\n    52→        public bool GravityActive = true;\n    53→\n    54→        [Header(\"Raycast Settings\")]\n    55→        [Tooltip(\"障碍物层遮罩\")]\n    56→        public LayerMask ObstaclesLayerMask;\n    57→        [Tooltip(\"向下射线检测长度\")]\n    58→        public float GroundedRaycastLength = 5f;\n    59→        [Tooltip(\"最小着地距离\")]\n    60→        public float MinimumGroundedDistance = 0.2f;\n    61→        [Tooltip(\"地面检测计算模式\")]\n    62→        public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n    63→        [Tooltip(\"地面法线高度阈值\")]\n    64→        public float GroundNormalHeightThreshold = 0.2f;\n    65→        [Tooltip(\"蹲伏时射线长度倍数\")]\n    66→        public float CrouchedRaycastLengthMultiplier = 1f;\n    67→        [Tooltip(\"是否执行基本方向障碍物射线检测\")]\n    68→        public bool PerformCardinalObstacleRaycastDetection = false;\n    69→\n    70→        [Header(\"Movement Settings\")]\n    71→        [Tooltip(\"最大下落速度\")]\n    72→        public float MaximumFallSpeed = 20.0f;\n    73→        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速。设为 0 表示立即到达目标速度，消除加速延迟\")]\n    74→        public float HorizontalAcceleration = 0f; // 改为 0，立即到达目标速度\n    75→        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速。设为 0 表示立即停止，消除减速延迟\")]\n    76→        public float HorizontalDeceleration = 0f; // 改为 0，立即停止\n    77→        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n    78→        public float InitialBurstMultiplier = 2.0f;\n    79→        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n    80→        public float BurstSpeedThreshold = 1.0f;\n    81→        [Tooltip(\"斜坡速度倍数曲线\")]\n    82→        public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n    83→            new Keyframe(-90, 1),\n    84→            new Keyframe(0, 1),\n    85→            new Keyframe(90, 0)\n    86→        );\n    87→        [Tooltip(\"冲击力衰减速度\")]\n    88→        public float ImpactFalloff = 5f;\n    89→\n    90→        [Header(\"Steep Surface Settings\")]\n    91→        [Tooltip(\"是否在陡峭表面滑动\")]\n    92→        public bool SlideOnSteepSurfaces = true;\n    93→        [Tooltip(\"滑动速度\")]\n    94→        public float SlidingSpeed = 15f;\n    95→        [Tooltip(\"滑动速度控制\")]\n    96→        public float SlidingSpeedControl = 0.4f;\n    97→        [Tooltip(\"滑动方向控制\")]\n    98→        public float SlidingDirectionControl = 1f;\n    99→\n   100→        [Header(\"Moving Platform Settings\")]\n   101→        [Tooltip(\"跳跃时的速度传递方式\")]\n   102→        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n   103→\n   104→        [Header(\"Runtime State - Read Only\")]\n   105→        [SerializeField, ReadOnly] private Vector3 _speed;\n   106→        [SerializeField, ReadOnly] private Vector3 _velocity;\n   107→        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n   108→        [SerializeField, ReadOnly] private Vector3 _acceleration;\n   109→        [SerializeField, ReadOnly] private bool _grounded;\n   110→        [SerializeField, ReadOnly] private bool _justGotGrounded;\n   111→        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n   112→        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n   113→        [SerializeField, ReadOnly] private float _friction;\n   114→        [SerializeField, ReadOnly] private Vector3 _addedForce;\n   115→        [SerializeField, ReadOnly] private bool _freeMovement = true;\n   116→        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n   117→        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n   118→        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n   119→\n   120→        // 公共只读属性\n   121→        public Vector3 Speed => _speed;\n   122→        public Vector3 Velocity => _velocity;\n   123→        public Vector3 VelocityLastFrame => _velocityLastFrame;\n   124→        public Vector3 Acceleration => _acceleration;\n   125→        public bool Grounded => _grounded;\n   126→        public bool JustGotGrounded => _justGotGrounded;\n   127→        public Vector3 CurrentMovement => _currentMovement;\n   128→        public Vector3 CurrentDirection => _currentDirection;\n   129→        public float Friction => _friction;\n   130→        public Vector3 AddedForce => _addedForce;\n   131→        public bool FreeMovement => _freeMovement;\n   132→        public Vector3 GroundNormal => _groundNormal;\n   133→        public Vector3 InputMoveDirection => _inputMoveDirection;\n   134→        public Vector3 TargetVelocity => _targetVelocity;\n   135→\n   136→        // 碰撞器相关属性\n   137→        public Vector3 ColliderCenter => transform.position + _characterController.center;\n   138→        public Vector3 ColliderBottom => transform.position + _characterController.center +\n   139→                                         Vector3.down * _characterController.bounds.extents.y;\n   140→        public Vector3 ColliderTop => transform.position + _characterController.center +\n   141→                                      Vector3.up * _characterController.bounds.extents.y;\n   142→        public Vector3 AppliedImpact => _impact;\n   143→\n   144→        // 环境检测属性\n   145→        public GameObject ObjectBelow { get; set; }\n   146→        public GameObject DetectedObstacleLeft { get; set; }\n   147→        public GameObject DetectedObstacleRight { get; set; }\n   148→        public GameObject DetectedObstacleUp { get; set; }\n   149→        public GameObject DetectedObstacleDown { get; set; }\n   150→        public bool CollidingWithCardinalObstacle { get; set; }\n   151→        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n   152→\n   153→        // 移动平台相关属性\n   154→        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n   155→        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n   156→        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n   157→        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n   158→\n   159→        // 组件引用\n   160→        private Transform _transform;\n   161→        private CharacterController _characterController;\n   162→\n   163→        // 碰撞器原始尺寸\n   164→        private float _originalColliderHeight;\n   165→        private Vector3 _originalColliderCenter;\n   166→\n   167→        // 运动状态追踪\n   168→        private Vector3 _positionLastFrame;\n   169→        private bool _groundedLastFrame;\n   170→        private Vector3 _impact;\n   171→        private Vector3 _lastGroundNormal = Vector3.zero;\n   172→        private bool _detached = false;\n   173→        private bool _tooSteepLastFrame;\n   174→\n   175→        // 移动平台追踪\n   176→        private Transform _movingPlatformHitCollider;\n   177→        private Transform _movingPlatformCurrentHitCollider;\n   178→        private Vector3 _movingPlatformCurrentHitColliderLocal;\n   179→        private Vector3 _movingPlatformCurrentGlobalPoint;\n   180→        private Quaternion _movingPlatformLocalRotation;\n   181→        private Quaternion _movingPlatformGlobalRotation;\n   182→        private Quaternion _lastMoveWithPlatformGlobalRotation;\n   183→        private Matrix4x4 _lastMovingPlatformMatrix;\n   184→        private Vector3 _movingPlatformVelocity;\n   185→        private bool _newMovingPlatform;\n   186→\n   187→        // 碰撞检测\n   188→        private CollisionFlags _collisionFlags;\n   189→        private Vector3 _frameVelocity = Vector3.zero;\n   190→        private Vector3 _hitPoint = Vector3.zero;\n   191→        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n   192→\n   193→        // 速度计算\n   194→        private Vector3 _newVelocity;\n   195→        private Vector3 _motion;\n   196→        private Vector3 _idealVelocity;\n   197→        private Vector3 _idealDirection;\n   198→        private Vector3 _horizontalVelocityDelta;\n   199→        private float _stickyOffset = 0f;\n   200→\n   201→        // 位置移动\n   202→        private RaycastHit _movePositionHit;\n   203→        private Vector3 _capsulePoint1;\n   204→        private Vector3 _capsulePoint2;\n   205→        private Vector3 _movePositionDirection;\n   206→        private float _movePositionDistance;\n   207→\n   208→        // 障碍物检测\n   209→        private RaycastHit _cardinalRaycast;\n   210→        private float _smallestDistance = Single.MaxValue;\n   211→        private float _longestDistance = Single.MinValue;\n   212→        private RaycastHit _smallestRaycast;\n   213→        private RaycastHit _emptyRaycast = new RaycastHit();\n   214→        private Vector3 _downRaycastsOffset;\n   215→\n   216→        // 平台移动计算\n   217→        private Vector3 _moveWithPlatformMoveDistance;\n   218→        private Vector3 _moveWithPlatformGlobalPoint;\n   219→        private Quaternion _moveWithPlatformRotationDiff;\n   220→        private Quaternion _moveWithPlatformGlobalRotation;\n   221→        private RaycastHit _raycastDownHit;\n   222→        private Vector3 _raycastDownDirection = Vector3.down;\n   223→        private RaycastHit _canGoBackHeadCheck;\n   224→        private Vector3 _originalSizeRaycastOrigin;\n   225→\n   226→        // 协程和可选组件\n   227→        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n   228→        private Rigidbody _rigidBody;\n   229→        private float _currentDeltaTime;\n   230→\n   231→        // ============== 插值相关变量（已废弃，保留用于兼容性）==============\n   232→        /// <summary>\n   233→        /// 逻辑帧的时间间隔（保留字段，用于外部调用兼容性）\n   234→        /// </summary>\n   235→        private float _logicDeltaTime = 1f / 30f;\n   236→        \n   237→        /// <summary>\n   238→        /// 上一次逻辑帧的时间戳\n   239→        /// </summary>\n   240→        private float _lastLogicUpdateTime = 0f;\n   241→\n   242→        /// <summary>\n   243→        /// 上一次执行逻辑更新的帧号（用于防止同一帧重复移动）\n   244→        /// </summary>\n   245→        private int _lastLogicUpdateFrame = -1;\n   246→\n   247→        /// <summary>\n   248→        /// 渲染帧专用的上一帧位置（用于计算速度显示）\n   249→        /// </summary>\n   250→        private Vector3 _renderPositionLastFrame = Vector3.zero;\n   251→\n   252→        /// <summary>\n   253→        /// 检查角色是否正在滑动\n   254→        /// </summary>\n   255→        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n   256→\n   257→        /// <summary>\n   258→        /// 检查角色头部是否与物体碰撞\n   259→        /// </summary>\n   260→        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n   261→\n   262→        /// <summary>\n   263→        /// 检查当前地面是否过于陡峭\n   264→        /// </summary>\n   265→        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n   266→\n   267→        /// <summary>\n   268→        /// 初始化组件和缓存引用\n   269→        /// </summary>\n   270→        protected virtual void Awake()\n   271→        {\n   272→            _characterController = GetComponent<CharacterController>();\n   273→            _transform = transform;\n   274→            _rigidBody = GetComponent<Rigidbody>();\n   275→            _originalColliderHeight = _characterController.height;\n   276→            _originalColliderCenter = _characterController.center;\n   277→            _currentDirection = _transform.forward;\n   278→            _lastLogicUpdateTime = Time.time;\n   279→            _renderPositionLastFrame = _transform.position;\n   280→        }\n   281→\n   282→        /// <summary>\n   283→        /// 每帧更新（渲染帧）\n   284→        /// 根据 UpdateModeType 决定是否在此执行物理计算\n   285→        /// </summary>\n   286→        protected virtual void Update()\n   287→        {\n   288→            float deltaTime = Time.deltaTime;\n   289→            _currentDeltaTime = deltaTime;\n   290→\n   291→            // 只在 Auto 模式下自动执行物理计算\n   292→            // Manual 模式下，物理计算由外部 LogicUpdate 调用控制\n   293→            if (UpdateModeType == UpdateMode.Auto)\n   294→            {\n   295→                // 在 Auto 模式下才更新平台速度\n   296→                GetMovingPlatformVelocity();\n   297→\n   298→                // 检查是否已经在 LogicUpdate 中处理过这一帧（防止双重移动）\n   299→                bool alreadyProcessedThisFrame = (Time.frameCount == _lastLogicUpdateFrame);\n   300→\n   301→                if (!alreadyProcessedThisFrame && _freeMovement)\n   302→                {\n   303→                    ProcessLogicUpdate(deltaTime);\n   304→                }\n   305→\n   306→                // 更新速度显示（仅用于调试）\n   307→                if (deltaTime > SMALL_VALUE)\n   308→                {\n   309→                    _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n   310→                    _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   311→                    _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   312→                    _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   313→                    _renderPositionLastFrame = _transform.position;\n   314→                }\n   315→            }\n   316→        }\n   317→\n   318→        /// <summary>\n   319→        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n   320→        /// 注意：如果外部调用了此方法，Update 将跳过这一帧的处理，避免双重移动\n   321→        /// </summary>\n   322→        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n   323→        public virtual void LogicUpdate(float deltaTime)\n   324→        {\n   325→            _logicDeltaTime = deltaTime;\n   326→            _currentDeltaTime = deltaTime;\n   327→            _lastLogicUpdateTime = Time.time;\n   328→            _lastLogicUpdateFrame = Time.frameCount; // 标记这一帧已处理\n   329→\n   330→            ProcessLogicUpdate(deltaTime);\n   331→        }\n   332→\n   333→        /// <summary>\n   334→        /// 固定时间更新（保留用于物理相关操作）\n   335→        /// </summary>\n   336→        protected virtual void FixedUpdate()\n   337→        {\n   338→            _currentDeltaTime = Time.fixedDeltaTime;\n   339→        }\n   340→\n   341→        /// <summary>\n   342→        /// 延迟更新，保存上一帧速度\n   343→        /// </summary>\n   344→        protected virtual void LateUpdate()\n   345→        {\n   346→            _velocityLastFrame = _velocity;\n   347→        }\n   348→\n   349→        /// <summary>\n   350→        /// 核心逻辑更新处理流程（使用指定的 deltaTime）\n   351→        /// 计算移动逻辑并执行 CharacterController.Move\n   352→        /// </summary>\n   353→        /// <param name=\"deltaTime\">时间增量</param>\n   354→        protected virtual void ProcessLogicUpdate(float deltaTime)\n   355→        {\n   356→            if (_transform == null || !_freeMovement)\n   357→            {\n   358→                return;\n   359→            }\n   360→\n   361→            _newVelocity = _velocity;\n   362→            _positionLastFrame = _transform.position;\n   363→\n   364→            CheckIfGrounded();\n   365→            HandleFriction();\n   366→            DetermineDirection();\n   367→            AddInput(deltaTime);\n   368→            AddGravity(deltaTime);\n   369→            MoveWithPlatform();\n   370→            ComputeVelocityDelta(deltaTime);\n   371→\n   372→            // 执行实际移动\n   373→            MoveCharacterControllerWithMotion(_motion);\n   374→            DetectNewMovingPlatform();\n   375→            ManualControllerColliderHit();\n   376→            HandleGroundContact();\n   377→\n   378→            ComputeNewVelocity(deltaTime);\n   379→        }\n   380→\n   381→        /// <summary>\n   382→        /// 使用指定的移动向量执行 CharacterController 移动\n   383→        /// </summary>\n   384→        /// <param name=\"motion\">移动向量</param>\n   385→        protected virtual void MoveCharacterControllerWithMotion(Vector3 motion)\n   386→        {\n   387→            _groundNormal = Vector3.zero;\n   388→            _collisionFlags = _characterController.Move(motion);\n   389→            _lastHitPoint = _hitPoint;\n   390→            _lastGroundNormal = _groundNormal;\n   391→        }\n   392→\n   393→        /// <summary>\n   394→        /// 处理输入并计算理想速度（包括滑坡逻辑）\n   395→        /// </summary>\n   396→        /// <param name=\"deltaTime\">时间增量</param>\n   397→        protected virtual void AddInput(float deltaTime)\n   398→        {\n   399→            if (_grounded && TooSteep())\n   400→            {\n   401→                _idealVelocity.x = _groundNormal.x;\n   402→                _idealVelocity.y = 0;\n   403→                _idealVelocity.z = _groundNormal.z;\n   404→                _idealVelocity = _idealVelocity.normalized;\n   405→                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n   406→                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n   407→                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n   408→                _idealVelocity = _idealVelocity * SlidingSpeed;\n   409→                _targetVelocity = _idealVelocity;\n   410→                _newVelocity = _idealVelocity;\n   411→                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n   412→            }\n   413→            else\n   414→            {\n   415→                _targetVelocity = _currentMovement;\n   416→\n   417→                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n   418→                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n   419→\n   420→                Vector3 newHorizontalVelocity;\n   421→\n   422→                // 如果加速度为 0，直接使用目标速度（零延迟响应）\n   423→                if (HorizontalAcceleration <= 0.001f && HorizontalDeceleration <= 0.001f)\n   424→                {\n   425→                    newHorizontalVelocity = targetHorizontalVelocity;\n   426→                }\n   427→                else if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n   428→                {\n   429→                    float effectiveAcceleration = HorizontalAcceleration;\n   430→\n   431→                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n   432→                    {\n   433→                        effectiveAcceleration *= InitialBurstMultiplier;\n   434→                    }\n   435→\n   436→                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n   437→                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n   438→\n   439→                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n   440→                    {\n   441→                        newHorizontalVelocity = targetHorizontalVelocity;\n   442→                    }\n   443→                    else\n   444→                    {\n   445→                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n   446→                    }\n   447→                }\n   448→                else\n   449→                {\n   450→                    float currentSpeed = currentHorizontalVelocity.magnitude;\n   451→                    float speedReduction = HorizontalDeceleration * deltaTime;\n   452→\n   453→                    if (currentSpeed <= speedReduction)\n   454→                    {\n   455→                        newHorizontalVelocity = Vector3.zero;\n   456→                    }\n   457→                    else\n   458→                    {\n   459→                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n   460→                    }\n   461→                }\n   462→\n   463→                _newVelocity.x = newHorizontalVelocity.x;\n   464→                _newVelocity.z = newHorizontalVelocity.z;\n   465→\n   466→                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n   467→                {\n   468→                    Vector3 floorVelocity = _frameVelocity;\n   469→                    floorVelocity.y = 0;\n   470→                    _newVelocity.x += floorVelocity.x;\n   471→                    _newVelocity.z += floorVelocity.z;\n   472→                }\n   473→\n   474→                if (_grounded)\n   475→                {\n   476→                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n   477→                    float velocityMagnitude = horizontalVelocity.magnitude;\n   478→\n   479→                    if (velocityMagnitude > SMALL_VALUE)\n   480→                    {\n   481→                        Vector3 velocityDirection = horizontalVelocity.normalized;\n   482→                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n   483→\n   484→                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n   485→                        {\n   486→                            projectedDirection.Normalize();\n   487→                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n   488→                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n   489→                        }\n   490→                    }\n   491→\n   492→                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n   493→                }\n   494→            }\n   495→        }\n   496→\n   497→        /// <summary>\n   498→        /// 应用重力到速度\n   499→        /// </summary>\n   500→        /// <param name=\"deltaTime\">时间增量</param>\n   501→        protected virtual void AddGravity(float deltaTime)\n   502→        {\n   503→            if (GravityActive)\n   504→            {\n   505→                if (_grounded)\n   506→                {\n   507→                    _newVelocity.y = -Gravity * deltaTime;\n   508→                }\n   509→                else\n   510→                {\n   511→                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n   512→                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n   513→                }\n   514→            }\n   515→            _newVelocity += _addedForce;\n   516→            _addedForce = Vector3.zero;\n   517→        }\n   518→\n   519→        /// <summary>\n   520→        /// 跟随移动平台移动\n   521→        /// </summary>\n   522→        protected virtual void MoveWithPlatform()\n   523→        {\n   524→            if (ShouldMoveWithPlatformThisFrame())\n   525→            {\n   526→                _moveWithPlatformMoveDistance = Vector3.zero;\n   527→                _moveWithPlatformGlobalPoint =\n   528→                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n   529→                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n   530→                if (_moveWithPlatformMoveDistance != Vector3.zero)\n   531→                {\n   532→                    _characterController.Move(_moveWithPlatformMoveDistance);\n   533→                }\n   534→                _moveWithPlatformGlobalRotation =\n   535→                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n   536→                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n   537→                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n   538→                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n   539→            }\n   540→        }\n   541→\n   542→        /// <summary>\n   543→        /// 计算速度增量和粘性偏移\n   544→        /// </summary>\n   545→        /// <param name=\"deltaTime\">时间增量</param>\n   546→        protected virtual void ComputeVelocityDelta(float deltaTime)\n   547→        {\n   548→            _motion = _newVelocity * deltaTime;\n   549→            _horizontalVelocityDelta.x = _motion.x;\n   550→            _horizontalVelocityDelta.y = 0f;\n   551→            _horizontalVelocityDelta.z = _motion.z;\n   552→\n   553→            // 临时禁用地面粘附，测试是否是它导致的抖动\n   554→            /*\n   555→            // 只有在有水平移动时才应用粘附偏移，避免静止时的抖动\n   556→            float horizontalSpeed = _horizontalVelocityDelta.magnitude;\n   557→            if (_grounded && horizontalSpeed > SMALL_VALUE)\n   558→            {\n   559→                // 使用较小的粘附值，避免过度向下推\n   560→                _stickyOffset = Mathf.Min(_characterController.stepOffset, horizontalSpeed);\n   561→                _motion.y -= _stickyOffset;\n   562→            }\n   563→            */\n   564→        }\n   565→\n   566→        /// <summary>\n   567→        /// 检测是否踩上新的移动平台\n   568→        /// </summary>\n   569→        protected virtual void DetectNewMovingPlatform()\n   570→        {\n   571→            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n   572→            {\n   573→                if (_movingPlatformHitCollider != null)\n   574→                {\n   575→                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n   576→                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n   577→                    _newMovingPlatform = true;\n   578→                }\n   579→            }\n   580→        }\n   581→\n   582→        /// <summary>\n   583→        /// 计算新速度和加速度\n   584→        /// </summary>\n   585→        /// <param name=\"deltaTime\">时间增量</param>\n   586→        protected virtual void ComputeNewVelocity(float deltaTime)\n   587→        {\n   588→            _velocity = _newVelocity;\n   589→            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n   590→        }\n   591→\n   592→        /// <summary>\n   593→        /// 处理地面接触状态和平台速度传递\n   594→        /// </summary>\n   595→        protected virtual void HandleGroundContact()\n   596→        {\n   597→            _grounded = _characterController.isGrounded;\n   598→            if (_grounded && !IsGroundedTest())\n   599→            {\n   600→                _grounded = false;\n   601→                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n   602→                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n   603→                {\n   604→                    _frameVelocity = _movingPlatformVelocity;\n   605→                    _velocity += _movingPlatformVelocity;\n   606→                }\n   607→            }\n   608→            else if (!_grounded && IsGroundedTest())\n   609→            {\n   610→                if (_detached && _velocity.y <= 0)\n   611→                {\n   612→                    _grounded = true;\n   613→                    _detached = false;\n   614→                }\n   615→                SubtractNewPlatformVelocity();\n   616→            }\n   617→\n   618→            if (ShouldMoveWithPlatformThisFrame())\n   619→            {\n   620→                _movingPlatformCurrentGlobalPoint = _transform.position;\n   621→                _movingPlatformCurrentHitColliderLocal =\n   622→                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n   623→                _movingPlatformGlobalRotation = _transform.rotation;\n   624→                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n   625→                                               _movingPlatformGlobalRotation;\n   626→            }\n   627→\n   628→            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n   629→            _tooSteepLastFrame = TooSteep();\n   630→        }\n   631→\n   632→        /// <summary>\n   633→        /// 计算当前速度（仅用于显示，不影响逻辑）\n   634→        /// </summary>\n   635→        /// <param name=\"deltaTime\">时间增量</param>\n   636→        protected virtual void ComputeSpeed(float deltaTime)\n   637→        {\n   638→            // 使用渲染帧专用的位置记录，避免干扰逻辑帧\n   639→            if (deltaTime > SMALL_VALUE)\n   640→            {\n   641→                _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n   642→            }\n   643→            _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   644→            _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   645→            _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   646→\n   647→            _renderPositionLastFrame = _transform.position;\n   648→        }\n   649→\n   650→        /// <summary>\n   651→        /// 根据当前移动向量确定方向\n   652→        /// </summary>\n   653→        protected virtual void DetermineDirection()\n   654→        {\n   655→            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n   656→            {\n   657→                _currentDirection = _currentMovement.normalized;\n   658→            }\n   659→        }\n   660→\n   661→        /// <summary>\n   662→        /// 处理摩擦力（预留方法，可在子类中实现）\n   663→        /// </summary>\n   664→        protected virtual void HandleFriction()\n   665→        {\n   666→        }\n   667→\n   668→        /// <summary>\n   669→        /// 检查是否刚刚着地\n   670→        /// </summary>\n   671→        protected virtual void CheckIfGrounded()\n   672→        {\n   673→            _justGotGrounded = !_groundedLastFrame && _grounded;\n   674→            _groundedLastFrame = _grounded;\n   675→        }\n   676→\n   677→        /// <summary>\n   678→        /// 手动触发碰撞器碰撞处理\n   679→        /// </summary>\n   680→        protected virtual void ManualControllerColliderHit()\n   681→        {\n   682→            HandleAdvancedGroundDetection();\n   683→        }\n   684→\n   685→        /// <summary>\n   686→        /// 高级地面检测（使用多方向射线）\n   687→        /// </summary>\n   688→        protected virtual void HandleAdvancedGroundDetection()\n   689→        {\n   690→            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n   691→            {\n   692→                return;\n   693→            }\n   694→\n   695→            _smallestDistance = Single.MaxValue;\n   696→            _longestDistance = Single.MinValue;\n   697→            _smallestRaycast = _emptyRaycast;\n   698→            float offset = _characterController.radius;\n   699→            _downRaycastsOffset = Vector3.zero;\n   700→            CastRayDownwards();\n   701→            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n   702→            CastRayDownwards();\n   703→            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n   704→            CastRayDownwards();\n   705→            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n   706→            CastRayDownwards();\n   707→            _downRaycastsOffset = new Vector3(0f, offset, offset);\n   708→            CastRayDownwards();\n   709→\n   710→            if (_smallestRaycast.collider != null)\n   711→            {\n   712→                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n   713→                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n   714→                {\n   715→                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n   716→                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n   717→                    {\n   718→                        _groundNormal = _smallestRaycast.normal;\n   719→                    }\n   720→                    else\n   721→                    {\n   722→                        _groundNormal = _lastGroundNormal;\n   723→                    }\n   724→\n   725→                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n   726→                    _hitPoint = _smallestRaycast.point;\n   727→                    _frameVelocity = Vector3.zero;\n   728→                }\n   729→            }\n   730→        }\n   731→\n   732→        /// <summary>\n   733→        /// 向下发射射线检测地面\n   734→        /// </summary>\n   735→        protected virtual void CastRayDownwards()\n   736→        {\n   737→            if (_smallestDistance <= MinimumGroundedDistance)\n   738→            {\n   739→                return;\n   740→            }\n   741→\n   742→            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n   743→                _raycastDownDirection, out _raycastDownHit,\n   744→                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n   745→\n   746→            if (_raycastDownHit.collider != null)\n   747→            {\n   748→                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n   749→                if (adjustedDistance < _smallestDistance)\n   750→                {\n   751→                    _smallestDistance = adjustedDistance;\n   752→                    _smallestRaycast = _raycastDownHit;\n   753→                }\n   754→                if (adjustedDistance > _longestDistance)\n   755→                {\n   756→                    _longestDistance = adjustedDistance;\n   757→                }\n   758→            }\n   759→        }\n   760→\n   761→        /// <summary>\n   762→        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n   763→        /// </summary>\n   764→        protected float AdjustDistance(float distance)\n   765→        {\n   766→            return distance - _characterController.height / 2f - _characterController.skinWidth;\n   767→        }\n   768→\n   769→        /// <summary>\n   770→        /// 测试是否真正着地\n   771→        /// </summary>\n   772→        protected virtual bool IsGroundedTest()\n   773→        {\n   774→            bool grounded = false;\n   775→            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n   776→            {\n   777→                if (_smallestDistance <= MinimumGroundedDistance)\n   778→                {\n   779→                    grounded = _groundNormal.y > 0.01f;\n   780→                }\n   781→            }\n   782→            else\n   783→            {\n   784→                grounded = _characterController.isGrounded;\n   785→                _groundNormal = Vector3.up;\n   786→            }\n   787→            return grounded;\n   788→        }\n   789→\n   790→        /// <summary>\n   791→        /// 获取移动平台速度\n   792→        /// </summary>\n   793→        protected virtual void GetMovingPlatformVelocity()\n   794→        {\n   795→            if (_movingPlatformCurrentHitCollider != null)\n   796→            {\n   797→                if (!_newMovingPlatform && _currentDeltaTime > SMALL_VALUE)\n   798→                {\n   799→                    _movingPlatformVelocity = (\n   800→                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n   801→                            _movingPlatformCurrentHitColliderLocal)\n   802→                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n   803→                    ) / _currentDeltaTime;\n   804→                }\n   805→                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n   806→                _newMovingPlatform = false;\n   807→            }\n   808→            else\n   809→            {\n   810→                _movingPlatformVelocity = Vector3.zero;\n   811→            }\n   812→        }\n   813→\n   814→        /// <summary>\n   815→        /// 减去新平台速度（处理平台切换）\n   816→        /// </summary>\n   817→        protected virtual void SubtractNewPlatformVelocity()\n   818→        {\n   819→            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n   820→                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n   821→            {\n   822→                if (_newMovingPlatform)\n   823→                {\n   824→                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n   825→                }\n   826→                else\n   827→                {\n   828→                    _velocity -= _movingPlatformVelocity;\n   829→                }\n   830→            }\n   831→        }\n   832→\n   833→        /// <summary>\n   834→        /// 协程：延迟减去平台速度\n   835→        /// </summary>\n   836→        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n   837→        {\n   838→            Transform platform = _movingPlatformCurrentHitCollider;\n   839→            yield return _waitForFixedUpdate;\n   840→            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n   841→            {\n   842→                yield return null;\n   843→            }\n   844→            _velocity -= _movingPlatformVelocity;\n   845→        }\n   846→\n   847→        /// <summary>\n   848→        /// 判断是否应该跟随平台移动\n   849→        /// </summary>\n   850→        protected virtual bool ShouldMoveWithPlatformThisFrame()\n   851→        {\n   852→            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n   853→                   && _movingPlatformCurrentHitCollider != null;\n   854→        }\n   855→\n   856→        /// <summary>\n   857→        /// 应用冲击力并逐渐衰减\n   858→        /// </summary>\n   859→        protected virtual void ApplyImpact()\n   860→        {\n   861→            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n   862→            {\n   863→                _characterController.Move(_impact * _currentDeltaTime);\n   864→            }\n   865→            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * _currentDeltaTime);\n   866→        }\n   867→\n   868→        /// <summary>\n   869→        /// 从地面分离（用于跳跃等）\n   870→        /// </summary>\n   871→        public virtual void DetachFromGround()\n   872→        {\n   873→            _detached = true;\n   874→        }\n   875→\n   876→        /// <summary>\n   877→        /// 从移动平台分离\n   878→        /// </summary>\n   879→        public virtual void DetachFromMovingPlatform()\n   880→        {\n   881→            _movingPlatformVelocity = Vector3.zero;\n   882→            _movingPlatformCurrentHitCollider = null;\n   883→            _movingPlatformHitCollider = null;\n   884→        }\n   885→\n   886→        /// <summary>\n   887→        /// 设置重力是否激活\n   888→        /// </summary>\n   889→        public virtual void SetGravityActive(bool status)\n   890→        {\n   891→            GravityActive = status;\n   892→        }\n   893→\n   894→        /// <summary>\n   895→        /// 添加外部力（会在下一帧应用）\n   896→        /// </summary>\n   897→        public virtual void AddForce(Vector3 movement)\n   898→        {\n   899→            _addedForce += movement;\n   900→        }\n   901→\n   902→        /// <summary>\n   903→        /// 施加瞬时冲击力\n   904→        /// </summary>\n   905→        /// <param name=\"direction\">冲击方向</param>\n   906→        /// <param name=\"force\">冲击力大小</param>\n   907→        public virtual void Impact(Vector3 direction, float force)\n   908→        {\n   909→            direction = direction.normalized;\n   910→            if (direction.y < 0)\n   911→            {\n   912→                direction.y = -direction.y;\n   913→            }\n   914→            _impact += direction.normalized * force;\n   915→        }\n   916→\n   917→        /// <summary>\n   918→        /// 设置移动向量（通常由输入系统调用）\n   919→        /// </summary>\n   920→        /// <param name=\"movement\">移动向量</param>\n   921→        public virtual void SetMovement(Vector3 movement)\n   922→        {\n   923→            _currentMovement = movement;\n   924→            Vector3 directionVector = movement;\n   925→            if (directionVector != Vector3.zero)\n   926→            {\n   927→                float directionLength = directionVector.magnitude;\n   928→                directionVector = directionVector / directionLength;\n   929→                directionLength = Mathf.Min(1, directionLength);\n   930→                directionLength = directionLength * directionLength;\n   931→                directionVector = directionVector * directionLength;\n   932→            }\n   933→            _inputMoveDirection = transform.rotation * directionVector;\n   934→        }\n   935→\n   936→        /// <summary>\n   937→        /// 移动到指定位置（带碰撞检测）\n   938→        /// </summary>\n   939→        /// <param name=\"newPosition\">目标位置</param>\n   940→        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n   941→        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n   942→        {\n   943→            _movePositionDirection = newPosition - transform.position;\n   944→            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n   945→\n   946→            _capsulePoint1 = transform.position\n   947→                             + _characterController.center\n   948→                             - (Vector3.up * _characterController.height / 2f)\n   949→                             + Vector3.up * _characterController.skinWidth\n   950→                             + Vector3.up * _characterController.radius;\n   951→\n   952→            _capsulePoint2 = transform.position\n   953→                             + _characterController.center\n   954→                             + (Vector3.up * _characterController.height / 2f)\n   955→                             - Vector3.up * _characterController.skinWidth\n   956→                             - Vector3.up * _characterController.radius;\n   957→\n   958→            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n   959→                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n   960→            {\n   961→                transform.position = newPosition;\n   962→            }\n   963→        }\n   964→\n   965→        /// <summary>\n   966→        /// 调整碰撞器高度（用于蹲伏等）\n   967→        /// </summary>\n   968→        /// <param name=\"newHeight\">新高度</param>\n   969→        /// <param name=\"translateCenter\">是否平移中心点</param>\n   970→        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n   971→        {\n   972→            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n   973→            _characterController.height = newHeight;\n   974→            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n   975→            if (translateCenter)\n   976→            {\n   977→                transform.Translate((newYOffset / 2f) * Vector3.up);\n   978→            }\n   979→        }\n   980→\n   981→        /// <summary>\n   982→        /// 重置碰撞器尺寸到原始大小\n   983→        /// </summary>\n   984→        public virtual void ResetColliderSize()\n   985→        {\n   986→            _characterController.height = _originalColliderHeight;\n   987→            _characterController.center = _originalColliderCenter;\n   988→        }\n   989→\n   990→        /// <summary>\n   991→        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n   992→        /// </summary>\n   993→        public virtual bool CanGoBackToOriginalSize()\n   994→        {\n   995→            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n   996→            {\n   997→                return true;\n   998→            }\n   999→\n  1000→            float headCheckDistance =\n  1001→                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n  1002→            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n  1003→            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n  1004→                ObstaclesLayerMask, Color.cyan, true);\n  1005→\n  1006→            return _canGoBackHeadCheck.collider == null;\n  1007→        }\n  1008→\n  1009→        /// <summary>\n  1010→        /// 启用碰撞\n  1011→        /// </summary>\n  1012→        public virtual void CollisionsOn()\n  1013→        {\n  1014→            if (_characterController != null)\n  1015→            {\n  1016→                _characterController.enabled = true;\n  1017→            }\n  1018→        }\n  1019→\n  1020→        /// <summary>\n  1021→        /// 禁用碰撞\n  1022→        /// </summary>\n  1023→        public virtual void CollisionsOff()\n  1024→        {\n  1025→            if (_characterController != null)\n  1026→            {\n  1027→                _characterController.enabled = false;\n  1028→            }\n  1029→        }\n  1030→\n  1031→        /// <summary>\n  1032→        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n  1033→        /// </summary>\n  1034→        public virtual void SetKinematic(bool state)\n  1035→        {\n  1036→            _rigidBody.isKinematic = state;\n  1037→        }\n  1038→\n  1039→        /// <summary>\n  1040→        /// 设置是否允许自由移动\n  1041→        /// </summary>\n  1042→        public virtual void SetFreeMovement(bool state)\n  1043→        {\n  1044→            _freeMovement = state;\n  1045→        }\n  1046→\n  1047→        /// <summary>\n  1048→        /// 检测四个基本方向的障碍物\n  1049→        /// </summary>\n  1050→        /// <param name=\"distance\">检测距离</param>\n  1051→        /// <param name=\"offset\">起始偏移</param>\n  1052→        public virtual void DetectObstacles(float distance, Vector3 offset)\n  1053→        {\n  1054→            if (!PerformCardinalObstacleRaycastDetection)\n  1055→            {\n  1056→                return;\n  1057→            }\n  1058→\n  1059→            CollidingWithCardinalObstacle = false;\n  1060→\n  1061→            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n  1062→                ObstaclesLayerMask, Color.yellow, true);\n  1063→            if (_cardinalRaycast.collider != null)\n  1064→            {\n  1065→                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n  1066→                CollidingWithCardinalObstacle = true;\n  1067→            }\n  1068→            else\n  1069→            {\n  1070→                DetectedObstacleRight = null;\n  1071→            }\n  1072→\n  1073→            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n  1074→                ObstaclesLayerMask, Color.yellow, true);\n  1075→            if (_cardinalRaycast.collider != null)\n  1076→            {\n  1077→                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n  1078→                CollidingWithCardinalObstacle = true;\n  1079→            }\n  1080→            else\n  1081→            {\n  1082→                DetectedObstacleLeft = null;\n  1083→            }\n  1084→\n  1085→            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n  1086→                ObstaclesLayerMask, Color.yellow, true);\n  1087→            if (_cardinalRaycast.collider != null)\n  1088→            {\n  1089→                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n  1090→                CollidingWithCardinalObstacle = true;\n  1091→            }\n  1092→            else\n  1093→            {\n  1094→                DetectedObstacleUp = null;\n  1095→            }\n  1096→\n  1097→            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n  1098→                ObstaclesLayerMask, Color.yellow, true);\n  1099→            if (_cardinalRaycast.collider != null)\n  1100→            {\n  1101→                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n  1102→                CollidingWithCardinalObstacle = true;\n  1103→            }\n  1104→            else\n  1105→            {\n  1106→                DetectedObstacleDown = null;\n  1107→            }\n  1108→        }\n  1109→\n  1110→        /// <summary>\n  1111→        /// 重置控制器到初始状态\n  1112→        /// </summary>\n  1113→        public virtual void ResetController()\n  1114→        {\n  1115→            _impact = Vector3.zero;\n  1116→            GravityActive = true;\n  1117→            _speed = Vector3.zero;\n  1118→            _velocity = Vector3.zero;\n  1119→            _velocityLastFrame = Vector3.zero;\n  1120→            _acceleration = Vector3.zero;\n  1121→            _grounded = true;\n  1122→            _justGotGrounded = false;\n  1123→            _currentMovement = Vector3.zero;\n  1124→            _currentDirection = Vector3.zero;\n  1125→            _addedForce = Vector3.zero;\n  1126→            _idealDirection = Vector3.zero;\n  1127→            _idealVelocity = Vector3.zero;\n  1128→            _newVelocity = Vector3.zero;\n  1129→            _movingPlatformVelocity = Vector3.zero;\n  1130→            _movingPlatformCurrentHitCollider = null;\n  1131→            _movingPlatformHitCollider = null;\n  1132→            _lastGroundNormal = Vector3.zero;\n  1133→            _detached = false;\n  1134→            _frameVelocity = Vector3.zero;\n  1135→            _hitPoint = Vector3.zero;\n  1136→            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n  1137→\n  1138→            _renderPositionLastFrame = _transform != null ? _transform.position : Vector3.zero;\n  1139→            _lastLogicUpdateTime = Time.time;\n  1140→            _lastLogicUpdateFrame = -1;\n  1141→\n  1142→            if (_rigidBody != null)\n  1143→            {\n  1144→                bool isKinematic = _rigidBody.isKinematic;\n  1145→                _rigidBody.isKinematic = false;\n  1146→                _rigidBody.linearVelocity = Vector3.zero;\n  1147→                _rigidBody.angularVelocity = Vector3.zero;\n  1148→                _rigidBody.isKinematic = isKinematic;\n  1149→            }\n  1150→        }\n  1151→\n  1152→        /// <summary>\n  1153→        /// 3D 射线检测辅助方法（带可视化调试）\n  1154→        /// </summary>\n  1155→        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n  1156→            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n  1157→        {\n  1158→            RaycastHit hit;\n  1159→            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n  1160→            if (Camera.current != null && (drawInSceneView || drawInGameView))\n  1161→            {\n  1162→                Debug.DrawRay(origin, direction * distance, color);\n  1163→            }\n  1164→            return hit;\n  1165→        }\n  1166→    }\n  1167→}\n  1168→"}]},"uuid":"326732cd-05fb-4296-bef4-d1a630012f3c","timestamp":"2025-12-15T10:55:11.667Z","toolUseResult":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","oldString":"using System;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing ActionMachine.Runtime.Attributes;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 运动学角色控制器（Kinematic Character Controller）\n    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    /// \n    /// 修复：添加逻辑帧与渲染帧之间的插值，解决 30fps 逻辑更新导致的卡顿\n    /// </summary>\n    [RequireComponent(typeof(CharacterController))]\n    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    public partial class Kcc : MonoBehaviour\n    {\n        private const float SMALL_VALUE = 0.0001f;\n        private const float SPEED_ROUNDING_PRECISION = 100f;\n        private const float IMPACT_THRESHOLD = 0.2f;\n\n        public enum GroundedComputationMode\n        {\n            Simple,\n            Advanced\n        }\n\n        public enum VelocityTransferMode\n        {\n            NoTransfer,\n            InitialVelocity,\n            FloorVelocity,\n            Relative\n        }\n\n        [Header(\"Update Mode Settings\")]\n        [Tooltip(\"更新模式：Auto = Update 中自动执行（用于无外部 LogicUpdate 调用）, Manual = 仅通过外部 LogicUpdate 调用执行\")]\n        public UpdateMode UpdateModeType = UpdateMode.Manual;\n\n        public enum UpdateMode\n        {\n            Auto,    // Update 中自动执行物理计算\n            Manual   // 仅通过外部 LogicUpdate 调用执行\n        }\n\n        [Header(\"Gravity Settings\")]\n        [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n        public float Gravity = 40f;\n        [Tooltip(\"是否激活重力\")]\n        public bool GravityActive = true;\n\n        [Header(\"Raycast Settings\")]\n        [Tooltip(\"障碍物层遮罩\")]\n        public LayerMask ObstaclesLayerMask;\n        [Tooltip(\"向下射线检测长度\")]\n        public float GroundedRaycastLength = 5f;\n        [Tooltip(\"最小着地距离\")]\n        public float MinimumGroundedDistance = 0.2f;\n        [Tooltip(\"地面检测计算模式\")]\n        public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n        [Tooltip(\"地面法线高度阈值\")]\n        public float GroundNormalHeightThreshold = 0.2f;\n        [Tooltip(\"蹲伏时射线长度倍数\")]\n        public float CrouchedRaycastLengthMultiplier = 1f;\n        [Tooltip(\"是否执行基本方向障碍物射线检测\")]\n        public bool PerformCardinalObstacleRaycastDetection = false;\n\n        [Header(\"Movement Settings\")]\n        [Tooltip(\"最大下落速度\")]\n        public float MaximumFallSpeed = 20.0f;\n        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速。设为 0 表示立即到达目标速度，消除加速延迟\")]\n        public float HorizontalAcceleration = 0f; // 改为 0，立即到达目标速度\n        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速。设为 0 表示立即停止，消除减速延迟\")]\n        public float HorizontalDeceleration = 0f; // 改为 0，立即停止\n        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n        public float InitialBurstMultiplier = 2.0f;\n        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n        public float BurstSpeedThreshold = 1.0f;\n        [Tooltip(\"斜坡速度倍数曲线\")]\n        public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n            new Keyframe(-90, 1),\n            new Keyframe(0, 1),\n            new Keyframe(90, 0)\n        );\n        [Tooltip(\"冲击力衰减速度\")]\n        public float ImpactFalloff = 5f;\n\n        [Header(\"Steep Surface Settings\")]\n        [Tooltip(\"是否在陡峭表面滑动\")]\n        public bool SlideOnSteepSurfaces = true;\n        [Tooltip(\"滑动速度\")]\n        public float SlidingSpeed = 15f;\n        [Tooltip(\"滑动速度控制\")]\n        public float SlidingSpeedControl = 0.4f;\n        [Tooltip(\"滑动方向控制\")]\n        public float SlidingDirectionControl = 1f;\n\n        [Header(\"Moving Platform Settings\")]\n        [Tooltip(\"跳跃时的速度传递方式\")]\n        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Runtime State - Read Only\")]\n        [SerializeField, ReadOnly] private Vector3 _speed;\n        [SerializeField, ReadOnly] private Vector3 _velocity;\n        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n        [SerializeField, ReadOnly] private Vector3 _acceleration;\n        [SerializeField, ReadOnly] private bool _grounded;\n        [SerializeField, ReadOnly] private bool _justGotGrounded;\n        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n        [SerializeField, ReadOnly] private float _friction;\n        [SerializeField, ReadOnly] private Vector3 _addedForce;\n        [SerializeField, ReadOnly] private bool _freeMovement = true;\n        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n\n        // 公共只读属性\n        public Vector3 Speed => _speed;\n        public Vector3 Velocity => _velocity;\n        public Vector3 VelocityLastFrame => _velocityLastFrame;\n        public Vector3 Acceleration => _acceleration;\n        public bool Grounded => _grounded;\n        public bool JustGotGrounded => _justGotGrounded;\n        public Vector3 CurrentMovement => _currentMovement;\n        public Vector3 CurrentDirection => _currentDirection;\n        public float Friction => _friction;\n        public Vector3 AddedForce => _addedForce;\n        public bool FreeMovement => _freeMovement;\n        public Vector3 GroundNormal => _groundNormal;\n        public Vector3 InputMoveDirection => _inputMoveDirection;\n        public Vector3 TargetVelocity => _targetVelocity;\n\n        // 碰撞器相关属性\n        public Vector3 ColliderCenter => transform.position + _characterController.center;\n        public Vector3 ColliderBottom => transform.position + _characterController.center +\n                                         Vector3.down * _characterController.bounds.extents.y;\n        public Vector3 ColliderTop => transform.position + _characterController.center +\n                                      Vector3.up * _characterController.bounds.extents.y;\n        public Vector3 AppliedImpact => _impact;\n\n        // 环境检测属性\n        public GameObject ObjectBelow { get; set; }\n        public GameObject DetectedObstacleLeft { get; set; }\n        public GameObject DetectedObstacleRight { get; set; }\n        public GameObject DetectedObstacleUp { get; set; }\n        public GameObject DetectedObstacleDown { get; set; }\n        public bool CollidingWithCardinalObstacle { get; set; }\n        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n\n        // 移动平台相关属性\n        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n\n        // 组件引用\n        private Transform _transform;\n        private CharacterController _characterController;\n\n        // 碰撞器原始尺寸\n        private float _originalColliderHeight;\n        private Vector3 _originalColliderCenter;\n\n        // 运动状态追踪\n        private Vector3 _positionLastFrame;\n        private bool _groundedLastFrame;\n        private Vector3 _impact;\n        private Vector3 _lastGroundNormal = Vector3.zero;\n        private bool _detached = false;\n        private bool _tooSteepLastFrame;\n\n        // 移动平台追踪\n        private Transform _movingPlatformHitCollider;\n        private Transform _movingPlatformCurrentHitCollider;\n        private Vector3 _movingPlatformCurrentHitColliderLocal;\n        private Vector3 _movingPlatformCurrentGlobalPoint;\n        private Quaternion _movingPlatformLocalRotation;\n        private Quaternion _movingPlatformGlobalRotation;\n        private Quaternion _lastMoveWithPlatformGlobalRotation;\n        private Matrix4x4 _lastMovingPlatformMatrix;\n        private Vector3 _movingPlatformVelocity;\n        private bool _newMovingPlatform;\n\n        // 碰撞检测\n        private CollisionFlags _collisionFlags;\n        private Vector3 _frameVelocity = Vector3.zero;\n        private Vector3 _hitPoint = Vector3.zero;\n        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n        // 速度计算\n        private Vector3 _newVelocity;\n        private Vector3 _motion;\n        private Vector3 _idealVelocity;\n        private Vector3 _idealDirection;\n        private Vector3 _horizontalVelocityDelta;\n        private float _stickyOffset = 0f;\n\n        // 位置移动\n        private RaycastHit _movePositionHit;\n        private Vector3 _capsulePoint1;\n        private Vector3 _capsulePoint2;\n        private Vector3 _movePositionDirection;\n        private float _movePositionDistance;\n\n        // 障碍物检测\n        private RaycastHit _cardinalRaycast;\n        private float _smallestDistance = Single.MaxValue;\n        private float _longestDistance = Single.MinValue;\n        private RaycastHit _smallestRaycast;\n        private RaycastHit _emptyRaycast = new RaycastHit();\n        private Vector3 _downRaycastsOffset;\n\n        // 平台移动计算\n        private Vector3 _moveWithPlatformMoveDistance;\n        private Vector3 _moveWithPlatformGlobalPoint;\n        private Quaternion _moveWithPlatformRotationDiff;\n        private Quaternion _moveWithPlatformGlobalRotation;\n        private RaycastHit _raycastDownHit;\n        private Vector3 _raycastDownDirection = Vector3.down;\n        private RaycastHit _canGoBackHeadCheck;\n        private Vector3 _originalSizeRaycastOrigin;\n\n        // 协程和可选组件\n        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        private float _currentDeltaTime;\n\n        // ============== 插值相关变量（已废弃，保留用于兼容性）==============\n        /// <summary>\n        /// 逻辑帧的时间间隔（保留字段，用于外部调用兼容性）\n        /// </summary>\n        private float _logicDeltaTime = 1f / 30f;\n        \n        /// <summary>\n        /// 上一次逻辑帧的时间戳\n        /// </summary>\n        private float _lastLogicUpdateTime = 0f;\n\n        /// <summary>\n        /// 上一次执行逻辑更新的帧号（用于防止同一帧重复移动）\n        /// </summary>\n        private int _lastLogicUpdateFrame = -1;\n\n        /// <summary>\n        /// 渲染帧专用的上一帧位置（用于计算速度显示）\n        /// </summary>\n        private Vector3 _renderPositionLastFrame = Vector3.zero;\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n        /// <summary>\n        /// 检查角色头部是否与物体碰撞\n        /// </summary>\n        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n\n        /// <summary>\n        /// 检查当前地面是否过于陡峭\n        /// </summary>\n        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n\n        /// <summary>\n        /// 初始化组件和缓存引用\n        /// </summary>\n        protected virtual void Awake()\n        {\n            _characterController = GetComponent<CharacterController>();\n            _transform = transform;\n            _rigidBody = GetComponent<Rigidbody>();\n            _originalColliderHeight = _characterController.height;\n            _originalColliderCenter = _characterController.center;\n            _currentDirection = _transform.forward;\n            _lastLogicUpdateTime = Time.time;\n            _renderPositionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 每帧更新（渲染帧）\n        /// 根据 UpdateModeType 决定是否在此执行物理计算\n        /// </summary>\n        protected virtual void Update()\n        {\n            float deltaTime = Time.deltaTime;\n            _currentDeltaTime = deltaTime;\n\n            GetMovingPlatformVelocity();\n\n            // 只在 Auto 模式下自动执行物理计算\n            // Manual 模式下，物理计算由外部 LogicUpdate 调用控制\n            if (UpdateModeType == UpdateMode.Auto)\n            {\n                // 检查是否已经在 LogicUpdate 中处理过这一帧（防止双重移动）\n                bool alreadyProcessedThisFrame = (Time.frameCount == _lastLogicUpdateFrame);\n\n                if (!alreadyProcessedThisFrame && _freeMovement)\n                {\n                    ProcessLogicUpdate(deltaTime);\n                }\n            }\n\n            // 更新速度显示（仅用于调试）\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n                _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                _renderPositionLastFrame = _transform.position;\n            }\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 注意：如果外部调用了此方法，Update 将跳过这一帧的处理，避免双重移动\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            _logicDeltaTime = deltaTime;\n            _currentDeltaTime = deltaTime;\n            _lastLogicUpdateTime = Time.time;\n            _lastLogicUpdateFrame = Time.frameCount; // 标记这一帧已处理\n\n            ProcessLogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 固定时间更新（保留用于物理相关操作）\n        /// </summary>\n        protected virtual void FixedUpdate()\n        {\n            _currentDeltaTime = Time.fixedDeltaTime;\n        }\n\n        /// <summary>\n        /// 延迟更新，保存上一帧速度\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            _velocityLastFrame = _velocity;\n        }\n\n        /// <summary>\n        /// 核心逻辑更新处理流程（使用指定的 deltaTime）\n        /// 计算移动逻辑并执行 CharacterController.Move\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ProcessLogicUpdate(float deltaTime)\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            CheckIfGrounded();\n            HandleFriction();\n            DetermineDirection();\n            AddInput(deltaTime);\n            AddGravity(deltaTime);\n            MoveWithPlatform();\n            ComputeVelocityDelta(deltaTime);\n\n            // 执行实际移动\n            MoveCharacterControllerWithMotion(_motion);\n            DetectNewMovingPlatform();\n            ManualControllerColliderHit();\n            HandleGroundContact();\n\n            ComputeNewVelocity(deltaTime);\n        }\n\n        /// <summary>\n        /// 使用指定的移动向量执行 CharacterController 移动\n        /// </summary>\n        /// <param name=\"motion\">移动向量</param>\n        protected virtual void MoveCharacterControllerWithMotion(Vector3 motion)\n        {\n            _groundNormal = Vector3.zero;\n            _collisionFlags = _characterController.Move(motion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n\n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n                _idealVelocity = _idealVelocity * SlidingSpeed;\n                _targetVelocity = _idealVelocity;\n                _newVelocity = _idealVelocity;\n                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n            }\n            else\n            {\n                _targetVelocity = _currentMovement;\n\n                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n\n                Vector3 newHorizontalVelocity;\n\n                // 如果加速度为 0，直接使用目标速度（零延迟响应）\n                if (HorizontalAcceleration <= 0.001f && HorizontalDeceleration <= 0.001f)\n                {\n                    newHorizontalVelocity = targetHorizontalVelocity;\n                }\n                else if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                {\n                    float effectiveAcceleration = HorizontalAcceleration;\n\n                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n                    {\n                        effectiveAcceleration *= InitialBurstMultiplier;\n                    }\n\n                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n\n                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n                    {\n                        newHorizontalVelocity = targetHorizontalVelocity;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n                    }\n                }\n                else\n                {\n                    float currentSpeed = currentHorizontalVelocity.magnitude;\n                    float speedReduction = HorizontalDeceleration * deltaTime;\n\n                    if (currentSpeed <= speedReduction)\n                    {\n                        newHorizontalVelocity = Vector3.zero;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n                    }\n                }\n\n                _newVelocity.x = newHorizontalVelocity.x;\n                _newVelocity.z = newHorizontalVelocity.z;\n\n                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    Vector3 floorVelocity = _frameVelocity;\n                    floorVelocity.y = 0;\n                    _newVelocity.x += floorVelocity.x;\n                    _newVelocity.z += floorVelocity.z;\n                }\n\n                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n\n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity.normalized;\n                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n\n                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n                        {\n                            projectedDirection.Normalize();\n                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                        }\n                    }\n\n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 应用重力到速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddGravity(float deltaTime)\n        {\n            if (GravityActive)\n            {\n                if (_grounded)\n                {\n                    _newVelocity.y = -Gravity * deltaTime;\n                }\n                else\n                {\n                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n                }\n            }\n            _newVelocity += _addedForce;\n            _addedForce = Vector3.zero;\n        }\n\n        /// <summary>\n        /// 跟随移动平台移动\n        /// </summary>\n        protected virtual void MoveWithPlatform()\n        {\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _moveWithPlatformMoveDistance = Vector3.zero;\n                _moveWithPlatformGlobalPoint =\n                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n                if (_moveWithPlatformMoveDistance != Vector3.zero)\n                {\n                    _characterController.Move(_moveWithPlatformMoveDistance);\n                }\n                _moveWithPlatformGlobalRotation =\n                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n            }\n        }\n\n        /// <summary>\n        /// 计算速度增量和粘性偏移\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeVelocityDelta(float deltaTime)\n        {\n            _motion = _newVelocity * deltaTime;\n            _horizontalVelocityDelta.x = _motion.x;\n            _horizontalVelocityDelta.y = 0f;\n            _horizontalVelocityDelta.z = _motion.z;\n\n            // 临时禁用地面粘附，测试是否是它导致的抖动\n            /*\n            // 只有在有水平移动时才应用粘附偏移，避免静止时的抖动\n            float horizontalSpeed = _horizontalVelocityDelta.magnitude;\n            if (_grounded && horizontalSpeed > SMALL_VALUE)\n            {\n                // 使用较小的粘附值，避免过度向下推\n                _stickyOffset = Mathf.Min(_characterController.stepOffset, horizontalSpeed);\n                _motion.y -= _stickyOffset;\n            }\n            */\n        }\n\n        /// <summary>\n        /// 检测是否踩上新的移动平台\n        /// </summary>\n        protected virtual void DetectNewMovingPlatform()\n        {\n            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n            {\n                if (_movingPlatformHitCollider != null)\n                {\n                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n                    _newMovingPlatform = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 计算新速度和加速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeNewVelocity(float deltaTime)\n        {\n            _velocity = _newVelocity;\n            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n        }\n\n        /// <summary>\n        /// 处理地面接触状态和平台速度传递\n        /// </summary>\n        protected virtual void HandleGroundContact()\n        {\n            _grounded = _characterController.isGrounded;\n            if (_grounded && !IsGroundedTest())\n            {\n                _grounded = false;\n                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    _frameVelocity = _movingPlatformVelocity;\n                    _velocity += _movingPlatformVelocity;\n                }\n            }\n            else if (!_grounded && IsGroundedTest())\n            {\n                if (_detached && _velocity.y <= 0)\n                {\n                    _grounded = true;\n                    _detached = false;\n                }\n                SubtractNewPlatformVelocity();\n            }\n\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _movingPlatformCurrentGlobalPoint = _transform.position;\n                _movingPlatformCurrentHitColliderLocal =\n                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n                _movingPlatformGlobalRotation = _transform.rotation;\n                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n                                               _movingPlatformGlobalRotation;\n            }\n\n            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n            _tooSteepLastFrame = TooSteep();\n        }\n\n        /// <summary>\n        /// 计算当前速度（仅用于显示，不影响逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeSpeed(float deltaTime)\n        {\n            // 使用渲染帧专用的位置记录，避免干扰逻辑帧\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n            }\n            _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n\n            _renderPositionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 根据当前移动向量确定方向\n        /// </summary>\n        protected virtual void DetermineDirection()\n        {\n            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n            {\n                _currentDirection = _currentMovement.normalized;\n            }\n        }\n\n        /// <summary>\n        /// 处理摩擦力（预留方法，可在子类中实现）\n        /// </summary>\n        protected virtual void HandleFriction()\n        {\n        }\n\n        /// <summary>\n        /// 检查是否刚刚着地\n        /// </summary>\n        protected virtual void CheckIfGrounded()\n        {\n            _justGotGrounded = !_groundedLastFrame && _grounded;\n            _groundedLastFrame = _grounded;\n        }\n\n        /// <summary>\n        /// 手动触发碰撞器碰撞处理\n        /// </summary>\n        protected virtual void ManualControllerColliderHit()\n        {\n            HandleAdvancedGroundDetection();\n        }\n\n        /// <summary>\n        /// 高级地面检测（使用多方向射线）\n        /// </summary>\n        protected virtual void HandleAdvancedGroundDetection()\n        {\n            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n            {\n                return;\n            }\n\n            _smallestDistance = Single.MaxValue;\n            _longestDistance = Single.MinValue;\n            _smallestRaycast = _emptyRaycast;\n            float offset = _characterController.radius;\n            _downRaycastsOffset = Vector3.zero;\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, offset);\n            CastRayDownwards();\n\n            if (_smallestRaycast.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n                {\n                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n                    {\n                        _groundNormal = _smallestRaycast.normal;\n                    }\n                    else\n                    {\n                        _groundNormal = _lastGroundNormal;\n                    }\n\n                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n                    _hitPoint = _smallestRaycast.point;\n                    _frameVelocity = Vector3.zero;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 向下发射射线检测地面\n        /// </summary>\n        protected virtual void CastRayDownwards()\n        {\n            if (_smallestDistance <= MinimumGroundedDistance)\n            {\n                return;\n            }\n\n            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n                _raycastDownDirection, out _raycastDownHit,\n                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n\n            if (_raycastDownHit.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n                if (adjustedDistance < _smallestDistance)\n                {\n                    _smallestDistance = adjustedDistance;\n                    _smallestRaycast = _raycastDownHit;\n                }\n                if (adjustedDistance > _longestDistance)\n                {\n                    _longestDistance = adjustedDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n        /// </summary>\n        protected float AdjustDistance(float distance)\n        {\n            return distance - _characterController.height / 2f - _characterController.skinWidth;\n        }\n\n        /// <summary>\n        /// 测试是否真正着地\n        /// </summary>\n        protected virtual bool IsGroundedTest()\n        {\n            bool grounded = false;\n            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n            {\n                if (_smallestDistance <= MinimumGroundedDistance)\n                {\n                    grounded = _groundNormal.y > 0.01f;\n                }\n            }\n            else\n            {\n                grounded = _characterController.isGrounded;\n                _groundNormal = Vector3.up;\n            }\n            return grounded;\n        }\n\n        /// <summary>\n        /// 获取移动平台速度\n        /// </summary>\n        protected virtual void GetMovingPlatformVelocity()\n        {\n            if (_movingPlatformCurrentHitCollider != null)\n            {\n                if (!_newMovingPlatform && _currentDeltaTime > SMALL_VALUE)\n                {\n                    _movingPlatformVelocity = (\n                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n                            _movingPlatformCurrentHitColliderLocal)\n                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n                    ) / _currentDeltaTime;\n                }\n                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n                _newMovingPlatform = false;\n            }\n            else\n            {\n                _movingPlatformVelocity = Vector3.zero;\n            }\n        }\n\n        /// <summary>\n        /// 减去新平台速度（处理平台切换）\n        /// </summary>\n        protected virtual void SubtractNewPlatformVelocity()\n        {\n            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n            {\n                if (_newMovingPlatform)\n                {\n                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n                }\n                else\n                {\n                    _velocity -= _movingPlatformVelocity;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 协程：延迟减去平台速度\n        /// </summary>\n        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n        {\n            Transform platform = _movingPlatformCurrentHitCollider;\n            yield return _waitForFixedUpdate;\n            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n            {\n                yield return null;\n            }\n            _velocity -= _movingPlatformVelocity;\n        }\n\n        /// <summary>\n        /// 判断是否应该跟随平台移动\n        /// </summary>\n        protected virtual bool ShouldMoveWithPlatformThisFrame()\n        {\n            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n                   && _movingPlatformCurrentHitCollider != null;\n        }\n\n        /// <summary>\n        /// 应用冲击力并逐渐衰减\n        /// </summary>\n        protected virtual void ApplyImpact()\n        {\n            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n            {\n                _characterController.Move(_impact * _currentDeltaTime);\n            }\n            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * _currentDeltaTime);\n        }\n\n        /// <summary>\n        /// 从地面分离（用于跳跃等）\n        /// </summary>\n        public virtual void DetachFromGround()\n        {\n            _detached = true;\n        }\n\n        /// <summary>\n        /// 从移动平台分离\n        /// </summary>\n        public virtual void DetachFromMovingPlatform()\n        {\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n        }\n\n        /// <summary>\n        /// 设置重力是否激活\n        /// </summary>\n        public virtual void SetGravityActive(bool status)\n        {\n            GravityActive = status;\n        }\n\n        /// <summary>\n        /// 添加外部力（会在下一帧应用）\n        /// </summary>\n        public virtual void AddForce(Vector3 movement)\n        {\n            _addedForce += movement;\n        }\n\n        /// <summary>\n        /// 施加瞬时冲击力\n        /// </summary>\n        /// <param name=\"direction\">冲击方向</param>\n        /// <param name=\"force\">冲击力大小</param>\n        public virtual void Impact(Vector3 direction, float force)\n        {\n            direction = direction.normalized;\n            if (direction.y < 0)\n            {\n                direction.y = -direction.y;\n            }\n            _impact += direction.normalized * force;\n        }\n\n        /// <summary>\n        /// 设置移动向量（通常由输入系统调用）\n        /// </summary>\n        /// <param name=\"movement\">移动向量</param>\n        public virtual void SetMovement(Vector3 movement)\n        {\n            _currentMovement = movement;\n            Vector3 directionVector = movement;\n            if (directionVector != Vector3.zero)\n            {\n                float directionLength = directionVector.magnitude;\n                directionVector = directionVector / directionLength;\n                directionLength = Mathf.Min(1, directionLength);\n                directionLength = directionLength * directionLength;\n                directionVector = directionVector * directionLength;\n            }\n            _inputMoveDirection = transform.rotation * directionVector;\n        }\n\n        /// <summary>\n        /// 移动到指定位置（带碰撞检测）\n        /// </summary>\n        /// <param name=\"newPosition\">目标位置</param>\n        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n        {\n            _movePositionDirection = newPosition - transform.position;\n            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n\n            _capsulePoint1 = transform.position\n                             + _characterController.center\n                             - (Vector3.up * _characterController.height / 2f)\n                             + Vector3.up * _characterController.skinWidth\n                             + Vector3.up * _characterController.radius;\n\n            _capsulePoint2 = transform.position\n                             + _characterController.center\n                             + (Vector3.up * _characterController.height / 2f)\n                             - Vector3.up * _characterController.skinWidth\n                             - Vector3.up * _characterController.radius;\n\n            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n            {\n                transform.position = newPosition;\n            }\n        }\n\n        /// <summary>\n        /// 调整碰撞器高度（用于蹲伏等）\n        /// </summary>\n        /// <param name=\"newHeight\">新高度</param>\n        /// <param name=\"translateCenter\">是否平移中心点</param>\n        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n        {\n            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n            _characterController.height = newHeight;\n            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n            if (translateCenter)\n            {\n                transform.Translate((newYOffset / 2f) * Vector3.up);\n            }\n        }\n\n        /// <summary>\n        /// 重置碰撞器尺寸到原始大小\n        /// </summary>\n        public virtual void ResetColliderSize()\n        {\n            _characterController.height = _originalColliderHeight;\n            _characterController.center = _originalColliderCenter;\n        }\n\n        /// <summary>\n        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n        /// </summary>\n        public virtual bool CanGoBackToOriginalSize()\n        {\n            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n            {\n                return true;\n            }\n\n            float headCheckDistance =\n                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n                ObstaclesLayerMask, Color.cyan, true);\n\n            return _canGoBackHeadCheck.collider == null;\n        }\n\n        /// <summary>\n        /// 启用碰撞\n        /// </summary>\n        public virtual void CollisionsOn()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = true;\n            }\n        }\n\n        /// <summary>\n        /// 禁用碰撞\n        /// </summary>\n        public virtual void CollisionsOff()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = false;\n            }\n        }\n\n        /// <summary>\n        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n        /// </summary>\n        public virtual void SetKinematic(bool state)\n        {\n            _rigidBody.isKinematic = state;\n        }\n\n        /// <summary>\n        /// 设置是否允许自由移动\n        /// </summary>\n        public virtual void SetFreeMovement(bool state)\n        {\n            _freeMovement = state;\n        }\n\n        /// <summary>\n        /// 检测四个基本方向的障碍物\n        /// </summary>\n        /// <param name=\"distance\">检测距离</param>\n        /// <param name=\"offset\">起始偏移</param>\n        public virtual void DetectObstacles(float distance, Vector3 offset)\n        {\n            if (!PerformCardinalObstacleRaycastDetection)\n            {\n                return;\n            }\n\n            CollidingWithCardinalObstacle = false;\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleRight = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleLeft = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleUp = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleDown = null;\n            }\n        }\n\n        /// <summary>\n        /// 重置控制器到初始状态\n        /// </summary>\n        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n            _renderPositionLastFrame = _transform != null ? _transform.position : Vector3.zero;\n            _lastLogicUpdateTime = Time.time;\n            _lastLogicUpdateFrame = -1;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n            return hit;\n        }\n    }\n}","newString":"using System;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing ActionMachine.Runtime.Attributes;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 运动学角色控制器（Kinematic Character Controller）\n    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    /// \n    /// 修复：添加逻辑帧与渲染帧之间的插值，解决 30fps 逻辑更新导致的卡顿\n    /// </summary>\n    [RequireComponent(typeof(CharacterController))]\n    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    public partial class Kcc : MonoBehaviour\n    {\n        private const float SMALL_VALUE = 0.0001f;\n        private const float SPEED_ROUNDING_PRECISION = 100f;\n        private const float IMPACT_THRESHOLD = 0.2f;\n\n        public enum GroundedComputationMode\n        {\n            Simple,\n            Advanced\n        }\n\n        public enum VelocityTransferMode\n        {\n            NoTransfer,\n            InitialVelocity,\n            FloorVelocity,\n            Relative\n        }\n\n        [Header(\"Update Mode Settings\")]\n        [Tooltip(\"更新模式：Auto = Update 中自动执行（用于无外部 LogicUpdate 调用）, Manual = 仅通过外部 LogicUpdate 调用执行\")]\n        public UpdateMode UpdateModeType = UpdateMode.Manual;\n\n        public enum UpdateMode\n        {\n            Auto,    // Update 中自动执行物理计算\n            Manual   // 仅通过外部 LogicUpdate 调用执行\n        }\n\n        [Header(\"Gravity Settings\")]\n        [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n        public float Gravity = 40f;\n        [Tooltip(\"是否激活重力\")]\n        public bool GravityActive = true;\n\n        [Header(\"Raycast Settings\")]\n        [Tooltip(\"障碍物层遮罩\")]\n        public LayerMask ObstaclesLayerMask;\n        [Tooltip(\"向下射线检测长度\")]\n        public float GroundedRaycastLength = 5f;\n        [Tooltip(\"最小着地距离\")]\n        public float MinimumGroundedDistance = 0.2f;\n        [Tooltip(\"地面检测计算模式\")]\n        public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n        [Tooltip(\"地面法线高度阈值\")]\n        public float GroundNormalHeightThreshold = 0.2f;\n        [Tooltip(\"蹲伏时射线长度倍数\")]\n        public float CrouchedRaycastLengthMultiplier = 1f;\n        [Tooltip(\"是否执行基本方向障碍物射线检测\")]\n        public bool PerformCardinalObstacleRaycastDetection = false;\n\n        [Header(\"Movement Settings\")]\n        [Tooltip(\"最大下落速度\")]\n        public float MaximumFallSpeed = 20.0f;\n        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速。设为 0 表示立即到达目标速度，消除加速延迟\")]\n        public float HorizontalAcceleration = 0f; // 改为 0，立即到达目标速度\n        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速。设为 0 表示立即停止，消除减速延迟\")]\n        public float HorizontalDeceleration = 0f; // 改为 0，立即停止\n        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n        public float InitialBurstMultiplier = 2.0f;\n        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n        public float BurstSpeedThreshold = 1.0f;\n        [Tooltip(\"斜坡速度倍数曲线\")]\n        public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n            new Keyframe(-90, 1),\n            new Keyframe(0, 1),\n            new Keyframe(90, 0)\n        );\n        [Tooltip(\"冲击力衰减速度\")]\n        public float ImpactFalloff = 5f;\n\n        [Header(\"Steep Surface Settings\")]\n        [Tooltip(\"是否在陡峭表面滑动\")]\n        public bool SlideOnSteepSurfaces = true;\n        [Tooltip(\"滑动速度\")]\n        public float SlidingSpeed = 15f;\n        [Tooltip(\"滑动速度控制\")]\n        public float SlidingSpeedControl = 0.4f;\n        [Tooltip(\"滑动方向控制\")]\n        public float SlidingDirectionControl = 1f;\n\n        [Header(\"Moving Platform Settings\")]\n        [Tooltip(\"跳跃时的速度传递方式\")]\n        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Runtime State - Read Only\")]\n        [SerializeField, ReadOnly] private Vector3 _speed;\n        [SerializeField, ReadOnly] private Vector3 _velocity;\n        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n        [SerializeField, ReadOnly] private Vector3 _acceleration;\n        [SerializeField, ReadOnly] private bool _grounded;\n        [SerializeField, ReadOnly] private bool _justGotGrounded;\n        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n        [SerializeField, ReadOnly] private float _friction;\n        [SerializeField, ReadOnly] private Vector3 _addedForce;\n        [SerializeField, ReadOnly] private bool _freeMovement = true;\n        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n\n        // 公共只读属性\n        public Vector3 Speed => _speed;\n        public Vector3 Velocity => _velocity;\n        public Vector3 VelocityLastFrame => _velocityLastFrame;\n        public Vector3 Acceleration => _acceleration;\n        public bool Grounded => _grounded;\n        public bool JustGotGrounded => _justGotGrounded;\n        public Vector3 CurrentMovement => _currentMovement;\n        public Vector3 CurrentDirection => _currentDirection;\n        public float Friction => _friction;\n        public Vector3 AddedForce => _addedForce;\n        public bool FreeMovement => _freeMovement;\n        public Vector3 GroundNormal => _groundNormal;\n        public Vector3 InputMoveDirection => _inputMoveDirection;\n        public Vector3 TargetVelocity => _targetVelocity;\n\n        // 碰撞器相关属性\n        public Vector3 ColliderCenter => transform.position + _characterController.center;\n        public Vector3 ColliderBottom => transform.position + _characterController.center +\n                                         Vector3.down * _characterController.bounds.extents.y;\n        public Vector3 ColliderTop => transform.position + _characterController.center +\n                                      Vector3.up * _characterController.bounds.extents.y;\n        public Vector3 AppliedImpact => _impact;\n\n        // 环境检测属性\n        public GameObject ObjectBelow { get; set; }\n        public GameObject DetectedObstacleLeft { get; set; }\n        public GameObject DetectedObstacleRight { get; set; }\n        public GameObject DetectedObstacleUp { get; set; }\n        public GameObject DetectedObstacleDown { get; set; }\n        public bool CollidingWithCardinalObstacle { get; set; }\n        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n\n        // 移动平台相关属性\n        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n\n        // 组件引用\n        private Transform _transform;\n        private CharacterController _characterController;\n\n        // 碰撞器原始尺寸\n        private float _originalColliderHeight;\n        private Vector3 _originalColliderCenter;\n\n        // 运动状态追踪\n        private Vector3 _positionLastFrame;\n        private bool _groundedLastFrame;\n        private Vector3 _impact;\n        private Vector3 _lastGroundNormal = Vector3.zero;\n        private bool _detached = false;\n        private bool _tooSteepLastFrame;\n\n        // 移动平台追踪\n        private Transform _movingPlatformHitCollider;\n        private Transform _movingPlatformCurrentHitCollider;\n        private Vector3 _movingPlatformCurrentHitColliderLocal;\n        private Vector3 _movingPlatformCurrentGlobalPoint;\n        private Quaternion _movingPlatformLocalRotation;\n        private Quaternion _movingPlatformGlobalRotation;\n        private Quaternion _lastMoveWithPlatformGlobalRotation;\n        private Matrix4x4 _lastMovingPlatformMatrix;\n        private Vector3 _movingPlatformVelocity;\n        private bool _newMovingPlatform;\n\n        // 碰撞检测\n        private CollisionFlags _collisionFlags;\n        private Vector3 _frameVelocity = Vector3.zero;\n        private Vector3 _hitPoint = Vector3.zero;\n        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n        // 速度计算\n        private Vector3 _newVelocity;\n        private Vector3 _motion;\n        private Vector3 _idealVelocity;\n        private Vector3 _idealDirection;\n        private Vector3 _horizontalVelocityDelta;\n        private float _stickyOffset = 0f;\n\n        // 位置移动\n        private RaycastHit _movePositionHit;\n        private Vector3 _capsulePoint1;\n        private Vector3 _capsulePoint2;\n        private Vector3 _movePositionDirection;\n        private float _movePositionDistance;\n\n        // 障碍物检测\n        private RaycastHit _cardinalRaycast;\n        private float _smallestDistance = Single.MaxValue;\n        private float _longestDistance = Single.MinValue;\n        private RaycastHit _smallestRaycast;\n        private RaycastHit _emptyRaycast = new RaycastHit();\n        private Vector3 _downRaycastsOffset;\n\n        // 平台移动计算\n        private Vector3 _moveWithPlatformMoveDistance;\n        private Vector3 _moveWithPlatformGlobalPoint;\n        private Quaternion _moveWithPlatformRotationDiff;\n        private Quaternion _moveWithPlatformGlobalRotation;\n        private RaycastHit _raycastDownHit;\n        private Vector3 _raycastDownDirection = Vector3.down;\n        private RaycastHit _canGoBackHeadCheck;\n        private Vector3 _originalSizeRaycastOrigin;\n\n        // 协程和可选组件\n        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        private float _currentDeltaTime;\n\n        // ============== 插值相关变量（已废弃，保留用于兼容性）==============\n        /// <summary>\n        /// 逻辑帧的时间间隔（保留字段，用于外部调用兼容性）\n        /// </summary>\n        private float _logicDeltaTime = 1f / 30f;\n        \n        /// <summary>\n        /// 上一次逻辑帧的时间戳\n        /// </summary>\n        private float _lastLogicUpdateTime = 0f;\n\n        /// <summary>\n        /// 上一次执行逻辑更新的帧号（用于防止同一帧重复移动）\n        /// </summary>\n        private int _lastLogicUpdateFrame = -1;\n\n        /// <summary>\n        /// 渲染帧专用的上一帧位置（用于计算速度显示）\n        /// </summary>\n        private Vector3 _renderPositionLastFrame = Vector3.zero;\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n        /// <summary>\n        /// 检查角色头部是否与物体碰撞\n        /// </summary>\n        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n\n        /// <summary>\n        /// 检查当前地面是否过于陡峭\n        /// </summary>\n        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n\n        /// <summary>\n        /// 初始化组件和缓存引用\n        /// </summary>\n        protected virtual void Awake()\n        {\n            _characterController = GetComponent<CharacterController>();\n            _transform = transform;\n            _rigidBody = GetComponent<Rigidbody>();\n            _originalColliderHeight = _characterController.height;\n            _originalColliderCenter = _characterController.center;\n            _currentDirection = _transform.forward;\n            _lastLogicUpdateTime = Time.time;\n            _renderPositionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 每帧更新（渲染帧）\n        /// 根据 UpdateModeType 决定是否在此执行物理计算\n        /// </summary>\n        protected virtual void Update()\n        {\n            float deltaTime = Time.deltaTime;\n            _currentDeltaTime = deltaTime;\n\n            // 只在 Auto 模式下自动执行物理计算\n            // Manual 模式下，物理计算由外部 LogicUpdate 调用控制\n            if (UpdateModeType == UpdateMode.Auto)\n            {\n                // 在 Auto 模式下才更新平台速度\n                GetMovingPlatformVelocity();\n\n                // 检查是否已经在 LogicUpdate 中处理过这一帧（防止双重移动）\n                bool alreadyProcessedThisFrame = (Time.frameCount == _lastLogicUpdateFrame);\n\n                if (!alreadyProcessedThisFrame && _freeMovement)\n                {\n                    ProcessLogicUpdate(deltaTime);\n                }\n\n                // 更新速度显示（仅用于调试）\n                if (deltaTime > SMALL_VALUE)\n                {\n                    _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n                    _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _renderPositionLastFrame = _transform.position;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 注意：如果外部调用了此方法，Update 将跳过这一帧的处理，避免双重移动\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            _logicDeltaTime = deltaTime;\n            _currentDeltaTime = deltaTime;\n            _lastLogicUpdateTime = Time.time;\n            _lastLogicUpdateFrame = Time.frameCount; // 标记这一帧已处理\n\n            ProcessLogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 固定时间更新（保留用于物理相关操作）\n        /// </summary>\n        protected virtual void FixedUpdate()\n        {\n            _currentDeltaTime = Time.fixedDeltaTime;\n        }\n\n        /// <summary>\n        /// 延迟更新，保存上一帧速度\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            _velocityLastFrame = _velocity;\n        }\n\n        /// <summary>\n        /// 核心逻辑更新处理流程（使用指定的 deltaTime）\n        /// 计算移动逻辑并执行 CharacterController.Move\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ProcessLogicUpdate(float deltaTime)\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            CheckIfGrounded();\n            HandleFriction();\n            DetermineDirection();\n            AddInput(deltaTime);\n            AddGravity(deltaTime);\n            MoveWithPlatform();\n            ComputeVelocityDelta(deltaTime);\n\n            // 执行实际移动\n            MoveCharacterControllerWithMotion(_motion);\n            DetectNewMovingPlatform();\n            ManualControllerColliderHit();\n            HandleGroundContact();\n\n            ComputeNewVelocity(deltaTime);\n        }\n\n        /// <summary>\n        /// 使用指定的移动向量执行 CharacterController 移动\n        /// </summary>\n        /// <param name=\"motion\">移动向量</param>\n        protected virtual void MoveCharacterControllerWithMotion(Vector3 motion)\n        {\n            _groundNormal = Vector3.zero;\n            _collisionFlags = _characterController.Move(motion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n\n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n                _idealVelocity = _idealVelocity * SlidingSpeed;\n                _targetVelocity = _idealVelocity;\n                _newVelocity = _idealVelocity;\n                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n            }\n            else\n            {\n                _targetVelocity = _currentMovement;\n\n                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n\n                Vector3 newHorizontalVelocity;\n\n                // 如果加速度为 0，直接使用目标速度（零延迟响应）\n                if (HorizontalAcceleration <= 0.001f && HorizontalDeceleration <= 0.001f)\n                {\n                    newHorizontalVelocity = targetHorizontalVelocity;\n                }\n                else if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                {\n                    float effectiveAcceleration = HorizontalAcceleration;\n\n                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n                    {\n                        effectiveAcceleration *= InitialBurstMultiplier;\n                    }\n\n                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n\n                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n                    {\n                        newHorizontalVelocity = targetHorizontalVelocity;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n                    }\n                }\n                else\n                {\n                    float currentSpeed = currentHorizontalVelocity.magnitude;\n                    float speedReduction = HorizontalDeceleration * deltaTime;\n\n                    if (currentSpeed <= speedReduction)\n                    {\n                        newHorizontalVelocity = Vector3.zero;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n                    }\n                }\n\n                _newVelocity.x = newHorizontalVelocity.x;\n                _newVelocity.z = newHorizontalVelocity.z;\n\n                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    Vector3 floorVelocity = _frameVelocity;\n                    floorVelocity.y = 0;\n                    _newVelocity.x += floorVelocity.x;\n                    _newVelocity.z += floorVelocity.z;\n                }\n\n                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n\n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity.normalized;\n                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n\n                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n                        {\n                            projectedDirection.Normalize();\n                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                        }\n                    }\n\n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 应用重力到速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddGravity(float deltaTime)\n        {\n            if (GravityActive)\n            {\n                if (_grounded)\n                {\n                    _newVelocity.y = -Gravity * deltaTime;\n                }\n                else\n                {\n                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n                }\n            }\n            _newVelocity += _addedForce;\n            _addedForce = Vector3.zero;\n        }\n\n        /// <summary>\n        /// 跟随移动平台移动\n        /// </summary>\n        protected virtual void MoveWithPlatform()\n        {\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _moveWithPlatformMoveDistance = Vector3.zero;\n                _moveWithPlatformGlobalPoint =\n                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n                if (_moveWithPlatformMoveDistance != Vector3.zero)\n                {\n                    _characterController.Move(_moveWithPlatformMoveDistance);\n                }\n                _moveWithPlatformGlobalRotation =\n                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n            }\n        }\n\n        /// <summary>\n        /// 计算速度增量和粘性偏移\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeVelocityDelta(float deltaTime)\n        {\n            _motion = _newVelocity * deltaTime;\n            _horizontalVelocityDelta.x = _motion.x;\n            _horizontalVelocityDelta.y = 0f;\n            _horizontalVelocityDelta.z = _motion.z;\n\n            // 临时禁用地面粘附，测试是否是它导致的抖动\n            /*\n            // 只有在有水平移动时才应用粘附偏移，避免静止时的抖动\n            float horizontalSpeed = _horizontalVelocityDelta.magnitude;\n            if (_grounded && horizontalSpeed > SMALL_VALUE)\n            {\n                // 使用较小的粘附值，避免过度向下推\n                _stickyOffset = Mathf.Min(_characterController.stepOffset, horizontalSpeed);\n                _motion.y -= _stickyOffset;\n            }\n            */\n        }\n\n        /// <summary>\n        /// 检测是否踩上新的移动平台\n        /// </summary>\n        protected virtual void DetectNewMovingPlatform()\n        {\n            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n            {\n                if (_movingPlatformHitCollider != null)\n                {\n                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n                    _newMovingPlatform = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 计算新速度和加速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeNewVelocity(float deltaTime)\n        {\n            _velocity = _newVelocity;\n            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n        }\n\n        /// <summary>\n        /// 处理地面接触状态和平台速度传递\n        /// </summary>\n        protected virtual void HandleGroundContact()\n        {\n            _grounded = _characterController.isGrounded;\n            if (_grounded && !IsGroundedTest())\n            {\n                _grounded = false;\n                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    _frameVelocity = _movingPlatformVelocity;\n                    _velocity += _movingPlatformVelocity;\n                }\n            }\n            else if (!_grounded && IsGroundedTest())\n            {\n                if (_detached && _velocity.y <= 0)\n                {\n                    _grounded = true;\n                    _detached = false;\n                }\n                SubtractNewPlatformVelocity();\n            }\n\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _movingPlatformCurrentGlobalPoint = _transform.position;\n                _movingPlatformCurrentHitColliderLocal =\n                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n                _movingPlatformGlobalRotation = _transform.rotation;\n                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n                                               _movingPlatformGlobalRotation;\n            }\n\n            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n            _tooSteepLastFrame = TooSteep();\n        }\n\n        /// <summary>\n        /// 计算当前速度（仅用于显示，不影响逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeSpeed(float deltaTime)\n        {\n            // 使用渲染帧专用的位置记录，避免干扰逻辑帧\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n            }\n            _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n\n            _renderPositionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 根据当前移动向量确定方向\n        /// </summary>\n        protected virtual void DetermineDirection()\n        {\n            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n            {\n                _currentDirection = _currentMovement.normalized;\n            }\n        }\n\n        /// <summary>\n        /// 处理摩擦力（预留方法，可在子类中实现）\n        /// </summary>\n        protected virtual void HandleFriction()\n        {\n        }\n\n        /// <summary>\n        /// 检查是否刚刚着地\n        /// </summary>\n        protected virtual void CheckIfGrounded()\n        {\n            _justGotGrounded = !_groundedLastFrame && _grounded;\n            _groundedLastFrame = _grounded;\n        }\n\n        /// <summary>\n        /// 手动触发碰撞器碰撞处理\n        /// </summary>\n        protected virtual void ManualControllerColliderHit()\n        {\n            HandleAdvancedGroundDetection();\n        }\n\n        /// <summary>\n        /// 高级地面检测（使用多方向射线）\n        /// </summary>\n        protected virtual void HandleAdvancedGroundDetection()\n        {\n            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n            {\n                return;\n            }\n\n            _smallestDistance = Single.MaxValue;\n            _longestDistance = Single.MinValue;\n            _smallestRaycast = _emptyRaycast;\n            float offset = _characterController.radius;\n            _downRaycastsOffset = Vector3.zero;\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, offset);\n            CastRayDownwards();\n\n            if (_smallestRaycast.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n                {\n                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n                    {\n                        _groundNormal = _smallestRaycast.normal;\n                    }\n                    else\n                    {\n                        _groundNormal = _lastGroundNormal;\n                    }\n\n                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n                    _hitPoint = _smallestRaycast.point;\n                    _frameVelocity = Vector3.zero;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 向下发射射线检测地面\n        /// </summary>\n        protected virtual void CastRayDownwards()\n        {\n            if (_smallestDistance <= MinimumGroundedDistance)\n            {\n                return;\n            }\n\n            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n                _raycastDownDirection, out _raycastDownHit,\n                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n\n            if (_raycastDownHit.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n                if (adjustedDistance < _smallestDistance)\n                {\n                    _smallestDistance = adjustedDistance;\n                    _smallestRaycast = _raycastDownHit;\n                }\n                if (adjustedDistance > _longestDistance)\n                {\n                    _longestDistance = adjustedDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n        /// </summary>\n        protected float AdjustDistance(float distance)\n        {\n            return distance - _characterController.height / 2f - _characterController.skinWidth;\n        }\n\n        /// <summary>\n        /// 测试是否真正着地\n        /// </summary>\n        protected virtual bool IsGroundedTest()\n        {\n            bool grounded = false;\n            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n            {\n                if (_smallestDistance <= MinimumGroundedDistance)\n                {\n                    grounded = _groundNormal.y > 0.01f;\n                }\n            }\n            else\n            {\n                grounded = _characterController.isGrounded;\n                _groundNormal = Vector3.up;\n            }\n            return grounded;\n        }\n\n        /// <summary>\n        /// 获取移动平台速度\n        /// </summary>\n        protected virtual void GetMovingPlatformVelocity()\n        {\n            if (_movingPlatformCurrentHitCollider != null)\n            {\n                if (!_newMovingPlatform && _currentDeltaTime > SMALL_VALUE)\n                {\n                    _movingPlatformVelocity = (\n                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n                            _movingPlatformCurrentHitColliderLocal)\n                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n                    ) / _currentDeltaTime;\n                }\n                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n                _newMovingPlatform = false;\n            }\n            else\n            {\n                _movingPlatformVelocity = Vector3.zero;\n            }\n        }\n\n        /// <summary>\n        /// 减去新平台速度（处理平台切换）\n        /// </summary>\n        protected virtual void SubtractNewPlatformVelocity()\n        {\n            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n            {\n                if (_newMovingPlatform)\n                {\n                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n                }\n                else\n                {\n                    _velocity -= _movingPlatformVelocity;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 协程：延迟减去平台速度\n        /// </summary>\n        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n        {\n            Transform platform = _movingPlatformCurrentHitCollider;\n            yield return _waitForFixedUpdate;\n            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n            {\n                yield return null;\n            }\n            _velocity -= _movingPlatformVelocity;\n        }\n\n        /// <summary>\n        /// 判断是否应该跟随平台移动\n        /// </summary>\n        protected virtual bool ShouldMoveWithPlatformThisFrame()\n        {\n            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n                   && _movingPlatformCurrentHitCollider != null;\n        }\n\n        /// <summary>\n        /// 应用冲击力并逐渐衰减\n        /// </summary>\n        protected virtual void ApplyImpact()\n        {\n            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n            {\n                _characterController.Move(_impact * _currentDeltaTime);\n            }\n            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * _currentDeltaTime);\n        }\n\n        /// <summary>\n        /// 从地面分离（用于跳跃等）\n        /// </summary>\n        public virtual void DetachFromGround()\n        {\n            _detached = true;\n        }\n\n        /// <summary>\n        /// 从移动平台分离\n        /// </summary>\n        public virtual void DetachFromMovingPlatform()\n        {\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n        }\n\n        /// <summary>\n        /// 设置重力是否激活\n        /// </summary>\n        public virtual void SetGravityActive(bool status)\n        {\n            GravityActive = status;\n        }\n\n        /// <summary>\n        /// 添加外部力（会在下一帧应用）\n        /// </summary>\n        public virtual void AddForce(Vector3 movement)\n        {\n            _addedForce += movement;\n        }\n\n        /// <summary>\n        /// 施加瞬时冲击力\n        /// </summary>\n        /// <param name=\"direction\">冲击方向</param>\n        /// <param name=\"force\">冲击力大小</param>\n        public virtual void Impact(Vector3 direction, float force)\n        {\n            direction = direction.normalized;\n            if (direction.y < 0)\n            {\n                direction.y = -direction.y;\n            }\n            _impact += direction.normalized * force;\n        }\n\n        /// <summary>\n        /// 设置移动向量（通常由输入系统调用）\n        /// </summary>\n        /// <param name=\"movement\">移动向量</param>\n        public virtual void SetMovement(Vector3 movement)\n        {\n            _currentMovement = movement;\n            Vector3 directionVector = movement;\n            if (directionVector != Vector3.zero)\n            {\n                float directionLength = directionVector.magnitude;\n                directionVector = directionVector / directionLength;\n                directionLength = Mathf.Min(1, directionLength);\n                directionLength = directionLength * directionLength;\n                directionVector = directionVector * directionLength;\n            }\n            _inputMoveDirection = transform.rotation * directionVector;\n        }\n\n        /// <summary>\n        /// 移动到指定位置（带碰撞检测）\n        /// </summary>\n        /// <param name=\"newPosition\">目标位置</param>\n        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n        {\n            _movePositionDirection = newPosition - transform.position;\n            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n\n            _capsulePoint1 = transform.position\n                             + _characterController.center\n                             - (Vector3.up * _characterController.height / 2f)\n                             + Vector3.up * _characterController.skinWidth\n                             + Vector3.up * _characterController.radius;\n\n            _capsulePoint2 = transform.position\n                             + _characterController.center\n                             + (Vector3.up * _characterController.height / 2f)\n                             - Vector3.up * _characterController.skinWidth\n                             - Vector3.up * _characterController.radius;\n\n            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n            {\n                transform.position = newPosition;\n            }\n        }\n\n        /// <summary>\n        /// 调整碰撞器高度（用于蹲伏等）\n        /// </summary>\n        /// <param name=\"newHeight\">新高度</param>\n        /// <param name=\"translateCenter\">是否平移中心点</param>\n        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n        {\n            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n            _characterController.height = newHeight;\n            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n            if (translateCenter)\n            {\n                transform.Translate((newYOffset / 2f) * Vector3.up);\n            }\n        }\n\n        /// <summary>\n        /// 重置碰撞器尺寸到原始大小\n        /// </summary>\n        public virtual void ResetColliderSize()\n        {\n            _characterController.height = _originalColliderHeight;\n            _characterController.center = _originalColliderCenter;\n        }\n\n        /// <summary>\n        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n        /// </summary>\n        public virtual bool CanGoBackToOriginalSize()\n        {\n            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n            {\n                return true;\n            }\n\n            float headCheckDistance =\n                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n                ObstaclesLayerMask, Color.cyan, true);\n\n            return _canGoBackHeadCheck.collider == null;\n        }\n\n        /// <summary>\n        /// 启用碰撞\n        /// </summary>\n        public virtual void CollisionsOn()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = true;\n            }\n        }\n\n        /// <summary>\n        /// 禁用碰撞\n        /// </summary>\n        public virtual void CollisionsOff()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = false;\n            }\n        }\n\n        /// <summary>\n        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n        /// </summary>\n        public virtual void SetKinematic(bool state)\n        {\n            _rigidBody.isKinematic = state;\n        }\n\n        /// <summary>\n        /// 设置是否允许自由移动\n        /// </summary>\n        public virtual void SetFreeMovement(bool state)\n        {\n            _freeMovement = state;\n        }\n\n        /// <summary>\n        /// 检测四个基本方向的障碍物\n        /// </summary>\n        /// <param name=\"distance\">检测距离</param>\n        /// <param name=\"offset\">起始偏移</param>\n        public virtual void DetectObstacles(float distance, Vector3 offset)\n        {\n            if (!PerformCardinalObstacleRaycastDetection)\n            {\n                return;\n            }\n\n            CollidingWithCardinalObstacle = false;\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleRight = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleLeft = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleUp = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleDown = null;\n            }\n        }\n\n        /// <summary>\n        /// 重置控制器到初始状态\n        /// </summary>\n        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n            _renderPositionLastFrame = _transform != null ? _transform.position : Vector3.zero;\n            _lastLogicUpdateTime = Time.time;\n            _lastLogicUpdateFrame = -1;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n            return hit;\n        }\n    }\n}","originalFile":"using System;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing ActionMachine.Runtime.Attributes;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 运动学角色控制器（Kinematic Character Controller）\n    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    /// \n    /// 修复：添加逻辑帧与渲染帧之间的插值，解决 30fps 逻辑更新导致的卡顿\n    /// </summary>\n    [RequireComponent(typeof(CharacterController))]\n    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    public partial class Kcc : MonoBehaviour\n    {\n        private const float SMALL_VALUE = 0.0001f;\n        private const float SPEED_ROUNDING_PRECISION = 100f;\n        private const float IMPACT_THRESHOLD = 0.2f;\n\n        public enum GroundedComputationMode\n        {\n            Simple,\n            Advanced\n        }\n\n        public enum VelocityTransferMode\n        {\n            NoTransfer,\n            InitialVelocity,\n            FloorVelocity,\n            Relative\n        }\n\n        [Header(\"Update Mode Settings\")]\n        [Tooltip(\"更新模式：Auto = Update 中自动执行（用于无外部 LogicUpdate 调用）, Manual = 仅通过外部 LogicUpdate 调用执行\")]\n        public UpdateMode UpdateModeType = UpdateMode.Manual;\n\n        public enum UpdateMode\n        {\n            Auto,    // Update 中自动执行物理计算\n            Manual   // 仅通过外部 LogicUpdate 调用执行\n        }\n\n        [Header(\"Gravity Settings\")]\n        [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n        public float Gravity = 40f;\n        [Tooltip(\"是否激活重力\")]\n        public bool GravityActive = true;\n\n        [Header(\"Raycast Settings\")]\n        [Tooltip(\"障碍物层遮罩\")]\n        public LayerMask ObstaclesLayerMask;\n        [Tooltip(\"向下射线检测长度\")]\n        public float GroundedRaycastLength = 5f;\n        [Tooltip(\"最小着地距离\")]\n        public float MinimumGroundedDistance = 0.2f;\n        [Tooltip(\"地面检测计算模式\")]\n        public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n        [Tooltip(\"地面法线高度阈值\")]\n        public float GroundNormalHeightThreshold = 0.2f;\n        [Tooltip(\"蹲伏时射线长度倍数\")]\n        public float CrouchedRaycastLengthMultiplier = 1f;\n        [Tooltip(\"是否执行基本方向障碍物射线检测\")]\n        public bool PerformCardinalObstacleRaycastDetection = false;\n\n        [Header(\"Movement Settings\")]\n        [Tooltip(\"最大下落速度\")]\n        public float MaximumFallSpeed = 20.0f;\n        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速。设为 0 表示立即到达目标速度，消除加速延迟\")]\n        public float HorizontalAcceleration = 0f; // 改为 0，立即到达目标速度\n        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速。设为 0 表示立即停止，消除减速延迟\")]\n        public float HorizontalDeceleration = 0f; // 改为 0，立即停止\n        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n        public float InitialBurstMultiplier = 2.0f;\n        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n        public float BurstSpeedThreshold = 1.0f;\n        [Tooltip(\"斜坡速度倍数曲线\")]\n        public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n            new Keyframe(-90, 1),\n            new Keyframe(0, 1),\n            new Keyframe(90, 0)\n        );\n        [Tooltip(\"冲击力衰减速度\")]\n        public float ImpactFalloff = 5f;\n\n        [Header(\"Steep Surface Settings\")]\n        [Tooltip(\"是否在陡峭表面滑动\")]\n        public bool SlideOnSteepSurfaces = true;\n        [Tooltip(\"滑动速度\")]\n        public float SlidingSpeed = 15f;\n        [Tooltip(\"滑动速度控制\")]\n        public float SlidingSpeedControl = 0.4f;\n        [Tooltip(\"滑动方向控制\")]\n        public float SlidingDirectionControl = 1f;\n\n        [Header(\"Moving Platform Settings\")]\n        [Tooltip(\"跳跃时的速度传递方式\")]\n        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Runtime State - Read Only\")]\n        [SerializeField, ReadOnly] private Vector3 _speed;\n        [SerializeField, ReadOnly] private Vector3 _velocity;\n        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n        [SerializeField, ReadOnly] private Vector3 _acceleration;\n        [SerializeField, ReadOnly] private bool _grounded;\n        [SerializeField, ReadOnly] private bool _justGotGrounded;\n        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n        [SerializeField, ReadOnly] private float _friction;\n        [SerializeField, ReadOnly] private Vector3 _addedForce;\n        [SerializeField, ReadOnly] private bool _freeMovement = true;\n        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n\n        // 公共只读属性\n        public Vector3 Speed => _speed;\n        public Vector3 Velocity => _velocity;\n        public Vector3 VelocityLastFrame => _velocityLastFrame;\n        public Vector3 Acceleration => _acceleration;\n        public bool Grounded => _grounded;\n        public bool JustGotGrounded => _justGotGrounded;\n        public Vector3 CurrentMovement => _currentMovement;\n        public Vector3 CurrentDirection => _currentDirection;\n        public float Friction => _friction;\n        public Vector3 AddedForce => _addedForce;\n        public bool FreeMovement => _freeMovement;\n        public Vector3 GroundNormal => _groundNormal;\n        public Vector3 InputMoveDirection => _inputMoveDirection;\n        public Vector3 TargetVelocity => _targetVelocity;\n\n        // 碰撞器相关属性\n        public Vector3 ColliderCenter => transform.position + _characterController.center;\n        public Vector3 ColliderBottom => transform.position + _characterController.center +\n                                         Vector3.down * _characterController.bounds.extents.y;\n        public Vector3 ColliderTop => transform.position + _characterController.center +\n                                      Vector3.up * _characterController.bounds.extents.y;\n        public Vector3 AppliedImpact => _impact;\n\n        // 环境检测属性\n        public GameObject ObjectBelow { get; set; }\n        public GameObject DetectedObstacleLeft { get; set; }\n        public GameObject DetectedObstacleRight { get; set; }\n        public GameObject DetectedObstacleUp { get; set; }\n        public GameObject DetectedObstacleDown { get; set; }\n        public bool CollidingWithCardinalObstacle { get; set; }\n        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n\n        // 移动平台相关属性\n        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n\n        // 组件引用\n        private Transform _transform;\n        private CharacterController _characterController;\n\n        // 碰撞器原始尺寸\n        private float _originalColliderHeight;\n        private Vector3 _originalColliderCenter;\n\n        // 运动状态追踪\n        private Vector3 _positionLastFrame;\n        private bool _groundedLastFrame;\n        private Vector3 _impact;\n        private Vector3 _lastGroundNormal = Vector3.zero;\n        private bool _detached = false;\n        private bool _tooSteepLastFrame;\n\n        // 移动平台追踪\n        private Transform _movingPlatformHitCollider;\n        private Transform _movingPlatformCurrentHitCollider;\n        private Vector3 _movingPlatformCurrentHitColliderLocal;\n        private Vector3 _movingPlatformCurrentGlobalPoint;\n        private Quaternion _movingPlatformLocalRotation;\n        private Quaternion _movingPlatformGlobalRotation;\n        private Quaternion _lastMoveWithPlatformGlobalRotation;\n        private Matrix4x4 _lastMovingPlatformMatrix;\n        private Vector3 _movingPlatformVelocity;\n        private bool _newMovingPlatform;\n\n        // 碰撞检测\n        private CollisionFlags _collisionFlags;\n        private Vector3 _frameVelocity = Vector3.zero;\n        private Vector3 _hitPoint = Vector3.zero;\n        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n        // 速度计算\n        private Vector3 _newVelocity;\n        private Vector3 _motion;\n        private Vector3 _idealVelocity;\n        private Vector3 _idealDirection;\n        private Vector3 _horizontalVelocityDelta;\n        private float _stickyOffset = 0f;\n\n        // 位置移动\n        private RaycastHit _movePositionHit;\n        private Vector3 _capsulePoint1;\n        private Vector3 _capsulePoint2;\n        private Vector3 _movePositionDirection;\n        private float _movePositionDistance;\n\n        // 障碍物检测\n        private RaycastHit _cardinalRaycast;\n        private float _smallestDistance = Single.MaxValue;\n        private float _longestDistance = Single.MinValue;\n        private RaycastHit _smallestRaycast;\n        private RaycastHit _emptyRaycast = new RaycastHit();\n        private Vector3 _downRaycastsOffset;\n\n        // 平台移动计算\n        private Vector3 _moveWithPlatformMoveDistance;\n        private Vector3 _moveWithPlatformGlobalPoint;\n        private Quaternion _moveWithPlatformRotationDiff;\n        private Quaternion _moveWithPlatformGlobalRotation;\n        private RaycastHit _raycastDownHit;\n        private Vector3 _raycastDownDirection = Vector3.down;\n        private RaycastHit _canGoBackHeadCheck;\n        private Vector3 _originalSizeRaycastOrigin;\n\n        // 协程和可选组件\n        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        private float _currentDeltaTime;\n\n        // ============== 插值相关变量（已废弃，保留用于兼容性）==============\n        /// <summary>\n        /// 逻辑帧的时间间隔（保留字段，用于外部调用兼容性）\n        /// </summary>\n        private float _logicDeltaTime = 1f / 30f;\n        \n        /// <summary>\n        /// 上一次逻辑帧的时间戳\n        /// </summary>\n        private float _lastLogicUpdateTime = 0f;\n\n        /// <summary>\n        /// 上一次执行逻辑更新的帧号（用于防止同一帧重复移动）\n        /// </summary>\n        private int _lastLogicUpdateFrame = -1;\n\n        /// <summary>\n        /// 渲染帧专用的上一帧位置（用于计算速度显示）\n        /// </summary>\n        private Vector3 _renderPositionLastFrame = Vector3.zero;\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n        /// <summary>\n        /// 检查角色头部是否与物体碰撞\n        /// </summary>\n        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n\n        /// <summary>\n        /// 检查当前地面是否过于陡峭\n        /// </summary>\n        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n\n        /// <summary>\n        /// 初始化组件和缓存引用\n        /// </summary>\n        protected virtual void Awake()\n        {\n            _characterController = GetComponent<CharacterController>();\n            _transform = transform;\n            _rigidBody = GetComponent<Rigidbody>();\n            _originalColliderHeight = _characterController.height;\n            _originalColliderCenter = _characterController.center;\n            _currentDirection = _transform.forward;\n            _lastLogicUpdateTime = Time.time;\n            _renderPositionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 每帧更新（渲染帧）\n        /// 根据 UpdateModeType 决定是否在此执行物理计算\n        /// </summary>\n        protected virtual void Update()\n        {\n            float deltaTime = Time.deltaTime;\n            _currentDeltaTime = deltaTime;\n\n            GetMovingPlatformVelocity();\n\n            // 只在 Auto 模式下自动执行物理计算\n            // Manual 模式下，物理计算由外部 LogicUpdate 调用控制\n            if (UpdateModeType == UpdateMode.Auto)\n            {\n                // 检查是否已经在 LogicUpdate 中处理过这一帧（防止双重移动）\n                bool alreadyProcessedThisFrame = (Time.frameCount == _lastLogicUpdateFrame);\n\n                if (!alreadyProcessedThisFrame && _freeMovement)\n                {\n                    ProcessLogicUpdate(deltaTime);\n                }\n            }\n\n            // 更新速度显示（仅用于调试）\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n                _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                _renderPositionLastFrame = _transform.position;\n            }\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 注意：如果外部调用了此方法，Update 将跳过这一帧的处理，避免双重移动\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            _logicDeltaTime = deltaTime;\n            _currentDeltaTime = deltaTime;\n            _lastLogicUpdateTime = Time.time;\n            _lastLogicUpdateFrame = Time.frameCount; // 标记这一帧已处理\n\n            ProcessLogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 固定时间更新（保留用于物理相关操作）\n        /// </summary>\n        protected virtual void FixedUpdate()\n        {\n            _currentDeltaTime = Time.fixedDeltaTime;\n        }\n\n        /// <summary>\n        /// 延迟更新，保存上一帧速度\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            _velocityLastFrame = _velocity;\n        }\n\n        /// <summary>\n        /// 核心逻辑更新处理流程（使用指定的 deltaTime）\n        /// 计算移动逻辑并执行 CharacterController.Move\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ProcessLogicUpdate(float deltaTime)\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            CheckIfGrounded();\n            HandleFriction();\n            DetermineDirection();\n            AddInput(deltaTime);\n            AddGravity(deltaTime);\n            MoveWithPlatform();\n            ComputeVelocityDelta(deltaTime);\n\n            // 执行实际移动\n            MoveCharacterControllerWithMotion(_motion);\n            DetectNewMovingPlatform();\n            ManualControllerColliderHit();\n            HandleGroundContact();\n\n            ComputeNewVelocity(deltaTime);\n        }\n\n        /// <summary>\n        /// 使用指定的移动向量执行 CharacterController 移动\n        /// </summary>\n        /// <param name=\"motion\">移动向量</param>\n        protected virtual void MoveCharacterControllerWithMotion(Vector3 motion)\n        {\n            _groundNormal = Vector3.zero;\n            _collisionFlags = _characterController.Move(motion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n\n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n                _idealVelocity = _idealVelocity * SlidingSpeed;\n                _targetVelocity = _idealVelocity;\n                _newVelocity = _idealVelocity;\n                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n            }\n            else\n            {\n                _targetVelocity = _currentMovement;\n\n                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n\n                Vector3 newHorizontalVelocity;\n\n                // 如果加速度为 0，直接使用目标速度（零延迟响应）\n                if (HorizontalAcceleration <= 0.001f && HorizontalDeceleration <= 0.001f)\n                {\n                    newHorizontalVelocity = targetHorizontalVelocity;\n                }\n                else if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                {\n                    float effectiveAcceleration = HorizontalAcceleration;\n\n                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n                    {\n                        effectiveAcceleration *= InitialBurstMultiplier;\n                    }\n\n                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n\n                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n                    {\n                        newHorizontalVelocity = targetHorizontalVelocity;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n                    }\n                }\n                else\n                {\n                    float currentSpeed = currentHorizontalVelocity.magnitude;\n                    float speedReduction = HorizontalDeceleration * deltaTime;\n\n                    if (currentSpeed <= speedReduction)\n                    {\n                        newHorizontalVelocity = Vector3.zero;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n                    }\n                }\n\n                _newVelocity.x = newHorizontalVelocity.x;\n                _newVelocity.z = newHorizontalVelocity.z;\n\n                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    Vector3 floorVelocity = _frameVelocity;\n                    floorVelocity.y = 0;\n                    _newVelocity.x += floorVelocity.x;\n                    _newVelocity.z += floorVelocity.z;\n                }\n\n                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n\n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity.normalized;\n                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n\n                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n                        {\n                            projectedDirection.Normalize();\n                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                        }\n                    }\n\n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 应用重力到速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddGravity(float deltaTime)\n        {\n            if (GravityActive)\n            {\n                if (_grounded)\n                {\n                    _newVelocity.y = -Gravity * deltaTime;\n                }\n                else\n                {\n                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n                }\n            }\n            _newVelocity += _addedForce;\n            _addedForce = Vector3.zero;\n        }\n\n        /// <summary>\n        /// 跟随移动平台移动\n        /// </summary>\n        protected virtual void MoveWithPlatform()\n        {\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _moveWithPlatformMoveDistance = Vector3.zero;\n                _moveWithPlatformGlobalPoint =\n                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n                if (_moveWithPlatformMoveDistance != Vector3.zero)\n                {\n                    _characterController.Move(_moveWithPlatformMoveDistance);\n                }\n                _moveWithPlatformGlobalRotation =\n                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n            }\n        }\n\n        /// <summary>\n        /// 计算速度增量和粘性偏移\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeVelocityDelta(float deltaTime)\n        {\n            _motion = _newVelocity * deltaTime;\n            _horizontalVelocityDelta.x = _motion.x;\n            _horizontalVelocityDelta.y = 0f;\n            _horizontalVelocityDelta.z = _motion.z;\n\n            // 临时禁用地面粘附，测试是否是它导致的抖动\n            /*\n            // 只有在有水平移动时才应用粘附偏移，避免静止时的抖动\n            float horizontalSpeed = _horizontalVelocityDelta.magnitude;\n            if (_grounded && horizontalSpeed > SMALL_VALUE)\n            {\n                // 使用较小的粘附值，避免过度向下推\n                _stickyOffset = Mathf.Min(_characterController.stepOffset, horizontalSpeed);\n                _motion.y -= _stickyOffset;\n            }\n            */\n        }\n\n        /// <summary>\n        /// 检测是否踩上新的移动平台\n        /// </summary>\n        protected virtual void DetectNewMovingPlatform()\n        {\n            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n            {\n                if (_movingPlatformHitCollider != null)\n                {\n                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n                    _newMovingPlatform = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 计算新速度和加速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeNewVelocity(float deltaTime)\n        {\n            _velocity = _newVelocity;\n            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n        }\n\n        /// <summary>\n        /// 处理地面接触状态和平台速度传递\n        /// </summary>\n        protected virtual void HandleGroundContact()\n        {\n            _grounded = _characterController.isGrounded;\n            if (_grounded && !IsGroundedTest())\n            {\n                _grounded = false;\n                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    _frameVelocity = _movingPlatformVelocity;\n                    _velocity += _movingPlatformVelocity;\n                }\n            }\n            else if (!_grounded && IsGroundedTest())\n            {\n                if (_detached && _velocity.y <= 0)\n                {\n                    _grounded = true;\n                    _detached = false;\n                }\n                SubtractNewPlatformVelocity();\n            }\n\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _movingPlatformCurrentGlobalPoint = _transform.position;\n                _movingPlatformCurrentHitColliderLocal =\n                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n                _movingPlatformGlobalRotation = _transform.rotation;\n                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n                                               _movingPlatformGlobalRotation;\n            }\n\n            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n            _tooSteepLastFrame = TooSteep();\n        }\n\n        /// <summary>\n        /// 计算当前速度（仅用于显示，不影响逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeSpeed(float deltaTime)\n        {\n            // 使用渲染帧专用的位置记录，避免干扰逻辑帧\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n            }\n            _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n\n            _renderPositionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 根据当前移动向量确定方向\n        /// </summary>\n        protected virtual void DetermineDirection()\n        {\n            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n            {\n                _currentDirection = _currentMovement.normalized;\n            }\n        }\n\n        /// <summary>\n        /// 处理摩擦力（预留方法，可在子类中实现）\n        /// </summary>\n        protected virtual void HandleFriction()\n        {\n        }\n\n        /// <summary>\n        /// 检查是否刚刚着地\n        /// </summary>\n        protected virtual void CheckIfGrounded()\n        {\n            _justGotGrounded = !_groundedLastFrame && _grounded;\n            _groundedLastFrame = _grounded;\n        }\n\n        /// <summary>\n        /// 手动触发碰撞器碰撞处理\n        /// </summary>\n        protected virtual void ManualControllerColliderHit()\n        {\n            HandleAdvancedGroundDetection();\n        }\n\n        /// <summary>\n        /// 高级地面检测（使用多方向射线）\n        /// </summary>\n        protected virtual void HandleAdvancedGroundDetection()\n        {\n            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n            {\n                return;\n            }\n\n            _smallestDistance = Single.MaxValue;\n            _longestDistance = Single.MinValue;\n            _smallestRaycast = _emptyRaycast;\n            float offset = _characterController.radius;\n            _downRaycastsOffset = Vector3.zero;\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, offset);\n            CastRayDownwards();\n\n            if (_smallestRaycast.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n                {\n                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n                    {\n                        _groundNormal = _smallestRaycast.normal;\n                    }\n                    else\n                    {\n                        _groundNormal = _lastGroundNormal;\n                    }\n\n                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n                    _hitPoint = _smallestRaycast.point;\n                    _frameVelocity = Vector3.zero;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 向下发射射线检测地面\n        /// </summary>\n        protected virtual void CastRayDownwards()\n        {\n            if (_smallestDistance <= MinimumGroundedDistance)\n            {\n                return;\n            }\n\n            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n                _raycastDownDirection, out _raycastDownHit,\n                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n\n            if (_raycastDownHit.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n                if (adjustedDistance < _smallestDistance)\n                {\n                    _smallestDistance = adjustedDistance;\n                    _smallestRaycast = _raycastDownHit;\n                }\n                if (adjustedDistance > _longestDistance)\n                {\n                    _longestDistance = adjustedDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n        /// </summary>\n        protected float AdjustDistance(float distance)\n        {\n            return distance - _characterController.height / 2f - _characterController.skinWidth;\n        }\n\n        /// <summary>\n        /// 测试是否真正着地\n        /// </summary>\n        protected virtual bool IsGroundedTest()\n        {\n            bool grounded = false;\n            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n            {\n                if (_smallestDistance <= MinimumGroundedDistance)\n                {\n                    grounded = _groundNormal.y > 0.01f;\n                }\n            }\n            else\n            {\n                grounded = _characterController.isGrounded;\n                _groundNormal = Vector3.up;\n            }\n            return grounded;\n        }\n\n        /// <summary>\n        /// 获取移动平台速度\n        /// </summary>\n        protected virtual void GetMovingPlatformVelocity()\n        {\n            if (_movingPlatformCurrentHitCollider != null)\n            {\n                if (!_newMovingPlatform && _currentDeltaTime > SMALL_VALUE)\n                {\n                    _movingPlatformVelocity = (\n                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n                            _movingPlatformCurrentHitColliderLocal)\n                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n                    ) / _currentDeltaTime;\n                }\n                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n                _newMovingPlatform = false;\n            }\n            else\n            {\n                _movingPlatformVelocity = Vector3.zero;\n            }\n        }\n\n        /// <summary>\n        /// 减去新平台速度（处理平台切换）\n        /// </summary>\n        protected virtual void SubtractNewPlatformVelocity()\n        {\n            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n            {\n                if (_newMovingPlatform)\n                {\n                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n                }\n                else\n                {\n                    _velocity -= _movingPlatformVelocity;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 协程：延迟减去平台速度\n        /// </summary>\n        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n        {\n            Transform platform = _movingPlatformCurrentHitCollider;\n            yield return _waitForFixedUpdate;\n            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n            {\n                yield return null;\n            }\n            _velocity -= _movingPlatformVelocity;\n        }\n\n        /// <summary>\n        /// 判断是否应该跟随平台移动\n        /// </summary>\n        protected virtual bool ShouldMoveWithPlatformThisFrame()\n        {\n            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n                   && _movingPlatformCurrentHitCollider != null;\n        }\n\n        /// <summary>\n        /// 应用冲击力并逐渐衰减\n        /// </summary>\n        protected virtual void ApplyImpact()\n        {\n            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n            {\n                _characterController.Move(_impact * _currentDeltaTime);\n            }\n            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * _currentDeltaTime);\n        }\n\n        /// <summary>\n        /// 从地面分离（用于跳跃等）\n        /// </summary>\n        public virtual void DetachFromGround()\n        {\n            _detached = true;\n        }\n\n        /// <summary>\n        /// 从移动平台分离\n        /// </summary>\n        public virtual void DetachFromMovingPlatform()\n        {\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n        }\n\n        /// <summary>\n        /// 设置重力是否激活\n        /// </summary>\n        public virtual void SetGravityActive(bool status)\n        {\n            GravityActive = status;\n        }\n\n        /// <summary>\n        /// 添加外部力（会在下一帧应用）\n        /// </summary>\n        public virtual void AddForce(Vector3 movement)\n        {\n            _addedForce += movement;\n        }\n\n        /// <summary>\n        /// 施加瞬时冲击力\n        /// </summary>\n        /// <param name=\"direction\">冲击方向</param>\n        /// <param name=\"force\">冲击力大小</param>\n        public virtual void Impact(Vector3 direction, float force)\n        {\n            direction = direction.normalized;\n            if (direction.y < 0)\n            {\n                direction.y = -direction.y;\n            }\n            _impact += direction.normalized * force;\n        }\n\n        /// <summary>\n        /// 设置移动向量（通常由输入系统调用）\n        /// </summary>\n        /// <param name=\"movement\">移动向量</param>\n        public virtual void SetMovement(Vector3 movement)\n        {\n            _currentMovement = movement;\n            Vector3 directionVector = movement;\n            if (directionVector != Vector3.zero)\n            {\n                float directionLength = directionVector.magnitude;\n                directionVector = directionVector / directionLength;\n                directionLength = Mathf.Min(1, directionLength);\n                directionLength = directionLength * directionLength;\n                directionVector = directionVector * directionLength;\n            }\n            _inputMoveDirection = transform.rotation * directionVector;\n        }\n\n        /// <summary>\n        /// 移动到指定位置（带碰撞检测）\n        /// </summary>\n        /// <param name=\"newPosition\">目标位置</param>\n        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n        {\n            _movePositionDirection = newPosition - transform.position;\n            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n\n            _capsulePoint1 = transform.position\n                             + _characterController.center\n                             - (Vector3.up * _characterController.height / 2f)\n                             + Vector3.up * _characterController.skinWidth\n                             + Vector3.up * _characterController.radius;\n\n            _capsulePoint2 = transform.position\n                             + _characterController.center\n                             + (Vector3.up * _characterController.height / 2f)\n                             - Vector3.up * _characterController.skinWidth\n                             - Vector3.up * _characterController.radius;\n\n            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n            {\n                transform.position = newPosition;\n            }\n        }\n\n        /// <summary>\n        /// 调整碰撞器高度（用于蹲伏等）\n        /// </summary>\n        /// <param name=\"newHeight\">新高度</param>\n        /// <param name=\"translateCenter\">是否平移中心点</param>\n        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n        {\n            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n            _characterController.height = newHeight;\n            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n            if (translateCenter)\n            {\n                transform.Translate((newYOffset / 2f) * Vector3.up);\n            }\n        }\n\n        /// <summary>\n        /// 重置碰撞器尺寸到原始大小\n        /// </summary>\n        public virtual void ResetColliderSize()\n        {\n            _characterController.height = _originalColliderHeight;\n            _characterController.center = _originalColliderCenter;\n        }\n\n        /// <summary>\n        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n        /// </summary>\n        public virtual bool CanGoBackToOriginalSize()\n        {\n            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n            {\n                return true;\n            }\n\n            float headCheckDistance =\n                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n                ObstaclesLayerMask, Color.cyan, true);\n\n            return _canGoBackHeadCheck.collider == null;\n        }\n\n        /// <summary>\n        /// 启用碰撞\n        /// </summary>\n        public virtual void CollisionsOn()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = true;\n            }\n        }\n\n        /// <summary>\n        /// 禁用碰撞\n        /// </summary>\n        public virtual void CollisionsOff()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = false;\n            }\n        }\n\n        /// <summary>\n        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n        /// </summary>\n        public virtual void SetKinematic(bool state)\n        {\n            _rigidBody.isKinematic = state;\n        }\n\n        /// <summary>\n        /// 设置是否允许自由移动\n        /// </summary>\n        public virtual void SetFreeMovement(bool state)\n        {\n            _freeMovement = state;\n        }\n\n        /// <summary>\n        /// 检测四个基本方向的障碍物\n        /// </summary>\n        /// <param name=\"distance\">检测距离</param>\n        /// <param name=\"offset\">起始偏移</param>\n        public virtual void DetectObstacles(float distance, Vector3 offset)\n        {\n            if (!PerformCardinalObstacleRaycastDetection)\n            {\n                return;\n            }\n\n            CollidingWithCardinalObstacle = false;\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleRight = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleLeft = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleUp = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleDown = null;\n            }\n        }\n\n        /// <summary>\n        /// 重置控制器到初始状态\n        /// </summary>\n        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n            _renderPositionLastFrame = _transform != null ? _transform.position : Vector3.zero;\n            _lastLogicUpdateTime = Time.time;\n            _lastLogicUpdateFrame = -1;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n            return hit;\n        }\n    }\n}\n","structuredPatch":[{"oldStart":288,"oldLines":12,"newStart":288,"newLines":13,"lines":["             float deltaTime = Time.deltaTime;","             _currentDeltaTime = deltaTime;"," ","-            GetMovingPlatformVelocity();","-","             // 只在 Auto 模式下自动执行物理计算","             // Manual 模式下，物理计算由外部 LogicUpdate 调用控制","             if (UpdateModeType == UpdateMode.Auto)","             {","+                // 在 Auto 模式下才更新平台速度","+                GetMovingPlatformVelocity();","+","                 // 检查是否已经在 LogicUpdate 中处理过这一帧（防止双重移动）","                 bool alreadyProcessedThisFrame = (Time.frameCount == _lastLogicUpdateFrame);"," "]},{"oldStart":301,"oldLines":16,"newStart":302,"newLines":16,"lines":["                 {","                     ProcessLogicUpdate(deltaTime);","                 }","-            }"," ","-            // 更新速度显示（仅用于调试）","-            if (deltaTime > SMALL_VALUE)","-            {","-                _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;","-                _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;","-                _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;","-                _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;","-                _renderPositionLastFrame = _transform.position;","+                // 更新速度显示（仅用于调试）","+                if (deltaTime > SMALL_VALUE)","+                {","+                    _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;","+                    _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;","+                    _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;","+                    _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;","+                    _renderPositionLastFrame = _transform.position;","+                }","             }","         }"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"326732cd-05fb-4296-bef4-d1a630012f3c","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0129JzzoExWdLGonbe99LZdc","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，我已经修改了 Kcc.cs 的 Update() 方法。现在在 Manual 模式下，GetMovingPlatformVelocity() 和速度显示的更新都不会执行了，只有在 Auto 模式下才会执行这些操作。\n\n现在让我再检查一下是否还有其他可能导致抖动的问题，并给用户一个总结和额外的建议。","signature":"EvUDCkYIChgCKkDrHTP5bPB013re/TGb5pXHf5sAQJErBrcIwkEnzVC/UWIIC2hz1dBhl99IeWWU8KR39dI8xf+jBuJLJ/dWJdS/EgxweXFhPF8TC0T4gnYaDJvwGddk19+jJ3mGXCIwTAmaoW+GnwXdtFm0h4Da/g+WR6Vo82F7/T4F/aGGF+rcS/SeImTCmN6+DdTOH4whKtwCeZbepsDqfAcBXwsjPzq1p4fsXpho+6RIoVQjGdBFNAJ1ZXiyayjJd0dtgnIM8K1PYPy/bJ4+zSNGSjkA8dKeejjJNsXiKk/6HRQpm11kZsrc9+/Y4Sbhv1LClQd9FR1uUcGIP8t0JYxMtKgA957hAQoDKsHScTcHpUrkdJ/lOVat9cOfyTqqqmMBgZwHilZmsZ32Cag/EDsBh7z9YE3nr8fEbG2y56RkP3pn0FTCO21xYM0pFXUmCR3BpwH5uA9zwFHlW3PWxAT0fHUrxmC6xQbqGaY7ceFgzFsdZma8+6o7CQNTPR7BRvTCqajLHDSxeBulUT987p5/Wj97ZlQQWCdJFqXWMk4L6UMV6El/wGpj5llyDIWHl7Y4g9/D0QgICj2TmxOOTlZlNtW3d7UXdnF/l/tljghRzI1P9Gip8shUvUm1ZuAYPZeWzMiAPZFp7KiW68MMiLQpZ310GAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":19248,"cache_read_input_tokens":96520,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":19248},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"e9a8ea89-cd7c-46fc-b76a-d9009cd40d1a","timestamp":"2025-12-15T10:55:25.932Z"}
{"parentUuid":"e9a8ea89-cd7c-46fc-b76a-d9009cd40d1a","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0129JzzoExWdLGonbe99LZdc","type":"message","role":"assistant","content":[{"type":"text","text":"好的，我已经修复了第一个问题。现在让我再检查 `ActionController` 中的 `UpdateRotation()` 方法，这也可能是导致抖动的原因："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":19248,"cache_read_input_tokens":96520,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":19248},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"55d15442-e4d2-4814-9015-5d551c943afe","timestamp":"2025-12-15T10:55:25.945Z"}
{"parentUuid":"55d15442-e4d2-4814-9015-5d551c943afe","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0129JzzoExWdLGonbe99LZdc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JNmrbEjM5JGc1cbA9h9rvF","name":"Edit","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\ActionController.cs","old_string":"        private void UpdateRotation()\n        {\n            Vector3 velocity = _kcc.Velocity;\n            velocity.y = 0f;\n            if (velocity.magnitude > 0.0001f)\n            {\n                _modelRotation = Quaternion.LookRotation(velocity);\n            }\n\n            var modelRoot = GetNodeTransform(CharacterNodeType.Animator);\n            modelRoot.rotation = Quaternion.Lerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 10);\n        }","new_string":"        private void UpdateRotation()\n        {\n            Vector3 velocity = _kcc.Velocity;\n            velocity.y = 0f;\n            if (velocity.magnitude > 0.0001f)\n            {\n                _modelRotation = Quaternion.LookRotation(velocity);\n\n                var modelRoot = GetNodeTransform(CharacterNodeType.Animator);\n                // 使用 Slerp 代替 Lerp 来获得更平滑的旋转\n                // 使用固定的插值速度，避免帧率波动导致的抖动\n                modelRoot.rotation = Quaternion.Slerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 15f);\n            }\n        }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":19248,"cache_read_input_tokens":96520,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":19248},"output_tokens":620,"service_tier":"standard"}},"type":"assistant","uuid":"10e514c2-6f83-4f2c-826f-925c43c82b04","timestamp":"2025-12-15T10:55:30.556Z"}
{"type":"file-history-snapshot","messageId":"10e514c2-6f83-4f2c-826f-925c43c82b04","snapshot":{"messageId":"914f6acc-1402-4804-a642-2a6ef5386e36","trackedFileBackups":{"CLAUDE.md":{"backupFileName":"0b5c4e3350b32821@v2","version":2,"backupTime":"2025-12-15T10:53:40.569Z"},"Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs":{"backupFileName":"b1c9467c2d2e4b63@v1","version":1,"backupTime":"2025-12-15T10:55:11.661Z"},"Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\ActionController.cs":{"backupFileName":"8e4255d1848fa081@v1","version":1,"backupTime":"2025-12-15T10:55:38.706Z"}},"timestamp":"2025-12-15T10:53:40.568Z"},"isSnapshotUpdate":true}
{"parentUuid":"10e514c2-6f83-4f2c-826f-925c43c82b04","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JNmrbEjM5JGc1cbA9h9rvF","type":"tool_result","content":"The file E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\ActionController.cs has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→using System;\n     2→using System.Collections.Generic;\n     3→using Animancer;\n     4→using NBC.ActionEditor;\n     5→using UnityEngine;\n     6→\n     7→namespace ActionMachine.Runtime.Controller\n     8→{\n     9→    /// <summary>\n    10→    /// 角色动作控制器\n    11→    /// </summary>\n    12→    public sealed partial class ActionController : MonoBehaviour, IActionController\n    13→    {\n    14→        [SerializeField] [HideInInspector] private AnimancerComponent animator;\n    15→        [SerializeField] [HideInInspector] private List<CharacterNode> characterNodes;\n    16→\n    17→\n    18→        /// <summary>\n    19→        /// 动作控制器\n    20→        /// </summary>\n    21→        private IActionMachine _actionMachine;\n    22→\n    23→        private Rigidbody _rigidbody;\n    24→        private Quaternion _modelRotation;\n    25→        private Kcc _kcc;\n    26→\n    27→        public AnimancerComponent Animator => animator;\n    28→\n    29→        public Quaternion ModelRotation => _modelRotation;\n    30→\n    31→        public Kcc Kcc => _kcc;\n    32→\n    33→        private void Awake()\n    34→        {\n    35→            _rigidbody = this.GetComponent<Rigidbody>();\n    36→            _kcc = this.GetComponent<Kcc>();\n    37→        }\n    38→\n    39→        private void Update()\n    40→        {\n    41→            if (_actionMachine == null)\n    42→            {\n    43→                return;\n    44→            }\n    45→\n    46→            _actionMachine.RenderUpdate(Time.deltaTime);\n    47→            UpdateRotation();\n    48→        }\n    49→\n    50→        public void LogicUpdate(float deltaTime)\n    51→        {\n    52→            if (_actionMachine == null)\n    53→            {\n    54→                return;\n    55→            }\n    56→\n    57→            _actionMachine.LogicUpdate(deltaTime);\n    58→            _kcc.LogicUpdate(deltaTime);\n    59→        }\n    60→\n    61→        /// <summary>\n    62→        /// 获取NodeTransform\n    63→        /// </summary>\n    64→        /// <param name=\"type\"></param>\n    65→        /// <returns></returns>\n    66→        public Transform GetNodeTransform(CharacterNodeType type)\n    67→        {\n    68→            if (type == CharacterNodeType.Animator)\n    69→            {\n    70→                if (animator != null)\n    71→                {\n    72→                    return animator.transform;\n    73→                }\n    74→\n    75→                return transform;\n    76→            }\n    77→\n    78→            for (int i = 0; i < characterNodes.Count; i++)\n    79→            {\n    80→                if (characterNodes[i].type == type)\n    81→                {\n    82→                    if (characterNodes[i].bindTransform == null)\n    83→                    {\n    84→                        return animator.transform;\n    85→                    }\n    86→\n    87→                    return characterNodes[i].bindTransform;\n    88→                }\n    89→            }\n    90→\n    91→            return animator.transform;\n    92→        }\n    93→\n    94→        public void Initialized(ActionMachineInitializeData data)\n    95→        {\n    96→            _actionMachine = new ActionMachine();\n    97→            _ = _actionMachine.Initialize(data, this);\n    98→        }\n    99→\n   100→        public Rigidbody GetRigidbody()\n   101→        {\n   102→            return _rigidbody;\n   103→        }\n   104→\n   105→        private void UpdateRotation()\n   106→        {\n   107→            Vector3 velocity = _kcc.Velocity;\n   108→            velocity.y = 0f;\n   109→            if (velocity.magnitude > 0.0001f)\n   110→            {\n   111→                _modelRotation = Quaternion.LookRotation(velocity);\n   112→\n   113→                var modelRoot = GetNodeTransform(CharacterNodeType.Animator);\n   114→                // 使用 Slerp 代替 Lerp 来获得更平滑的旋转\n   115→                // 使用固定的插值速度，避免帧率波动导致的抖动\n   116→                modelRoot.rotation = Quaternion.Slerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 15f);\n   117→            }\n   118→        }\n   119→    }\n   120→}"}]},"uuid":"55650c17-6f85-4d3b-96f9-9fd9d2aa83d8","timestamp":"2025-12-15T10:55:38.709Z","toolUseResult":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\ActionController.cs","oldString":"using System;\nusing System.Collections.Generic;\nusing Animancer;\nusing NBC.ActionEditor;\nusing UnityEngine;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 角色动作控制器\n    /// </summary>\n    public sealed partial class ActionController : MonoBehaviour, IActionController\n    {\n        [SerializeField] [HideInInspector] private AnimancerComponent animator;\n        [SerializeField] [HideInInspector] private List<CharacterNode> characterNodes;\n\n\n        /// <summary>\n        /// 动作控制器\n        /// </summary>\n        private IActionMachine _actionMachine;\n\n        private Rigidbody _rigidbody;\n        private Quaternion _modelRotation;\n        private Kcc _kcc;\n\n        public AnimancerComponent Animator => animator;\n\n        public Quaternion ModelRotation => _modelRotation;\n\n        public Kcc Kcc => _kcc;\n\n        private void Awake()\n        {\n            _rigidbody = this.GetComponent<Rigidbody>();\n            _kcc = this.GetComponent<Kcc>();\n        }\n\n        private void Update()\n        {\n            if (_actionMachine == null)\n            {\n                return;\n            }\n\n            _actionMachine.RenderUpdate(Time.deltaTime);\n            UpdateRotation();\n        }\n\n        public void LogicUpdate(float deltaTime)\n        {\n            if (_actionMachine == null)\n            {\n                return;\n            }\n\n            _actionMachine.LogicUpdate(deltaTime);\n            _kcc.LogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 获取NodeTransform\n        /// </summary>\n        /// <param name=\"type\"></param>\n        /// <returns></returns>\n        public Transform GetNodeTransform(CharacterNodeType type)\n        {\n            if (type == CharacterNodeType.Animator)\n            {\n                if (animator != null)\n                {\n                    return animator.transform;\n                }\n\n                return transform;\n            }\n\n            for (int i = 0; i < characterNodes.Count; i++)\n            {\n                if (characterNodes[i].type == type)\n                {\n                    if (characterNodes[i].bindTransform == null)\n                    {\n                        return animator.transform;\n                    }\n\n                    return characterNodes[i].bindTransform;\n                }\n            }\n\n            return animator.transform;\n        }\n\n        public void Initialized(ActionMachineInitializeData data)\n        {\n            _actionMachine = new ActionMachine();\n            _ = _actionMachine.Initialize(data, this);\n        }\n\n        public Rigidbody GetRigidbody()\n        {\n            return _rigidbody;\n        }\n\n        private void UpdateRotation()\n        {\n            Vector3 velocity = _kcc.Velocity;\n            velocity.y = 0f;\n            if (velocity.magnitude > 0.0001f)\n            {\n                _modelRotation = Quaternion.LookRotation(velocity);\n            }\n\n            var modelRoot = GetNodeTransform(CharacterNodeType.Animator);\n            modelRoot.rotation = Quaternion.Lerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 10);\n        }\n    }\n}","newString":"using System;\nusing System.Collections.Generic;\nusing Animancer;\nusing NBC.ActionEditor;\nusing UnityEngine;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 角色动作控制器\n    /// </summary>\n    public sealed partial class ActionController : MonoBehaviour, IActionController\n    {\n        [SerializeField] [HideInInspector] private AnimancerComponent animator;\n        [SerializeField] [HideInInspector] private List<CharacterNode> characterNodes;\n\n\n        /// <summary>\n        /// 动作控制器\n        /// </summary>\n        private IActionMachine _actionMachine;\n\n        private Rigidbody _rigidbody;\n        private Quaternion _modelRotation;\n        private Kcc _kcc;\n\n        public AnimancerComponent Animator => animator;\n\n        public Quaternion ModelRotation => _modelRotation;\n\n        public Kcc Kcc => _kcc;\n\n        private void Awake()\n        {\n            _rigidbody = this.GetComponent<Rigidbody>();\n            _kcc = this.GetComponent<Kcc>();\n        }\n\n        private void Update()\n        {\n            if (_actionMachine == null)\n            {\n                return;\n            }\n\n            _actionMachine.RenderUpdate(Time.deltaTime);\n            UpdateRotation();\n        }\n\n        public void LogicUpdate(float deltaTime)\n        {\n            if (_actionMachine == null)\n            {\n                return;\n            }\n\n            _actionMachine.LogicUpdate(deltaTime);\n            _kcc.LogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 获取NodeTransform\n        /// </summary>\n        /// <param name=\"type\"></param>\n        /// <returns></returns>\n        public Transform GetNodeTransform(CharacterNodeType type)\n        {\n            if (type == CharacterNodeType.Animator)\n            {\n                if (animator != null)\n                {\n                    return animator.transform;\n                }\n\n                return transform;\n            }\n\n            for (int i = 0; i < characterNodes.Count; i++)\n            {\n                if (characterNodes[i].type == type)\n                {\n                    if (characterNodes[i].bindTransform == null)\n                    {\n                        return animator.transform;\n                    }\n\n                    return characterNodes[i].bindTransform;\n                }\n            }\n\n            return animator.transform;\n        }\n\n        public void Initialized(ActionMachineInitializeData data)\n        {\n            _actionMachine = new ActionMachine();\n            _ = _actionMachine.Initialize(data, this);\n        }\n\n        public Rigidbody GetRigidbody()\n        {\n            return _rigidbody;\n        }\n\n        private void UpdateRotation()\n        {\n            Vector3 velocity = _kcc.Velocity;\n            velocity.y = 0f;\n            if (velocity.magnitude > 0.0001f)\n            {\n                _modelRotation = Quaternion.LookRotation(velocity);\n\n                var modelRoot = GetNodeTransform(CharacterNodeType.Animator);\n                // 使用 Slerp 代替 Lerp 来获得更平滑的旋转\n                // 使用固定的插值速度，避免帧率波动导致的抖动\n                modelRoot.rotation = Quaternion.Slerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 15f);\n            }\n        }\n    }\n}","originalFile":"using System;\nusing System.Collections.Generic;\nusing Animancer;\nusing NBC.ActionEditor;\nusing UnityEngine;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 角色动作控制器\n    /// </summary>\n    public sealed partial class ActionController : MonoBehaviour, IActionController\n    {\n        [SerializeField] [HideInInspector] private AnimancerComponent animator;\n        [SerializeField] [HideInInspector] private List<CharacterNode> characterNodes;\n\n\n        /// <summary>\n        /// 动作控制器\n        /// </summary>\n        private IActionMachine _actionMachine;\n\n        private Rigidbody _rigidbody;\n        private Quaternion _modelRotation;\n        private Kcc _kcc;\n\n        public AnimancerComponent Animator => animator;\n\n        public Quaternion ModelRotation => _modelRotation;\n\n        public Kcc Kcc => _kcc;\n\n        private void Awake()\n        {\n            _rigidbody = this.GetComponent<Rigidbody>();\n            _kcc = this.GetComponent<Kcc>();\n        }\n\n        private void Update()\n        {\n            if (_actionMachine == null)\n            {\n                return;\n            }\n\n            _actionMachine.RenderUpdate(Time.deltaTime);\n            UpdateRotation();\n        }\n\n        public void LogicUpdate(float deltaTime)\n        {\n            if (_actionMachine == null)\n            {\n                return;\n            }\n\n            _actionMachine.LogicUpdate(deltaTime);\n            _kcc.LogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 获取NodeTransform\n        /// </summary>\n        /// <param name=\"type\"></param>\n        /// <returns></returns>\n        public Transform GetNodeTransform(CharacterNodeType type)\n        {\n            if (type == CharacterNodeType.Animator)\n            {\n                if (animator != null)\n                {\n                    return animator.transform;\n                }\n\n                return transform;\n            }\n\n            for (int i = 0; i < characterNodes.Count; i++)\n            {\n                if (characterNodes[i].type == type)\n                {\n                    if (characterNodes[i].bindTransform == null)\n                    {\n                        return animator.transform;\n                    }\n\n                    return characterNodes[i].bindTransform;\n                }\n            }\n\n            return animator.transform;\n        }\n\n        public void Initialized(ActionMachineInitializeData data)\n        {\n            _actionMachine = new ActionMachine();\n            _ = _actionMachine.Initialize(data, this);\n        }\n\n        public Rigidbody GetRigidbody()\n        {\n            return _rigidbody;\n        }\n\n        private void UpdateRotation()\n        {\n            Vector3 velocity = _kcc.Velocity;\n            velocity.y = 0f;\n            if (velocity.magnitude > 0.0001f)\n            {\n                _modelRotation = Quaternion.LookRotation(velocity);\n            }\n\n            var modelRoot = GetNodeTransform(CharacterNodeType.Animator);\n            modelRoot.rotation = Quaternion.Lerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 10);\n        }\n    }\n}","structuredPatch":[{"oldStart":109,"oldLines":10,"newStart":109,"newLines":12,"lines":["             if (velocity.magnitude > 0.0001f)","             {","                 _modelRotation = Quaternion.LookRotation(velocity);","-            }"," ","-            var modelRoot = GetNodeTransform(CharacterNodeType.Animator);","-            modelRoot.rotation = Quaternion.Lerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 10);","+                var modelRoot = GetNodeTransform(CharacterNodeType.Animator);","+                // 使用 Slerp 代替 Lerp 来获得更平滑的旋转","+                // 使用固定的插值速度，避免帧率波动导致的抖动","+                modelRoot.rotation = Quaternion.Slerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 15f);","+            }","         }","     }"," }","\\ No newline at end of file"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"55650c17-6f85-4d3b-96f9-9fd9d2aa83d8","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JQHaVUwmT9cnhppEUjqHUf","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，我已经做了以下修改：\n\n1. 在 Kcc.cs 中：\n   - 将 GetMovingPlatformVelocity() 移到 Auto 模式的判断内部\n   - 将速度显示更新也移到 Auto 模式的判断内部\n   - 这样在 Manual 模式下，Update() 中几乎什么都不做\n\n2. 在 ActionController.cs 中：\n   - 使用 Quaternion.Slerp 代替 Lerp（Slerp 对旋转更平滑）\n   - 将旋转速度从 10 提高到 15，使旋转更快响应\n   - 将旋转更新移到 if 块内部，只在有速度时才更新\n\n现在让我总结一下问题和解决方案给用户。","signature":"EtUFCkYIChgCKkBoI7UKh/jHltHDhhS2F2m+r7X7G/zVdlSMEnMjNbARwDDO9nfxpCylG4frqbsyyiQTVGv3UjaieUjjSQBUm6cJEgzBzD1x2zDcZALdxeUaDP+NpNWxjRBui28pfyIwXZWFcL8CLlUSAA2OnsKNACzZ4CO2xl7c1g3cdjVcXLO+2/2t3Ix27LNToCAGyybnKrwEPUndxnoYcWCy02VimpMDSmM2nsXki10HQxjwhkY4z2vRfB1msd+TSXzlCLeeqG86MeTnD2/TN9uJbk3PuNekPptNodwpy9ENHYf3biQW9N5Xz4x4Ny0PVzSWrb3dBFV4xzC47O3Atrg4EByVN0uRXFw7cEiuMkvbTlIIl/eNVNCpkGhTHZC5GQ/1ZbCYD98AZKoa06wZkOqEgYz8yp9AQPkTppQ65UZKFPCspnotSF7UQZQwIzdxqmGnP1FIoUYAHUKGMxE0djcNn+I5FucaUA6nRgJEPdWtnzieT0U79N2CiPxi2pDx+en8ICebMmeuNeb2o3A3bbMJf+Kqvo0PrmbJvo8Wl8pL/Jc7X7Xydxk4Yt8EsUg3w35eICTYacw7/jV6sk29kFtvaFs+vO9Sjzp0WXM10vEc3Fzu5uazqJaOtic/RwcOHRkc91HDIc1gdEVdTWDKS+9Y4Ggp6dmTECtmnKP7mRL6U6OcTVlKcKoeHs1uDTfA43mGACnlfP8Jh4qvu3k507UCwEPqM1K3fhEpZJcqeuxgv6OhQwdSK2tuFV16jtTeswgIiUx96V3LJs9T/chmKKbuwZldgUyitJ3jAThfl5j+CNFaa2RuYN/lxl+KR+R/D9w5BiuIuCIt8EnCOU/+upvsmAhGQYqhq2o2CYwd0gyzrjUTWSXe7vEWladV2Yfn4rY+AJ1r8blHRE3O6SZy1B+CzNxAF9zCvsx/3pN3DceKMr7mgETtEXukXPobcZZt5PNt4h8YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":2060,"cache_read_input_tokens":115768,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2060},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"181ceb6c-2c45-40fb-aac9-6b34c4b88a40","timestamp":"2025-12-15T10:55:48.536Z"}
{"parentUuid":"181ceb6c-2c45-40fb-aac9-6b34c4b88a40","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JQHaVUwmT9cnhppEUjqHUf","type":"message","role":"assistant","content":[{"type":"text","text":"## 修复总结\n\n我已经修复了导致抖动的两个主要问题：\n\n### 问题 1：Kcc.Update() 中的冗余更新（已修复）\n\n**原因**：在 Manual 模式下，`GetMovingPlatformVelocity()` 和速度显示计算每帧都在执行，导致不必要的计算和状态更新。\n\n**修复**：将这些操作移到 `Auto` 模式的条件判断内：\n```csharp:Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs\nif (UpdateModeType == UpdateMode.Auto)\n{\n    // 只在 Auto 模式下才更新平台速度和速度显示\n    GetMovingPlatformVelocity();\n    // ... 其他更新\n}\n```\n\n### 问题 2：UpdateRotation() 使用 Lerp 导致旋转不平滑（已修复）\n\n**原因**：\n- 使用 `Quaternion.Lerp` 对旋转插值不够平滑\n- 旋转速度 10 可能不够快，导致延迟\n- 每帧都执行旋转，即使角色没有移动\n\n**修复**：\n```csharp:Assets/_Game/Scripts/ActionMachine/Runtime/Controller/ActionController.cs\nif (velocity.magnitude > 0.0001f)\n{\n    _modelRotation = Quaternion.LookRotation(velocity);\n    // 使用 Slerp 获得更平滑的旋转\n    modelRoot.rotation = Quaternion.Slerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 15f);\n}\n```\n\n## 其他潜在问题检查\n\n让我检查一下 Kcc 在 Unity 中的配置：\n\n如果抖动仍然存在，请检查以下设置：\n\n### 1. **确认 UpdateModeType 设置为 Manual**\n在 Unity Inspector 中，确保 Kcc 组件的 `UpdateModeType` 是 `Manual`。\n\n### 2. **检查 CharacterController 的 Skin Width**\n```csharp\n// 建议值\ncharacterController.skinWidth = 0.08f; // 默认是 0.08，太小可能导致抖动\n```\n\n### 3. **检查地面检测设置**\n```csharp\n// 在 Kcc 组件上\nGroundDetectionMode = Advanced;  // 使用高级检测\nMinimumGroundedDistance = 0.1f;  // 不要太小\nGroundedRaycastLength = 0.5f;    // 适中的检测距离\n```\n\n### 4. **检查是否有其他脚本在 Update 中移动角色**\n搜索是否有其他地方调用了 `transform.position` 或 `CharacterController.Move`："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":2060,"cache_read_input_tokens":115768,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2060},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"958a59da-0b26-4e9d-996a-a13a15503b86","timestamp":"2025-12-15T10:56:00.931Z"}
{"parentUuid":"958a59da-0b26-4e9d-996a-a13a15503b86","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JQHaVUwmT9cnhppEUjqHUf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Sj4Lpk5kkNYU83MC1Y6z2Y","name":"Grep","input":{"pattern":"transform\\.position\\s*=","glob":"**/*.cs","output_mode":"files_with_matches","path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":2060,"cache_read_input_tokens":115768,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2060},"output_tokens":1168,"service_tier":"standard"}},"type":"assistant","uuid":"4009df9b-ebb5-4312-ad42-5c2524a8077d","timestamp":"2025-12-15T10:56:02.473Z"}
{"parentUuid":"4009df9b-ebb5-4312-ad42-5c2524a8077d","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Sj4Lpk5kkNYU83MC1Y6z2Y","type":"tool_result","content":"Found 6 files\nAssets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs\nAssets\\_Game\\Scripts\\ActionMachine\\Runtime\\Directables\\InstantiateObjectParam.cs\nAssets\\_Game\\Scripts\\ActionMachine\\Runtime\\Tool\\NodeFollower.cs\nAssets\\_Game\\Scripts\\ActionMachine\\Editor\\Preview\\Clips\\MoveToPreview.cs\nAssets\\_Game\\Scripts\\ActionMachine\\Editor\\Preview\\Clips\\MoveByPreview.cs\nAssets\\_Game\\Scripts\\ActionMachine\\Editor\\Preview\\Clips\\Animation\\PlayAnimationPreview.cs"}]},"uuid":"b8e618c0-e2bc-49a9-8565-4d27fa2f06c4","timestamp":"2025-12-15T10:56:03.555Z","toolUseResult":{"mode":"files_with_matches","filenames":["Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Directables\\InstantiateObjectParam.cs","Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Tool\\NodeFollower.cs","Assets\\_Game\\Scripts\\ActionMachine\\Editor\\Preview\\Clips\\MoveToPreview.cs","Assets\\_Game\\Scripts\\ActionMachine\\Editor\\Preview\\Clips\\MoveByPreview.cs","Assets\\_Game\\Scripts\\ActionMachine\\Editor\\Preview\\Clips\\Animation\\PlayAnimationPreview.cs"],"numFiles":6}}
{"parentUuid":"b8e618c0-e2bc-49a9-8565-4d27fa2f06c4","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01HaEYMxeHWY8zF586TBMXzV","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，看起来没有其他地方直接设置 transform.position（除了 Kcc.cs 和一些编辑器预览脚本）。\n\n让我给用户一些额外的调试建议。","signature":"Es4CCkYIChgCKkDpsQTZGTO4semR+5XbN0Czgx8R6lHW8cGm0FD3S1sbl1XtQ288fglga6hcAszSlr/u27ZzB7c/COTa7qwDT5NKEgwu1IgJdt6o0WD6uXMaDB/ItVB0ssUjXWIJXiIwmAEnMphUNHJs/1XITxTrzbBfNsPrMw5ltxAERRN8DLFNRWTbqfc8jDO9bL9T2Po4KrUBW58jLdLptE5vLZqaW1wZPCZrzJ3wgE5XA6OSw/Kqrs/yw/+hmmPQGrrdEAoxggQu0JXQZhyt+4fGAp3A8VGOmX2iXJFI3PJq/ATmvhqTyZ6jXNd611w4M7zx0xVpsfZWlmisIVQoYGw5l2v1I0gdifw+Xk8rrQHiGMm9nOK/SQNkzd+hYGJ8hYAM/HheEq/+KgSIgkHuzNsmfMbbXiJ/Cjc8Zcjv5UWSOfdmx5B1GEUSL4atahgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1333,"cache_read_input_tokens":117828,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1333},"output_tokens":4,"service_tier":"standard"}},"type":"assistant","uuid":"b79932f5-344c-4932-abaa-348a7aea3b50","timestamp":"2025-12-15T10:56:16.840Z"}
{"parentUuid":"b79932f5-344c-4932-abaa-348a7aea3b50","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01HaEYMxeHWY8zF586TBMXzV","type":"message","role":"assistant","content":[{"type":"text","text":"## 调试建议\n\n如果修改后抖动仍然存在，请尝试以下调试步骤：\n\n### 步骤 1：在 Unity Scene 视图中观察\n\n打开 Unity 的 Scene 视图，在游戏运行时观察：\n- 角色的移动是否流畅\n- 是否有明显的位置跳动\n- 旋转是否平滑\n\n### 步骤 2：添加调试日志\n\n在 `Kcc.LogicUpdate()` 中添加日志：\n\n```csharp\npublic virtual void LogicUpdate(float deltaTime)\n{\n    #if UNITY_EDITOR\n    Debug.Log($\"[Kcc] Frame:{Time.frameCount} DeltaTime:{deltaTime:F4} Position:{_transform.position}\");\n    #endif\n    \n    _logicDeltaTime = deltaTime;\n    _currentDeltaTime = deltaTime;\n    _lastLogicUpdateTime = Time.time;\n    _lastLogicUpdateFrame = Time.frameCount;\n\n    ProcessLogicUpdate(deltaTime);\n}\n```\n\n### 步骤 3：检查帧率\n\n在 GameManager 中添加帧率显示：\n\n```csharp\nprivate void OnGUI()\n{\n    GUILayout.Label($\"FPS: {1f / Time.deltaTime:F1}\");\n    GUILayout.Label($\"DeltaTime: {Time.deltaTime:F4}\");\n}\n```\n\n### 步骤 4：尝试禁用 RenderUpdate\n\n临时注释掉 `ActionController.Update()` 中的 RenderUpdate，看看是否还抖动：\n\n```csharp\nprivate void Update()\n{\n    if (_actionMachine == null) return;\n\n    // _actionMachine.RenderUpdate(Time.deltaTime);  // 临时注释\n    UpdateRotation();\n}\n```\n\n### 步骤 5：检查摄像机跟随\n\n如果你有摄像机跟随脚本，确保它在 `LateUpdate` 中更新：\n\n```csharp\nprivate void LateUpdate()\n{\n    // 摄像机跟随逻辑应该放在这里\n    transform.position = Vector3.Lerp(transform.position, target.position, Time.deltaTime * followSpeed);\n}\n```\n\n## 如果还有问题\n\n请告诉我：\n1. 抖动是**水平方向**还是**上下方向**？\n2. 抖动是**持续的**还是**偶尔发生**？\n3. 角色**静止时**是否也抖动，还是只在**移动时**抖动？\n4. 当前的帧率是多少？（在 Game 视图显示 Stats）\n\n这些信息可以帮助我更精确地定位问题。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1333,"cache_read_input_tokens":117828,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1333},"output_tokens":819,"service_tier":"standard"}},"type":"assistant","uuid":"4bea485a-037d-4600-afd1-c94c2c616f30","timestamp":"2025-12-15T10:56:28.568Z"}
{"type":"file-history-snapshot","messageId":"381c5577-05d9-4270-a22c-166f8b8ff45b","snapshot":{"messageId":"381c5577-05d9-4270-a22c-166f8b8ff45b","trackedFileBackups":{"CLAUDE.md":{"backupFileName":"0b5c4e3350b32821@v2","version":2,"backupTime":"2025-12-15T10:53:40.569Z"},"Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs":{"backupFileName":"b1c9467c2d2e4b63@v2","version":2,"backupTime":"2025-12-15T10:57:29.948Z"},"Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\ActionController.cs":{"backupFileName":"8e4255d1848fa081@v2","version":2,"backupTime":"2025-12-15T10:57:29.950Z"}},"timestamp":"2025-12-15T10:57:29.946Z"},"isSnapshotUpdate":false}
{"parentUuid":"4bea485a-037d-4600-afd1-c94c2c616f30","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":"水平方向 移动的时候抖动 一直发生"},"uuid":"381c5577-05d9-4270-a22c-166f8b8ff45b","timestamp":"2025-12-15T10:57:29.946Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]},"todos":[]}
{"parentUuid":"381c5577-05d9-4270-a22c-166f8b8ff45b","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01AiPejZXsW8K7VJsmS87WWR","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"用户说水平方向在移动时一直抖动。这是一个很重要的线索。让我分析可能的原因：\n\n1. **水平方向抖动** - 说明不是重力或垂直运动的问题\n2. **移动时发生** - 说明和输入、速度计算有关\n3. **一直发生** - 说明是系统性问题，不是偶发的\n\n可能的原因：\n1. `HorizontalAcceleration = 0` 和 `HorizontalDeceleration = 0` 导致速度在每帧立即切换到目标速度，没有平滑过渡\n2. 输入系统可能在抖动（输入值在变化）\n3. `SetMovement` 被频繁调用，导致目标速度频繁变化\n4. `UpdateRotation` 可能导致模型旋转与移动不同步\n5. 地面法线投影可能导致速度方向频繁变化\n\n让我检查输入系统的实现：","signature":"EpEHCkYIChgCKkBCOAhCMHJCVJTJLP5kDgQAnmb195rooMiQN4vzLU+k15b2BmAfLEPQtpNE25r7duCkF16sqH7gbhVpzrUGutSDEgyk7zbqjzOy4xGHPRoaDCBzC9VhtvrhSSgiKiIwp/gSrflq8rSn6+39BzPys4n402rY5g8haRjxm+s/RP6HHfodBuGHo9TIpJGd5HvGKvgFci7LLhMnCiMJbfGC1xipxcd1BBczdaX8A7p5W3ZCRuG1Hfem6ZI7ORPnjr9AE5cjfyjXOX9twvGGboLTM4KTzt99U98y+FDsihPkN1BJ9Q54MzdgUj+gkeK6wxMySQM4QSnoaLYjVxxOZBM7jk6wqXqPKgAmn4NE9G+sye7y263cYT7Yfp0CDgTmXMerBSnAbNaq7SeMVzgtddZTqOak6NjjG63w8vjQio65qEnQiluBmAonEBm2S+zwFI95gDRTichGczP+ppRlkkTd7WIEA5Min/7dJsbWdJDDJTeX+Fpam9k9OKVBBVGWLG1PfZWF3zkwEp58BqvshnikteyRooZK15lPd82s87aJvSI1JLuBmUqN+idR9dybCzmE7BHRLDfsjaoKg1nB+oCMMcQemo7nrx0cDEmc8rDfQrTVHWREL2aotyA/hFFJs6LGszikpluQiZg7ZKGlRnWfBLruW/1IIYRU5ngqNmgdx/oz4p8X+d9S0APZRuK99vQEeAvItMcS6ko+TH6OoN2R33anjA0JTm7OZDnm3HQ/Bsy+bye75A1RF7vW1hPumOel1FJXWjF51i9gAv1+jwvHcQzwUAYe3uW4WzZzzfJQeFFYMOf5oC0tkL995aPPVyDoYiBR0rk7bqdhdW3Z6wlPlOeMEH/Iz98fMcb0gkGATTOYvYVWwJBgFHzzQKhhSPevhOc5rVOvetxAQ1pj0NHQwQMAFTcHF43rcahY1MXGkLNO9G6LSH56pOmSDxJiD1DaO2plkENMIguv4eRJh/12y5sknLYQuiJe1Y1vNeanWx/BshtMe4FzQUFur9Jn+K9bg3tiWsFigUPVxtmu95vpeBzulp9A1ga+r1uvoo58W3m2F0qQ4mlhOPNCi/RBGwvtctUwaoHyRgkjLQysWTX5F6osv+WIkGLHg45ihCuB791fuIhPfRMG5ErwVl51olvRz+lcCtl7PaEkBnEzdekepaa3l2oi18X0Ajue76SwJscn2hs0h2pKXTQoGBgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25923,"cache_read_input_tokens":92222,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":25923},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"a3e10517-18df-4922-a174-62b7dab34df3","timestamp":"2025-12-15T10:57:42.009Z"}
{"parentUuid":"a3e10517-18df-4922-a174-62b7dab34df3","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01AiPejZXsW8K7VJsmS87WWR","type":"message","role":"assistant","content":[{"type":"text","text":"明白了，**水平方向移动时一直抖动**。这给了我关键信息。让我检查输入系统和移动逻辑："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25923,"cache_read_input_tokens":92222,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":25923},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"02a8d315-00cc-4b66-85fe-031c3b713562","timestamp":"2025-12-15T10:57:42.929Z"}
{"parentUuid":"02a8d315-00cc-4b66-85fe-031c3b713562","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01AiPejZXsW8K7VJsmS87WWR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01E4GcJvPUq1BSHzjKMiCjzr","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\InputData\\InputData.cs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25923,"cache_read_input_tokens":92222,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":25923},"output_tokens":424,"service_tier":"standard"}},"type":"assistant","uuid":"64b8f743-d87f-4389-ae44-c090bdfc869f","timestamp":"2025-12-15T10:57:43.703Z"}
{"parentUuid":"64b8f743-d87f-4389-ae44-c090bdfc869f","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01E4GcJvPUq1BSHzjKMiCjzr","type":"tool_result","content":"     1→using System;\n     2→using UnityEngine;\n     3→\n     4→namespace ActionMachine.Runtime\n     5→{\n     6→    [Flags]\n     7→    public enum InputEvents\n     8→    {\n     9→        None = 0b0000,\n    10→        Moving = 0b0001,\n    11→        Attack = 0b0010,\n    12→        Jump = 0b0100,\n    13→        Jumping = 0b1000,\n    14→    }\n    15→\n    16→    public static class InputData\n    17→    {\n    18→        public static InputEvents inputEvents { get; set; } = InputEvents.None;\n    19→        public static Vector2 axisValue { get; set; } = Vector2.zero;\n    20→\n    21→        public static bool HasEvent(InputEvents e, bool fullMatch = false)\n    22→        {\n    23→            return fullMatch ? ((inputEvents & e) == inputEvents) : ((inputEvents & e) != 0);\n    24→        }\n    25→\n    26→        public static void Clear()\n    27→        {\n    28→            inputEvents = InputEvents.None;\n    29→            axisValue = Vector2.zero;\n    30→        }\n    31→\n    32→\n    33→        public static void Update()\n    34→        {\n    35→            if (Input.GetMouseButtonDown(0))\n    36→            {\n    37→                InputData.inputEvents |= InputEvents.Attack;\n    38→            }\n    39→\n    40→            float h = Input.GetAxis(\"Horizontal\");\n    41→            float v = Input.GetAxis(\"Vertical\");\n    42→            \n    43→            InputData.axisValue = new Vector2(h, v);\n    44→            \n    45→            if (h != 0 || v != 0)\n    46→            {\n    47→                InputData.inputEvents |= InputEvents.Moving;\n    48→            }\n    49→        }\n    50→    }\n    51→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"365e278c-3d0c-432a-aaad-814a5fdbc268","timestamp":"2025-12-15T10:57:44.695Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\InputData\\InputData.cs","content":"using System;\nusing UnityEngine;\n\nnamespace ActionMachine.Runtime\n{\n    [Flags]\n    public enum InputEvents\n    {\n        None = 0b0000,\n        Moving = 0b0001,\n        Attack = 0b0010,\n        Jump = 0b0100,\n        Jumping = 0b1000,\n    }\n\n    public static class InputData\n    {\n        public static InputEvents inputEvents { get; set; } = InputEvents.None;\n        public static Vector2 axisValue { get; set; } = Vector2.zero;\n\n        public static bool HasEvent(InputEvents e, bool fullMatch = false)\n        {\n            return fullMatch ? ((inputEvents & e) == inputEvents) : ((inputEvents & e) != 0);\n        }\n\n        public static void Clear()\n        {\n            inputEvents = InputEvents.None;\n            axisValue = Vector2.zero;\n        }\n\n\n        public static void Update()\n        {\n            if (Input.GetMouseButtonDown(0))\n            {\n                InputData.inputEvents |= InputEvents.Attack;\n            }\n\n            float h = Input.GetAxis(\"Horizontal\");\n            float v = Input.GetAxis(\"Vertical\");\n            \n            InputData.axisValue = new Vector2(h, v);\n            \n            if (h != 0 || v != 0)\n            {\n                InputData.inputEvents |= InputEvents.Moving;\n            }\n        }\n    }\n}","numLines":51,"startLine":1,"totalLines":51}}}
{"parentUuid":"365e278c-3d0c-432a-aaad-814a5fdbc268","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0111MNANHdGix1sfMixv3jRN","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，现在我看到了输入系统。`Input.GetAxis` 会返回平滑的值，但是每帧可能会有微小的变化。\n\n让我检查一下实际调用 SetMovement 的地方在哪里。可能是在某个 ClipHandler 中。","signature":"EooDCkYIChgCKkBNZtbwANkxTueS9JON5JrMIfnn+6EgtXzJm/g/cg6USdaTU7VOgokivARaxq6XHYSW2H+x9G9cpxuFb3xSzYFyEgywrhWEjXVCUla6umwaDFdmcLY54NsZbiPJTCIwY3z4W1JD+XY9zFwCJCNR5OrdMeHzMx/KHkORqvRly3aKa0Z8CyTHWIkGwy44xDqiKvEBQ6jPDjNbOXTcT3V3NIX2XHeDhw1En/SzlyuxkAbWGB6ldoPVVjmM46lGx0Kj+PX0uvIE3kPD2DexsKiGzKCg1ZvMOt+Uwq/ssJiR2V6VplH0wd9s0T5sAwGQNtYTpIuqtMifEgnVsQOVemp4rgwC5dPwNI8bb92iTqzkY/jT0zE/V+pgiaMiKtvHr5IWjaqyvZoGbEEAtHi3soV8oWSo2K3Gs52aP8+BdAex+agSFcVctHt+nDImVC5GSycu52i7NbzIUjZ6JAaiWHPqoyKx5HhV2C+HbBYCIurQaFAICEW09xlwcX5YeN6pw2khMCEdVhgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":1036,"cache_read_input_tokens":118145,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1036},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"c7e923a2-5159-4202-bcf4-0f6862178954","timestamp":"2025-12-15T10:57:57.903Z"}
{"parentUuid":"c7e923a2-5159-4202-bcf4-0f6862178954","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0111MNANHdGix1sfMixv3jRN","type":"message","role":"assistant","content":[{"type":"text","text":"让我检查是谁在调用 `Kcc.SetMovement()`："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":1036,"cache_read_input_tokens":118145,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1036},"output_tokens":274,"service_tier":"standard"}},"type":"assistant","uuid":"33552428-6b9a-4c10-8cd3-98663e98f05d","timestamp":"2025-12-15T10:58:00.132Z"}
{"parentUuid":"33552428-6b9a-4c10-8cd3-98663e98f05d","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0111MNANHdGix1sfMixv3jRN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VS9bLc6dJN7o2r15NyXxof","name":"Grep","input":{"pattern":"SetMovement","output_mode":"content","-n":true,"-C":3,"path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts","glob":"**/*.cs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":1036,"cache_read_input_tokens":118145,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1036},"output_tokens":274,"service_tier":"standard"}},"type":"assistant","uuid":"dac3f881-5d6b-48fe-b16f-d885c5883b0c","timestamp":"2025-12-15T10:58:00.140Z"}
{"parentUuid":"dac3f881-5d6b-48fe-b16f-d885c5883b0c","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VS9bLc6dJN7o2r15NyXxof","type":"tool_result","content":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs-918-        /// 设置移动向量（通常由输入系统调用）\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs-919-        /// </summary>\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs-920-        /// <param name=\"movement\">移动向量</param>\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs:921:        public virtual void SetMovement(Vector3 movement)\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs-922-        {\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs-923-            _currentMovement = movement;\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs-924-            Vector3 directionVector = movement;\r\n--\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-16-            var kcc = clipNode.ActionMachine.Controller.Kcc;\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-17-            var move = InputData.axisValue.normalized * BindData.MoveSpeed;\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-18-            var movement = new Vector3(move.x, 0, move.y);\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs:19:            kcc.SetMovement(movement);\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-20-        }\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-21-\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-22-        protected override void OnExit(ClipNode clipNode)\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-23-        {\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-24-            var kcc = clipNode.ActionMachine.Controller.Kcc;\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs:25:            kcc.SetMovement(Vector3.zero);\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-26-        }\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-27-    }\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-28-}"}]},"uuid":"8664e54c-0837-43ff-b891-4db8d414bc70","timestamp":"2025-12-15T10:58:01.074Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs-918-        /// 设置移动向量（通常由输入系统调用）\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs-919-        /// </summary>\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs-920-        /// <param name=\"movement\">移动向量</param>\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs:921:        public virtual void SetMovement(Vector3 movement)\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs-922-        {\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs-923-            _currentMovement = movement;\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs-924-            Vector3 directionVector = movement;\r\n--\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-16-            var kcc = clipNode.ActionMachine.Controller.Kcc;\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-17-            var move = InputData.axisValue.normalized * BindData.MoveSpeed;\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-18-            var movement = new Vector3(move.x, 0, move.y);\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs:19:            kcc.SetMovement(movement);\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-20-        }\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-21-\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-22-        protected override void OnExit(ClipNode clipNode)\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-23-        {\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-24-            var kcc = clipNode.ActionMachine.Controller.Kcc;\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs:25:            kcc.SetMovement(Vector3.zero);\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-26-        }\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-27-    }\r\nE:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs-28-}","numLines":21}}
{"parentUuid":"8664e54c-0837-43ff-b891-4db8d414bc70","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01US4baAVLveE6Qd16We94vK","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"找到了！`MoveClipHandler` 在每次 `OnLogicUpdate` 中都调用 `SetMovement`。问题可能在这里：\n\n1. `InputData.axisValue.normalized` 每帧可能有微小变化\n2. 因为 `HorizontalAcceleration = 0`，Kcc 会立即响应这些变化\n3. 地面法线投影也可能导致方向抖动\n\n让我看看完整的 MoveClipHandler：","signature":"EvkDCkYIChgCKkBPPtJ/HGUHDKAVM2EE9Vfc4+Izyym6fYAdhH/ppymrWQkpAg2JjT1zJShfdchQPib709t64pJJyn3Wfb1OB+/nEgyedNQS5F1hoUn8/qEaDJBXY8NoManJR/f5SiIwAz/P8QY6qJhaVUlo4Bf0l9QYU25177rjxQURmCTv8IT6c7etEgfZT2fMbiQ4vkE4KuACXijOrKb7NZ6BN9GNYRaHg9nK96jLPdmD2M5kTBBZwQJ41z1I4Ivz6Gm0CE0E4PWvJNMqQ7F6tqbGp/k+0vT5Pubz/Di/i2/Nb9Zxxh+G1W4pqJjKqhqMw7m0VS8ORSX/wMqNfQ+3fGt/1LKCvL6X9ziTfHZtxH++DthZ7CVr6A3B/9Wyxcs1KaNfC7xT+Qm1ct66v6kSaw+gavLokkDu6NouKQNuQ32LZthRz+s3AcG2HddED+NFpZlWVaaeqkjM9nmBooUOAHn0X4bqMMks7736CUxjt49ndHGM/ChksNRiWI52j3xabQUZCYfaIYkWk/5Qe1XpBzhEfQU/jC+iF+uCTuGcWGQr4smde3ABp8JmODbTbR/D9nv7555ylbvUk96USwe4kvl330/OXTfRa8GD/bxZxCOjdiEM4pVMq9u9/1/L3zmsMQBTFsow6Hg/4WZFyfA8ZRf4GH8/7JF3oRgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1541,"cache_read_input_tokens":119181,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1541},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"23061817-91ec-4647-bcc3-6e4fc81e41e0","timestamp":"2025-12-15T10:58:10.206Z"}
{"parentUuid":"23061817-91ec-4647-bcc3-6e4fc81e41e0","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01US4baAVLveE6Qd16We94vK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0141Y1YbrtYzGTGF6zP9vonU","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1541,"cache_read_input_tokens":119181,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1541},"output_tokens":241,"service_tier":"standard"}},"type":"assistant","uuid":"bab83e0d-168d-4c9a-8f7c-6228eac6a2fc","timestamp":"2025-12-15T10:58:10.805Z"}
{"parentUuid":"bab83e0d-168d-4c9a-8f7c-6228eac6a2fc","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0141Y1YbrtYzGTGF6zP9vonU","type":"tool_result","content":"     1→using ActionMachine.Runtime.Attributes;\n     2→using ActionMachine.Runtime.Directables;\n     3→using UnityEngine;\n     4→\n     5→namespace ActionMachine.Runtime.Handlers\n     6→{\n     7→    [CustomHandler(typeof(MoveClip))]\n     8→    public class MoveClipHandler : ClipHandlerBase<MoveClip>\n     9→    {\n    10→        protected override void OnEnter(ClipNode clipNode)\n    11→        {\n    12→        }\n    13→\n    14→        protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt)\n    15→        {\n    16→            var kcc = clipNode.ActionMachine.Controller.Kcc;\n    17→            var move = InputData.axisValue.normalized * BindData.MoveSpeed;\n    18→            var movement = new Vector3(move.x, 0, move.y);\n    19→            kcc.SetMovement(movement);\n    20→        }\n    21→\n    22→        protected override void OnExit(ClipNode clipNode)\n    23→        {\n    24→            var kcc = clipNode.ActionMachine.Controller.Kcc;\n    25→            kcc.SetMovement(Vector3.zero);\n    26→        }\n    27→    }\n    28→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"0c18eb3f-1dc3-4606-9672-bf85c2eb7288","timestamp":"2025-12-15T10:58:11.690Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs","content":"using ActionMachine.Runtime.Attributes;\nusing ActionMachine.Runtime.Directables;\nusing UnityEngine;\n\nnamespace ActionMachine.Runtime.Handlers\n{\n    [CustomHandler(typeof(MoveClip))]\n    public class MoveClipHandler : ClipHandlerBase<MoveClip>\n    {\n        protected override void OnEnter(ClipNode clipNode)\n        {\n        }\n\n        protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt)\n        {\n            var kcc = clipNode.ActionMachine.Controller.Kcc;\n            var move = InputData.axisValue.normalized * BindData.MoveSpeed;\n            var movement = new Vector3(move.x, 0, move.y);\n            kcc.SetMovement(movement);\n        }\n\n        protected override void OnExit(ClipNode clipNode)\n        {\n            var kcc = clipNode.ActionMachine.Controller.Kcc;\n            kcc.SetMovement(Vector3.zero);\n        }\n    }\n}","numLines":28,"startLine":1,"totalLines":28}}}
{"parentUuid":"0c18eb3f-1dc3-4606-9672-bf85c2eb7288","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01F9YAN3LUBT73cXMVEhfex3","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"找到问题了！`MoveClipHandler` 每帧都在计算 `InputData.axisValue.normalized * BindData.MoveSpeed`。问题可能是：\n\n1. `normalized` 在输入值接近零时会产生不稳定的方向\n2. 每帧的微小输入变化被立即反映到速度上（因为 `HorizontalAcceleration = 0`）\n3. 地面法线投影在 Kcc 的 `AddInput` 中可能导致方向抖动\n\n让我看看 Kcc 的地面投影部分：","signature":"EsMECkYIChgCKkDjHjzbVpCaSi6b/+4VxuKqciinddlh7WB0Ks0Zk67RK/b3FJmTtENl53UbbQmECfYvkn9xmM1wr+V0uiiEemPkEgyxuq++c3mD9N568nkaDDJA8oGAzCySI+cYMyIwZEzxqPRslxxAKiNksjaXfix5Az2fZO1Qe/bo7Ix3cJlj6N3pm2fe2nt8nnpt5hn7KqoD8Fi1mzjrIP2c/dOZocp9+58rcF/h+PkbkrhW/gESSSOX6R8a2csvqf/WToIt2NI8VRsqRu8QEbQsllfR8vYti6yxij+PPYdY1CYHQYqFUCdhjUp3hSRd8ibtOwUSBif1rjrROuwvuXXVtAmXZOUPmOVIMNP1SgkoXTuWPvDZvFpG4f8AGLrkWcG/t4QE+3QU3RpHHQ7kVI4ZFS8aNILfuMVLogjAEHtbcNijEPAea8/2iwHF/TbDmso7ny+ZCi3UB5B8Fq6tXDSeQZpIyVbgU/noIWpdlcezHg7cLPUr0YwlkTLkaYkXsel2Qj+uabnE87etW45HlExFpLwxs4TJ27BzN8P7BrpQUYqgxINLjBLTon5TlswcKnFCRi4w2Ce2WCAI5X0SlnT3Xo0F7NkV5Tt03KloeHxU0lELWUrdDJheyKW7xVAPrQU9pqLDYBCjgO45Sn7cTujra63GMkd9knqaj3oNiTT5kuqd8X2zX+ERerLPgl6HHmbSsc1SKLFg+PCbjKHJJ4HZCv7PySTAOv6M++e7t5CWWSK304jktBIUjnAuv3JQra6KGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":687,"cache_read_input_tokens":120722,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":687},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"ff26ebd3-52b5-412f-bad7-b081ca33a797","timestamp":"2025-12-15T10:58:19.657Z"}
{"parentUuid":"ff26ebd3-52b5-412f-bad7-b081ca33a797","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01F9YAN3LUBT73cXMVEhfex3","type":"message","role":"assistant","content":[{"type":"text","text":"找到问题了！现在我明白为什么会抖动了。问题出在几个地方：\n\n## 问题分析\n\n### 1. **输入归一化问题**（主要原因）\n```csharp:Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Clip/ClipHandlers/Rigidbody/MoveClipHandler.cs\nvar move = InputData.axisValue.normalized * BindData.MoveSpeed;\n```\n\n当 `axisValue` 很小时，`normalized` 会导致方向不稳定。例如：\n- `(0.01, 0.02).normalized` ≈ `(0.447, 0.894)`\n- `(0.02, 0.01).normalized` ≈ `(0.894, 0.447)`\n\n小的输入变化会导致归一化后方向剧烈变化！\n\n### 2. **地面法线投影导致方向抖动**\n在 `Kcc.AddInput()` 中：\n```csharp:Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs\nif (_grounded)\n{\n    Vector3 velocityDirection = horizontalVelocity.normalized;\n    Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n    // 这里每帧都在重新投影，如果地面法线有微小变化，会导致方向抖动\n}\n```\n\n### 3. **零加速度导致立即响应**\n`HorizontalAcceleration = 0` 意味着每帧的输入抖动都会立即反映到移动上。\n\n## 修复方案"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":687,"cache_read_input_tokens":120722,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":687},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"452b3c03-7b7e-40d4-8e37-510f24309c08","timestamp":"2025-12-15T10:58:26.692Z"}
{"parentUuid":"452b3c03-7b7e-40d4-8e37-510f24309c08","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01F9YAN3LUBT73cXMVEhfex3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CmQBHvKeuLTDgtaKe5P8TH","name":"Edit","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs","old_string":"        protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt)\n        {\n            var kcc = clipNode.ActionMachine.Controller.Kcc;\n            var move = InputData.axisValue.normalized * BindData.MoveSpeed;\n            var movement = new Vector3(move.x, 0, move.y);\n            kcc.SetMovement(movement);\n        }","new_string":"        protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt)\n        {\n            var kcc = clipNode.ActionMachine.Controller.Kcc;\n\n            // 获取原始输入值\n            Vector2 input = InputData.axisValue;\n\n            // 计算输入大小\n            float inputMagnitude = input.magnitude;\n\n            Vector3 movement;\n            if (inputMagnitude > 0.01f)  // 添加死区，避免小输入导致的抖动\n            {\n                // 限制输入大小到 [0, 1] 范围\n                float clampedMagnitude = Mathf.Min(inputMagnitude, 1f);\n\n                // 先归一化方向，再乘以限制后的大小和速度\n                Vector2 direction = input / inputMagnitude;\n                Vector2 move = direction * clampedMagnitude * BindData.MoveSpeed;\n                movement = new Vector3(move.x, 0, move.y);\n            }\n            else\n            {\n                // 输入太小，直接设为零\n                movement = Vector3.zero;\n            }\n\n            kcc.SetMovement(movement);\n        }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":687,"cache_read_input_tokens":120722,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":687},"output_tokens":1182,"service_tier":"standard"}},"type":"assistant","uuid":"20cc7774-fac5-4fcd-9cdc-e42a1b23861f","timestamp":"2025-12-15T10:58:33.155Z"}
{"type":"file-history-snapshot","messageId":"20cc7774-fac5-4fcd-9cdc-e42a1b23861f","snapshot":{"messageId":"381c5577-05d9-4270-a22c-166f8b8ff45b","trackedFileBackups":{"CLAUDE.md":{"backupFileName":"0b5c4e3350b32821@v2","version":2,"backupTime":"2025-12-15T10:53:40.569Z"},"Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs":{"backupFileName":"b1c9467c2d2e4b63@v2","version":2,"backupTime":"2025-12-15T10:57:29.948Z"},"Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\ActionController.cs":{"backupFileName":"8e4255d1848fa081@v2","version":2,"backupTime":"2025-12-15T10:57:29.950Z"},"Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs":{"backupFileName":"8d63fd6f02843659@v1","version":1,"backupTime":"2025-12-15T10:59:01.265Z"}},"timestamp":"2025-12-15T10:57:29.946Z"},"isSnapshotUpdate":true}
{"parentUuid":"20cc7774-fac5-4fcd-9cdc-e42a1b23861f","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CmQBHvKeuLTDgtaKe5P8TH","type":"tool_result","content":"The file E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→using ActionMachine.Runtime.Attributes;\n     2→using ActionMachine.Runtime.Directables;\n     3→using UnityEngine;\n     4→\n     5→namespace ActionMachine.Runtime.Handlers\n     6→{\n     7→    [CustomHandler(typeof(MoveClip))]\n     8→    public class MoveClipHandler : ClipHandlerBase<MoveClip>\n     9→    {\n    10→        protected override void OnEnter(ClipNode clipNode)\n    11→        {\n    12→        }\n    13→\n    14→        protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt)\n    15→        {\n    16→            var kcc = clipNode.ActionMachine.Controller.Kcc;\n    17→\n    18→            // 获取原始输入值\n    19→            Vector2 input = InputData.axisValue;\n    20→\n    21→            // 计算输入大小\n    22→            float inputMagnitude = input.magnitude;\n    23→\n    24→            Vector3 movement;\n    25→            if (inputMagnitude > 0.01f)  // 添加死区，避免小输入导致的抖动\n    26→            {\n    27→                // 限制输入大小到 [0, 1] 范围\n    28→                float clampedMagnitude = Mathf.Min(inputMagnitude, 1f);\n    29→\n    30→                // 先归一化方向，再乘以限制后的大小和速度\n    31→                Vector2 direction = input / inputMagnitude;\n    32→                Vector2 move = direction * clampedMagnitude * BindData.MoveSpeed;\n    33→                movement = new Vector3(move.x, 0, move.y);\n    34→            }\n    35→            else\n    36→            {\n    37→                // 输入太小，直接设为零\n    38→                movement = Vector3.zero;\n    39→            }\n    40→\n    41→            kcc.SetMovement(movement);\n    42→        }\n    43→\n    44→        protected override void OnExit(ClipNode clipNode)\n    45→        {\n    46→            var kcc = clipNode.ActionMachine.Controller.Kcc;\n    47→            kcc.SetMovement(Vector3.zero);\n    48→        }\n    49→    }\n    50→}"}]},"uuid":"997823cc-161b-45e5-bc83-0f4c2bc9b718","timestamp":"2025-12-15T10:59:01.268Z","toolUseResult":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs","oldString":"using ActionMachine.Runtime.Attributes;\nusing ActionMachine.Runtime.Directables;\nusing UnityEngine;\n\nnamespace ActionMachine.Runtime.Handlers\n{\n    [CustomHandler(typeof(MoveClip))]\n    public class MoveClipHandler : ClipHandlerBase<MoveClip>\n    {\n        protected override void OnEnter(ClipNode clipNode)\n        {\n        }\n\n        protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt)\n        {\n            var kcc = clipNode.ActionMachine.Controller.Kcc;\n            var move = InputData.axisValue.normalized * BindData.MoveSpeed;\n            var movement = new Vector3(move.x, 0, move.y);\n            kcc.SetMovement(movement);\n        }\n\n        protected override void OnExit(ClipNode clipNode)\n        {\n            var kcc = clipNode.ActionMachine.Controller.Kcc;\n            kcc.SetMovement(Vector3.zero);\n        }\n    }\n}","newString":"using ActionMachine.Runtime.Attributes;\nusing ActionMachine.Runtime.Directables;\nusing UnityEngine;\n\nnamespace ActionMachine.Runtime.Handlers\n{\n    [CustomHandler(typeof(MoveClip))]\n    public class MoveClipHandler : ClipHandlerBase<MoveClip>\n    {\n        protected override void OnEnter(ClipNode clipNode)\n        {\n        }\n\n        protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt)\n        {\n            var kcc = clipNode.ActionMachine.Controller.Kcc;\n\n            // 获取原始输入值\n            Vector2 input = InputData.axisValue;\n\n            // 计算输入大小\n            float inputMagnitude = input.magnitude;\n\n            Vector3 movement;\n            if (inputMagnitude > 0.01f)  // 添加死区，避免小输入导致的抖动\n            {\n                // 限制输入大小到 [0, 1] 范围\n                float clampedMagnitude = Mathf.Min(inputMagnitude, 1f);\n\n                // 先归一化方向，再乘以限制后的大小和速度\n                Vector2 direction = input / inputMagnitude;\n                Vector2 move = direction * clampedMagnitude * BindData.MoveSpeed;\n                movement = new Vector3(move.x, 0, move.y);\n            }\n            else\n            {\n                // 输入太小，直接设为零\n                movement = Vector3.zero;\n            }\n\n            kcc.SetMovement(movement);\n        }\n\n        protected override void OnExit(ClipNode clipNode)\n        {\n            var kcc = clipNode.ActionMachine.Controller.Kcc;\n            kcc.SetMovement(Vector3.zero);\n        }\n    }\n}","originalFile":"using ActionMachine.Runtime.Attributes;\nusing ActionMachine.Runtime.Directables;\nusing UnityEngine;\n\nnamespace ActionMachine.Runtime.Handlers\n{\n    [CustomHandler(typeof(MoveClip))]\n    public class MoveClipHandler : ClipHandlerBase<MoveClip>\n    {\n        protected override void OnEnter(ClipNode clipNode)\n        {\n        }\n\n        protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt)\n        {\n            var kcc = clipNode.ActionMachine.Controller.Kcc;\n            var move = InputData.axisValue.normalized * BindData.MoveSpeed;\n            var movement = new Vector3(move.x, 0, move.y);\n            kcc.SetMovement(movement);\n        }\n\n        protected override void OnExit(ClipNode clipNode)\n        {\n            var kcc = clipNode.ActionMachine.Controller.Kcc;\n            kcc.SetMovement(Vector3.zero);\n        }\n    }\n}","structuredPatch":[{"oldStart":14,"oldLines":8,"newStart":14,"newLines":30,"lines":["         protected override void OnLogicUpdate(ClipNode clipNode, float deltaTime, int updateCnt)","         {","             var kcc = clipNode.ActionMachine.Controller.Kcc;","-            var move = InputData.axisValue.normalized * BindData.MoveSpeed;","-            var movement = new Vector3(move.x, 0, move.y);","+","+            // 获取原始输入值","+            Vector2 input = InputData.axisValue;","+","+            // 计算输入大小","+            float inputMagnitude = input.magnitude;","+","+            Vector3 movement;","+            if (inputMagnitude > 0.01f)  // 添加死区，避免小输入导致的抖动","+            {","+                // 限制输入大小到 [0, 1] 范围","+                float clampedMagnitude = Mathf.Min(inputMagnitude, 1f);","+","+                // 先归一化方向，再乘以限制后的大小和速度","+                Vector2 direction = input / inputMagnitude;","+                Vector2 move = direction * clampedMagnitude * BindData.MoveSpeed;","+                movement = new Vector3(move.x, 0, move.y);","+            }","+            else","+            {","+                // 输入太小，直接设为零","+                movement = Vector3.zero;","+            }","+","             kcc.SetMovement(movement);","         }"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"997823cc-161b-45e5-bc83-0f4c2bc9b718","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01QESo2YabQ7d5tjbkdA2VQh","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，现在我修复了输入处理的问题。但是还有一个问题需要解决：地面法线投影可能导致的方向抖动。让我修复 Kcc 中的投影逻辑：","signature":"EtkCCkYIChgCKkBVu1XVFxJ3q/k1q1yeOdqYcbncp1uo7/SDd6JP6HeY8hYv51lM4HOf6nkI2i740MNo6xb6ARMCKWYKTkJme7iMEgwQGONEjxz/QH3u7WQaDJAEMo/0HNOCA4B2hiIwVDK4qZ+UkIHZ9zMBy9/W5EqV2xlWP64x2sRgqry0gmKDYh0pSPhsyUQRRvyv3QWjKsABk69Ga4Lb9Zq0eagI1F+tTnOz+gWnD/sp+mR7pgylucN5CTyEQWjkxFBOrmOugVmHyn0gjdPOl5BsWYaYG3rgWReO/EyNQObjGAF+0Ik/bjsz0NJHdYqUprWf+iHKhMgwxE3GeTWEBpuwDVSFejzcgk/sOHpSdo0uVMWzf+YhCDK/gsjyrO8wjFJ5s6z5oAN8eliBfgjYv+ZbSv3cvqzFE/cV3AWzHZA22j/58MGo9AhQ67ddqq+wdyK6d0eIZM92GAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1998,"cache_read_input_tokens":121409,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1998},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"872a6d98-6ae7-41b6-89c6-a8be3366b62e","timestamp":"2025-12-15T10:59:09.058Z"}
{"parentUuid":"872a6d98-6ae7-41b6-89c6-a8be3366b62e","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01QESo2YabQ7d5tjbkdA2VQh","type":"message","role":"assistant","content":[{"type":"text","text":"现在修复 Kcc 中的地面法线投影问题："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1998,"cache_read_input_tokens":121409,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1998},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"33bd8248-4e56-40e7-ab51-316568670e0a","timestamp":"2025-12-15T10:59:09.499Z"}
{"parentUuid":"33bd8248-4e56-40e7-ab51-316568670e0a","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01QESo2YabQ7d5tjbkdA2VQh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01X4zC6E8HEcfTpMN6QdaxnW","name":"Edit","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","old_string":"                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n\n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity.normalized;\n                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n\n                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n                        {\n                            projectedDirection.Normalize();\n                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                        }\n                    }\n\n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }","new_string":"                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n\n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity / velocityMagnitude;\n\n                        // 只有当地面法线不是水平面时才投影，避免平地上的抖动\n                        if (_groundNormal.y < 0.999f)  // 如果地面法线几乎是正上方，跳过投影\n                        {\n                            Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n\n                            // 检查投影后的方向是否有效\n                            if (projectedDirection.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                            {\n                                projectedDirection.Normalize();\n                                _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                                _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                            }\n                        }\n                    }\n\n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1998,"cache_read_input_tokens":121409,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1998},"output_tokens":827,"service_tier":"standard"}},"type":"assistant","uuid":"2c71354e-7fe8-46ac-abb0-2e898c3d6290","timestamp":"2025-12-15T10:59:17.562Z"}
{"parentUuid":"2c71354e-7fe8-46ac-abb0-2e898c3d6290","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01X4zC6E8HEcfTpMN6QdaxnW","type":"tool_result","content":"The file E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→using System;\n     2→using UnityEngine;\n     3→using System.Collections;\n     4→using System.Collections.Generic;\n     5→using ActionMachine.Runtime.Attributes;\n     6→\n     7→namespace ActionMachine.Runtime.Controller\n     8→{\n     9→    /// <summary>\n    10→    /// 运动学角色控制器（Kinematic Character Controller）\n    11→    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    12→    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    13→    /// \n    14→    /// 修复：添加逻辑帧与渲染帧之间的插值，解决 30fps 逻辑更新导致的卡顿\n    15→    /// </summary>\n    16→    [RequireComponent(typeof(CharacterController))]\n    17→    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    18→    public partial class Kcc : MonoBehaviour\n    19→    {\n    20→        private const float SMALL_VALUE = 0.0001f;\n    21→        private const float SPEED_ROUNDING_PRECISION = 100f;\n    22→        private const float IMPACT_THRESHOLD = 0.2f;\n    23→\n    24→        public enum GroundedComputationMode\n    25→        {\n    26→            Simple,\n    27→            Advanced\n    28→        }\n    29→\n    30→        public enum VelocityTransferMode\n    31→        {\n    32→            NoTransfer,\n    33→            InitialVelocity,\n    34→            FloorVelocity,\n    35→            Relative\n    36→        }\n    37→\n    38→        [Header(\"Update Mode Settings\")]\n    39→        [Tooltip(\"更新模式：Auto = Update 中自动执行（用于无外部 LogicUpdate 调用）, Manual = 仅通过外部 LogicUpdate 调用执行\")]\n    40→        public UpdateMode UpdateModeType = UpdateMode.Manual;\n    41→\n    42→        public enum UpdateMode\n    43→        {\n    44→            Auto,    // Update 中自动执行物理计算\n    45→            Manual   // 仅通过外部 LogicUpdate 调用执行\n    46→        }\n    47→\n    48→        [Header(\"Gravity Settings\")]\n    49→        [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n    50→        public float Gravity = 40f;\n    51→        [Tooltip(\"是否激活重力\")]\n    52→        public bool GravityActive = true;\n    53→\n    54→        [Header(\"Raycast Settings\")]\n    55→        [Tooltip(\"障碍物层遮罩\")]\n    56→        public LayerMask ObstaclesLayerMask;\n    57→        [Tooltip(\"向下射线检测长度\")]\n    58→        public float GroundedRaycastLength = 5f;\n    59→        [Tooltip(\"最小着地距离\")]\n    60→        public float MinimumGroundedDistance = 0.2f;\n    61→        [Tooltip(\"地面检测计算模式\")]\n    62→        public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n    63→        [Tooltip(\"地面法线高度阈值\")]\n    64→        public float GroundNormalHeightThreshold = 0.2f;\n    65→        [Tooltip(\"蹲伏时射线长度倍数\")]\n    66→        public float CrouchedRaycastLengthMultiplier = 1f;\n    67→        [Tooltip(\"是否执行基本方向障碍物射线检测\")]\n    68→        public bool PerformCardinalObstacleRaycastDetection = false;\n    69→\n    70→        [Header(\"Movement Settings\")]\n    71→        [Tooltip(\"最大下落速度\")]\n    72→        public float MaximumFallSpeed = 20.0f;\n    73→        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速。设为 0 表示立即到达目标速度，消除加速延迟\")]\n    74→        public float HorizontalAcceleration = 0f; // 改为 0，立即到达目标速度\n    75→        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速。设为 0 表示立即停止，消除减速延迟\")]\n    76→        public float HorizontalDeceleration = 0f; // 改为 0，立即停止\n    77→        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n    78→        public float InitialBurstMultiplier = 2.0f;\n    79→        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n    80→        public float BurstSpeedThreshold = 1.0f;\n    81→        [Tooltip(\"斜坡速度倍数曲线\")]\n    82→        public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n    83→            new Keyframe(-90, 1),\n    84→            new Keyframe(0, 1),\n    85→            new Keyframe(90, 0)\n    86→        );\n    87→        [Tooltip(\"冲击力衰减速度\")]\n    88→        public float ImpactFalloff = 5f;\n    89→\n    90→        [Header(\"Steep Surface Settings\")]\n    91→        [Tooltip(\"是否在陡峭表面滑动\")]\n    92→        public bool SlideOnSteepSurfaces = true;\n    93→        [Tooltip(\"滑动速度\")]\n    94→        public float SlidingSpeed = 15f;\n    95→        [Tooltip(\"滑动速度控制\")]\n    96→        public float SlidingSpeedControl = 0.4f;\n    97→        [Tooltip(\"滑动方向控制\")]\n    98→        public float SlidingDirectionControl = 1f;\n    99→\n   100→        [Header(\"Moving Platform Settings\")]\n   101→        [Tooltip(\"跳跃时的速度传递方式\")]\n   102→        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n   103→\n   104→        [Header(\"Runtime State - Read Only\")]\n   105→        [SerializeField, ReadOnly] private Vector3 _speed;\n   106→        [SerializeField, ReadOnly] private Vector3 _velocity;\n   107→        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n   108→        [SerializeField, ReadOnly] private Vector3 _acceleration;\n   109→        [SerializeField, ReadOnly] private bool _grounded;\n   110→        [SerializeField, ReadOnly] private bool _justGotGrounded;\n   111→        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n   112→        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n   113→        [SerializeField, ReadOnly] private float _friction;\n   114→        [SerializeField, ReadOnly] private Vector3 _addedForce;\n   115→        [SerializeField, ReadOnly] private bool _freeMovement = true;\n   116→        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n   117→        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n   118→        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n   119→\n   120→        // 公共只读属性\n   121→        public Vector3 Speed => _speed;\n   122→        public Vector3 Velocity => _velocity;\n   123→        public Vector3 VelocityLastFrame => _velocityLastFrame;\n   124→        public Vector3 Acceleration => _acceleration;\n   125→        public bool Grounded => _grounded;\n   126→        public bool JustGotGrounded => _justGotGrounded;\n   127→        public Vector3 CurrentMovement => _currentMovement;\n   128→        public Vector3 CurrentDirection => _currentDirection;\n   129→        public float Friction => _friction;\n   130→        public Vector3 AddedForce => _addedForce;\n   131→        public bool FreeMovement => _freeMovement;\n   132→        public Vector3 GroundNormal => _groundNormal;\n   133→        public Vector3 InputMoveDirection => _inputMoveDirection;\n   134→        public Vector3 TargetVelocity => _targetVelocity;\n   135→\n   136→        // 碰撞器相关属性\n   137→        public Vector3 ColliderCenter => transform.position + _characterController.center;\n   138→        public Vector3 ColliderBottom => transform.position + _characterController.center +\n   139→                                         Vector3.down * _characterController.bounds.extents.y;\n   140→        public Vector3 ColliderTop => transform.position + _characterController.center +\n   141→                                      Vector3.up * _characterController.bounds.extents.y;\n   142→        public Vector3 AppliedImpact => _impact;\n   143→\n   144→        // 环境检测属性\n   145→        public GameObject ObjectBelow { get; set; }\n   146→        public GameObject DetectedObstacleLeft { get; set; }\n   147→        public GameObject DetectedObstacleRight { get; set; }\n   148→        public GameObject DetectedObstacleUp { get; set; }\n   149→        public GameObject DetectedObstacleDown { get; set; }\n   150→        public bool CollidingWithCardinalObstacle { get; set; }\n   151→        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n   152→\n   153→        // 移动平台相关属性\n   154→        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n   155→        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n   156→        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n   157→        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n   158→\n   159→        // 组件引用\n   160→        private Transform _transform;\n   161→        private CharacterController _characterController;\n   162→\n   163→        // 碰撞器原始尺寸\n   164→        private float _originalColliderHeight;\n   165→        private Vector3 _originalColliderCenter;\n   166→\n   167→        // 运动状态追踪\n   168→        private Vector3 _positionLastFrame;\n   169→        private bool _groundedLastFrame;\n   170→        private Vector3 _impact;\n   171→        private Vector3 _lastGroundNormal = Vector3.zero;\n   172→        private bool _detached = false;\n   173→        private bool _tooSteepLastFrame;\n   174→\n   175→        // 移动平台追踪\n   176→        private Transform _movingPlatformHitCollider;\n   177→        private Transform _movingPlatformCurrentHitCollider;\n   178→        private Vector3 _movingPlatformCurrentHitColliderLocal;\n   179→        private Vector3 _movingPlatformCurrentGlobalPoint;\n   180→        private Quaternion _movingPlatformLocalRotation;\n   181→        private Quaternion _movingPlatformGlobalRotation;\n   182→        private Quaternion _lastMoveWithPlatformGlobalRotation;\n   183→        private Matrix4x4 _lastMovingPlatformMatrix;\n   184→        private Vector3 _movingPlatformVelocity;\n   185→        private bool _newMovingPlatform;\n   186→\n   187→        // 碰撞检测\n   188→        private CollisionFlags _collisionFlags;\n   189→        private Vector3 _frameVelocity = Vector3.zero;\n   190→        private Vector3 _hitPoint = Vector3.zero;\n   191→        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n   192→\n   193→        // 速度计算\n   194→        private Vector3 _newVelocity;\n   195→        private Vector3 _motion;\n   196→        private Vector3 _idealVelocity;\n   197→        private Vector3 _idealDirection;\n   198→        private Vector3 _horizontalVelocityDelta;\n   199→        private float _stickyOffset = 0f;\n   200→\n   201→        // 位置移动\n   202→        private RaycastHit _movePositionHit;\n   203→        private Vector3 _capsulePoint1;\n   204→        private Vector3 _capsulePoint2;\n   205→        private Vector3 _movePositionDirection;\n   206→        private float _movePositionDistance;\n   207→\n   208→        // 障碍物检测\n   209→        private RaycastHit _cardinalRaycast;\n   210→        private float _smallestDistance = Single.MaxValue;\n   211→        private float _longestDistance = Single.MinValue;\n   212→        private RaycastHit _smallestRaycast;\n   213→        private RaycastHit _emptyRaycast = new RaycastHit();\n   214→        private Vector3 _downRaycastsOffset;\n   215→\n   216→        // 平台移动计算\n   217→        private Vector3 _moveWithPlatformMoveDistance;\n   218→        private Vector3 _moveWithPlatformGlobalPoint;\n   219→        private Quaternion _moveWithPlatformRotationDiff;\n   220→        private Quaternion _moveWithPlatformGlobalRotation;\n   221→        private RaycastHit _raycastDownHit;\n   222→        private Vector3 _raycastDownDirection = Vector3.down;\n   223→        private RaycastHit _canGoBackHeadCheck;\n   224→        private Vector3 _originalSizeRaycastOrigin;\n   225→\n   226→        // 协程和可选组件\n   227→        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n   228→        private Rigidbody _rigidBody;\n   229→        private float _currentDeltaTime;\n   230→\n   231→        // ============== 插值相关变量（已废弃，保留用于兼容性）==============\n   232→        /// <summary>\n   233→        /// 逻辑帧的时间间隔（保留字段，用于外部调用兼容性）\n   234→        /// </summary>\n   235→        private float _logicDeltaTime = 1f / 30f;\n   236→        \n   237→        /// <summary>\n   238→        /// 上一次逻辑帧的时间戳\n   239→        /// </summary>\n   240→        private float _lastLogicUpdateTime = 0f;\n   241→\n   242→        /// <summary>\n   243→        /// 上一次执行逻辑更新的帧号（用于防止同一帧重复移动）\n   244→        /// </summary>\n   245→        private int _lastLogicUpdateFrame = -1;\n   246→\n   247→        /// <summary>\n   248→        /// 渲染帧专用的上一帧位置（用于计算速度显示）\n   249→        /// </summary>\n   250→        private Vector3 _renderPositionLastFrame = Vector3.zero;\n   251→\n   252→        /// <summary>\n   253→        /// 检查角色是否正在滑动\n   254→        /// </summary>\n   255→        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n   256→\n   257→        /// <summary>\n   258→        /// 检查角色头部是否与物体碰撞\n   259→        /// </summary>\n   260→        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n   261→\n   262→        /// <summary>\n   263→        /// 检查当前地面是否过于陡峭\n   264→        /// </summary>\n   265→        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n   266→\n   267→        /// <summary>\n   268→        /// 初始化组件和缓存引用\n   269→        /// </summary>\n   270→        protected virtual void Awake()\n   271→        {\n   272→            _characterController = GetComponent<CharacterController>();\n   273→            _transform = transform;\n   274→            _rigidBody = GetComponent<Rigidbody>();\n   275→            _originalColliderHeight = _characterController.height;\n   276→            _originalColliderCenter = _characterController.center;\n   277→            _currentDirection = _transform.forward;\n   278→            _lastLogicUpdateTime = Time.time;\n   279→            _renderPositionLastFrame = _transform.position;\n   280→        }\n   281→\n   282→        /// <summary>\n   283→        /// 每帧更新（渲染帧）\n   284→        /// 根据 UpdateModeType 决定是否在此执行物理计算\n   285→        /// </summary>\n   286→        protected virtual void Update()\n   287→        {\n   288→            float deltaTime = Time.deltaTime;\n   289→            _currentDeltaTime = deltaTime;\n   290→\n   291→            // 只在 Auto 模式下自动执行物理计算\n   292→            // Manual 模式下，物理计算由外部 LogicUpdate 调用控制\n   293→            if (UpdateModeType == UpdateMode.Auto)\n   294→            {\n   295→                // 在 Auto 模式下才更新平台速度\n   296→                GetMovingPlatformVelocity();\n   297→\n   298→                // 检查是否已经在 LogicUpdate 中处理过这一帧（防止双重移动）\n   299→                bool alreadyProcessedThisFrame = (Time.frameCount == _lastLogicUpdateFrame);\n   300→\n   301→                if (!alreadyProcessedThisFrame && _freeMovement)\n   302→                {\n   303→                    ProcessLogicUpdate(deltaTime);\n   304→                }\n   305→\n   306→                // 更新速度显示（仅用于调试）\n   307→                if (deltaTime > SMALL_VALUE)\n   308→                {\n   309→                    _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n   310→                    _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   311→                    _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   312→                    _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   313→                    _renderPositionLastFrame = _transform.position;\n   314→                }\n   315→            }\n   316→        }\n   317→\n   318→        /// <summary>\n   319→        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n   320→        /// 注意：如果外部调用了此方法，Update 将跳过这一帧的处理，避免双重移动\n   321→        /// </summary>\n   322→        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n   323→        public virtual void LogicUpdate(float deltaTime)\n   324→        {\n   325→            _logicDeltaTime = deltaTime;\n   326→            _currentDeltaTime = deltaTime;\n   327→            _lastLogicUpdateTime = Time.time;\n   328→            _lastLogicUpdateFrame = Time.frameCount; // 标记这一帧已处理\n   329→\n   330→            ProcessLogicUpdate(deltaTime);\n   331→        }\n   332→\n   333→        /// <summary>\n   334→        /// 固定时间更新（保留用于物理相关操作）\n   335→        /// </summary>\n   336→        protected virtual void FixedUpdate()\n   337→        {\n   338→            _currentDeltaTime = Time.fixedDeltaTime;\n   339→        }\n   340→\n   341→        /// <summary>\n   342→        /// 延迟更新，保存上一帧速度\n   343→        /// </summary>\n   344→        protected virtual void LateUpdate()\n   345→        {\n   346→            _velocityLastFrame = _velocity;\n   347→        }\n   348→\n   349→        /// <summary>\n   350→        /// 核心逻辑更新处理流程（使用指定的 deltaTime）\n   351→        /// 计算移动逻辑并执行 CharacterController.Move\n   352→        /// </summary>\n   353→        /// <param name=\"deltaTime\">时间增量</param>\n   354→        protected virtual void ProcessLogicUpdate(float deltaTime)\n   355→        {\n   356→            if (_transform == null || !_freeMovement)\n   357→            {\n   358→                return;\n   359→            }\n   360→\n   361→            _newVelocity = _velocity;\n   362→            _positionLastFrame = _transform.position;\n   363→\n   364→            CheckIfGrounded();\n   365→            HandleFriction();\n   366→            DetermineDirection();\n   367→            AddInput(deltaTime);\n   368→            AddGravity(deltaTime);\n   369→            MoveWithPlatform();\n   370→            ComputeVelocityDelta(deltaTime);\n   371→\n   372→            // 执行实际移动\n   373→            MoveCharacterControllerWithMotion(_motion);\n   374→            DetectNewMovingPlatform();\n   375→            ManualControllerColliderHit();\n   376→            HandleGroundContact();\n   377→\n   378→            ComputeNewVelocity(deltaTime);\n   379→        }\n   380→\n   381→        /// <summary>\n   382→        /// 使用指定的移动向量执行 CharacterController 移动\n   383→        /// </summary>\n   384→        /// <param name=\"motion\">移动向量</param>\n   385→        protected virtual void MoveCharacterControllerWithMotion(Vector3 motion)\n   386→        {\n   387→            _groundNormal = Vector3.zero;\n   388→            _collisionFlags = _characterController.Move(motion);\n   389→            _lastHitPoint = _hitPoint;\n   390→            _lastGroundNormal = _groundNormal;\n   391→        }\n   392→\n   393→        /// <summary>\n   394→        /// 处理输入并计算理想速度（包括滑坡逻辑）\n   395→        /// </summary>\n   396→        /// <param name=\"deltaTime\">时间增量</param>\n   397→        protected virtual void AddInput(float deltaTime)\n   398→        {\n   399→            if (_grounded && TooSteep())\n   400→            {\n   401→                _idealVelocity.x = _groundNormal.x;\n   402→                _idealVelocity.y = 0;\n   403→                _idealVelocity.z = _groundNormal.z;\n   404→                _idealVelocity = _idealVelocity.normalized;\n   405→                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n   406→                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n   407→                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n   408→                _idealVelocity = _idealVelocity * SlidingSpeed;\n   409→                _targetVelocity = _idealVelocity;\n   410→                _newVelocity = _idealVelocity;\n   411→                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n   412→            }\n   413→            else\n   414→            {\n   415→                _targetVelocity = _currentMovement;\n   416→\n   417→                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n   418→                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n   419→\n   420→                Vector3 newHorizontalVelocity;\n   421→\n   422→                // 如果加速度为 0，直接使用目标速度（零延迟响应）\n   423→                if (HorizontalAcceleration <= 0.001f && HorizontalDeceleration <= 0.001f)\n   424→                {\n   425→                    newHorizontalVelocity = targetHorizontalVelocity;\n   426→                }\n   427→                else if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n   428→                {\n   429→                    float effectiveAcceleration = HorizontalAcceleration;\n   430→\n   431→                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n   432→                    {\n   433→                        effectiveAcceleration *= InitialBurstMultiplier;\n   434→                    }\n   435→\n   436→                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n   437→                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n   438→\n   439→                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n   440→                    {\n   441→                        newHorizontalVelocity = targetHorizontalVelocity;\n   442→                    }\n   443→                    else\n   444→                    {\n   445→                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n   446→                    }\n   447→                }\n   448→                else\n   449→                {\n   450→                    float currentSpeed = currentHorizontalVelocity.magnitude;\n   451→                    float speedReduction = HorizontalDeceleration * deltaTime;\n   452→\n   453→                    if (currentSpeed <= speedReduction)\n   454→                    {\n   455→                        newHorizontalVelocity = Vector3.zero;\n   456→                    }\n   457→                    else\n   458→                    {\n   459→                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n   460→                    }\n   461→                }\n   462→\n   463→                _newVelocity.x = newHorizontalVelocity.x;\n   464→                _newVelocity.z = newHorizontalVelocity.z;\n   465→\n   466→                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n   467→                {\n   468→                    Vector3 floorVelocity = _frameVelocity;\n   469→                    floorVelocity.y = 0;\n   470→                    _newVelocity.x += floorVelocity.x;\n   471→                    _newVelocity.z += floorVelocity.z;\n   472→                }\n   473→\n   474→                if (_grounded)\n   475→                {\n   476→                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n   477→                    float velocityMagnitude = horizontalVelocity.magnitude;\n   478→\n   479→                    if (velocityMagnitude > SMALL_VALUE)\n   480→                    {\n   481→                        Vector3 velocityDirection = horizontalVelocity / velocityMagnitude;\n   482→\n   483→                        // 只有当地面法线不是水平面时才投影，避免平地上的抖动\n   484→                        if (_groundNormal.y < 0.999f)  // 如果地面法线几乎是正上方，跳过投影\n   485→                        {\n   486→                            Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n   487→\n   488→                            // 检查投影后的方向是否有效\n   489→                            if (projectedDirection.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n   490→                            {\n   491→                                projectedDirection.Normalize();\n   492→                                _newVelocity.x = projectedDirection.x * velocityMagnitude;\n   493→                                _newVelocity.z = projectedDirection.z * velocityMagnitude;\n   494→                            }\n   495→                        }\n   496→                    }\n   497→\n   498→                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n   499→                }\n   500→            }\n   501→        }\n   502→\n   503→        /// <summary>\n   504→        /// 应用重力到速度\n   505→        /// </summary>\n   506→        /// <param name=\"deltaTime\">时间增量</param>\n   507→        protected virtual void AddGravity(float deltaTime)\n   508→        {\n   509→            if (GravityActive)\n   510→            {\n   511→                if (_grounded)\n   512→                {\n   513→                    _newVelocity.y = -Gravity * deltaTime;\n   514→                }\n   515→                else\n   516→                {\n   517→                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n   518→                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n   519→                }\n   520→            }\n   521→            _newVelocity += _addedForce;\n   522→            _addedForce = Vector3.zero;\n   523→        }\n   524→\n   525→        /// <summary>\n   526→        /// 跟随移动平台移动\n   527→        /// </summary>\n   528→        protected virtual void MoveWithPlatform()\n   529→        {\n   530→            if (ShouldMoveWithPlatformThisFrame())\n   531→            {\n   532→                _moveWithPlatformMoveDistance = Vector3.zero;\n   533→                _moveWithPlatformGlobalPoint =\n   534→                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n   535→                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n   536→                if (_moveWithPlatformMoveDistance != Vector3.zero)\n   537→                {\n   538→                    _characterController.Move(_moveWithPlatformMoveDistance);\n   539→                }\n   540→                _moveWithPlatformGlobalRotation =\n   541→                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n   542→                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n   543→                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n   544→                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n   545→            }\n   546→        }\n   547→\n   548→        /// <summary>\n   549→        /// 计算速度增量和粘性偏移\n   550→        /// </summary>\n   551→        /// <param name=\"deltaTime\">时间增量</param>\n   552→        protected virtual void ComputeVelocityDelta(float deltaTime)\n   553→        {\n   554→            _motion = _newVelocity * deltaTime;\n   555→            _horizontalVelocityDelta.x = _motion.x;\n   556→            _horizontalVelocityDelta.y = 0f;\n   557→            _horizontalVelocityDelta.z = _motion.z;\n   558→\n   559→            // 临时禁用地面粘附，测试是否是它导致的抖动\n   560→            /*\n   561→            // 只有在有水平移动时才应用粘附偏移，避免静止时的抖动\n   562→            float horizontalSpeed = _horizontalVelocityDelta.magnitude;\n   563→            if (_grounded && horizontalSpeed > SMALL_VALUE)\n   564→            {\n   565→                // 使用较小的粘附值，避免过度向下推\n   566→                _stickyOffset = Mathf.Min(_characterController.stepOffset, horizontalSpeed);\n   567→                _motion.y -= _stickyOffset;\n   568→            }\n   569→            */\n   570→        }\n   571→\n   572→        /// <summary>\n   573→        /// 检测是否踩上新的移动平台\n   574→        /// </summary>\n   575→        protected virtual void DetectNewMovingPlatform()\n   576→        {\n   577→            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n   578→            {\n   579→                if (_movingPlatformHitCollider != null)\n   580→                {\n   581→                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n   582→                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n   583→                    _newMovingPlatform = true;\n   584→                }\n   585→            }\n   586→        }\n   587→\n   588→        /// <summary>\n   589→        /// 计算新速度和加速度\n   590→        /// </summary>\n   591→        /// <param name=\"deltaTime\">时间增量</param>\n   592→        protected virtual void ComputeNewVelocity(float deltaTime)\n   593→        {\n   594→            _velocity = _newVelocity;\n   595→            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n   596→        }\n   597→\n   598→        /// <summary>\n   599→        /// 处理地面接触状态和平台速度传递\n   600→        /// </summary>\n   601→        protected virtual void HandleGroundContact()\n   602→        {\n   603→            _grounded = _characterController.isGrounded;\n   604→            if (_grounded && !IsGroundedTest())\n   605→            {\n   606→                _grounded = false;\n   607→                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n   608→                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n   609→                {\n   610→                    _frameVelocity = _movingPlatformVelocity;\n   611→                    _velocity += _movingPlatformVelocity;\n   612→                }\n   613→            }\n   614→            else if (!_grounded && IsGroundedTest())\n   615→            {\n   616→                if (_detached && _velocity.y <= 0)\n   617→                {\n   618→                    _grounded = true;\n   619→                    _detached = false;\n   620→                }\n   621→                SubtractNewPlatformVelocity();\n   622→            }\n   623→\n   624→            if (ShouldMoveWithPlatformThisFrame())\n   625→            {\n   626→                _movingPlatformCurrentGlobalPoint = _transform.position;\n   627→                _movingPlatformCurrentHitColliderLocal =\n   628→                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n   629→                _movingPlatformGlobalRotation = _transform.rotation;\n   630→                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n   631→                                               _movingPlatformGlobalRotation;\n   632→            }\n   633→\n   634→            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n   635→            _tooSteepLastFrame = TooSteep();\n   636→        }\n   637→\n   638→        /// <summary>\n   639→        /// 计算当前速度（仅用于显示，不影响逻辑）\n   640→        /// </summary>\n   641→        /// <param name=\"deltaTime\">时间增量</param>\n   642→        protected virtual void ComputeSpeed(float deltaTime)\n   643→        {\n   644→            // 使用渲染帧专用的位置记录，避免干扰逻辑帧\n   645→            if (deltaTime > SMALL_VALUE)\n   646→            {\n   647→                _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n   648→            }\n   649→            _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   650→            _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   651→            _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   652→\n   653→            _renderPositionLastFrame = _transform.position;\n   654→        }\n   655→\n   656→        /// <summary>\n   657→        /// 根据当前移动向量确定方向\n   658→        /// </summary>\n   659→        protected virtual void DetermineDirection()\n   660→        {\n   661→            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n   662→            {\n   663→                _currentDirection = _currentMovement.normalized;\n   664→            }\n   665→        }\n   666→\n   667→        /// <summary>\n   668→        /// 处理摩擦力（预留方法，可在子类中实现）\n   669→        /// </summary>\n   670→        protected virtual void HandleFriction()\n   671→        {\n   672→        }\n   673→\n   674→        /// <summary>\n   675→        /// 检查是否刚刚着地\n   676→        /// </summary>\n   677→        protected virtual void CheckIfGrounded()\n   678→        {\n   679→            _justGotGrounded = !_groundedLastFrame && _grounded;\n   680→            _groundedLastFrame = _grounded;\n   681→        }\n   682→\n   683→        /// <summary>\n   684→        /// 手动触发碰撞器碰撞处理\n   685→        /// </summary>\n   686→        protected virtual void ManualControllerColliderHit()\n   687→        {\n   688→            HandleAdvancedGroundDetection();\n   689→        }\n   690→\n   691→        /// <summary>\n   692→        /// 高级地面检测（使用多方向射线）\n   693→        /// </summary>\n   694→        protected virtual void HandleAdvancedGroundDetection()\n   695→        {\n   696→            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n   697→            {\n   698→                return;\n   699→            }\n   700→\n   701→            _smallestDistance = Single.MaxValue;\n   702→            _longestDistance = Single.MinValue;\n   703→            _smallestRaycast = _emptyRaycast;\n   704→            float offset = _characterController.radius;\n   705→            _downRaycastsOffset = Vector3.zero;\n   706→            CastRayDownwards();\n   707→            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n   708→            CastRayDownwards();\n   709→            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n   710→            CastRayDownwards();\n   711→            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n   712→            CastRayDownwards();\n   713→            _downRaycastsOffset = new Vector3(0f, offset, offset);\n   714→            CastRayDownwards();\n   715→\n   716→            if (_smallestRaycast.collider != null)\n   717→            {\n   718→                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n   719→                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n   720→                {\n   721→                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n   722→                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n   723→                    {\n   724→                        _groundNormal = _smallestRaycast.normal;\n   725→                    }\n   726→                    else\n   727→                    {\n   728→                        _groundNormal = _lastGroundNormal;\n   729→                    }\n   730→\n   731→                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n   732→                    _hitPoint = _smallestRaycast.point;\n   733→                    _frameVelocity = Vector3.zero;\n   734→                }\n   735→            }\n   736→        }\n   737→\n   738→        /// <summary>\n   739→        /// 向下发射射线检测地面\n   740→        /// </summary>\n   741→        protected virtual void CastRayDownwards()\n   742→        {\n   743→            if (_smallestDistance <= MinimumGroundedDistance)\n   744→            {\n   745→                return;\n   746→            }\n   747→\n   748→            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n   749→                _raycastDownDirection, out _raycastDownHit,\n   750→                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n   751→\n   752→            if (_raycastDownHit.collider != null)\n   753→            {\n   754→                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n   755→                if (adjustedDistance < _smallestDistance)\n   756→                {\n   757→                    _smallestDistance = adjustedDistance;\n   758→                    _smallestRaycast = _raycastDownHit;\n   759→                }\n   760→                if (adjustedDistance > _longestDistance)\n   761→                {\n   762→                    _longestDistance = adjustedDistance;\n   763→                }\n   764→            }\n   765→        }\n   766→\n   767→        /// <summary>\n   768→        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n   769→        /// </summary>\n   770→        protected float AdjustDistance(float distance)\n   771→        {\n   772→            return distance - _characterController.height / 2f - _characterController.skinWidth;\n   773→        }\n   774→\n   775→        /// <summary>\n   776→        /// 测试是否真正着地\n   777→        /// </summary>\n   778→        protected virtual bool IsGroundedTest()\n   779→        {\n   780→            bool grounded = false;\n   781→            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n   782→            {\n   783→                if (_smallestDistance <= MinimumGroundedDistance)\n   784→                {\n   785→                    grounded = _groundNormal.y > 0.01f;\n   786→                }\n   787→            }\n   788→            else\n   789→            {\n   790→                grounded = _characterController.isGrounded;\n   791→                _groundNormal = Vector3.up;\n   792→            }\n   793→            return grounded;\n   794→        }\n   795→\n   796→        /// <summary>\n   797→        /// 获取移动平台速度\n   798→        /// </summary>\n   799→        protected virtual void GetMovingPlatformVelocity()\n   800→        {\n   801→            if (_movingPlatformCurrentHitCollider != null)\n   802→            {\n   803→                if (!_newMovingPlatform && _currentDeltaTime > SMALL_VALUE)\n   804→                {\n   805→                    _movingPlatformVelocity = (\n   806→                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n   807→                            _movingPlatformCurrentHitColliderLocal)\n   808→                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n   809→                    ) / _currentDeltaTime;\n   810→                }\n   811→                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n   812→                _newMovingPlatform = false;\n   813→            }\n   814→            else\n   815→            {\n   816→                _movingPlatformVelocity = Vector3.zero;\n   817→            }\n   818→        }\n   819→\n   820→        /// <summary>\n   821→        /// 减去新平台速度（处理平台切换）\n   822→        /// </summary>\n   823→        protected virtual void SubtractNewPlatformVelocity()\n   824→        {\n   825→            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n   826→                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n   827→            {\n   828→                if (_newMovingPlatform)\n   829→                {\n   830→                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n   831→                }\n   832→                else\n   833→                {\n   834→                    _velocity -= _movingPlatformVelocity;\n   835→                }\n   836→            }\n   837→        }\n   838→\n   839→        /// <summary>\n   840→        /// 协程：延迟减去平台速度\n   841→        /// </summary>\n   842→        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n   843→        {\n   844→            Transform platform = _movingPlatformCurrentHitCollider;\n   845→            yield return _waitForFixedUpdate;\n   846→            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n   847→            {\n   848→                yield return null;\n   849→            }\n   850→            _velocity -= _movingPlatformVelocity;\n   851→        }\n   852→\n   853→        /// <summary>\n   854→        /// 判断是否应该跟随平台移动\n   855→        /// </summary>\n   856→        protected virtual bool ShouldMoveWithPlatformThisFrame()\n   857→        {\n   858→            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n   859→                   && _movingPlatformCurrentHitCollider != null;\n   860→        }\n   861→\n   862→        /// <summary>\n   863→        /// 应用冲击力并逐渐衰减\n   864→        /// </summary>\n   865→        protected virtual void ApplyImpact()\n   866→        {\n   867→            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n   868→            {\n   869→                _characterController.Move(_impact * _currentDeltaTime);\n   870→            }\n   871→            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * _currentDeltaTime);\n   872→        }\n   873→\n   874→        /// <summary>\n   875→        /// 从地面分离（用于跳跃等）\n   876→        /// </summary>\n   877→        public virtual void DetachFromGround()\n   878→        {\n   879→            _detached = true;\n   880→        }\n   881→\n   882→        /// <summary>\n   883→        /// 从移动平台分离\n   884→        /// </summary>\n   885→        public virtual void DetachFromMovingPlatform()\n   886→        {\n   887→            _movingPlatformVelocity = Vector3.zero;\n   888→            _movingPlatformCurrentHitCollider = null;\n   889→            _movingPlatformHitCollider = null;\n   890→        }\n   891→\n   892→        /// <summary>\n   893→        /// 设置重力是否激活\n   894→        /// </summary>\n   895→        public virtual void SetGravityActive(bool status)\n   896→        {\n   897→            GravityActive = status;\n   898→        }\n   899→\n   900→        /// <summary>\n   901→        /// 添加外部力（会在下一帧应用）\n   902→        /// </summary>\n   903→        public virtual void AddForce(Vector3 movement)\n   904→        {\n   905→            _addedForce += movement;\n   906→        }\n   907→\n   908→        /// <summary>\n   909→        /// 施加瞬时冲击力\n   910→        /// </summary>\n   911→        /// <param name=\"direction\">冲击方向</param>\n   912→        /// <param name=\"force\">冲击力大小</param>\n   913→        public virtual void Impact(Vector3 direction, float force)\n   914→        {\n   915→            direction = direction.normalized;\n   916→            if (direction.y < 0)\n   917→            {\n   918→                direction.y = -direction.y;\n   919→            }\n   920→            _impact += direction.normalized * force;\n   921→        }\n   922→\n   923→        /// <summary>\n   924→        /// 设置移动向量（通常由输入系统调用）\n   925→        /// </summary>\n   926→        /// <param name=\"movement\">移动向量</param>\n   927→        public virtual void SetMovement(Vector3 movement)\n   928→        {\n   929→            _currentMovement = movement;\n   930→            Vector3 directionVector = movement;\n   931→            if (directionVector != Vector3.zero)\n   932→            {\n   933→                float directionLength = directionVector.magnitude;\n   934→                directionVector = directionVector / directionLength;\n   935→                directionLength = Mathf.Min(1, directionLength);\n   936→                directionLength = directionLength * directionLength;\n   937→                directionVector = directionVector * directionLength;\n   938→            }\n   939→            _inputMoveDirection = transform.rotation * directionVector;\n   940→        }\n   941→\n   942→        /// <summary>\n   943→        /// 移动到指定位置（带碰撞检测）\n   944→        /// </summary>\n   945→        /// <param name=\"newPosition\">目标位置</param>\n   946→        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n   947→        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n   948→        {\n   949→            _movePositionDirection = newPosition - transform.position;\n   950→            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n   951→\n   952→            _capsulePoint1 = transform.position\n   953→                             + _characterController.center\n   954→                             - (Vector3.up * _characterController.height / 2f)\n   955→                             + Vector3.up * _characterController.skinWidth\n   956→                             + Vector3.up * _characterController.radius;\n   957→\n   958→            _capsulePoint2 = transform.position\n   959→                             + _characterController.center\n   960→                             + (Vector3.up * _characterController.height / 2f)\n   961→                             - Vector3.up * _characterController.skinWidth\n   962→                             - Vector3.up * _characterController.radius;\n   963→\n   964→            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n   965→                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n   966→            {\n   967→                transform.position = newPosition;\n   968→            }\n   969→        }\n   970→\n   971→        /// <summary>\n   972→        /// 调整碰撞器高度（用于蹲伏等）\n   973→        /// </summary>\n   974→        /// <param name=\"newHeight\">新高度</param>\n   975→        /// <param name=\"translateCenter\">是否平移中心点</param>\n   976→        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n   977→        {\n   978→            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n   979→            _characterController.height = newHeight;\n   980→            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n   981→            if (translateCenter)\n   982→            {\n   983→                transform.Translate((newYOffset / 2f) * Vector3.up);\n   984→            }\n   985→        }\n   986→\n   987→        /// <summary>\n   988→        /// 重置碰撞器尺寸到原始大小\n   989→        /// </summary>\n   990→        public virtual void ResetColliderSize()\n   991→        {\n   992→            _characterController.height = _originalColliderHeight;\n   993→            _characterController.center = _originalColliderCenter;\n   994→        }\n   995→\n   996→        /// <summary>\n   997→        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n   998→        /// </summary>\n   999→        public virtual bool CanGoBackToOriginalSize()\n  1000→        {\n  1001→            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n  1002→            {\n  1003→                return true;\n  1004→            }\n  1005→\n  1006→            float headCheckDistance =\n  1007→                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n  1008→            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n  1009→            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n  1010→                ObstaclesLayerMask, Color.cyan, true);\n  1011→\n  1012→            return _canGoBackHeadCheck.collider == null;\n  1013→        }\n  1014→\n  1015→        /// <summary>\n  1016→        /// 启用碰撞\n  1017→        /// </summary>\n  1018→        public virtual void CollisionsOn()\n  1019→        {\n  1020→            if (_characterController != null)\n  1021→            {\n  1022→                _characterController.enabled = true;\n  1023→            }\n  1024→        }\n  1025→\n  1026→        /// <summary>\n  1027→        /// 禁用碰撞\n  1028→        /// </summary>\n  1029→        public virtual void CollisionsOff()\n  1030→        {\n  1031→            if (_characterController != null)\n  1032→            {\n  1033→                _characterController.enabled = false;\n  1034→            }\n  1035→        }\n  1036→\n  1037→        /// <summary>\n  1038→        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n  1039→        /// </summary>\n  1040→        public virtual void SetKinematic(bool state)\n  1041→        {\n  1042→            _rigidBody.isKinematic = state;\n  1043→        }\n  1044→\n  1045→        /// <summary>\n  1046→        /// 设置是否允许自由移动\n  1047→        /// </summary>\n  1048→        public virtual void SetFreeMovement(bool state)\n  1049→        {\n  1050→            _freeMovement = state;\n  1051→        }\n  1052→\n  1053→        /// <summary>\n  1054→        /// 检测四个基本方向的障碍物\n  1055→        /// </summary>\n  1056→        /// <param name=\"distance\">检测距离</param>\n  1057→        /// <param name=\"offset\">起始偏移</param>\n  1058→        public virtual void DetectObstacles(float distance, Vector3 offset)\n  1059→        {\n  1060→            if (!PerformCardinalObstacleRaycastDetection)\n  1061→            {\n  1062→                return;\n  1063→            }\n  1064→\n  1065→            CollidingWithCardinalObstacle = false;\n  1066→\n  1067→            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n  1068→                ObstaclesLayerMask, Color.yellow, true);\n  1069→            if (_cardinalRaycast.collider != null)\n  1070→            {\n  1071→                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n  1072→                CollidingWithCardinalObstacle = true;\n  1073→            }\n  1074→            else\n  1075→            {\n  1076→                DetectedObstacleRight = null;\n  1077→            }\n  1078→\n  1079→            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n  1080→                ObstaclesLayerMask, Color.yellow, true);\n  1081→            if (_cardinalRaycast.collider != null)\n  1082→            {\n  1083→                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n  1084→                CollidingWithCardinalObstacle = true;\n  1085→            }\n  1086→            else\n  1087→            {\n  1088→                DetectedObstacleLeft = null;\n  1089→            }\n  1090→\n  1091→            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n  1092→                ObstaclesLayerMask, Color.yellow, true);\n  1093→            if (_cardinalRaycast.collider != null)\n  1094→            {\n  1095→                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n  1096→                CollidingWithCardinalObstacle = true;\n  1097→            }\n  1098→            else\n  1099→            {\n  1100→                DetectedObstacleUp = null;\n  1101→            }\n  1102→\n  1103→            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n  1104→                ObstaclesLayerMask, Color.yellow, true);\n  1105→            if (_cardinalRaycast.collider != null)\n  1106→            {\n  1107→                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n  1108→                CollidingWithCardinalObstacle = true;\n  1109→            }\n  1110→            else\n  1111→            {\n  1112→                DetectedObstacleDown = null;\n  1113→            }\n  1114→        }\n  1115→\n  1116→        /// <summary>\n  1117→        /// 重置控制器到初始状态\n  1118→        /// </summary>\n  1119→        public virtual void ResetController()\n  1120→        {\n  1121→            _impact = Vector3.zero;\n  1122→            GravityActive = true;\n  1123→            _speed = Vector3.zero;\n  1124→            _velocity = Vector3.zero;\n  1125→            _velocityLastFrame = Vector3.zero;\n  1126→            _acceleration = Vector3.zero;\n  1127→            _grounded = true;\n  1128→            _justGotGrounded = false;\n  1129→            _currentMovement = Vector3.zero;\n  1130→            _currentDirection = Vector3.zero;\n  1131→            _addedForce = Vector3.zero;\n  1132→            _idealDirection = Vector3.zero;\n  1133→            _idealVelocity = Vector3.zero;\n  1134→            _newVelocity = Vector3.zero;\n  1135→            _movingPlatformVelocity = Vector3.zero;\n  1136→            _movingPlatformCurrentHitCollider = null;\n  1137→            _movingPlatformHitCollider = null;\n  1138→            _lastGroundNormal = Vector3.zero;\n  1139→            _detached = false;\n  1140→            _frameVelocity = Vector3.zero;\n  1141→            _hitPoint = Vector3.zero;\n  1142→            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n  1143→\n  1144→            _renderPositionLastFrame = _transform != null ? _transform.position : Vector3.zero;\n  1145→            _lastLogicUpdateTime = Time.time;\n  1146→            _lastLogicUpdateFrame = -1;\n  1147→\n  1148→            if (_rigidBody != null)\n  1149→            {\n  1150→                bool isKinematic = _rigidBody.isKinematic;\n  1151→                _rigidBody.isKinematic = false;\n  1152→                _rigidBody.linearVelocity = Vector3.zero;\n  1153→                _rigidBody.angularVelocity = Vector3.zero;\n  1154→                _rigidBody.isKinematic = isKinematic;\n  1155→            }\n  1156→        }\n  1157→\n  1158→        /// <summary>\n  1159→        /// 3D 射线检测辅助方法（带可视化调试）\n  1160→        /// </summary>\n  1161→        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n  1162→            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n  1163→        {\n  1164→            RaycastHit hit;\n  1165→            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n  1166→            if (Camera.current != null && (drawInSceneView || drawInGameView))\n  1167→            {\n  1168→                Debug.DrawRay(origin, direction * distance, color);\n  1169→            }\n  1170→            return hit;\n  1171→        }\n  1172→    }\n  1173→}\n  1174→"}]},"uuid":"e09efd35-af49-4a5e-9a89-6c2c2cb12e88","timestamp":"2025-12-15T10:59:27.807Z","toolUseResult":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","oldString":"using System;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing ActionMachine.Runtime.Attributes;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 运动学角色控制器（Kinematic Character Controller）\n    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    /// \n    /// 修复：添加逻辑帧与渲染帧之间的插值，解决 30fps 逻辑更新导致的卡顿\n    /// </summary>\n    [RequireComponent(typeof(CharacterController))]\n    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    public partial class Kcc : MonoBehaviour\n    {\n        private const float SMALL_VALUE = 0.0001f;\n        private const float SPEED_ROUNDING_PRECISION = 100f;\n        private const float IMPACT_THRESHOLD = 0.2f;\n\n        public enum GroundedComputationMode\n        {\n            Simple,\n            Advanced\n        }\n\n        public enum VelocityTransferMode\n        {\n            NoTransfer,\n            InitialVelocity,\n            FloorVelocity,\n            Relative\n        }\n\n        [Header(\"Update Mode Settings\")]\n        [Tooltip(\"更新模式：Auto = Update 中自动执行（用于无外部 LogicUpdate 调用）, Manual = 仅通过外部 LogicUpdate 调用执行\")]\n        public UpdateMode UpdateModeType = UpdateMode.Manual;\n\n        public enum UpdateMode\n        {\n            Auto,    // Update 中自动执行物理计算\n            Manual   // 仅通过外部 LogicUpdate 调用执行\n        }\n\n        [Header(\"Gravity Settings\")]\n        [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n        public float Gravity = 40f;\n        [Tooltip(\"是否激活重力\")]\n        public bool GravityActive = true;\n\n        [Header(\"Raycast Settings\")]\n        [Tooltip(\"障碍物层遮罩\")]\n        public LayerMask ObstaclesLayerMask;\n        [Tooltip(\"向下射线检测长度\")]\n        public float GroundedRaycastLength = 5f;\n        [Tooltip(\"最小着地距离\")]\n        public float MinimumGroundedDistance = 0.2f;\n        [Tooltip(\"地面检测计算模式\")]\n        public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n        [Tooltip(\"地面法线高度阈值\")]\n        public float GroundNormalHeightThreshold = 0.2f;\n        [Tooltip(\"蹲伏时射线长度倍数\")]\n        public float CrouchedRaycastLengthMultiplier = 1f;\n        [Tooltip(\"是否执行基本方向障碍物射线检测\")]\n        public bool PerformCardinalObstacleRaycastDetection = false;\n\n        [Header(\"Movement Settings\")]\n        [Tooltip(\"最大下落速度\")]\n        public float MaximumFallSpeed = 20.0f;\n        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速。设为 0 表示立即到达目标速度，消除加速延迟\")]\n        public float HorizontalAcceleration = 0f; // 改为 0，立即到达目标速度\n        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速。设为 0 表示立即停止，消除减速延迟\")]\n        public float HorizontalDeceleration = 0f; // 改为 0，立即停止\n        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n        public float InitialBurstMultiplier = 2.0f;\n        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n        public float BurstSpeedThreshold = 1.0f;\n        [Tooltip(\"斜坡速度倍数曲线\")]\n        public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n            new Keyframe(-90, 1),\n            new Keyframe(0, 1),\n            new Keyframe(90, 0)\n        );\n        [Tooltip(\"冲击力衰减速度\")]\n        public float ImpactFalloff = 5f;\n\n        [Header(\"Steep Surface Settings\")]\n        [Tooltip(\"是否在陡峭表面滑动\")]\n        public bool SlideOnSteepSurfaces = true;\n        [Tooltip(\"滑动速度\")]\n        public float SlidingSpeed = 15f;\n        [Tooltip(\"滑动速度控制\")]\n        public float SlidingSpeedControl = 0.4f;\n        [Tooltip(\"滑动方向控制\")]\n        public float SlidingDirectionControl = 1f;\n\n        [Header(\"Moving Platform Settings\")]\n        [Tooltip(\"跳跃时的速度传递方式\")]\n        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Runtime State - Read Only\")]\n        [SerializeField, ReadOnly] private Vector3 _speed;\n        [SerializeField, ReadOnly] private Vector3 _velocity;\n        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n        [SerializeField, ReadOnly] private Vector3 _acceleration;\n        [SerializeField, ReadOnly] private bool _grounded;\n        [SerializeField, ReadOnly] private bool _justGotGrounded;\n        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n        [SerializeField, ReadOnly] private float _friction;\n        [SerializeField, ReadOnly] private Vector3 _addedForce;\n        [SerializeField, ReadOnly] private bool _freeMovement = true;\n        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n\n        // 公共只读属性\n        public Vector3 Speed => _speed;\n        public Vector3 Velocity => _velocity;\n        public Vector3 VelocityLastFrame => _velocityLastFrame;\n        public Vector3 Acceleration => _acceleration;\n        public bool Grounded => _grounded;\n        public bool JustGotGrounded => _justGotGrounded;\n        public Vector3 CurrentMovement => _currentMovement;\n        public Vector3 CurrentDirection => _currentDirection;\n        public float Friction => _friction;\n        public Vector3 AddedForce => _addedForce;\n        public bool FreeMovement => _freeMovement;\n        public Vector3 GroundNormal => _groundNormal;\n        public Vector3 InputMoveDirection => _inputMoveDirection;\n        public Vector3 TargetVelocity => _targetVelocity;\n\n        // 碰撞器相关属性\n        public Vector3 ColliderCenter => transform.position + _characterController.center;\n        public Vector3 ColliderBottom => transform.position + _characterController.center +\n                                         Vector3.down * _characterController.bounds.extents.y;\n        public Vector3 ColliderTop => transform.position + _characterController.center +\n                                      Vector3.up * _characterController.bounds.extents.y;\n        public Vector3 AppliedImpact => _impact;\n\n        // 环境检测属性\n        public GameObject ObjectBelow { get; set; }\n        public GameObject DetectedObstacleLeft { get; set; }\n        public GameObject DetectedObstacleRight { get; set; }\n        public GameObject DetectedObstacleUp { get; set; }\n        public GameObject DetectedObstacleDown { get; set; }\n        public bool CollidingWithCardinalObstacle { get; set; }\n        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n\n        // 移动平台相关属性\n        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n\n        // 组件引用\n        private Transform _transform;\n        private CharacterController _characterController;\n\n        // 碰撞器原始尺寸\n        private float _originalColliderHeight;\n        private Vector3 _originalColliderCenter;\n\n        // 运动状态追踪\n        private Vector3 _positionLastFrame;\n        private bool _groundedLastFrame;\n        private Vector3 _impact;\n        private Vector3 _lastGroundNormal = Vector3.zero;\n        private bool _detached = false;\n        private bool _tooSteepLastFrame;\n\n        // 移动平台追踪\n        private Transform _movingPlatformHitCollider;\n        private Transform _movingPlatformCurrentHitCollider;\n        private Vector3 _movingPlatformCurrentHitColliderLocal;\n        private Vector3 _movingPlatformCurrentGlobalPoint;\n        private Quaternion _movingPlatformLocalRotation;\n        private Quaternion _movingPlatformGlobalRotation;\n        private Quaternion _lastMoveWithPlatformGlobalRotation;\n        private Matrix4x4 _lastMovingPlatformMatrix;\n        private Vector3 _movingPlatformVelocity;\n        private bool _newMovingPlatform;\n\n        // 碰撞检测\n        private CollisionFlags _collisionFlags;\n        private Vector3 _frameVelocity = Vector3.zero;\n        private Vector3 _hitPoint = Vector3.zero;\n        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n        // 速度计算\n        private Vector3 _newVelocity;\n        private Vector3 _motion;\n        private Vector3 _idealVelocity;\n        private Vector3 _idealDirection;\n        private Vector3 _horizontalVelocityDelta;\n        private float _stickyOffset = 0f;\n\n        // 位置移动\n        private RaycastHit _movePositionHit;\n        private Vector3 _capsulePoint1;\n        private Vector3 _capsulePoint2;\n        private Vector3 _movePositionDirection;\n        private float _movePositionDistance;\n\n        // 障碍物检测\n        private RaycastHit _cardinalRaycast;\n        private float _smallestDistance = Single.MaxValue;\n        private float _longestDistance = Single.MinValue;\n        private RaycastHit _smallestRaycast;\n        private RaycastHit _emptyRaycast = new RaycastHit();\n        private Vector3 _downRaycastsOffset;\n\n        // 平台移动计算\n        private Vector3 _moveWithPlatformMoveDistance;\n        private Vector3 _moveWithPlatformGlobalPoint;\n        private Quaternion _moveWithPlatformRotationDiff;\n        private Quaternion _moveWithPlatformGlobalRotation;\n        private RaycastHit _raycastDownHit;\n        private Vector3 _raycastDownDirection = Vector3.down;\n        private RaycastHit _canGoBackHeadCheck;\n        private Vector3 _originalSizeRaycastOrigin;\n\n        // 协程和可选组件\n        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        private float _currentDeltaTime;\n\n        // ============== 插值相关变量（已废弃，保留用于兼容性）==============\n        /// <summary>\n        /// 逻辑帧的时间间隔（保留字段，用于外部调用兼容性）\n        /// </summary>\n        private float _logicDeltaTime = 1f / 30f;\n        \n        /// <summary>\n        /// 上一次逻辑帧的时间戳\n        /// </summary>\n        private float _lastLogicUpdateTime = 0f;\n\n        /// <summary>\n        /// 上一次执行逻辑更新的帧号（用于防止同一帧重复移动）\n        /// </summary>\n        private int _lastLogicUpdateFrame = -1;\n\n        /// <summary>\n        /// 渲染帧专用的上一帧位置（用于计算速度显示）\n        /// </summary>\n        private Vector3 _renderPositionLastFrame = Vector3.zero;\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n        /// <summary>\n        /// 检查角色头部是否与物体碰撞\n        /// </summary>\n        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n\n        /// <summary>\n        /// 检查当前地面是否过于陡峭\n        /// </summary>\n        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n\n        /// <summary>\n        /// 初始化组件和缓存引用\n        /// </summary>\n        protected virtual void Awake()\n        {\n            _characterController = GetComponent<CharacterController>();\n            _transform = transform;\n            _rigidBody = GetComponent<Rigidbody>();\n            _originalColliderHeight = _characterController.height;\n            _originalColliderCenter = _characterController.center;\n            _currentDirection = _transform.forward;\n            _lastLogicUpdateTime = Time.time;\n            _renderPositionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 每帧更新（渲染帧）\n        /// 根据 UpdateModeType 决定是否在此执行物理计算\n        /// </summary>\n        protected virtual void Update()\n        {\n            float deltaTime = Time.deltaTime;\n            _currentDeltaTime = deltaTime;\n\n            // 只在 Auto 模式下自动执行物理计算\n            // Manual 模式下，物理计算由外部 LogicUpdate 调用控制\n            if (UpdateModeType == UpdateMode.Auto)\n            {\n                // 在 Auto 模式下才更新平台速度\n                GetMovingPlatformVelocity();\n\n                // 检查是否已经在 LogicUpdate 中处理过这一帧（防止双重移动）\n                bool alreadyProcessedThisFrame = (Time.frameCount == _lastLogicUpdateFrame);\n\n                if (!alreadyProcessedThisFrame && _freeMovement)\n                {\n                    ProcessLogicUpdate(deltaTime);\n                }\n\n                // 更新速度显示（仅用于调试）\n                if (deltaTime > SMALL_VALUE)\n                {\n                    _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n                    _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _renderPositionLastFrame = _transform.position;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 注意：如果外部调用了此方法，Update 将跳过这一帧的处理，避免双重移动\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            _logicDeltaTime = deltaTime;\n            _currentDeltaTime = deltaTime;\n            _lastLogicUpdateTime = Time.time;\n            _lastLogicUpdateFrame = Time.frameCount; // 标记这一帧已处理\n\n            ProcessLogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 固定时间更新（保留用于物理相关操作）\n        /// </summary>\n        protected virtual void FixedUpdate()\n        {\n            _currentDeltaTime = Time.fixedDeltaTime;\n        }\n\n        /// <summary>\n        /// 延迟更新，保存上一帧速度\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            _velocityLastFrame = _velocity;\n        }\n\n        /// <summary>\n        /// 核心逻辑更新处理流程（使用指定的 deltaTime）\n        /// 计算移动逻辑并执行 CharacterController.Move\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ProcessLogicUpdate(float deltaTime)\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            CheckIfGrounded();\n            HandleFriction();\n            DetermineDirection();\n            AddInput(deltaTime);\n            AddGravity(deltaTime);\n            MoveWithPlatform();\n            ComputeVelocityDelta(deltaTime);\n\n            // 执行实际移动\n            MoveCharacterControllerWithMotion(_motion);\n            DetectNewMovingPlatform();\n            ManualControllerColliderHit();\n            HandleGroundContact();\n\n            ComputeNewVelocity(deltaTime);\n        }\n\n        /// <summary>\n        /// 使用指定的移动向量执行 CharacterController 移动\n        /// </summary>\n        /// <param name=\"motion\">移动向量</param>\n        protected virtual void MoveCharacterControllerWithMotion(Vector3 motion)\n        {\n            _groundNormal = Vector3.zero;\n            _collisionFlags = _characterController.Move(motion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n\n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n                _idealVelocity = _idealVelocity * SlidingSpeed;\n                _targetVelocity = _idealVelocity;\n                _newVelocity = _idealVelocity;\n                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n            }\n            else\n            {\n                _targetVelocity = _currentMovement;\n\n                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n\n                Vector3 newHorizontalVelocity;\n\n                // 如果加速度为 0，直接使用目标速度（零延迟响应）\n                if (HorizontalAcceleration <= 0.001f && HorizontalDeceleration <= 0.001f)\n                {\n                    newHorizontalVelocity = targetHorizontalVelocity;\n                }\n                else if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                {\n                    float effectiveAcceleration = HorizontalAcceleration;\n\n                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n                    {\n                        effectiveAcceleration *= InitialBurstMultiplier;\n                    }\n\n                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n\n                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n                    {\n                        newHorizontalVelocity = targetHorizontalVelocity;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n                    }\n                }\n                else\n                {\n                    float currentSpeed = currentHorizontalVelocity.magnitude;\n                    float speedReduction = HorizontalDeceleration * deltaTime;\n\n                    if (currentSpeed <= speedReduction)\n                    {\n                        newHorizontalVelocity = Vector3.zero;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n                    }\n                }\n\n                _newVelocity.x = newHorizontalVelocity.x;\n                _newVelocity.z = newHorizontalVelocity.z;\n\n                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    Vector3 floorVelocity = _frameVelocity;\n                    floorVelocity.y = 0;\n                    _newVelocity.x += floorVelocity.x;\n                    _newVelocity.z += floorVelocity.z;\n                }\n\n                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n\n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity.normalized;\n                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n\n                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n                        {\n                            projectedDirection.Normalize();\n                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                        }\n                    }\n\n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 应用重力到速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddGravity(float deltaTime)\n        {\n            if (GravityActive)\n            {\n                if (_grounded)\n                {\n                    _newVelocity.y = -Gravity * deltaTime;\n                }\n                else\n                {\n                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n                }\n            }\n            _newVelocity += _addedForce;\n            _addedForce = Vector3.zero;\n        }\n\n        /// <summary>\n        /// 跟随移动平台移动\n        /// </summary>\n        protected virtual void MoveWithPlatform()\n        {\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _moveWithPlatformMoveDistance = Vector3.zero;\n                _moveWithPlatformGlobalPoint =\n                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n                if (_moveWithPlatformMoveDistance != Vector3.zero)\n                {\n                    _characterController.Move(_moveWithPlatformMoveDistance);\n                }\n                _moveWithPlatformGlobalRotation =\n                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n            }\n        }\n\n        /// <summary>\n        /// 计算速度增量和粘性偏移\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeVelocityDelta(float deltaTime)\n        {\n            _motion = _newVelocity * deltaTime;\n            _horizontalVelocityDelta.x = _motion.x;\n            _horizontalVelocityDelta.y = 0f;\n            _horizontalVelocityDelta.z = _motion.z;\n\n            // 临时禁用地面粘附，测试是否是它导致的抖动\n            /*\n            // 只有在有水平移动时才应用粘附偏移，避免静止时的抖动\n            float horizontalSpeed = _horizontalVelocityDelta.magnitude;\n            if (_grounded && horizontalSpeed > SMALL_VALUE)\n            {\n                // 使用较小的粘附值，避免过度向下推\n                _stickyOffset = Mathf.Min(_characterController.stepOffset, horizontalSpeed);\n                _motion.y -= _stickyOffset;\n            }\n            */\n        }\n\n        /// <summary>\n        /// 检测是否踩上新的移动平台\n        /// </summary>\n        protected virtual void DetectNewMovingPlatform()\n        {\n            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n            {\n                if (_movingPlatformHitCollider != null)\n                {\n                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n                    _newMovingPlatform = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 计算新速度和加速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeNewVelocity(float deltaTime)\n        {\n            _velocity = _newVelocity;\n            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n        }\n\n        /// <summary>\n        /// 处理地面接触状态和平台速度传递\n        /// </summary>\n        protected virtual void HandleGroundContact()\n        {\n            _grounded = _characterController.isGrounded;\n            if (_grounded && !IsGroundedTest())\n            {\n                _grounded = false;\n                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    _frameVelocity = _movingPlatformVelocity;\n                    _velocity += _movingPlatformVelocity;\n                }\n            }\n            else if (!_grounded && IsGroundedTest())\n            {\n                if (_detached && _velocity.y <= 0)\n                {\n                    _grounded = true;\n                    _detached = false;\n                }\n                SubtractNewPlatformVelocity();\n            }\n\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _movingPlatformCurrentGlobalPoint = _transform.position;\n                _movingPlatformCurrentHitColliderLocal =\n                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n                _movingPlatformGlobalRotation = _transform.rotation;\n                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n                                               _movingPlatformGlobalRotation;\n            }\n\n            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n            _tooSteepLastFrame = TooSteep();\n        }\n\n        /// <summary>\n        /// 计算当前速度（仅用于显示，不影响逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeSpeed(float deltaTime)\n        {\n            // 使用渲染帧专用的位置记录，避免干扰逻辑帧\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n            }\n            _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n\n            _renderPositionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 根据当前移动向量确定方向\n        /// </summary>\n        protected virtual void DetermineDirection()\n        {\n            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n            {\n                _currentDirection = _currentMovement.normalized;\n            }\n        }\n\n        /// <summary>\n        /// 处理摩擦力（预留方法，可在子类中实现）\n        /// </summary>\n        protected virtual void HandleFriction()\n        {\n        }\n\n        /// <summary>\n        /// 检查是否刚刚着地\n        /// </summary>\n        protected virtual void CheckIfGrounded()\n        {\n            _justGotGrounded = !_groundedLastFrame && _grounded;\n            _groundedLastFrame = _grounded;\n        }\n\n        /// <summary>\n        /// 手动触发碰撞器碰撞处理\n        /// </summary>\n        protected virtual void ManualControllerColliderHit()\n        {\n            HandleAdvancedGroundDetection();\n        }\n\n        /// <summary>\n        /// 高级地面检测（使用多方向射线）\n        /// </summary>\n        protected virtual void HandleAdvancedGroundDetection()\n        {\n            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n            {\n                return;\n            }\n\n            _smallestDistance = Single.MaxValue;\n            _longestDistance = Single.MinValue;\n            _smallestRaycast = _emptyRaycast;\n            float offset = _characterController.radius;\n            _downRaycastsOffset = Vector3.zero;\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, offset);\n            CastRayDownwards();\n\n            if (_smallestRaycast.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n                {\n                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n                    {\n                        _groundNormal = _smallestRaycast.normal;\n                    }\n                    else\n                    {\n                        _groundNormal = _lastGroundNormal;\n                    }\n\n                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n                    _hitPoint = _smallestRaycast.point;\n                    _frameVelocity = Vector3.zero;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 向下发射射线检测地面\n        /// </summary>\n        protected virtual void CastRayDownwards()\n        {\n            if (_smallestDistance <= MinimumGroundedDistance)\n            {\n                return;\n            }\n\n            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n                _raycastDownDirection, out _raycastDownHit,\n                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n\n            if (_raycastDownHit.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n                if (adjustedDistance < _smallestDistance)\n                {\n                    _smallestDistance = adjustedDistance;\n                    _smallestRaycast = _raycastDownHit;\n                }\n                if (adjustedDistance > _longestDistance)\n                {\n                    _longestDistance = adjustedDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n        /// </summary>\n        protected float AdjustDistance(float distance)\n        {\n            return distance - _characterController.height / 2f - _characterController.skinWidth;\n        }\n\n        /// <summary>\n        /// 测试是否真正着地\n        /// </summary>\n        protected virtual bool IsGroundedTest()\n        {\n            bool grounded = false;\n            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n            {\n                if (_smallestDistance <= MinimumGroundedDistance)\n                {\n                    grounded = _groundNormal.y > 0.01f;\n                }\n            }\n            else\n            {\n                grounded = _characterController.isGrounded;\n                _groundNormal = Vector3.up;\n            }\n            return grounded;\n        }\n\n        /// <summary>\n        /// 获取移动平台速度\n        /// </summary>\n        protected virtual void GetMovingPlatformVelocity()\n        {\n            if (_movingPlatformCurrentHitCollider != null)\n            {\n                if (!_newMovingPlatform && _currentDeltaTime > SMALL_VALUE)\n                {\n                    _movingPlatformVelocity = (\n                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n                            _movingPlatformCurrentHitColliderLocal)\n                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n                    ) / _currentDeltaTime;\n                }\n                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n                _newMovingPlatform = false;\n            }\n            else\n            {\n                _movingPlatformVelocity = Vector3.zero;\n            }\n        }\n\n        /// <summary>\n        /// 减去新平台速度（处理平台切换）\n        /// </summary>\n        protected virtual void SubtractNewPlatformVelocity()\n        {\n            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n            {\n                if (_newMovingPlatform)\n                {\n                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n                }\n                else\n                {\n                    _velocity -= _movingPlatformVelocity;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 协程：延迟减去平台速度\n        /// </summary>\n        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n        {\n            Transform platform = _movingPlatformCurrentHitCollider;\n            yield return _waitForFixedUpdate;\n            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n            {\n                yield return null;\n            }\n            _velocity -= _movingPlatformVelocity;\n        }\n\n        /// <summary>\n        /// 判断是否应该跟随平台移动\n        /// </summary>\n        protected virtual bool ShouldMoveWithPlatformThisFrame()\n        {\n            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n                   && _movingPlatformCurrentHitCollider != null;\n        }\n\n        /// <summary>\n        /// 应用冲击力并逐渐衰减\n        /// </summary>\n        protected virtual void ApplyImpact()\n        {\n            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n            {\n                _characterController.Move(_impact * _currentDeltaTime);\n            }\n            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * _currentDeltaTime);\n        }\n\n        /// <summary>\n        /// 从地面分离（用于跳跃等）\n        /// </summary>\n        public virtual void DetachFromGround()\n        {\n            _detached = true;\n        }\n\n        /// <summary>\n        /// 从移动平台分离\n        /// </summary>\n        public virtual void DetachFromMovingPlatform()\n        {\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n        }\n\n        /// <summary>\n        /// 设置重力是否激活\n        /// </summary>\n        public virtual void SetGravityActive(bool status)\n        {\n            GravityActive = status;\n        }\n\n        /// <summary>\n        /// 添加外部力（会在下一帧应用）\n        /// </summary>\n        public virtual void AddForce(Vector3 movement)\n        {\n            _addedForce += movement;\n        }\n\n        /// <summary>\n        /// 施加瞬时冲击力\n        /// </summary>\n        /// <param name=\"direction\">冲击方向</param>\n        /// <param name=\"force\">冲击力大小</param>\n        public virtual void Impact(Vector3 direction, float force)\n        {\n            direction = direction.normalized;\n            if (direction.y < 0)\n            {\n                direction.y = -direction.y;\n            }\n            _impact += direction.normalized * force;\n        }\n\n        /// <summary>\n        /// 设置移动向量（通常由输入系统调用）\n        /// </summary>\n        /// <param name=\"movement\">移动向量</param>\n        public virtual void SetMovement(Vector3 movement)\n        {\n            _currentMovement = movement;\n            Vector3 directionVector = movement;\n            if (directionVector != Vector3.zero)\n            {\n                float directionLength = directionVector.magnitude;\n                directionVector = directionVector / directionLength;\n                directionLength = Mathf.Min(1, directionLength);\n                directionLength = directionLength * directionLength;\n                directionVector = directionVector * directionLength;\n            }\n            _inputMoveDirection = transform.rotation * directionVector;\n        }\n\n        /// <summary>\n        /// 移动到指定位置（带碰撞检测）\n        /// </summary>\n        /// <param name=\"newPosition\">目标位置</param>\n        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n        {\n            _movePositionDirection = newPosition - transform.position;\n            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n\n            _capsulePoint1 = transform.position\n                             + _characterController.center\n                             - (Vector3.up * _characterController.height / 2f)\n                             + Vector3.up * _characterController.skinWidth\n                             + Vector3.up * _characterController.radius;\n\n            _capsulePoint2 = transform.position\n                             + _characterController.center\n                             + (Vector3.up * _characterController.height / 2f)\n                             - Vector3.up * _characterController.skinWidth\n                             - Vector3.up * _characterController.radius;\n\n            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n            {\n                transform.position = newPosition;\n            }\n        }\n\n        /// <summary>\n        /// 调整碰撞器高度（用于蹲伏等）\n        /// </summary>\n        /// <param name=\"newHeight\">新高度</param>\n        /// <param name=\"translateCenter\">是否平移中心点</param>\n        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n        {\n            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n            _characterController.height = newHeight;\n            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n            if (translateCenter)\n            {\n                transform.Translate((newYOffset / 2f) * Vector3.up);\n            }\n        }\n\n        /// <summary>\n        /// 重置碰撞器尺寸到原始大小\n        /// </summary>\n        public virtual void ResetColliderSize()\n        {\n            _characterController.height = _originalColliderHeight;\n            _characterController.center = _originalColliderCenter;\n        }\n\n        /// <summary>\n        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n        /// </summary>\n        public virtual bool CanGoBackToOriginalSize()\n        {\n            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n            {\n                return true;\n            }\n\n            float headCheckDistance =\n                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n                ObstaclesLayerMask, Color.cyan, true);\n\n            return _canGoBackHeadCheck.collider == null;\n        }\n\n        /// <summary>\n        /// 启用碰撞\n        /// </summary>\n        public virtual void CollisionsOn()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = true;\n            }\n        }\n\n        /// <summary>\n        /// 禁用碰撞\n        /// </summary>\n        public virtual void CollisionsOff()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = false;\n            }\n        }\n\n        /// <summary>\n        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n        /// </summary>\n        public virtual void SetKinematic(bool state)\n        {\n            _rigidBody.isKinematic = state;\n        }\n\n        /// <summary>\n        /// 设置是否允许自由移动\n        /// </summary>\n        public virtual void SetFreeMovement(bool state)\n        {\n            _freeMovement = state;\n        }\n\n        /// <summary>\n        /// 检测四个基本方向的障碍物\n        /// </summary>\n        /// <param name=\"distance\">检测距离</param>\n        /// <param name=\"offset\">起始偏移</param>\n        public virtual void DetectObstacles(float distance, Vector3 offset)\n        {\n            if (!PerformCardinalObstacleRaycastDetection)\n            {\n                return;\n            }\n\n            CollidingWithCardinalObstacle = false;\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleRight = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleLeft = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleUp = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleDown = null;\n            }\n        }\n\n        /// <summary>\n        /// 重置控制器到初始状态\n        /// </summary>\n        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n            _renderPositionLastFrame = _transform != null ? _transform.position : Vector3.zero;\n            _lastLogicUpdateTime = Time.time;\n            _lastLogicUpdateFrame = -1;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n            return hit;\n        }\n    }\n}","newString":"using System;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing ActionMachine.Runtime.Attributes;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 运动学角色控制器（Kinematic Character Controller）\n    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    /// \n    /// 修复：添加逻辑帧与渲染帧之间的插值，解决 30fps 逻辑更新导致的卡顿\n    /// </summary>\n    [RequireComponent(typeof(CharacterController))]\n    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    public partial class Kcc : MonoBehaviour\n    {\n        private const float SMALL_VALUE = 0.0001f;\n        private const float SPEED_ROUNDING_PRECISION = 100f;\n        private const float IMPACT_THRESHOLD = 0.2f;\n\n        public enum GroundedComputationMode\n        {\n            Simple,\n            Advanced\n        }\n\n        public enum VelocityTransferMode\n        {\n            NoTransfer,\n            InitialVelocity,\n            FloorVelocity,\n            Relative\n        }\n\n        [Header(\"Update Mode Settings\")]\n        [Tooltip(\"更新模式：Auto = Update 中自动执行（用于无外部 LogicUpdate 调用）, Manual = 仅通过外部 LogicUpdate 调用执行\")]\n        public UpdateMode UpdateModeType = UpdateMode.Manual;\n\n        public enum UpdateMode\n        {\n            Auto,    // Update 中自动执行物理计算\n            Manual   // 仅通过外部 LogicUpdate 调用执行\n        }\n\n        [Header(\"Gravity Settings\")]\n        [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n        public float Gravity = 40f;\n        [Tooltip(\"是否激活重力\")]\n        public bool GravityActive = true;\n\n        [Header(\"Raycast Settings\")]\n        [Tooltip(\"障碍物层遮罩\")]\n        public LayerMask ObstaclesLayerMask;\n        [Tooltip(\"向下射线检测长度\")]\n        public float GroundedRaycastLength = 5f;\n        [Tooltip(\"最小着地距离\")]\n        public float MinimumGroundedDistance = 0.2f;\n        [Tooltip(\"地面检测计算模式\")]\n        public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n        [Tooltip(\"地面法线高度阈值\")]\n        public float GroundNormalHeightThreshold = 0.2f;\n        [Tooltip(\"蹲伏时射线长度倍数\")]\n        public float CrouchedRaycastLengthMultiplier = 1f;\n        [Tooltip(\"是否执行基本方向障碍物射线检测\")]\n        public bool PerformCardinalObstacleRaycastDetection = false;\n\n        [Header(\"Movement Settings\")]\n        [Tooltip(\"最大下落速度\")]\n        public float MaximumFallSpeed = 20.0f;\n        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速。设为 0 表示立即到达目标速度，消除加速延迟\")]\n        public float HorizontalAcceleration = 0f; // 改为 0，立即到达目标速度\n        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速。设为 0 表示立即停止，消除减速延迟\")]\n        public float HorizontalDeceleration = 0f; // 改为 0，立即停止\n        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n        public float InitialBurstMultiplier = 2.0f;\n        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n        public float BurstSpeedThreshold = 1.0f;\n        [Tooltip(\"斜坡速度倍数曲线\")]\n        public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n            new Keyframe(-90, 1),\n            new Keyframe(0, 1),\n            new Keyframe(90, 0)\n        );\n        [Tooltip(\"冲击力衰减速度\")]\n        public float ImpactFalloff = 5f;\n\n        [Header(\"Steep Surface Settings\")]\n        [Tooltip(\"是否在陡峭表面滑动\")]\n        public bool SlideOnSteepSurfaces = true;\n        [Tooltip(\"滑动速度\")]\n        public float SlidingSpeed = 15f;\n        [Tooltip(\"滑动速度控制\")]\n        public float SlidingSpeedControl = 0.4f;\n        [Tooltip(\"滑动方向控制\")]\n        public float SlidingDirectionControl = 1f;\n\n        [Header(\"Moving Platform Settings\")]\n        [Tooltip(\"跳跃时的速度传递方式\")]\n        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Runtime State - Read Only\")]\n        [SerializeField, ReadOnly] private Vector3 _speed;\n        [SerializeField, ReadOnly] private Vector3 _velocity;\n        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n        [SerializeField, ReadOnly] private Vector3 _acceleration;\n        [SerializeField, ReadOnly] private bool _grounded;\n        [SerializeField, ReadOnly] private bool _justGotGrounded;\n        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n        [SerializeField, ReadOnly] private float _friction;\n        [SerializeField, ReadOnly] private Vector3 _addedForce;\n        [SerializeField, ReadOnly] private bool _freeMovement = true;\n        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n\n        // 公共只读属性\n        public Vector3 Speed => _speed;\n        public Vector3 Velocity => _velocity;\n        public Vector3 VelocityLastFrame => _velocityLastFrame;\n        public Vector3 Acceleration => _acceleration;\n        public bool Grounded => _grounded;\n        public bool JustGotGrounded => _justGotGrounded;\n        public Vector3 CurrentMovement => _currentMovement;\n        public Vector3 CurrentDirection => _currentDirection;\n        public float Friction => _friction;\n        public Vector3 AddedForce => _addedForce;\n        public bool FreeMovement => _freeMovement;\n        public Vector3 GroundNormal => _groundNormal;\n        public Vector3 InputMoveDirection => _inputMoveDirection;\n        public Vector3 TargetVelocity => _targetVelocity;\n\n        // 碰撞器相关属性\n        public Vector3 ColliderCenter => transform.position + _characterController.center;\n        public Vector3 ColliderBottom => transform.position + _characterController.center +\n                                         Vector3.down * _characterController.bounds.extents.y;\n        public Vector3 ColliderTop => transform.position + _characterController.center +\n                                      Vector3.up * _characterController.bounds.extents.y;\n        public Vector3 AppliedImpact => _impact;\n\n        // 环境检测属性\n        public GameObject ObjectBelow { get; set; }\n        public GameObject DetectedObstacleLeft { get; set; }\n        public GameObject DetectedObstacleRight { get; set; }\n        public GameObject DetectedObstacleUp { get; set; }\n        public GameObject DetectedObstacleDown { get; set; }\n        public bool CollidingWithCardinalObstacle { get; set; }\n        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n\n        // 移动平台相关属性\n        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n\n        // 组件引用\n        private Transform _transform;\n        private CharacterController _characterController;\n\n        // 碰撞器原始尺寸\n        private float _originalColliderHeight;\n        private Vector3 _originalColliderCenter;\n\n        // 运动状态追踪\n        private Vector3 _positionLastFrame;\n        private bool _groundedLastFrame;\n        private Vector3 _impact;\n        private Vector3 _lastGroundNormal = Vector3.zero;\n        private bool _detached = false;\n        private bool _tooSteepLastFrame;\n\n        // 移动平台追踪\n        private Transform _movingPlatformHitCollider;\n        private Transform _movingPlatformCurrentHitCollider;\n        private Vector3 _movingPlatformCurrentHitColliderLocal;\n        private Vector3 _movingPlatformCurrentGlobalPoint;\n        private Quaternion _movingPlatformLocalRotation;\n        private Quaternion _movingPlatformGlobalRotation;\n        private Quaternion _lastMoveWithPlatformGlobalRotation;\n        private Matrix4x4 _lastMovingPlatformMatrix;\n        private Vector3 _movingPlatformVelocity;\n        private bool _newMovingPlatform;\n\n        // 碰撞检测\n        private CollisionFlags _collisionFlags;\n        private Vector3 _frameVelocity = Vector3.zero;\n        private Vector3 _hitPoint = Vector3.zero;\n        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n        // 速度计算\n        private Vector3 _newVelocity;\n        private Vector3 _motion;\n        private Vector3 _idealVelocity;\n        private Vector3 _idealDirection;\n        private Vector3 _horizontalVelocityDelta;\n        private float _stickyOffset = 0f;\n\n        // 位置移动\n        private RaycastHit _movePositionHit;\n        private Vector3 _capsulePoint1;\n        private Vector3 _capsulePoint2;\n        private Vector3 _movePositionDirection;\n        private float _movePositionDistance;\n\n        // 障碍物检测\n        private RaycastHit _cardinalRaycast;\n        private float _smallestDistance = Single.MaxValue;\n        private float _longestDistance = Single.MinValue;\n        private RaycastHit _smallestRaycast;\n        private RaycastHit _emptyRaycast = new RaycastHit();\n        private Vector3 _downRaycastsOffset;\n\n        // 平台移动计算\n        private Vector3 _moveWithPlatformMoveDistance;\n        private Vector3 _moveWithPlatformGlobalPoint;\n        private Quaternion _moveWithPlatformRotationDiff;\n        private Quaternion _moveWithPlatformGlobalRotation;\n        private RaycastHit _raycastDownHit;\n        private Vector3 _raycastDownDirection = Vector3.down;\n        private RaycastHit _canGoBackHeadCheck;\n        private Vector3 _originalSizeRaycastOrigin;\n\n        // 协程和可选组件\n        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        private float _currentDeltaTime;\n\n        // ============== 插值相关变量（已废弃，保留用于兼容性）==============\n        /// <summary>\n        /// 逻辑帧的时间间隔（保留字段，用于外部调用兼容性）\n        /// </summary>\n        private float _logicDeltaTime = 1f / 30f;\n        \n        /// <summary>\n        /// 上一次逻辑帧的时间戳\n        /// </summary>\n        private float _lastLogicUpdateTime = 0f;\n\n        /// <summary>\n        /// 上一次执行逻辑更新的帧号（用于防止同一帧重复移动）\n        /// </summary>\n        private int _lastLogicUpdateFrame = -1;\n\n        /// <summary>\n        /// 渲染帧专用的上一帧位置（用于计算速度显示）\n        /// </summary>\n        private Vector3 _renderPositionLastFrame = Vector3.zero;\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n        /// <summary>\n        /// 检查角色头部是否与物体碰撞\n        /// </summary>\n        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n\n        /// <summary>\n        /// 检查当前地面是否过于陡峭\n        /// </summary>\n        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n\n        /// <summary>\n        /// 初始化组件和缓存引用\n        /// </summary>\n        protected virtual void Awake()\n        {\n            _characterController = GetComponent<CharacterController>();\n            _transform = transform;\n            _rigidBody = GetComponent<Rigidbody>();\n            _originalColliderHeight = _characterController.height;\n            _originalColliderCenter = _characterController.center;\n            _currentDirection = _transform.forward;\n            _lastLogicUpdateTime = Time.time;\n            _renderPositionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 每帧更新（渲染帧）\n        /// 根据 UpdateModeType 决定是否在此执行物理计算\n        /// </summary>\n        protected virtual void Update()\n        {\n            float deltaTime = Time.deltaTime;\n            _currentDeltaTime = deltaTime;\n\n            // 只在 Auto 模式下自动执行物理计算\n            // Manual 模式下，物理计算由外部 LogicUpdate 调用控制\n            if (UpdateModeType == UpdateMode.Auto)\n            {\n                // 在 Auto 模式下才更新平台速度\n                GetMovingPlatformVelocity();\n\n                // 检查是否已经在 LogicUpdate 中处理过这一帧（防止双重移动）\n                bool alreadyProcessedThisFrame = (Time.frameCount == _lastLogicUpdateFrame);\n\n                if (!alreadyProcessedThisFrame && _freeMovement)\n                {\n                    ProcessLogicUpdate(deltaTime);\n                }\n\n                // 更新速度显示（仅用于调试）\n                if (deltaTime > SMALL_VALUE)\n                {\n                    _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n                    _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _renderPositionLastFrame = _transform.position;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 注意：如果外部调用了此方法，Update 将跳过这一帧的处理，避免双重移动\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            _logicDeltaTime = deltaTime;\n            _currentDeltaTime = deltaTime;\n            _lastLogicUpdateTime = Time.time;\n            _lastLogicUpdateFrame = Time.frameCount; // 标记这一帧已处理\n\n            ProcessLogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 固定时间更新（保留用于物理相关操作）\n        /// </summary>\n        protected virtual void FixedUpdate()\n        {\n            _currentDeltaTime = Time.fixedDeltaTime;\n        }\n\n        /// <summary>\n        /// 延迟更新，保存上一帧速度\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            _velocityLastFrame = _velocity;\n        }\n\n        /// <summary>\n        /// 核心逻辑更新处理流程（使用指定的 deltaTime）\n        /// 计算移动逻辑并执行 CharacterController.Move\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ProcessLogicUpdate(float deltaTime)\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            CheckIfGrounded();\n            HandleFriction();\n            DetermineDirection();\n            AddInput(deltaTime);\n            AddGravity(deltaTime);\n            MoveWithPlatform();\n            ComputeVelocityDelta(deltaTime);\n\n            // 执行实际移动\n            MoveCharacterControllerWithMotion(_motion);\n            DetectNewMovingPlatform();\n            ManualControllerColliderHit();\n            HandleGroundContact();\n\n            ComputeNewVelocity(deltaTime);\n        }\n\n        /// <summary>\n        /// 使用指定的移动向量执行 CharacterController 移动\n        /// </summary>\n        /// <param name=\"motion\">移动向量</param>\n        protected virtual void MoveCharacterControllerWithMotion(Vector3 motion)\n        {\n            _groundNormal = Vector3.zero;\n            _collisionFlags = _characterController.Move(motion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n\n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n                _idealVelocity = _idealVelocity * SlidingSpeed;\n                _targetVelocity = _idealVelocity;\n                _newVelocity = _idealVelocity;\n                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n            }\n            else\n            {\n                _targetVelocity = _currentMovement;\n\n                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n\n                Vector3 newHorizontalVelocity;\n\n                // 如果加速度为 0，直接使用目标速度（零延迟响应）\n                if (HorizontalAcceleration <= 0.001f && HorizontalDeceleration <= 0.001f)\n                {\n                    newHorizontalVelocity = targetHorizontalVelocity;\n                }\n                else if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                {\n                    float effectiveAcceleration = HorizontalAcceleration;\n\n                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n                    {\n                        effectiveAcceleration *= InitialBurstMultiplier;\n                    }\n\n                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n\n                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n                    {\n                        newHorizontalVelocity = targetHorizontalVelocity;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n                    }\n                }\n                else\n                {\n                    float currentSpeed = currentHorizontalVelocity.magnitude;\n                    float speedReduction = HorizontalDeceleration * deltaTime;\n\n                    if (currentSpeed <= speedReduction)\n                    {\n                        newHorizontalVelocity = Vector3.zero;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n                    }\n                }\n\n                _newVelocity.x = newHorizontalVelocity.x;\n                _newVelocity.z = newHorizontalVelocity.z;\n\n                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    Vector3 floorVelocity = _frameVelocity;\n                    floorVelocity.y = 0;\n                    _newVelocity.x += floorVelocity.x;\n                    _newVelocity.z += floorVelocity.z;\n                }\n\n                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n\n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity / velocityMagnitude;\n\n                        // 只有当地面法线不是水平面时才投影，避免平地上的抖动\n                        if (_groundNormal.y < 0.999f)  // 如果地面法线几乎是正上方，跳过投影\n                        {\n                            Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n\n                            // 检查投影后的方向是否有效\n                            if (projectedDirection.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                            {\n                                projectedDirection.Normalize();\n                                _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                                _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                            }\n                        }\n                    }\n\n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 应用重力到速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddGravity(float deltaTime)\n        {\n            if (GravityActive)\n            {\n                if (_grounded)\n                {\n                    _newVelocity.y = -Gravity * deltaTime;\n                }\n                else\n                {\n                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n                }\n            }\n            _newVelocity += _addedForce;\n            _addedForce = Vector3.zero;\n        }\n\n        /// <summary>\n        /// 跟随移动平台移动\n        /// </summary>\n        protected virtual void MoveWithPlatform()\n        {\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _moveWithPlatformMoveDistance = Vector3.zero;\n                _moveWithPlatformGlobalPoint =\n                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n                if (_moveWithPlatformMoveDistance != Vector3.zero)\n                {\n                    _characterController.Move(_moveWithPlatformMoveDistance);\n                }\n                _moveWithPlatformGlobalRotation =\n                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n            }\n        }\n\n        /// <summary>\n        /// 计算速度增量和粘性偏移\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeVelocityDelta(float deltaTime)\n        {\n            _motion = _newVelocity * deltaTime;\n            _horizontalVelocityDelta.x = _motion.x;\n            _horizontalVelocityDelta.y = 0f;\n            _horizontalVelocityDelta.z = _motion.z;\n\n            // 临时禁用地面粘附，测试是否是它导致的抖动\n            /*\n            // 只有在有水平移动时才应用粘附偏移，避免静止时的抖动\n            float horizontalSpeed = _horizontalVelocityDelta.magnitude;\n            if (_grounded && horizontalSpeed > SMALL_VALUE)\n            {\n                // 使用较小的粘附值，避免过度向下推\n                _stickyOffset = Mathf.Min(_characterController.stepOffset, horizontalSpeed);\n                _motion.y -= _stickyOffset;\n            }\n            */\n        }\n\n        /// <summary>\n        /// 检测是否踩上新的移动平台\n        /// </summary>\n        protected virtual void DetectNewMovingPlatform()\n        {\n            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n            {\n                if (_movingPlatformHitCollider != null)\n                {\n                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n                    _newMovingPlatform = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 计算新速度和加速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeNewVelocity(float deltaTime)\n        {\n            _velocity = _newVelocity;\n            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n        }\n\n        /// <summary>\n        /// 处理地面接触状态和平台速度传递\n        /// </summary>\n        protected virtual void HandleGroundContact()\n        {\n            _grounded = _characterController.isGrounded;\n            if (_grounded && !IsGroundedTest())\n            {\n                _grounded = false;\n                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    _frameVelocity = _movingPlatformVelocity;\n                    _velocity += _movingPlatformVelocity;\n                }\n            }\n            else if (!_grounded && IsGroundedTest())\n            {\n                if (_detached && _velocity.y <= 0)\n                {\n                    _grounded = true;\n                    _detached = false;\n                }\n                SubtractNewPlatformVelocity();\n            }\n\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _movingPlatformCurrentGlobalPoint = _transform.position;\n                _movingPlatformCurrentHitColliderLocal =\n                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n                _movingPlatformGlobalRotation = _transform.rotation;\n                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n                                               _movingPlatformGlobalRotation;\n            }\n\n            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n            _tooSteepLastFrame = TooSteep();\n        }\n\n        /// <summary>\n        /// 计算当前速度（仅用于显示，不影响逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeSpeed(float deltaTime)\n        {\n            // 使用渲染帧专用的位置记录，避免干扰逻辑帧\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n            }\n            _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n\n            _renderPositionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 根据当前移动向量确定方向\n        /// </summary>\n        protected virtual void DetermineDirection()\n        {\n            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n            {\n                _currentDirection = _currentMovement.normalized;\n            }\n        }\n\n        /// <summary>\n        /// 处理摩擦力（预留方法，可在子类中实现）\n        /// </summary>\n        protected virtual void HandleFriction()\n        {\n        }\n\n        /// <summary>\n        /// 检查是否刚刚着地\n        /// </summary>\n        protected virtual void CheckIfGrounded()\n        {\n            _justGotGrounded = !_groundedLastFrame && _grounded;\n            _groundedLastFrame = _grounded;\n        }\n\n        /// <summary>\n        /// 手动触发碰撞器碰撞处理\n        /// </summary>\n        protected virtual void ManualControllerColliderHit()\n        {\n            HandleAdvancedGroundDetection();\n        }\n\n        /// <summary>\n        /// 高级地面检测（使用多方向射线）\n        /// </summary>\n        protected virtual void HandleAdvancedGroundDetection()\n        {\n            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n            {\n                return;\n            }\n\n            _smallestDistance = Single.MaxValue;\n            _longestDistance = Single.MinValue;\n            _smallestRaycast = _emptyRaycast;\n            float offset = _characterController.radius;\n            _downRaycastsOffset = Vector3.zero;\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, offset);\n            CastRayDownwards();\n\n            if (_smallestRaycast.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n                {\n                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n                    {\n                        _groundNormal = _smallestRaycast.normal;\n                    }\n                    else\n                    {\n                        _groundNormal = _lastGroundNormal;\n                    }\n\n                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n                    _hitPoint = _smallestRaycast.point;\n                    _frameVelocity = Vector3.zero;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 向下发射射线检测地面\n        /// </summary>\n        protected virtual void CastRayDownwards()\n        {\n            if (_smallestDistance <= MinimumGroundedDistance)\n            {\n                return;\n            }\n\n            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n                _raycastDownDirection, out _raycastDownHit,\n                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n\n            if (_raycastDownHit.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n                if (adjustedDistance < _smallestDistance)\n                {\n                    _smallestDistance = adjustedDistance;\n                    _smallestRaycast = _raycastDownHit;\n                }\n                if (adjustedDistance > _longestDistance)\n                {\n                    _longestDistance = adjustedDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n        /// </summary>\n        protected float AdjustDistance(float distance)\n        {\n            return distance - _characterController.height / 2f - _characterController.skinWidth;\n        }\n\n        /// <summary>\n        /// 测试是否真正着地\n        /// </summary>\n        protected virtual bool IsGroundedTest()\n        {\n            bool grounded = false;\n            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n            {\n                if (_smallestDistance <= MinimumGroundedDistance)\n                {\n                    grounded = _groundNormal.y > 0.01f;\n                }\n            }\n            else\n            {\n                grounded = _characterController.isGrounded;\n                _groundNormal = Vector3.up;\n            }\n            return grounded;\n        }\n\n        /// <summary>\n        /// 获取移动平台速度\n        /// </summary>\n        protected virtual void GetMovingPlatformVelocity()\n        {\n            if (_movingPlatformCurrentHitCollider != null)\n            {\n                if (!_newMovingPlatform && _currentDeltaTime > SMALL_VALUE)\n                {\n                    _movingPlatformVelocity = (\n                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n                            _movingPlatformCurrentHitColliderLocal)\n                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n                    ) / _currentDeltaTime;\n                }\n                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n                _newMovingPlatform = false;\n            }\n            else\n            {\n                _movingPlatformVelocity = Vector3.zero;\n            }\n        }\n\n        /// <summary>\n        /// 减去新平台速度（处理平台切换）\n        /// </summary>\n        protected virtual void SubtractNewPlatformVelocity()\n        {\n            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n            {\n                if (_newMovingPlatform)\n                {\n                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n                }\n                else\n                {\n                    _velocity -= _movingPlatformVelocity;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 协程：延迟减去平台速度\n        /// </summary>\n        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n        {\n            Transform platform = _movingPlatformCurrentHitCollider;\n            yield return _waitForFixedUpdate;\n            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n            {\n                yield return null;\n            }\n            _velocity -= _movingPlatformVelocity;\n        }\n\n        /// <summary>\n        /// 判断是否应该跟随平台移动\n        /// </summary>\n        protected virtual bool ShouldMoveWithPlatformThisFrame()\n        {\n            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n                   && _movingPlatformCurrentHitCollider != null;\n        }\n\n        /// <summary>\n        /// 应用冲击力并逐渐衰减\n        /// </summary>\n        protected virtual void ApplyImpact()\n        {\n            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n            {\n                _characterController.Move(_impact * _currentDeltaTime);\n            }\n            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * _currentDeltaTime);\n        }\n\n        /// <summary>\n        /// 从地面分离（用于跳跃等）\n        /// </summary>\n        public virtual void DetachFromGround()\n        {\n            _detached = true;\n        }\n\n        /// <summary>\n        /// 从移动平台分离\n        /// </summary>\n        public virtual void DetachFromMovingPlatform()\n        {\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n        }\n\n        /// <summary>\n        /// 设置重力是否激活\n        /// </summary>\n        public virtual void SetGravityActive(bool status)\n        {\n            GravityActive = status;\n        }\n\n        /// <summary>\n        /// 添加外部力（会在下一帧应用）\n        /// </summary>\n        public virtual void AddForce(Vector3 movement)\n        {\n            _addedForce += movement;\n        }\n\n        /// <summary>\n        /// 施加瞬时冲击力\n        /// </summary>\n        /// <param name=\"direction\">冲击方向</param>\n        /// <param name=\"force\">冲击力大小</param>\n        public virtual void Impact(Vector3 direction, float force)\n        {\n            direction = direction.normalized;\n            if (direction.y < 0)\n            {\n                direction.y = -direction.y;\n            }\n            _impact += direction.normalized * force;\n        }\n\n        /// <summary>\n        /// 设置移动向量（通常由输入系统调用）\n        /// </summary>\n        /// <param name=\"movement\">移动向量</param>\n        public virtual void SetMovement(Vector3 movement)\n        {\n            _currentMovement = movement;\n            Vector3 directionVector = movement;\n            if (directionVector != Vector3.zero)\n            {\n                float directionLength = directionVector.magnitude;\n                directionVector = directionVector / directionLength;\n                directionLength = Mathf.Min(1, directionLength);\n                directionLength = directionLength * directionLength;\n                directionVector = directionVector * directionLength;\n            }\n            _inputMoveDirection = transform.rotation * directionVector;\n        }\n\n        /// <summary>\n        /// 移动到指定位置（带碰撞检测）\n        /// </summary>\n        /// <param name=\"newPosition\">目标位置</param>\n        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n        {\n            _movePositionDirection = newPosition - transform.position;\n            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n\n            _capsulePoint1 = transform.position\n                             + _characterController.center\n                             - (Vector3.up * _characterController.height / 2f)\n                             + Vector3.up * _characterController.skinWidth\n                             + Vector3.up * _characterController.radius;\n\n            _capsulePoint2 = transform.position\n                             + _characterController.center\n                             + (Vector3.up * _characterController.height / 2f)\n                             - Vector3.up * _characterController.skinWidth\n                             - Vector3.up * _characterController.radius;\n\n            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n            {\n                transform.position = newPosition;\n            }\n        }\n\n        /// <summary>\n        /// 调整碰撞器高度（用于蹲伏等）\n        /// </summary>\n        /// <param name=\"newHeight\">新高度</param>\n        /// <param name=\"translateCenter\">是否平移中心点</param>\n        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n        {\n            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n            _characterController.height = newHeight;\n            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n            if (translateCenter)\n            {\n                transform.Translate((newYOffset / 2f) * Vector3.up);\n            }\n        }\n\n        /// <summary>\n        /// 重置碰撞器尺寸到原始大小\n        /// </summary>\n        public virtual void ResetColliderSize()\n        {\n            _characterController.height = _originalColliderHeight;\n            _characterController.center = _originalColliderCenter;\n        }\n\n        /// <summary>\n        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n        /// </summary>\n        public virtual bool CanGoBackToOriginalSize()\n        {\n            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n            {\n                return true;\n            }\n\n            float headCheckDistance =\n                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n                ObstaclesLayerMask, Color.cyan, true);\n\n            return _canGoBackHeadCheck.collider == null;\n        }\n\n        /// <summary>\n        /// 启用碰撞\n        /// </summary>\n        public virtual void CollisionsOn()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = true;\n            }\n        }\n\n        /// <summary>\n        /// 禁用碰撞\n        /// </summary>\n        public virtual void CollisionsOff()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = false;\n            }\n        }\n\n        /// <summary>\n        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n        /// </summary>\n        public virtual void SetKinematic(bool state)\n        {\n            _rigidBody.isKinematic = state;\n        }\n\n        /// <summary>\n        /// 设置是否允许自由移动\n        /// </summary>\n        public virtual void SetFreeMovement(bool state)\n        {\n            _freeMovement = state;\n        }\n\n        /// <summary>\n        /// 检测四个基本方向的障碍物\n        /// </summary>\n        /// <param name=\"distance\">检测距离</param>\n        /// <param name=\"offset\">起始偏移</param>\n        public virtual void DetectObstacles(float distance, Vector3 offset)\n        {\n            if (!PerformCardinalObstacleRaycastDetection)\n            {\n                return;\n            }\n\n            CollidingWithCardinalObstacle = false;\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleRight = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleLeft = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleUp = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleDown = null;\n            }\n        }\n\n        /// <summary>\n        /// 重置控制器到初始状态\n        /// </summary>\n        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n            _renderPositionLastFrame = _transform != null ? _transform.position : Vector3.zero;\n            _lastLogicUpdateTime = Time.time;\n            _lastLogicUpdateFrame = -1;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n            return hit;\n        }\n    }\n}","originalFile":"using System;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing ActionMachine.Runtime.Attributes;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 运动学角色控制器（Kinematic Character Controller）\n    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    /// \n    /// 修复：添加逻辑帧与渲染帧之间的插值，解决 30fps 逻辑更新导致的卡顿\n    /// </summary>\n    [RequireComponent(typeof(CharacterController))]\n    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    public partial class Kcc : MonoBehaviour\n    {\n        private const float SMALL_VALUE = 0.0001f;\n        private const float SPEED_ROUNDING_PRECISION = 100f;\n        private const float IMPACT_THRESHOLD = 0.2f;\n\n        public enum GroundedComputationMode\n        {\n            Simple,\n            Advanced\n        }\n\n        public enum VelocityTransferMode\n        {\n            NoTransfer,\n            InitialVelocity,\n            FloorVelocity,\n            Relative\n        }\n\n        [Header(\"Update Mode Settings\")]\n        [Tooltip(\"更新模式：Auto = Update 中自动执行（用于无外部 LogicUpdate 调用）, Manual = 仅通过外部 LogicUpdate 调用执行\")]\n        public UpdateMode UpdateModeType = UpdateMode.Manual;\n\n        public enum UpdateMode\n        {\n            Auto,    // Update 中自动执行物理计算\n            Manual   // 仅通过外部 LogicUpdate 调用执行\n        }\n\n        [Header(\"Gravity Settings\")]\n        [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n        public float Gravity = 40f;\n        [Tooltip(\"是否激活重力\")]\n        public bool GravityActive = true;\n\n        [Header(\"Raycast Settings\")]\n        [Tooltip(\"障碍物层遮罩\")]\n        public LayerMask ObstaclesLayerMask;\n        [Tooltip(\"向下射线检测长度\")]\n        public float GroundedRaycastLength = 5f;\n        [Tooltip(\"最小着地距离\")]\n        public float MinimumGroundedDistance = 0.2f;\n        [Tooltip(\"地面检测计算模式\")]\n        public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n        [Tooltip(\"地面法线高度阈值\")]\n        public float GroundNormalHeightThreshold = 0.2f;\n        [Tooltip(\"蹲伏时射线长度倍数\")]\n        public float CrouchedRaycastLengthMultiplier = 1f;\n        [Tooltip(\"是否执行基本方向障碍物射线检测\")]\n        public bool PerformCardinalObstacleRaycastDetection = false;\n\n        [Header(\"Movement Settings\")]\n        [Tooltip(\"最大下落速度\")]\n        public float MaximumFallSpeed = 20.0f;\n        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速。设为 0 表示立即到达目标速度，消除加速延迟\")]\n        public float HorizontalAcceleration = 0f; // 改为 0，立即到达目标速度\n        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速。设为 0 表示立即停止，消除减速延迟\")]\n        public float HorizontalDeceleration = 0f; // 改为 0，立即停止\n        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n        public float InitialBurstMultiplier = 2.0f;\n        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n        public float BurstSpeedThreshold = 1.0f;\n        [Tooltip(\"斜坡速度倍数曲线\")]\n        public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n            new Keyframe(-90, 1),\n            new Keyframe(0, 1),\n            new Keyframe(90, 0)\n        );\n        [Tooltip(\"冲击力衰减速度\")]\n        public float ImpactFalloff = 5f;\n\n        [Header(\"Steep Surface Settings\")]\n        [Tooltip(\"是否在陡峭表面滑动\")]\n        public bool SlideOnSteepSurfaces = true;\n        [Tooltip(\"滑动速度\")]\n        public float SlidingSpeed = 15f;\n        [Tooltip(\"滑动速度控制\")]\n        public float SlidingSpeedControl = 0.4f;\n        [Tooltip(\"滑动方向控制\")]\n        public float SlidingDirectionControl = 1f;\n\n        [Header(\"Moving Platform Settings\")]\n        [Tooltip(\"跳跃时的速度传递方式\")]\n        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Runtime State - Read Only\")]\n        [SerializeField, ReadOnly] private Vector3 _speed;\n        [SerializeField, ReadOnly] private Vector3 _velocity;\n        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n        [SerializeField, ReadOnly] private Vector3 _acceleration;\n        [SerializeField, ReadOnly] private bool _grounded;\n        [SerializeField, ReadOnly] private bool _justGotGrounded;\n        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n        [SerializeField, ReadOnly] private float _friction;\n        [SerializeField, ReadOnly] private Vector3 _addedForce;\n        [SerializeField, ReadOnly] private bool _freeMovement = true;\n        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n\n        // 公共只读属性\n        public Vector3 Speed => _speed;\n        public Vector3 Velocity => _velocity;\n        public Vector3 VelocityLastFrame => _velocityLastFrame;\n        public Vector3 Acceleration => _acceleration;\n        public bool Grounded => _grounded;\n        public bool JustGotGrounded => _justGotGrounded;\n        public Vector3 CurrentMovement => _currentMovement;\n        public Vector3 CurrentDirection => _currentDirection;\n        public float Friction => _friction;\n        public Vector3 AddedForce => _addedForce;\n        public bool FreeMovement => _freeMovement;\n        public Vector3 GroundNormal => _groundNormal;\n        public Vector3 InputMoveDirection => _inputMoveDirection;\n        public Vector3 TargetVelocity => _targetVelocity;\n\n        // 碰撞器相关属性\n        public Vector3 ColliderCenter => transform.position + _characterController.center;\n        public Vector3 ColliderBottom => transform.position + _characterController.center +\n                                         Vector3.down * _characterController.bounds.extents.y;\n        public Vector3 ColliderTop => transform.position + _characterController.center +\n                                      Vector3.up * _characterController.bounds.extents.y;\n        public Vector3 AppliedImpact => _impact;\n\n        // 环境检测属性\n        public GameObject ObjectBelow { get; set; }\n        public GameObject DetectedObstacleLeft { get; set; }\n        public GameObject DetectedObstacleRight { get; set; }\n        public GameObject DetectedObstacleUp { get; set; }\n        public GameObject DetectedObstacleDown { get; set; }\n        public bool CollidingWithCardinalObstacle { get; set; }\n        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n\n        // 移动平台相关属性\n        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n\n        // 组件引用\n        private Transform _transform;\n        private CharacterController _characterController;\n\n        // 碰撞器原始尺寸\n        private float _originalColliderHeight;\n        private Vector3 _originalColliderCenter;\n\n        // 运动状态追踪\n        private Vector3 _positionLastFrame;\n        private bool _groundedLastFrame;\n        private Vector3 _impact;\n        private Vector3 _lastGroundNormal = Vector3.zero;\n        private bool _detached = false;\n        private bool _tooSteepLastFrame;\n\n        // 移动平台追踪\n        private Transform _movingPlatformHitCollider;\n        private Transform _movingPlatformCurrentHitCollider;\n        private Vector3 _movingPlatformCurrentHitColliderLocal;\n        private Vector3 _movingPlatformCurrentGlobalPoint;\n        private Quaternion _movingPlatformLocalRotation;\n        private Quaternion _movingPlatformGlobalRotation;\n        private Quaternion _lastMoveWithPlatformGlobalRotation;\n        private Matrix4x4 _lastMovingPlatformMatrix;\n        private Vector3 _movingPlatformVelocity;\n        private bool _newMovingPlatform;\n\n        // 碰撞检测\n        private CollisionFlags _collisionFlags;\n        private Vector3 _frameVelocity = Vector3.zero;\n        private Vector3 _hitPoint = Vector3.zero;\n        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n        // 速度计算\n        private Vector3 _newVelocity;\n        private Vector3 _motion;\n        private Vector3 _idealVelocity;\n        private Vector3 _idealDirection;\n        private Vector3 _horizontalVelocityDelta;\n        private float _stickyOffset = 0f;\n\n        // 位置移动\n        private RaycastHit _movePositionHit;\n        private Vector3 _capsulePoint1;\n        private Vector3 _capsulePoint2;\n        private Vector3 _movePositionDirection;\n        private float _movePositionDistance;\n\n        // 障碍物检测\n        private RaycastHit _cardinalRaycast;\n        private float _smallestDistance = Single.MaxValue;\n        private float _longestDistance = Single.MinValue;\n        private RaycastHit _smallestRaycast;\n        private RaycastHit _emptyRaycast = new RaycastHit();\n        private Vector3 _downRaycastsOffset;\n\n        // 平台移动计算\n        private Vector3 _moveWithPlatformMoveDistance;\n        private Vector3 _moveWithPlatformGlobalPoint;\n        private Quaternion _moveWithPlatformRotationDiff;\n        private Quaternion _moveWithPlatformGlobalRotation;\n        private RaycastHit _raycastDownHit;\n        private Vector3 _raycastDownDirection = Vector3.down;\n        private RaycastHit _canGoBackHeadCheck;\n        private Vector3 _originalSizeRaycastOrigin;\n\n        // 协程和可选组件\n        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        private float _currentDeltaTime;\n\n        // ============== 插值相关变量（已废弃，保留用于兼容性）==============\n        /// <summary>\n        /// 逻辑帧的时间间隔（保留字段，用于外部调用兼容性）\n        /// </summary>\n        private float _logicDeltaTime = 1f / 30f;\n        \n        /// <summary>\n        /// 上一次逻辑帧的时间戳\n        /// </summary>\n        private float _lastLogicUpdateTime = 0f;\n\n        /// <summary>\n        /// 上一次执行逻辑更新的帧号（用于防止同一帧重复移动）\n        /// </summary>\n        private int _lastLogicUpdateFrame = -1;\n\n        /// <summary>\n        /// 渲染帧专用的上一帧位置（用于计算速度显示）\n        /// </summary>\n        private Vector3 _renderPositionLastFrame = Vector3.zero;\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n        /// <summary>\n        /// 检查角色头部是否与物体碰撞\n        /// </summary>\n        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n\n        /// <summary>\n        /// 检查当前地面是否过于陡峭\n        /// </summary>\n        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n\n        /// <summary>\n        /// 初始化组件和缓存引用\n        /// </summary>\n        protected virtual void Awake()\n        {\n            _characterController = GetComponent<CharacterController>();\n            _transform = transform;\n            _rigidBody = GetComponent<Rigidbody>();\n            _originalColliderHeight = _characterController.height;\n            _originalColliderCenter = _characterController.center;\n            _currentDirection = _transform.forward;\n            _lastLogicUpdateTime = Time.time;\n            _renderPositionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 每帧更新（渲染帧）\n        /// 根据 UpdateModeType 决定是否在此执行物理计算\n        /// </summary>\n        protected virtual void Update()\n        {\n            float deltaTime = Time.deltaTime;\n            _currentDeltaTime = deltaTime;\n\n            // 只在 Auto 模式下自动执行物理计算\n            // Manual 模式下，物理计算由外部 LogicUpdate 调用控制\n            if (UpdateModeType == UpdateMode.Auto)\n            {\n                // 在 Auto 模式下才更新平台速度\n                GetMovingPlatformVelocity();\n\n                // 检查是否已经在 LogicUpdate 中处理过这一帧（防止双重移动）\n                bool alreadyProcessedThisFrame = (Time.frameCount == _lastLogicUpdateFrame);\n\n                if (!alreadyProcessedThisFrame && _freeMovement)\n                {\n                    ProcessLogicUpdate(deltaTime);\n                }\n\n                // 更新速度显示（仅用于调试）\n                if (deltaTime > SMALL_VALUE)\n                {\n                    _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n                    _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n                    _renderPositionLastFrame = _transform.position;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 注意：如果外部调用了此方法，Update 将跳过这一帧的处理，避免双重移动\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            _logicDeltaTime = deltaTime;\n            _currentDeltaTime = deltaTime;\n            _lastLogicUpdateTime = Time.time;\n            _lastLogicUpdateFrame = Time.frameCount; // 标记这一帧已处理\n\n            ProcessLogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 固定时间更新（保留用于物理相关操作）\n        /// </summary>\n        protected virtual void FixedUpdate()\n        {\n            _currentDeltaTime = Time.fixedDeltaTime;\n        }\n\n        /// <summary>\n        /// 延迟更新，保存上一帧速度\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            _velocityLastFrame = _velocity;\n        }\n\n        /// <summary>\n        /// 核心逻辑更新处理流程（使用指定的 deltaTime）\n        /// 计算移动逻辑并执行 CharacterController.Move\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ProcessLogicUpdate(float deltaTime)\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            CheckIfGrounded();\n            HandleFriction();\n            DetermineDirection();\n            AddInput(deltaTime);\n            AddGravity(deltaTime);\n            MoveWithPlatform();\n            ComputeVelocityDelta(deltaTime);\n\n            // 执行实际移动\n            MoveCharacterControllerWithMotion(_motion);\n            DetectNewMovingPlatform();\n            ManualControllerColliderHit();\n            HandleGroundContact();\n\n            ComputeNewVelocity(deltaTime);\n        }\n\n        /// <summary>\n        /// 使用指定的移动向量执行 CharacterController 移动\n        /// </summary>\n        /// <param name=\"motion\">移动向量</param>\n        protected virtual void MoveCharacterControllerWithMotion(Vector3 motion)\n        {\n            _groundNormal = Vector3.zero;\n            _collisionFlags = _characterController.Move(motion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n\n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n                _idealVelocity = _idealVelocity * SlidingSpeed;\n                _targetVelocity = _idealVelocity;\n                _newVelocity = _idealVelocity;\n                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n            }\n            else\n            {\n                _targetVelocity = _currentMovement;\n\n                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n\n                Vector3 newHorizontalVelocity;\n\n                // 如果加速度为 0，直接使用目标速度（零延迟响应）\n                if (HorizontalAcceleration <= 0.001f && HorizontalDeceleration <= 0.001f)\n                {\n                    newHorizontalVelocity = targetHorizontalVelocity;\n                }\n                else if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                {\n                    float effectiveAcceleration = HorizontalAcceleration;\n\n                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n                    {\n                        effectiveAcceleration *= InitialBurstMultiplier;\n                    }\n\n                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n\n                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n                    {\n                        newHorizontalVelocity = targetHorizontalVelocity;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n                    }\n                }\n                else\n                {\n                    float currentSpeed = currentHorizontalVelocity.magnitude;\n                    float speedReduction = HorizontalDeceleration * deltaTime;\n\n                    if (currentSpeed <= speedReduction)\n                    {\n                        newHorizontalVelocity = Vector3.zero;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n                    }\n                }\n\n                _newVelocity.x = newHorizontalVelocity.x;\n                _newVelocity.z = newHorizontalVelocity.z;\n\n                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    Vector3 floorVelocity = _frameVelocity;\n                    floorVelocity.y = 0;\n                    _newVelocity.x += floorVelocity.x;\n                    _newVelocity.z += floorVelocity.z;\n                }\n\n                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n\n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity.normalized;\n                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n\n                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n                        {\n                            projectedDirection.Normalize();\n                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                        }\n                    }\n\n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 应用重力到速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddGravity(float deltaTime)\n        {\n            if (GravityActive)\n            {\n                if (_grounded)\n                {\n                    _newVelocity.y = -Gravity * deltaTime;\n                }\n                else\n                {\n                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n                }\n            }\n            _newVelocity += _addedForce;\n            _addedForce = Vector3.zero;\n        }\n\n        /// <summary>\n        /// 跟随移动平台移动\n        /// </summary>\n        protected virtual void MoveWithPlatform()\n        {\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _moveWithPlatformMoveDistance = Vector3.zero;\n                _moveWithPlatformGlobalPoint =\n                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n                if (_moveWithPlatformMoveDistance != Vector3.zero)\n                {\n                    _characterController.Move(_moveWithPlatformMoveDistance);\n                }\n                _moveWithPlatformGlobalRotation =\n                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n            }\n        }\n\n        /// <summary>\n        /// 计算速度增量和粘性偏移\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeVelocityDelta(float deltaTime)\n        {\n            _motion = _newVelocity * deltaTime;\n            _horizontalVelocityDelta.x = _motion.x;\n            _horizontalVelocityDelta.y = 0f;\n            _horizontalVelocityDelta.z = _motion.z;\n\n            // 临时禁用地面粘附，测试是否是它导致的抖动\n            /*\n            // 只有在有水平移动时才应用粘附偏移，避免静止时的抖动\n            float horizontalSpeed = _horizontalVelocityDelta.magnitude;\n            if (_grounded && horizontalSpeed > SMALL_VALUE)\n            {\n                // 使用较小的粘附值，避免过度向下推\n                _stickyOffset = Mathf.Min(_characterController.stepOffset, horizontalSpeed);\n                _motion.y -= _stickyOffset;\n            }\n            */\n        }\n\n        /// <summary>\n        /// 检测是否踩上新的移动平台\n        /// </summary>\n        protected virtual void DetectNewMovingPlatform()\n        {\n            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n            {\n                if (_movingPlatformHitCollider != null)\n                {\n                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n                    _newMovingPlatform = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 计算新速度和加速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeNewVelocity(float deltaTime)\n        {\n            _velocity = _newVelocity;\n            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n        }\n\n        /// <summary>\n        /// 处理地面接触状态和平台速度传递\n        /// </summary>\n        protected virtual void HandleGroundContact()\n        {\n            _grounded = _characterController.isGrounded;\n            if (_grounded && !IsGroundedTest())\n            {\n                _grounded = false;\n                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    _frameVelocity = _movingPlatformVelocity;\n                    _velocity += _movingPlatformVelocity;\n                }\n            }\n            else if (!_grounded && IsGroundedTest())\n            {\n                if (_detached && _velocity.y <= 0)\n                {\n                    _grounded = true;\n                    _detached = false;\n                }\n                SubtractNewPlatformVelocity();\n            }\n\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _movingPlatformCurrentGlobalPoint = _transform.position;\n                _movingPlatformCurrentHitColliderLocal =\n                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n                _movingPlatformGlobalRotation = _transform.rotation;\n                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n                                               _movingPlatformGlobalRotation;\n            }\n\n            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n            _tooSteepLastFrame = TooSteep();\n        }\n\n        /// <summary>\n        /// 计算当前速度（仅用于显示，不影响逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeSpeed(float deltaTime)\n        {\n            // 使用渲染帧专用的位置记录，避免干扰逻辑帧\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _renderPositionLastFrame) / deltaTime;\n            }\n            _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n\n            _renderPositionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 根据当前移动向量确定方向\n        /// </summary>\n        protected virtual void DetermineDirection()\n        {\n            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n            {\n                _currentDirection = _currentMovement.normalized;\n            }\n        }\n\n        /// <summary>\n        /// 处理摩擦力（预留方法，可在子类中实现）\n        /// </summary>\n        protected virtual void HandleFriction()\n        {\n        }\n\n        /// <summary>\n        /// 检查是否刚刚着地\n        /// </summary>\n        protected virtual void CheckIfGrounded()\n        {\n            _justGotGrounded = !_groundedLastFrame && _grounded;\n            _groundedLastFrame = _grounded;\n        }\n\n        /// <summary>\n        /// 手动触发碰撞器碰撞处理\n        /// </summary>\n        protected virtual void ManualControllerColliderHit()\n        {\n            HandleAdvancedGroundDetection();\n        }\n\n        /// <summary>\n        /// 高级地面检测（使用多方向射线）\n        /// </summary>\n        protected virtual void HandleAdvancedGroundDetection()\n        {\n            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n            {\n                return;\n            }\n\n            _smallestDistance = Single.MaxValue;\n            _longestDistance = Single.MinValue;\n            _smallestRaycast = _emptyRaycast;\n            float offset = _characterController.radius;\n            _downRaycastsOffset = Vector3.zero;\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, offset);\n            CastRayDownwards();\n\n            if (_smallestRaycast.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n                {\n                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n                    {\n                        _groundNormal = _smallestRaycast.normal;\n                    }\n                    else\n                    {\n                        _groundNormal = _lastGroundNormal;\n                    }\n\n                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n                    _hitPoint = _smallestRaycast.point;\n                    _frameVelocity = Vector3.zero;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 向下发射射线检测地面\n        /// </summary>\n        protected virtual void CastRayDownwards()\n        {\n            if (_smallestDistance <= MinimumGroundedDistance)\n            {\n                return;\n            }\n\n            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n                _raycastDownDirection, out _raycastDownHit,\n                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n\n            if (_raycastDownHit.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n                if (adjustedDistance < _smallestDistance)\n                {\n                    _smallestDistance = adjustedDistance;\n                    _smallestRaycast = _raycastDownHit;\n                }\n                if (adjustedDistance > _longestDistance)\n                {\n                    _longestDistance = adjustedDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n        /// </summary>\n        protected float AdjustDistance(float distance)\n        {\n            return distance - _characterController.height / 2f - _characterController.skinWidth;\n        }\n\n        /// <summary>\n        /// 测试是否真正着地\n        /// </summary>\n        protected virtual bool IsGroundedTest()\n        {\n            bool grounded = false;\n            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n            {\n                if (_smallestDistance <= MinimumGroundedDistance)\n                {\n                    grounded = _groundNormal.y > 0.01f;\n                }\n            }\n            else\n            {\n                grounded = _characterController.isGrounded;\n                _groundNormal = Vector3.up;\n            }\n            return grounded;\n        }\n\n        /// <summary>\n        /// 获取移动平台速度\n        /// </summary>\n        protected virtual void GetMovingPlatformVelocity()\n        {\n            if (_movingPlatformCurrentHitCollider != null)\n            {\n                if (!_newMovingPlatform && _currentDeltaTime > SMALL_VALUE)\n                {\n                    _movingPlatformVelocity = (\n                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n                            _movingPlatformCurrentHitColliderLocal)\n                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n                    ) / _currentDeltaTime;\n                }\n                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n                _newMovingPlatform = false;\n            }\n            else\n            {\n                _movingPlatformVelocity = Vector3.zero;\n            }\n        }\n\n        /// <summary>\n        /// 减去新平台速度（处理平台切换）\n        /// </summary>\n        protected virtual void SubtractNewPlatformVelocity()\n        {\n            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n            {\n                if (_newMovingPlatform)\n                {\n                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n                }\n                else\n                {\n                    _velocity -= _movingPlatformVelocity;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 协程：延迟减去平台速度\n        /// </summary>\n        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n        {\n            Transform platform = _movingPlatformCurrentHitCollider;\n            yield return _waitForFixedUpdate;\n            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n            {\n                yield return null;\n            }\n            _velocity -= _movingPlatformVelocity;\n        }\n\n        /// <summary>\n        /// 判断是否应该跟随平台移动\n        /// </summary>\n        protected virtual bool ShouldMoveWithPlatformThisFrame()\n        {\n            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n                   && _movingPlatformCurrentHitCollider != null;\n        }\n\n        /// <summary>\n        /// 应用冲击力并逐渐衰减\n        /// </summary>\n        protected virtual void ApplyImpact()\n        {\n            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n            {\n                _characterController.Move(_impact * _currentDeltaTime);\n            }\n            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * _currentDeltaTime);\n        }\n\n        /// <summary>\n        /// 从地面分离（用于跳跃等）\n        /// </summary>\n        public virtual void DetachFromGround()\n        {\n            _detached = true;\n        }\n\n        /// <summary>\n        /// 从移动平台分离\n        /// </summary>\n        public virtual void DetachFromMovingPlatform()\n        {\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n        }\n\n        /// <summary>\n        /// 设置重力是否激活\n        /// </summary>\n        public virtual void SetGravityActive(bool status)\n        {\n            GravityActive = status;\n        }\n\n        /// <summary>\n        /// 添加外部力（会在下一帧应用）\n        /// </summary>\n        public virtual void AddForce(Vector3 movement)\n        {\n            _addedForce += movement;\n        }\n\n        /// <summary>\n        /// 施加瞬时冲击力\n        /// </summary>\n        /// <param name=\"direction\">冲击方向</param>\n        /// <param name=\"force\">冲击力大小</param>\n        public virtual void Impact(Vector3 direction, float force)\n        {\n            direction = direction.normalized;\n            if (direction.y < 0)\n            {\n                direction.y = -direction.y;\n            }\n            _impact += direction.normalized * force;\n        }\n\n        /// <summary>\n        /// 设置移动向量（通常由输入系统调用）\n        /// </summary>\n        /// <param name=\"movement\">移动向量</param>\n        public virtual void SetMovement(Vector3 movement)\n        {\n            _currentMovement = movement;\n            Vector3 directionVector = movement;\n            if (directionVector != Vector3.zero)\n            {\n                float directionLength = directionVector.magnitude;\n                directionVector = directionVector / directionLength;\n                directionLength = Mathf.Min(1, directionLength);\n                directionLength = directionLength * directionLength;\n                directionVector = directionVector * directionLength;\n            }\n            _inputMoveDirection = transform.rotation * directionVector;\n        }\n\n        /// <summary>\n        /// 移动到指定位置（带碰撞检测）\n        /// </summary>\n        /// <param name=\"newPosition\">目标位置</param>\n        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n        {\n            _movePositionDirection = newPosition - transform.position;\n            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n\n            _capsulePoint1 = transform.position\n                             + _characterController.center\n                             - (Vector3.up * _characterController.height / 2f)\n                             + Vector3.up * _characterController.skinWidth\n                             + Vector3.up * _characterController.radius;\n\n            _capsulePoint2 = transform.position\n                             + _characterController.center\n                             + (Vector3.up * _characterController.height / 2f)\n                             - Vector3.up * _characterController.skinWidth\n                             - Vector3.up * _characterController.radius;\n\n            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n            {\n                transform.position = newPosition;\n            }\n        }\n\n        /// <summary>\n        /// 调整碰撞器高度（用于蹲伏等）\n        /// </summary>\n        /// <param name=\"newHeight\">新高度</param>\n        /// <param name=\"translateCenter\">是否平移中心点</param>\n        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n        {\n            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n            _characterController.height = newHeight;\n            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n            if (translateCenter)\n            {\n                transform.Translate((newYOffset / 2f) * Vector3.up);\n            }\n        }\n\n        /// <summary>\n        /// 重置碰撞器尺寸到原始大小\n        /// </summary>\n        public virtual void ResetColliderSize()\n        {\n            _characterController.height = _originalColliderHeight;\n            _characterController.center = _originalColliderCenter;\n        }\n\n        /// <summary>\n        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n        /// </summary>\n        public virtual bool CanGoBackToOriginalSize()\n        {\n            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n            {\n                return true;\n            }\n\n            float headCheckDistance =\n                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n                ObstaclesLayerMask, Color.cyan, true);\n\n            return _canGoBackHeadCheck.collider == null;\n        }\n\n        /// <summary>\n        /// 启用碰撞\n        /// </summary>\n        public virtual void CollisionsOn()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = true;\n            }\n        }\n\n        /// <summary>\n        /// 禁用碰撞\n        /// </summary>\n        public virtual void CollisionsOff()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = false;\n            }\n        }\n\n        /// <summary>\n        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n        /// </summary>\n        public virtual void SetKinematic(bool state)\n        {\n            _rigidBody.isKinematic = state;\n        }\n\n        /// <summary>\n        /// 设置是否允许自由移动\n        /// </summary>\n        public virtual void SetFreeMovement(bool state)\n        {\n            _freeMovement = state;\n        }\n\n        /// <summary>\n        /// 检测四个基本方向的障碍物\n        /// </summary>\n        /// <param name=\"distance\">检测距离</param>\n        /// <param name=\"offset\">起始偏移</param>\n        public virtual void DetectObstacles(float distance, Vector3 offset)\n        {\n            if (!PerformCardinalObstacleRaycastDetection)\n            {\n                return;\n            }\n\n            CollidingWithCardinalObstacle = false;\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleRight = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleLeft = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleUp = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleDown = null;\n            }\n        }\n\n        /// <summary>\n        /// 重置控制器到初始状态\n        /// </summary>\n        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n            _renderPositionLastFrame = _transform != null ? _transform.position : Vector3.zero;\n            _lastLogicUpdateTime = Time.time;\n            _lastLogicUpdateFrame = -1;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n            return hit;\n        }\n    }\n}\n","structuredPatch":[{"oldStart":478,"oldLines":14,"newStart":478,"newLines":20,"lines":[" ","                     if (velocityMagnitude > SMALL_VALUE)","                     {","-                        Vector3 velocityDirection = horizontalVelocity.normalized;","-                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);","+                        Vector3 velocityDirection = horizontalVelocity / velocityMagnitude;"," ","-                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)","+                        // 只有当地面法线不是水平面时才投影，避免平地上的抖动","+                        if (_groundNormal.y < 0.999f)  // 如果地面法线几乎是正上方，跳过投影","                         {","-                            projectedDirection.Normalize();","-                            _newVelocity.x = projectedDirection.x * velocityMagnitude;","-                            _newVelocity.z = projectedDirection.z * velocityMagnitude;","+                            Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);","+","+                            // 检查投影后的方向是否有效","+                            if (projectedDirection.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)","+                            {","+                                projectedDirection.Normalize();","+                                _newVelocity.x = projectedDirection.x * velocityMagnitude;","+                                _newVelocity.z = projectedDirection.z * velocityMagnitude;","+                            }","                         }","                     }"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"e09efd35-af49-4a5e-9a89-6c2c2cb12e88","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","message":{"id":"msg_01VDGN2pvCNrEgsSc5Bz5A2B","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，我已经修复了三个主要问题：\n\n1. **输入归一化问题** - 在 MoveClipHandler 中添加了死区和更稳定的归一化逻辑\n2. **地面法线投影** - 在平地上跳过投影，避免不必要的计算导致抖动\n3. **Kcc Update 中的冗余更新** - 移到 Auto 模式条件内\n\n现在让我总结一下修复内容。","signature":"EoYECkYIChgCKkB67H6oscD/7aN9zVcydchov8AVk7CJ4ZsV7zgp5Xb7uudWWr4nSjV9nsP2R3LNBIzCYEwO3j/TUSk6X2cg9/1AEgzItkP0js8fdko06rQaDGU27Y8M/0AnePKBHyIwt8IcgbJ0+RkADL9PUPpb3MgsBOAyYyexbwpTEPMN3Uw+la5ndBRtdTWDn56nl4s8Ku0CdxoTJ8PFMD49Fboon4T0yGpKH8prs2XuUZrfZ4lJjaPWiP2eLfsPucnC6+4sRYBcku37ABTA6K5duKA5SivotP9nOU8ATcXTenoml90owRVw4tN4cF6YODlxXLtriFmxHBXDYPcYJHwbf6HzvslBQLoE8qXdzdEtGBdouMfNGa99yBRB9x9WAmcuCZx3xFPUh2bol6PXpmrB2ixxVtM8wo1QZMVIOn0nX5wf3kJbFYMUweiG5V/ZdIY6lmoUp7eyfefP/p0YvPjNtnGn5fR9oHCWFS+ybwWKvqgmelewdrU3HoOEPHN88m6rQW//z9JgHaHndTbZiyEAoZ0EAjozuWmaoqdic6NTugbb151reQ1BuzHa9bwEVrh7kht3RkxQQIfybaWfS47qUPZxWtC9qHqOie1oeIMKIV+kfU+xvJYsl4HG1gcInTGQyWEACWK67H0PKFG4IiBgMXR2zHEsn1Hp/GyuFwOFlqtHVAQYAQ=="},{"type":"text","text":"## ✅ 修复完成！\n\n我已经修复了导致水平移动抖动的**三个关键问题**：\n\n### 1. **输入归一化不稳定** ⭐ 主要原因\n```csharp:Assets/_Game/Scripts/ActionMachine/Runtime/Handlers/Clip/ClipHandlers/Rigidbody/MoveClipHandler.cs\n// 旧代码：小输入值归一化后方向剧烈变化\nvar move = InputData.axisValue.normalized * BindData.MoveSpeed;  // ❌\n\n// 新代码：添加死区并稳定归一化\nif (inputMagnitude > 0.01f)  // 0.01 死区\n{\n    Vector2 direction = input / inputMagnitude;  // 手动归一化\n    Vector2 move = direction * clampedMagnitude * BindData.MoveSpeed;\n}\n```\n\n### 2. **地面法线投影导致方向抖动**\n```csharp:Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs\n// 新增：只有在斜坡上才投影，平地跳过\nif (_groundNormal.y < 0.999f)  // 地面法线几乎垂直时跳过\n{\n    Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n    // 检查投影后是否有效\n    if (projectedDirection.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n    {\n        // 应用投影\n    }\n}\n```\n\n### 3. **Kcc.Update() 中的冗余更新**\n```csharp:Assets/_Game/Scripts/ActionMachine/Runtime/Controller/Kcc/Kcc.cs\n// 旧代码：Manual 模式下也会执行这些\nGetMovingPlatformVelocity();  // ❌ 每帧都在算\n_speed = ...;  // ❌ 每帧都在算\n\n// 新代码：只在 Auto 模式下执行\nif (UpdateModeType == UpdateMode.Auto)\n{\n    GetMovingPlatformVelocity();\n    _speed = ...;\n}\n```\n\n### 4. **旋转插值改进**（额外优化）\n```csharp:Assets/_Game/Scripts/ActionMachine/Runtime/Controller/ActionController.cs\n// 改用 Slerp 并只在有速度时旋转\nif (velocity.magnitude > 0.0001f)\n{\n    _modelRotation = Quaternion.LookRotation(velocity);\n    modelRoot.rotation = Quaternion.Slerp(modelRoot.rotation, _modelRotation, Time.deltaTime * 15f);\n}\n```\n\n## 测试建议\n\n请在 Unity 中测试：\n\n1. **平地移动** - 应该完全平滑，无抖动\n2. **小幅度移动摇杆** - 不应该有方向跳动\n3. **快速改变方向** - 应该平滑转向\n4. **斜坡移动** - 应该正常贴合地面\n\n## 如果还有问题\n\n如果抖动仍然存在，可能需要调整死区值：\n\n```csharp\n// 在 MoveClipHandler.cs 第 25 行\nif (inputMagnitude > 0.01f)  // 试试改成 0.02f 或 0.03f\n```\n\n或者临时添加一些平滑：\n\n```csharp\n// 在 MoveClipHandler 中添加平滑\nprivate Vector3 _smoothedMovement;\n\nprotected override void OnLogicUpdate(...)\n{\n    // ... 计算 movement\n    \n    // 添加平滑\n    _smoothedMovement = Vector3.Lerp(_smoothedMovement, movement, deltaTime * 10f);\n    kcc.SetMovement(_smoothedMovement);\n}\n```\n\n请测试一下，告诉我结果如何！"}],"model":"claude-sonnet-4-5-20250929","stop_reason":"end_turn","usage":{"cache_creation":{"ephemeral_1h_input_tokens":98792,"ephemeral_5m_input_tokens":0},"cache_creation_input_tokens":98792,"cache_read_input_tokens":42670,"input_tokens":13,"output_tokens":1227,"service_tier":"standard"}},"type":"assistant","uuid":"e2d4d6c9-cdc9-4c6c-a823-fa0a8f2abf5a","timestamp":"2025-12-15T11:00:36.090Z"}
{"type":"file-history-snapshot","messageId":"f1710557-3a93-49a8-b6f5-309556b531df","snapshot":{"messageId":"f1710557-3a93-49a8-b6f5-309556b531df","trackedFileBackups":{"CLAUDE.md":{"backupFileName":"0b5c4e3350b32821@v2","version":2,"backupTime":"2025-12-15T10:53:40.569Z"},"Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs":{"backupFileName":"b1c9467c2d2e4b63@v3","version":3,"backupTime":"2025-12-15T11:15:48.010Z"},"Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\ActionController.cs":{"backupFileName":"8e4255d1848fa081@v2","version":2,"backupTime":"2025-12-15T10:57:29.950Z"},"Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Handlers\\Clip\\ClipHandlers\\Rigidbody\\MoveClipHandler.cs":{"backupFileName":"8d63fd6f02843659@v2","version":2,"backupTime":"2025-12-15T11:15:48.012Z"}},"timestamp":"2025-12-15T11:15:48.007Z"},"isSnapshotUpdate":false}
{"parentUuid":"e2d4d6c9-cdc9-4c6c-a823-fa0a8f2abf5a","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":"Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."},"isMeta":true,"uuid":"334b23c2-61e1-4b85-a538-762e9a97f0a0","timestamp":"2025-12-15T11:15:48.007Z"}
{"parentUuid":"334b23c2-61e1-4b85-a538-762e9a97f0a0","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":"<command-name>/ide</command-name>\n            <command-message>ide</command-message>\n            <command-args></command-args>"},"uuid":"f1710557-3a93-49a8-b6f5-309556b531df","timestamp":"2025-12-15T11:15:48.007Z"}
{"parentUuid":"f1710557-3a93-49a8-b6f5-309556b531df","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"ea720e96-307f-4187-981b-cf9cf3a5a39a","version":"2.0.69","gitBranch":"master","slug":"dazzling-honking-gosling","type":"user","message":{"role":"user","content":"<local-command-stdout>Connected to JetBrains Rider.</local-command-stdout>"},"uuid":"9e211218-cbc9-4f29-9d2e-6b7e7fc0401a","timestamp":"2025-12-15T11:15:48.007Z"}
