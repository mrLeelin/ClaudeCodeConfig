{"type":"file-history-snapshot","messageId":"3046c6ba-7f61-428a-bf2a-450e94005fa2","snapshot":{"messageId":"3046c6ba-7f61-428a-bf2a-450e94005fa2","trackedFileBackups":{},"timestamp":"2025-12-15T11:43:55.562Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","type":"user","message":{"role":"user","content":"Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."},"isMeta":true,"uuid":"b4483bbe-1561-4e3b-bfbc-976045e8d5d2","timestamp":"2025-12-15T11:43:55.559Z"}
{"parentUuid":"b4483bbe-1561-4e3b-bfbc-976045e8d5d2","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","type":"user","message":{"role":"user","content":"<command-name>/clear</command-name>\n            <command-message>clear</command-message>\n            <command-args></command-args>"},"uuid":"3046c6ba-7f61-428a-bf2a-450e94005fa2","timestamp":"2025-12-15T11:43:55.552Z"}
{"parentUuid":"3046c6ba-7f61-428a-bf2a-450e94005fa2","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","type":"user","message":{"role":"user","content":"<local-command-stdout></local-command-stdout>"},"uuid":"08aa0eac-ffac-43e5-a53f-380fac36fcdd","timestamp":"2025-12-15T11:43:55.559Z"}
{"type":"file-history-snapshot","messageId":"8feb74f9-38fc-4041-8373-79ac17fbe524","snapshot":{"messageId":"8feb74f9-38fc-4041-8373-79ac17fbe524","trackedFileBackups":{},"timestamp":"2025-12-15T11:44:45.697Z"},"isSnapshotUpdate":false}
{"parentUuid":"08aa0eac-ffac-43e5-a53f-380fac36fcdd","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","type":"user","message":{"role":"user","content":"读取一下 @Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc.cs 这个脚本  这个脚本因为 logicUpdate 和 Update 的执行时机不同导致的抖动。 不行不需要LogicUpdate了 试试能不能解决抖动"},"uuid":"8feb74f9-38fc-4041-8373-79ac17fbe524","timestamp":"2025-12-15T11:44:45.696Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]}}
{"parentUuid":"8feb74f9-38fc-4041-8373-79ac17fbe524","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0141i2kmjHT6g1vt9ic4v3y8","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"用户想让我读取 Kcc.cs 脚本，并且提到因为 logicUpdate 和 Update 的执行时机不同导致了抖动问题。用户想尝试移除 LogicUpdate，看看能否解决抖动。\n\n让我先读取这个文件看看具体情况。","signature":"EpUDCkYIChgCKkB4TpNyYVUQPxGO0oMmH5GkMNd4C+TIrpT7MY5SR+vih5aVuTaH81ZbVzpPn3Wrv7RXqyTrKpagncvoW4KDJXuHEgz4DY3JcCLO6LSTxwcaDKIKBCBz5Qk1s5XmIiIwcwTMCni68P1rpoEYGBJpWLWOoNvPbt2wjBCc9DtbtkZWtHgpEgCnALFhu9l2S/NJKvwBQowwaGfHYC0t31Z5kB1tKE65eXVcQrNc//Q//AZZw26TqKdPn5zAMvZOvshW3QJMo96VFlzZXH4uZlwLxBhgvlpNdm+qPd3lcZX13OpCdes/4dRnElYMIUgsRNj6IAj0H/CefjZ77ck/HN9cfxItWg33AjyVg9JPrKdxHmx+JdSG3sp3JHVFi1+YMoqFTEK7c1CkdSWZQxPY8EnIQ17tthuEAmMAIfrL124E3vZTwJvd4q4wYMXrozRrEilFXZjH1hnvHO8chQwyDWRqBSI++Tg4bFUQduCwJFcd3Ivxdm/gj2ppcTY/Ip7Ipak5StOlWF5NlWR2OiMis25dGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":32335,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":32335,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"33956c32-90cb-47f4-aec5-839289dc82f8","timestamp":"2025-12-15T11:44:52.631Z"}
{"parentUuid":"33956c32-90cb-47f4-aec5-839289dc82f8","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0141i2kmjHT6g1vt9ic4v3y8","type":"message","role":"assistant","content":[{"type":"text","text":"我来读取 Kcc.cs 脚本，了解当前的 logicUpdate 和 Update 执行时机导致的抖动问题。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":32335,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":32335,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"8c004be5-6a5a-43d4-88df-d66b92720ac9","timestamp":"2025-12-15T11:44:53.191Z"}
{"parentUuid":"8c004be5-6a5a-43d4-88df-d66b92720ac9","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0141i2kmjHT6g1vt9ic4v3y8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XcHqndMn89KhkfJZKNRSEi","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":32335,"cache_read_input_tokens":12861,"cache_creation":{"ephemeral_5m_input_tokens":32335,"ephemeral_1h_input_tokens":0},"output_tokens":227,"service_tier":"standard"}},"type":"assistant","uuid":"1f7e043a-d67d-420a-ac9b-080f7ce69ea9","timestamp":"2025-12-15T11:44:53.902Z"}
{"parentUuid":"1f7e043a-d67d-420a-ac9b-080f7ce69ea9","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XcHqndMn89KhkfJZKNRSEi","type":"tool_result","content":"     1→using System;\n     2→using UnityEngine;\n     3→using System.Collections;\n     4→using System.Collections.Generic;\n     5→using ActionMachine.Runtime.Attributes;\n     6→\n     7→namespace ActionMachine.Runtime.Controller\n     8→{\n     9→    /// <summary>\n    10→    /// 运动学角色控制器（Kinematic Character Controller）\n    11→    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    12→    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    13→    /// </summary>\n    14→    [RequireComponent(typeof(CharacterController))]\n    15→    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    16→    public partial class Kcc : MonoBehaviour\n    17→    {\n    18→        private const float SMALL_VALUE = 0.0001f; // 浮点数比较的最小阈值\n    19→        private const float SPEED_ROUNDING_PRECISION = 100f; // 速度值舍入精度\n    20→        private const float IMPACT_THRESHOLD = 0.2f; // 冲击力应用的最小阈值\n    21→\n    22→        /// <summary>\n    23→        /// 地面检测计算模式\n    24→        /// </summary>\n    25→        public enum GroundedComputationMode\n    26→        {\n    27→            Simple, // 简单模式：使用 CharacterController.isGrounded\n    28→            Advanced // 高级模式：使用多方向射线检测\n    29→        }\n    30→\n    31→        /// <summary>\n    32→        /// 速度传递模式（用于移动平台交互）\n    33→        /// </summary>\n    34→        public enum VelocityTransferMode\n    35→        {\n    36→            NoTransfer, // 不传递速度\n    37→            InitialVelocity, // 传递初始速度\n    38→            FloorVelocity, // 传递地面速度\n    39→            Relative // 相对速度模式\n    40→        }\n    41→\n    42→        [Header(\"Gravity Settings\")] [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n    43→        public float Gravity = 40f;\n    44→\n    45→        [Tooltip(\"是否激活重力\")] public bool GravityActive = true;\n    46→\n    47→        [Header(\"Raycast Settings\")] [Tooltip(\"障碍物层遮罩\")]\n    48→        public LayerMask ObstaclesLayerMask;\n    49→\n    50→        [Tooltip(\"向下射线检测长度\")] public float GroundedRaycastLength = 5f;\n    51→\n    52→        [Tooltip(\"最小着地距离\")] public float MinimumGroundedDistance = 0.2f;\n    53→\n    54→        [Tooltip(\"地面检测计算模式\")] public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n    55→\n    56→        [Tooltip(\"地面法线高度阈值\")] public float GroundNormalHeightThreshold = 0.2f;\n    57→\n    58→        [Tooltip(\"蹲伏时射线长度倍数\")] public float CrouchedRaycastLengthMultiplier = 1f;\n    59→\n    60→        [Tooltip(\"是否执行基本方向障碍物射线检测\")] public bool PerformCardinalObstacleRaycastDetection = false;\n    61→\n    62→        [Header(\"Movement Settings\")] [Tooltip(\"最大下落速度\")]\n    63→        public float MaximumFallSpeed = 20.0f;\n    64→\n    65→        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速\")] \n    66→        public float HorizontalAcceleration = 20f;\n    67→\n    68→        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速\")] \n    69→        public float HorizontalDeceleration = 20f;\n    70→        \n    71→        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n    72→        public float InitialBurstMultiplier = 2.0f;\n    73→        \n    74→        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n    75→        public float BurstSpeedThreshold = 1.0f;\n    76→\n    77→        [Tooltip(\"斜坡速度倍数曲线\")] public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n    78→            new Keyframe(-90, 1),\n    79→            new Keyframe(0, 1),\n    80→            new Keyframe(90, 0)\n    81→        );\n    82→\n    83→        [Tooltip(\"冲击力衰减速度\")] public float ImpactFalloff = 5f;\n    84→\n    85→        [Header(\"Steep Surface Settings\")] [Tooltip(\"是否在陡峭表面滑动\")]\n    86→        public bool SlideOnSteepSurfaces = true;\n    87→\n    88→        [Tooltip(\"滑动速度\")] public float SlidingSpeed = 15f;\n    89→\n    90→        [Tooltip(\"滑动速度控制\")] public float SlidingSpeedControl = 0.4f;\n    91→\n    92→        [Tooltip(\"滑动方向控制\")] public float SlidingDirectionControl = 1f;\n    93→\n    94→        [Header(\"Moving Platform Settings\")] [Tooltip(\"跳跃时的速度传递方式\")]\n    95→        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n    96→\n    97→        [Header(\"Movement Smoothing\")]\n    98→        [Tooltip(\"是否启用移动平滑\")]\n    99→        public bool EnableMovementSmoothing = true;\n   100→        \n   101→        [Tooltip(\"水平移动平滑时间（秒）\")]\n   102→        [Range(0.01f, 0.1f)]\n   103→        public float HorizontalSmoothTime = 0.03f;\n   104→        \n   105→        [Tooltip(\"垂直移动平滑时间（秒）\")]\n   106→        [Range(0.01f, 0.1f)]\n   107→        public float VerticalSmoothTime = 0.05f;\n   108→\n   109→        [Header(\"Runtime State - Read Only\")]\n   110→        [SerializeField, ReadOnly] private Vector3 _speed;\n   111→        [SerializeField, ReadOnly] private Vector3 _velocity;\n   112→        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n   113→        [SerializeField, ReadOnly] private Vector3 _acceleration;\n   114→        [SerializeField, ReadOnly] private bool _grounded;\n   115→        [SerializeField, ReadOnly] private bool _justGotGrounded;\n   116→        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n   117→        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n   118→        [SerializeField, ReadOnly] private float _friction;\n   119→        [SerializeField, ReadOnly] private Vector3 _addedForce;\n   120→        [SerializeField, ReadOnly] private bool _freeMovement = true;\n   121→        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n   122→        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n   123→        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n   124→\n   125→        // 公共只读属性\n   126→        public Vector3 Speed => _speed;\n   127→        public Vector3 Velocity => _velocity;\n   128→        public Vector3 VelocityLastFrame => _velocityLastFrame;\n   129→        public Vector3 Acceleration => _acceleration;\n   130→        public bool Grounded => _grounded;\n   131→        public bool JustGotGrounded => _justGotGrounded;\n   132→        public Vector3 CurrentMovement => _currentMovement;\n   133→        public Vector3 CurrentDirection => _currentDirection;\n   134→        public float Friction => _friction;\n   135→        public Vector3 AddedForce => _addedForce;\n   136→        public bool FreeMovement => _freeMovement;\n   137→        public Vector3 GroundNormal => _groundNormal;\n   138→        public Vector3 InputMoveDirection => _inputMoveDirection;\n   139→        public Vector3 TargetVelocity => _targetVelocity;\n   140→\n   141→        // 碰撞器相关属性\n   142→        public Vector3 ColliderCenter => transform.position + _characterController.center;\n   143→\n   144→        public Vector3 ColliderBottom => transform.position + _characterController.center +\n   145→                                         Vector3.down * _characterController.bounds.extents.y;\n   146→\n   147→        public Vector3 ColliderTop => transform.position + _characterController.center +\n   148→                                      Vector3.up * _characterController.bounds.extents.y;\n   149→\n   150→        public Vector3 AppliedImpact => _impact;\n   151→\n   152→        // 环境检测属性\n   153→        public GameObject ObjectBelow { get; set; }\n   154→        public GameObject DetectedObstacleLeft { get; set; }\n   155→        public GameObject DetectedObstacleRight { get; set; }\n   156→        public GameObject DetectedObstacleUp { get; set; }\n   157→        public GameObject DetectedObstacleDown { get; set; }\n   158→        public bool CollidingWithCardinalObstacle { get; set; }\n   159→        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n   160→\n   161→        // 移动平台相关属性\n   162→        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n   163→        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n   164→        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n   165→        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n   166→\n   167→        // 组件引用\n   168→        private Transform _transform;\n   169→        private CharacterController _characterController;\n   170→\n   171→        // 碰撞器原始尺寸\n   172→        private float _originalColliderHeight;\n   173→        private Vector3 _originalColliderCenter;\n   174→\n   175→        // 运动状态追踪\n   176→        private Vector3 _positionLastFrame;\n   177→        private bool _groundedLastFrame;\n   178→        private Vector3 _impact;\n   179→        private Vector3 _lastGroundNormal = Vector3.zero;\n   180→        private bool _detached = false;\n   181→        private bool _tooSteepLastFrame;\n   182→\n   183→        // 移动平台追踪\n   184→        private Transform _movingPlatformHitCollider;\n   185→        private Transform _movingPlatformCurrentHitCollider;\n   186→        private Vector3 _movingPlatformCurrentHitColliderLocal;\n   187→        private Vector3 _movingPlatformCurrentGlobalPoint;\n   188→        private Quaternion _movingPlatformLocalRotation;\n   189→        private Quaternion _movingPlatformGlobalRotation;\n   190→        private Quaternion _lastMoveWithPlatformGlobalRotation;\n   191→        private Matrix4x4 _lastMovingPlatformMatrix;\n   192→        private Vector3 _movingPlatformVelocity;\n   193→        private bool _newMovingPlatform;\n   194→\n   195→        // 碰撞检测\n   196→        private CollisionFlags _collisionFlags;\n   197→        private Vector3 _frameVelocity = Vector3.zero;\n   198→        private Vector3 _hitPoint = Vector3.zero;\n   199→        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n   200→\n   201→        // 速度计算\n   202→        private Vector3 _newVelocity;\n   203→        private Vector3 _motion;\n   204→        private Vector3 _idealVelocity;\n   205→        private Vector3 _idealDirection;\n   206→        private Vector3 _horizontalVelocityDelta;\n   207→        private float _stickyOffset = 0f;\n   208→\n   209→        // 位置移动\n   210→        private RaycastHit _movePositionHit;\n   211→        private Vector3 _capsulePoint1;\n   212→        private Vector3 _capsulePoint2;\n   213→        private Vector3 _movePositionDirection;\n   214→        private float _movePositionDistance;\n   215→\n   216→        // 障碍物检测\n   217→        private RaycastHit _cardinalRaycast;\n   218→        private float _smallestDistance = Single.MaxValue;\n   219→        private float _longestDistance = Single.MinValue;\n   220→        private RaycastHit _smallestRaycast;\n   221→        private RaycastHit _emptyRaycast = new RaycastHit();\n   222→        private Vector3 _downRaycastsOffset;\n   223→\n   224→        // 平台移动计算\n   225→        private Vector3 _moveWithPlatformMoveDistance;\n   226→        private Vector3 _moveWithPlatformGlobalPoint;\n   227→        private Quaternion _moveWithPlatformRotationDiff;\n   228→        private Quaternion _moveWithPlatformGlobalRotation;\n   229→        private RaycastHit _raycastDownHit;\n   230→        private Vector3 _raycastDownDirection = Vector3.down;\n   231→        private RaycastHit _canGoBackHeadCheck;\n   232→        private Vector3 _originalSizeRaycastOrigin;\n   233→\n   234→        // 协程和可选组件\n   235→        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n   236→        private Rigidbody _rigidBody;\n   237→        \n   238→        // 逻辑帧与渲染帧分离\n   239→        private Vector3 _pendingMotion = Vector3.zero;\n   240→        private float _lastLogicDeltaTime = 0f; // 保存逻辑帧的时间增量\n   241→        \n   242→        // 移动平滑相关\n   243→        private Vector3 _smoothedMotion = Vector3.zero;\n   244→        private Vector3 _motionVelocity = Vector3.zero; // SmoothDamp 速度缓存\n   245→\n   246→        /// <summary>\n   247→        /// 检查角色是否正在滑动\n   248→        /// </summary>\n   249→        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n   250→\n   251→        /// <summary>\n   252→        /// 检查角色头部是否与物体碰撞\n   253→        /// </summary>\n   254→        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n   255→\n   256→        /// <summary>\n   257→        /// 检查当前地面是否过于陡峭\n   258→        /// </summary>\n   259→        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n   260→\n   261→        /// <summary>\n   262→        /// 初始化组件和缓存引用\n   263→        /// </summary>\n   264→        protected virtual void Awake()\n   265→        {\n   266→            _characterController = GetComponent<CharacterController>();\n   267→            _transform = transform;\n   268→            _rigidBody = GetComponent<Rigidbody>();\n   269→\n   270→            _originalColliderHeight = _characterController.height;\n   271→            _originalColliderCenter = _characterController.center;\n   272→            _currentDirection = _transform.forward;\n   273→        }\n   274→\n   275→        /// <summary>\n   276→        /// 固定时间更新（物理帧，处理物理相关的计算）\n   277→        /// 负责物理模拟、重力计算、碰撞检测等需要固定时间步长的操作\n   278→        /// </summary>\n   279→        protected virtual void FixedUpdate()\n   280→        {\n   281→            // 物理相关的固定更新\n   282→            ProcessFixedUpdate();\n   283→        }\n   284→\n   285→        /// <summary>\n   286→        /// 每帧更新（渲染帧，处理输入和实际移动）\n   287→        /// 负责输入处理、实际移动执行、视觉效果等需要每帧更新的操作\n   288→        /// </summary>\n   289→        protected virtual void Update()\n   290→        {\n   291→            // 渲染帧更新\n   292→            ProcessRenderUpdate();\n   293→        }\n   294→\n   295→        /// <summary>\n   296→        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n   297→        /// 负责游戏逻辑计算，如移动意图、状态机更新等\n   298→        /// </summary>\n   299→        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n   300→        public virtual void LogicUpdate(float deltaTime)\n   301→        {\n   302→            // 逻辑帧更新\n   303→            ProcessLogicUpdate(deltaTime);\n   304→        }\n   305→\n   306→        /// <summary>\n   307→        /// 延迟更新，目前为空方法，保留用于扩展\n   308→        /// </summary>\n   309→        protected virtual void LateUpdate()\n   310→        {\n   311→            // LateUpdate 不再处理 _velocityLastFrame，改为在 LogicUpdate 中处理\n   312→        }\n   313→\n   314→        /// <summary>\n   315→        /// 固定更新处理（物理帧）\n   316→        /// 处理物理相关的计算，确保物理模拟的一致性\n   317→        /// </summary>\n   318→        protected virtual void ProcessFixedUpdate()\n   319→        {\n   320→            if (_transform == null || !_freeMovement)\n   321→            {\n   322→                return;\n   323→            }\n   324→\n   325→            // 物理相关的固定更新\n   326→            // 1. 重力计算（固定时间步长确保物理一致性）\n   327→            if (GravityActive)\n   328→            {\n   329→                ApplyGravityFixed(Time.fixedDeltaTime);\n   330→            }\n   331→\n   332→            // 2. 移动平台速度计算（物理相关）\n   333→            GetMovingPlatformVelocity();\n   334→            \n   335→            // 3. 应用冲击力（物理相关，固定时间步长）\n   336→            ApplyImpact(Time.fixedDeltaTime);\n   337→        }\n   338→\n   339→        /// <summary>\n   340→        /// 渲染更新处理（每帧）\n   341→        /// 处理实际的移动执行和视觉效果\n   342→        /// </summary>\n   343→        protected virtual void ProcessRenderUpdate()\n   344→        {\n   345→            if (_transform == null || !_freeMovement)\n   346→            {\n   347→                return;\n   348→            }\n   349→\n   350→            // 1. 基于当前速度和渲染帧时间重新计算移动\n   351→            CalculateRenderFrameMotion();\n   352→            \n   353→            // 2. 执行实际的移动（每帧执行，确保视觉流畅）\n   354→            ExecutePendingMove();\n   355→        }\n   356→\n   357→        /// <summary>\n   358→        /// 逻辑更新处理（逻辑帧）\n   359→        /// 处理游戏逻辑计算，如移动意图、状态更新等\n   360→        /// </summary>\n   361→        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n   362→        protected virtual void ProcessLogicUpdate(float deltaTime)\n   363→        {\n   364→            if (_transform == null || !_freeMovement)\n   365→            {\n   366→                return;\n   367→            }\n   368→\n   369→            // 保存逻辑帧时间增量，用于渲染帧的移动计算\n   370→            _lastLogicDeltaTime = deltaTime;\n   371→\n   372→            // 保存上一帧状态（在 LogicUpdate 开始时保存，确保时序正确）\n   373→            _velocityLastFrame = _velocity;\n   374→            _newVelocity = _velocity;\n   375→            _positionLastFrame = _transform.position;\n   376→\n   377→            // 1. 地面检测（逻辑相关）\n   378→            CheckIfGrounded();\n   379→            \n   380→            // 2. 处理摩擦力（逻辑相关）\n   381→            HandleFriction();\n   382→            \n   383→            // 3. 确定移动方向（基于输入）\n   384→            DetermineDirection();\n   385→            \n   386→            // 4. 处理输入移动（逻辑计算，不实际移动）\n   387→            AddInput(deltaTime);\n   388→            \n   389→            // 5. 处理重力（逻辑计算，不包含固定更新中的重力）\n   390→            AddGravityLogic(deltaTime);\n   391→            \n   392→            // 6. 处理移动平台（逻辑计算）\n   393→            MoveWithPlatform();\n   394→            \n   395→            // 7. 计算速度变化（逻辑计算）\n   396→            ComputeVelocityDelta(deltaTime);\n   397→            \n   398→            // 8. 计算新速度（逻辑状态更新）\n   399→            ComputeNewVelocity(deltaTime);\n   400→            \n   401→            // 9. 计算实际速度（基于逻辑帧时间增量）\n   402→            ComputeSpeed(deltaTime);\n   403→        }\n   404→        \n   405→        /// <summary>\n   406→        /// 处理输入并计算理想速度（包括滑坡逻辑）\n   407→        /// </summary>\n   408→        /// <param name=\"deltaTime\">时间增量</param>\n   409→        protected virtual void AddInput(float deltaTime)\n   410→        {\n   411→            if (_grounded && TooSteep())\n   412→            {\n   413→                _idealVelocity.x = _groundNormal.x;\n   414→                _idealVelocity.y = 0;\n   415→                _idealVelocity.z = _groundNormal.z;\n   416→                _idealVelocity = _idealVelocity.normalized;\n   417→                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n   418→                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n   419→                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n   420→                _idealVelocity = _idealVelocity * SlidingSpeed;\n   421→                _targetVelocity = _idealVelocity;\n   422→                _newVelocity = _idealVelocity;\n   423→                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n   424→            }\n   425→            else\n   426→            {\n   427→                _targetVelocity = _currentMovement;\n   428→                \n   429→                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n   430→                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n   431→                \n   432→                Vector3 newHorizontalVelocity;\n   433→                \n   434→                if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n   435→                {\n   436→                    float effectiveAcceleration = HorizontalAcceleration;\n   437→                    \n   438→                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n   439→                    {\n   440→                        effectiveAcceleration *= InitialBurstMultiplier;\n   441→                    }\n   442→                    \n   443→                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n   444→                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n   445→                    \n   446→\n   447→                    \n   448→                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n   449→                    {\n   450→                        newHorizontalVelocity = targetHorizontalVelocity;\n   451→                    }\n   452→                    else\n   453→                    {\n   454→                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n   455→                    }\n   456→                }\n   457→                else\n   458→                {\n   459→                    float currentSpeed = currentHorizontalVelocity.magnitude;\n   460→                    float speedReduction = HorizontalDeceleration * deltaTime;\n   461→                    \n   462→\n   463→                    \n   464→                    if (currentSpeed <= speedReduction)\n   465→                    {\n   466→                        newHorizontalVelocity = Vector3.zero;\n   467→                    }\n   468→                    else\n   469→                    {\n   470→                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n   471→                    }\n   472→                }\n   473→                \n   474→                _newVelocity.x = newHorizontalVelocity.x;\n   475→                _newVelocity.z = newHorizontalVelocity.z;\n   476→                \n   477→\n   478→                \n   479→                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n   480→                {\n   481→                    Vector3 floorVelocity = _frameVelocity;\n   482→                    floorVelocity.y = 0;\n   483→                    _newVelocity.x += floorVelocity.x;\n   484→                    _newVelocity.z += floorVelocity.z;\n   485→                }\n   486→                \n   487→                if (_grounded)\n   488→                {\n   489→                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n   490→                    float velocityMagnitude = horizontalVelocity.magnitude;\n   491→                    \n   492→                    if (velocityMagnitude > SMALL_VALUE)\n   493→                    {\n   494→                        Vector3 velocityDirection = horizontalVelocity.normalized;\n   495→                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n   496→                        \n   497→                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n   498→                        {\n   499→                            projectedDirection.Normalize();\n   500→                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n   501→                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n   502→                        }\n   503→                    }\n   504→                    \n   505→                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n   506→                }\n   507→            }\n   508→        }\n   509→\n   510→        /// <summary>\n   511→        /// 固定更新中的重力应用（物理帧）\n   512→        /// </summary>\n   513→        /// <param name=\"deltaTime\">固定时间增量</param>\n   514→        protected virtual void ApplyGravityFixed(float deltaTime)\n   515→        {\n   516→            // 固定更新中的重力处理，主要用于物理一致性\n   517→            // 这里可以添加需要在固定时间步长中处理的重力相关逻辑\n   518→        }\n   519→\n   520→        /// <summary>\n   521→        /// 逻辑更新中的重力应用（逻辑帧）\n   522→        /// </summary>\n   523→        /// <param name=\"deltaTime\">逻辑时间增量</param>\n   524→        protected virtual void AddGravityLogic(float deltaTime)\n   525→        {\n   526→            if (GravityActive)\n   527→            {\n   528→                if (_grounded)\n   529→                {\n   530→                    _newVelocity.y = -Gravity * deltaTime;\n   531→\n   532→                }\n   533→                else\n   534→                {\n   535→                    float oldY = _newVelocity.y;\n   536→                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n   537→                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n   538→\n   539→                }\n   540→            }\n   541→\n   542→            _newVelocity += _addedForce;\n   543→            _addedForce = Vector3.zero;\n   544→        }\n   545→\n   546→        /// <summary>\n   547→        /// 应用重力到速度（保持向后兼容）\n   548→        /// </summary>\n   549→        /// <param name=\"deltaTime\">时间增量</param>\n   550→        protected virtual void AddGravity(float deltaTime)\n   551→        {\n   552→            AddGravityLogic(deltaTime);\n   553→        }\n   554→\n   555→        /// <summary>\n   556→        /// 跟随移动平台移动\n   557→        /// </summary>\n   558→        protected virtual void MoveWithPlatform()\n   559→        {\n   560→            if (ShouldMoveWithPlatformThisFrame())\n   561→            {\n   562→                _moveWithPlatformMoveDistance = Vector3.zero;\n   563→                _moveWithPlatformGlobalPoint =\n   564→                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n   565→                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n   566→\n   567→                if (_moveWithPlatformMoveDistance != Vector3.zero)\n   568→                {\n   569→                    _characterController.Move(_moveWithPlatformMoveDistance);\n   570→                }\n   571→\n   572→                _moveWithPlatformGlobalRotation =\n   573→                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n   574→                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n   575→                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n   576→                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n   577→            }\n   578→        }\n   579→\n   580→        /// <summary>\n   581→        /// 计算速度增量和粘性偏移\n   582→        /// </summary>\n   583→        /// <param name=\"deltaTime\">时间增量</param>\n   584→        protected virtual void ComputeVelocityDelta(float deltaTime)\n   585→        {\n   586→            _motion = _newVelocity * deltaTime;\n   587→            _horizontalVelocityDelta.x = _motion.x;\n   588→            _horizontalVelocityDelta.y = 0f;\n   589→            _horizontalVelocityDelta.z = _motion.z;\n   590→            _stickyOffset = Mathf.Max(_characterController.stepOffset, _horizontalVelocityDelta.magnitude);\n   591→\n   592→            if (_grounded)\n   593→            {\n   594→                _motion -= _stickyOffset * Vector3.up;\n   595→            }\n   596→        }\n   597→\n   598→        /// <summary>\n   599→        /// 基于当前速度和渲染帧时间重新计算移动\n   600→        /// Logic 赋值 Velocity，Render 对这个进行插值渲染\n   601→        /// </summary>\n   602→        protected virtual void CalculateRenderFrameMotion()\n   603→        {\n   604→            // 根据速度动态调整时间增量，避免高速时移动幅度过大\n   605→            float speedMagnitude = _velocity.magnitude;\n   606→            float adjustedDeltaTime = Time.deltaTime;\n   607→            \n   608→            // 高速时减少有效时间增量，控制移动幅度\n   609→            if (speedMagnitude > 8f)\n   610→            {\n   611→                // 速度越高，时间增量缩放越小\n   612→                // 扩展速度范围到 100，支持更高的速度\n   613→                float speedFactor = Mathf.InverseLerp(8f, 100f, speedMagnitude);\n   614→                adjustedDeltaTime *= Mathf.Lerp(1f, 0.05f, speedFactor);\n   615→            }\n   616→            \n   617→            // 使用调整后的时间增量计算移动向量\n   618→            Vector3 targetMotion = _velocity * adjustedDeltaTime;\n   619→            \n   620→            // 应用地面接触的粘性偏移（如果需要）\n   621→            if (_grounded)\n   622→            {\n   623→                Vector3 horizontalMotion = new Vector3(targetMotion.x, 0, targetMotion.z);\n   624→                float stickyOffset = Mathf.Max(_characterController.stepOffset * 0.1f, horizontalMotion.magnitude * 0.01f);\n   625→                targetMotion.y -= stickyOffset;\n   626→            }\n   627→            \n   628→            // 应用移动平滑（如果启用）\n   629→            if (EnableMovementSmoothing)\n   630→            {\n   631→                _pendingMotion = CalculateSmoothedMotion(targetMotion);\n   632→            }\n   633→            else\n   634→            {\n   635→                _pendingMotion = targetMotion;\n   636→            }\n   637→        }\n   638→\n   639→        /// <summary>\n   640→        /// 执行待处理的移动（在渲染帧中调用）\n   641→        /// 执行实际的物理移动和碰撞检测\n   642→        /// </summary>\n   643→        protected virtual void ExecutePendingMove()\n   644→        {\n   645→            // 1. 执行实际的 CharacterController 移动\n   646→            MoveCharacterController();\n   647→            \n   648→            // 2. 检测新的移动平台（碰撞相关）\n   649→            DetectNewMovingPlatform();\n   650→            \n   651→            // 3. 手动处理碰撞器碰撞（物理相关）\n   652→            ManualControllerColliderHit();\n   653→            \n   654→            // 4. 处理地面接触状态（物理相关）\n   655→            HandleGroundContact();\n   656→        }\n   657→\n   658→        /// <summary>\n   659→        /// 执行 CharacterController 移动\n   660→        /// </summary>\n   661→        protected virtual void MoveCharacterController()\n   662→        {\n   663→            _groundNormal = Vector3.zero;\n   664→            \n   665→            // 直接使用基于渲染帧时间计算的移动向量\n   666→            _collisionFlags = _characterController.Move(_pendingMotion);\n   667→            _lastHitPoint = _hitPoint;\n   668→            _lastGroundNormal = _groundNormal;\n   669→        }\n   670→        \n   671→        /// <summary>\n   672→        /// 计算平滑后的移动向量\n   673→        /// 使用简单的 Lerp 进行平滑，避免过度复杂化\n   674→        /// </summary>\n   675→        /// <param name=\"targetMotion\">目标移动向量</param>\n   676→        /// <returns>平滑后的移动向量</returns>\n   677→        protected virtual Vector3 CalculateSmoothedMotion(Vector3 targetMotion)\n   678→        {\n   679→            // 计算目标移动的幅度，用于动态调整平滑强度\n   680→            float targetMagnitude = targetMotion.magnitude;\n   681→            \n   682→            // 基于移动幅度动态调整平滑时间\n   683→            // 移动距离越大，需要更强的平滑\n   684→            float dynamicSmoothTime = 0.016f; // 基础平滑时间（60fps）\n   685→            \n   686→            if (targetMagnitude > 0.1f) // 只对有明显移动时进行调整\n   687→            {\n   688→                // 移动距离越大，平滑时间越长\n   689→                // 这样可以确保高速移动时有足够的平滑\n   690→                dynamicSmoothTime = Mathf.Lerp(0.016f, 0.1f, Mathf.InverseLerp(0.1f, 0.5f, targetMagnitude));\n   691→            }\n   692→            \n   693→            // 使用 SmoothDamp 进行平滑，它能更好地处理不同幅度的移动\n   694→            Vector3 smoothed = Vector3.SmoothDamp(_smoothedMotion, targetMotion, ref _motionVelocity, \n   695→                                                 dynamicSmoothTime, Mathf.Infinity, Time.deltaTime);\n   696→            \n   697→            _smoothedMotion = smoothed;\n   698→            \n   699→            // 防抖动处理\n   700→            if (targetMotion.sqrMagnitude < 0.001f * 0.001f)\n   701→            {\n   702→                _smoothedMotion *= 0.9f;\n   703→                if (_smoothedMotion.sqrMagnitude < 0.0001f)\n   704→                {\n   705→                    _smoothedMotion = Vector3.zero;\n   706→                    _motionVelocity = Vector3.zero;\n   707→                }\n   708→            }\n   709→            \n   710→            return _smoothedMotion;\n   711→        }\n   712→\n   713→        /// <summary>\n   714→        /// 检测是否踩上新的移动平台\n   715→        /// </summary>\n   716→        protected virtual void DetectNewMovingPlatform()\n   717→        {\n   718→            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n   719→            {\n   720→                if (_movingPlatformHitCollider != null)\n   721→                {\n   722→                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n   723→                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n   724→                    _newMovingPlatform = true;\n   725→                }\n   726→            }\n   727→        }\n   728→\n   729→        /// <summary>\n   730→        /// 计算新速度和加速度\n   731→        /// </summary>\n   732→        /// <param name=\"deltaTime\">时间增量</param>\n   733→        protected virtual void ComputeNewVelocity(float deltaTime)\n   734→        {\n   735→            _velocity = _newVelocity;\n   736→            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n   737→        }\n   738→\n   739→        /// <summary>\n   740→        /// 处理地面接触状态和平台速度传递\n   741→        /// </summary>\n   742→        protected virtual void HandleGroundContact()\n   743→        {\n   744→            _grounded = _characterController.isGrounded;\n   745→\n   746→            if (_grounded && !IsGroundedTest())\n   747→            {\n   748→                _grounded = false;\n   749→                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n   750→                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n   751→                {\n   752→                    _frameVelocity = _movingPlatformVelocity;\n   753→                    _velocity += _movingPlatformVelocity;\n   754→                }\n   755→            }\n   756→            else if (!_grounded && IsGroundedTest())\n   757→            {\n   758→                if (_detached && _velocity.y <= 0)\n   759→                {\n   760→                    _grounded = true;\n   761→                    _detached = false;\n   762→                }\n   763→\n   764→                SubtractNewPlatformVelocity();\n   765→            }\n   766→\n   767→            if (ShouldMoveWithPlatformThisFrame())\n   768→            {\n   769→                _movingPlatformCurrentGlobalPoint = _transform.position;\n   770→                _movingPlatformCurrentHitColliderLocal =\n   771→                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n   772→                _movingPlatformGlobalRotation = _transform.rotation;\n   773→                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n   774→                                               _movingPlatformGlobalRotation;\n   775→            }\n   776→\n   777→            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n   778→            _tooSteepLastFrame = TooSteep();\n   779→        }\n   780→\n   781→        /// <summary>\n   782→        /// 计算当前速度\n   783→        /// </summary>\n   784→        /// <param name=\"deltaTime\">时间增量</param>\n   785→        protected virtual void ComputeSpeed(float deltaTime)\n   786→        {\n   787→            if (deltaTime > SMALL_VALUE)\n   788→            {\n   789→                _speed = (_transform.position - _positionLastFrame) / deltaTime;\n   790→            }\n   791→\n   792→            // 暂时禁用速度舍入，避免高速时的舍入误差导致抖动\n   793→            // _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   794→            // _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   795→            // _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n   796→            \n   797→            _positionLastFrame = _transform.position;\n   798→        }\n   799→\n   800→        /// <summary>\n   801→        /// 根据当前移动向量确定方向\n   802→        /// </summary>\n   803→        protected virtual void DetermineDirection()\n   804→        {\n   805→            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n   806→            {\n   807→                _currentDirection = _currentMovement.normalized;\n   808→            }\n   809→        }\n   810→\n   811→        /// <summary>\n   812→        /// 处理摩擦力（预留方法，可在子类中实现）\n   813→        /// </summary>\n   814→        protected virtual void HandleFriction()\n   815→        {\n   816→        }\n   817→\n   818→        /// <summary>\n   819→        /// 检查是否刚刚着地\n   820→        /// </summary>\n   821→        protected virtual void CheckIfGrounded()\n   822→        {\n   823→            _justGotGrounded = !_groundedLastFrame && _grounded;\n   824→            _groundedLastFrame = _grounded;\n   825→        }\n   826→\n   827→        /// <summary>\n   828→        /// 手动触发碰撞器碰撞处理\n   829→        /// </summary>\n   830→        protected virtual void ManualControllerColliderHit()\n   831→        {\n   832→            HandleAdvancedGroundDetection();\n   833→        }\n   834→\n   835→        /// <summary>\n   836→        /// 高级地面检测（使用多方向射线）\n   837→        /// </summary>\n   838→        protected virtual void HandleAdvancedGroundDetection()\n   839→        {\n   840→            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n   841→            {\n   842→                return;\n   843→            }\n   844→\n   845→            _smallestDistance = Single.MaxValue;\n   846→            _longestDistance = Single.MinValue;\n   847→            _smallestRaycast = _emptyRaycast;\n   848→\n   849→            float offset = _characterController.radius;\n   850→\n   851→            _downRaycastsOffset = Vector3.zero;\n   852→            CastRayDownwards();\n   853→            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n   854→            CastRayDownwards();\n   855→            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n   856→            CastRayDownwards();\n   857→            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n   858→            CastRayDownwards();\n   859→            _downRaycastsOffset = new Vector3(0f, offset, offset);\n   860→            CastRayDownwards();\n   861→\n   862→            if (_smallestRaycast.collider != null)\n   863→            {\n   864→                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n   865→\n   866→                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n   867→                {\n   868→                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n   869→                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n   870→                    {\n   871→                        _groundNormal = _smallestRaycast.normal;\n   872→                    }\n   873→                    else\n   874→                    {\n   875→                        _groundNormal = _lastGroundNormal;\n   876→                    }\n   877→\n   878→                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n   879→                    _hitPoint = _smallestRaycast.point;\n   880→                    _frameVelocity = Vector3.zero;\n   881→                }\n   882→            }\n   883→        }\n   884→\n   885→        /// <summary>\n   886→        /// 向下发射射线检测地面\n   887→        /// </summary>\n   888→        protected virtual void CastRayDownwards()\n   889→        {\n   890→            if (_smallestDistance <= MinimumGroundedDistance)\n   891→            {\n   892→                return;\n   893→            }\n   894→\n   895→            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n   896→                _raycastDownDirection, out _raycastDownHit,\n   897→                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n   898→\n   899→            if (_raycastDownHit.collider != null)\n   900→            {\n   901→                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n   902→\n   903→                if (adjustedDistance < _smallestDistance)\n   904→                {\n   905→                    _smallestDistance = adjustedDistance;\n   906→                    _smallestRaycast = _raycastDownHit;\n   907→                }\n   908→\n   909→                if (adjustedDistance > _longestDistance)\n   910→                {\n   911→                    _longestDistance = adjustedDistance;\n   912→                }\n   913→            }\n   914→        }\n   915→\n   916→        /// <summary>\n   917→        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n   918→        /// </summary>\n   919→        protected float AdjustDistance(float distance)\n   920→        {\n   921→            return distance - _characterController.height / 2f - _characterController.skinWidth;\n   922→        }\n   923→\n   924→        /// <summary>\n   925→        /// 测试是否真正着地\n   926→        /// </summary>\n   927→        protected virtual bool IsGroundedTest()\n   928→        {\n   929→            bool grounded = false;\n   930→            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n   931→            {\n   932→                if (_smallestDistance <= MinimumGroundedDistance)\n   933→                {\n   934→                    grounded = _groundNormal.y > 0.01f;\n   935→                }\n   936→            }\n   937→            else\n   938→            {\n   939→                grounded = _characterController.isGrounded;\n   940→                _groundNormal = Vector3.up;\n   941→            }\n   942→\n   943→            return grounded;\n   944→        }\n   945→\n   946→        /// <summary>\n   947→        /// 获取移动平台速度\n   948→        /// </summary>\n   949→        protected virtual void GetMovingPlatformVelocity()\n   950→        {\n   951→            if (_movingPlatformCurrentHitCollider != null)\n   952→            {\n   953→                if (!_newMovingPlatform && Time.fixedDeltaTime > SMALL_VALUE)\n   954→                {\n   955→                    _movingPlatformVelocity = (\n   956→                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n   957→                            _movingPlatformCurrentHitColliderLocal)\n   958→                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n   959→                    ) / Time.fixedDeltaTime;\n   960→                }\n   961→\n   962→                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n   963→                _newMovingPlatform = false;\n   964→            }\n   965→            else\n   966→            {\n   967→                _movingPlatformVelocity = Vector3.zero;\n   968→            }\n   969→        }\n   970→\n   971→        /// <summary>\n   972→        /// 减去新平台速度（处理平台切换）\n   973→        /// </summary>\n   974→        protected virtual void SubtractNewPlatformVelocity()\n   975→        {\n   976→            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n   977→                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n   978→            {\n   979→                if (_newMovingPlatform)\n   980→                {\n   981→                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n   982→                }\n   983→                else\n   984→                {\n   985→                    _velocity -= _movingPlatformVelocity;\n   986→                }\n   987→            }\n   988→        }\n   989→\n   990→        /// <summary>\n   991→        /// 协程：延迟减去平台速度\n   992→        /// </summary>\n   993→        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n   994→        {\n   995→            Transform platform = _movingPlatformCurrentHitCollider;\n   996→            yield return _waitForFixedUpdate;\n   997→            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n   998→            {\n   999→                yield return null;\n  1000→            }\n  1001→\n  1002→            _velocity -= _movingPlatformVelocity;\n  1003→        }\n  1004→\n  1005→        /// <summary>\n  1006→        /// 判断是否应该跟随平台移动\n  1007→        /// </summary>\n  1008→        protected virtual bool ShouldMoveWithPlatformThisFrame()\n  1009→        {\n  1010→            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n  1011→                   && _movingPlatformCurrentHitCollider != null;\n  1012→        }\n  1013→\n  1014→        /// <summary>\n  1015→        /// 应用冲击力并逐渐衰减\n  1016→        /// </summary>\n  1017→        /// <param name=\"deltaTime\">时间增量</param>\n  1018→        protected virtual void ApplyImpact(float deltaTime)\n  1019→        {\n  1020→            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n  1021→            {\n  1022→                _characterController.Move(_impact * deltaTime);\n  1023→            }\n  1024→\n  1025→            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * deltaTime);\n  1026→        }\n  1027→\n  1028→        /// <summary>\n  1029→        /// 从地面分离（用于跳跃等）\n  1030→        /// </summary>\n  1031→        public virtual void DetachFromGround()\n  1032→        {\n  1033→            _detached = true;\n  1034→        }\n  1035→\n  1036→        /// <summary>\n  1037→        /// 从移动平台分离\n  1038→        /// </summary>\n  1039→        public virtual void DetachFromMovingPlatform()\n  1040→        {\n  1041→            _movingPlatformVelocity = Vector3.zero;\n  1042→            _movingPlatformCurrentHitCollider = null;\n  1043→            _movingPlatformHitCollider = null;\n  1044→        }\n  1045→\n  1046→        /// <summary>\n  1047→        /// 设置重力是否激活\n  1048→        /// </summary>\n  1049→        public virtual void SetGravityActive(bool status)\n  1050→        {\n  1051→            GravityActive = status;\n  1052→        }\n  1053→\n  1054→        /// <summary>\n  1055→        /// 添加外部力（会在下一帧应用）\n  1056→        /// </summary>\n  1057→        public virtual void AddForce(Vector3 movement)\n  1058→        {\n  1059→            _addedForce += movement;\n  1060→        }\n  1061→\n  1062→        /// <summary>\n  1063→        /// 施加瞬时冲击力\n  1064→        /// </summary>\n  1065→        /// <param name=\"direction\">冲击方向</param>\n  1066→        /// <param name=\"force\">冲击力大小</param>\n  1067→        public virtual void Impact(Vector3 direction, float force)\n  1068→        {\n  1069→            direction = direction.normalized;\n  1070→            if (direction.y < 0)\n  1071→            {\n  1072→                direction.y = -direction.y;\n  1073→            }\n  1074→\n  1075→            _impact += direction.normalized * force;\n  1076→        }\n  1077→\n  1078→        /// <summary>\n  1079→        /// 设置移动向量（通常由输入系统调用）\n  1080→        /// </summary>\n  1081→        /// <param name=\"movement\">移动向量</param>\n  1082→        public virtual void SetMovement(Vector3 movement)\n  1083→        {\n  1084→            _currentMovement = movement;\n  1085→\n  1086→            Vector3 directionVector = movement;\n  1087→            if (directionVector != Vector3.zero)\n  1088→            {\n  1089→                float directionLength = directionVector.magnitude;\n  1090→                directionVector = directionVector / directionLength;\n  1091→                directionLength = Mathf.Min(1, directionLength);\n  1092→                // 移除平方操作，保持线性响应，避免高速时的非线性抖动\n  1093→                directionVector = directionVector * directionLength;\n  1094→            }\n  1095→\n  1096→            _inputMoveDirection = transform.rotation * directionVector;\n  1097→        }\n  1098→\n  1099→        /// <summary>\n  1100→        /// 移动到指定位置（带碰撞检测）\n  1101→        /// </summary>\n  1102→        /// <param name=\"newPosition\">目标位置</param>\n  1103→        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n  1104→        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n  1105→        {\n  1106→            _movePositionDirection = newPosition - transform.position;\n  1107→            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n  1108→\n  1109→            _capsulePoint1 = transform.position\n  1110→                             + _characterController.center\n  1111→                             - (Vector3.up * _characterController.height / 2f)\n  1112→                             + Vector3.up * _characterController.skinWidth\n  1113→                             + Vector3.up * _characterController.radius;\n  1114→\n  1115→            _capsulePoint2 = transform.position\n  1116→                             + _characterController.center\n  1117→                             + (Vector3.up * _characterController.height / 2f)\n  1118→                             - Vector3.up * _characterController.skinWidth\n  1119→                             - Vector3.up * _characterController.radius;\n  1120→\n  1121→            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n  1122→                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n  1123→            {\n  1124→                transform.position = newPosition;\n  1125→            }\n  1126→        }\n  1127→\n  1128→        /// <summary>\n  1129→        /// 调整碰撞器高度（用于蹲伏等）\n  1130→        /// </summary>\n  1131→        /// <param name=\"newHeight\">新高度</param>\n  1132→        /// <param name=\"translateCenter\">是否平移中心点</param>\n  1133→        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n  1134→        {\n  1135→            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n  1136→            _characterController.height = newHeight;\n  1137→            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n  1138→\n  1139→            if (translateCenter)\n  1140→            {\n  1141→                transform.Translate((newYOffset / 2f) * Vector3.up);\n  1142→            }\n  1143→        }\n  1144→\n  1145→        /// <summary>\n  1146→        /// 重置碰撞器尺寸到原始大小\n  1147→        /// </summary>\n  1148→        public virtual void ResetColliderSize()\n  1149→        {\n  1150→            _characterController.height = _originalColliderHeight;\n  1151→            _characterController.center = _originalColliderCenter;\n  1152→        }\n  1153→\n  1154→        /// <summary>\n  1155→        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n  1156→        /// </summary>\n  1157→        public virtual bool CanGoBackToOriginalSize()\n  1158→        {\n  1159→            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n  1160→            {\n  1161→                return true;\n  1162→            }\n  1163→\n  1164→            float headCheckDistance =\n  1165→                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n  1166→            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n  1167→\n  1168→            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n  1169→                ObstaclesLayerMask, Color.cyan, true);\n  1170→\n  1171→            return _canGoBackHeadCheck.collider == null;\n  1172→        }\n  1173→\n  1174→        /// <summary>\n  1175→        /// 启用碰撞\n  1176→        /// </summary>\n  1177→        public virtual void CollisionsOn()\n  1178→        {\n  1179→            if (_characterController != null)\n  1180→            {\n  1181→                _characterController.enabled = true;\n  1182→            }\n  1183→        }\n  1184→\n  1185→        /// <summary>\n  1186→        /// 禁用碰撞\n  1187→        /// </summary>\n  1188→        public virtual void CollisionsOff()\n  1189→        {\n  1190→            if (_characterController != null)\n  1191→            {\n  1192→                _characterController.enabled = false;\n  1193→            }\n  1194→        }\n  1195→\n  1196→        /// <summary>\n  1197→        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n  1198→        /// </summary>\n  1199→        public virtual void SetKinematic(bool state)\n  1200→        {\n  1201→            _rigidBody.isKinematic = state;\n  1202→        }\n  1203→\n  1204→        /// <summary>\n  1205→        /// 设置是否允许自由移动\n  1206→        /// </summary>\n  1207→        public virtual void SetFreeMovement(bool state)\n  1208→        {\n  1209→            _freeMovement = state;\n  1210→        }\n  1211→\n  1212→        /// <summary>\n  1213→        /// 检测四个基本方向的障碍物\n  1214→        /// </summary>\n  1215→        /// <param name=\"distance\">检测距离</param>\n  1216→        /// <param name=\"offset\">起始偏移</param>\n  1217→        public virtual void DetectObstacles(float distance, Vector3 offset)\n  1218→        {\n  1219→            if (!PerformCardinalObstacleRaycastDetection)\n  1220→            {\n  1221→                return;\n  1222→            }\n  1223→\n  1224→            CollidingWithCardinalObstacle = false;\n  1225→\n  1226→            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n  1227→                ObstaclesLayerMask, Color.yellow, true);\n  1228→            if (_cardinalRaycast.collider != null)\n  1229→            {\n  1230→                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n  1231→                CollidingWithCardinalObstacle = true;\n  1232→            }\n  1233→            else\n  1234→            {\n  1235→                DetectedObstacleRight = null;\n  1236→            }\n  1237→\n  1238→            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n  1239→                ObstaclesLayerMask, Color.yellow, true);\n  1240→            if (_cardinalRaycast.collider != null)\n  1241→            {\n  1242→                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n  1243→                CollidingWithCardinalObstacle = true;\n  1244→            }\n  1245→            else\n  1246→            {\n  1247→                DetectedObstacleLeft = null;\n  1248→            }\n  1249→\n  1250→            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n  1251→                ObstaclesLayerMask, Color.yellow, true);\n  1252→            if (_cardinalRaycast.collider != null)\n  1253→            {\n  1254→                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n  1255→                CollidingWithCardinalObstacle = true;\n  1256→            }\n  1257→            else\n  1258→            {\n  1259→                DetectedObstacleUp = null;\n  1260→            }\n  1261→\n  1262→            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n  1263→                ObstaclesLayerMask, Color.yellow, true);\n  1264→            if (_cardinalRaycast.collider != null)\n  1265→            {\n  1266→                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n  1267→                CollidingWithCardinalObstacle = true;\n  1268→            }\n  1269→            else\n  1270→            {\n  1271→                DetectedObstacleDown = null;\n  1272→            }\n  1273→        }\n  1274→\n  1275→        /// <summary>\n  1276→        /// 重置控制器到初始状态\n  1277→        /// </summary>\n  1278→        public virtual void ResetController()\n  1279→        {\n  1280→            _impact = Vector3.zero;\n  1281→            GravityActive = true;\n  1282→            _speed = Vector3.zero;\n  1283→            _velocity = Vector3.zero;\n  1284→            _velocityLastFrame = Vector3.zero;\n  1285→            _acceleration = Vector3.zero;\n  1286→            _grounded = true;\n  1287→            _justGotGrounded = false;\n  1288→            _currentMovement = Vector3.zero;\n  1289→            _currentDirection = Vector3.zero;\n  1290→            _addedForce = Vector3.zero;\n  1291→            _idealDirection = Vector3.zero;\n  1292→            _idealVelocity = Vector3.zero;\n  1293→            _newVelocity = Vector3.zero;\n  1294→            _movingPlatformVelocity = Vector3.zero;\n  1295→            _movingPlatformCurrentHitCollider = null;\n  1296→            _movingPlatformHitCollider = null;\n  1297→            _lastGroundNormal = Vector3.zero;\n  1298→            _detached = false;\n  1299→            _frameVelocity = Vector3.zero;\n  1300→            _hitPoint = Vector3.zero;\n  1301→            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n  1302→            \n  1303→            // 重置平滑移动相关变量\n  1304→            _pendingMotion = Vector3.zero;\n  1305→            _smoothedMotion = Vector3.zero;\n  1306→\n  1307→            if (_rigidBody != null)\n  1308→            {\n  1309→                bool isKinematic = _rigidBody.isKinematic;\n  1310→                _rigidBody.isKinematic = false;\n  1311→                _rigidBody.linearVelocity = Vector3.zero;\n  1312→                _rigidBody.angularVelocity = Vector3.zero;\n  1313→                _rigidBody.isKinematic = isKinematic;\n  1314→            }\n  1315→        }\n  1316→\n  1317→        /// <summary>\n  1318→        /// 3D 射线检测辅助方法（带可视化调试）\n  1319→        /// </summary>\n  1320→        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n  1321→            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n  1322→        {\n  1323→            RaycastHit hit;\n  1324→            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n  1325→\n  1326→            if (Camera.current != null && (drawInSceneView || drawInGameView))\n  1327→            {\n  1328→                Debug.DrawRay(origin, direction * distance, color);\n  1329→            }\n  1330→\n  1331→            return hit;\n  1332→        }\n  1333→    }\n  1334→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a65e3dc7-bdef-48e7-b64e-e4d8ee3a50d5","timestamp":"2025-12-15T11:44:56.228Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","content":"using System;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing ActionMachine.Runtime.Attributes;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 运动学角色控制器（Kinematic Character Controller）\n    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    /// </summary>\n    [RequireComponent(typeof(CharacterController))]\n    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    public partial class Kcc : MonoBehaviour\n    {\n        private const float SMALL_VALUE = 0.0001f; // 浮点数比较的最小阈值\n        private const float SPEED_ROUNDING_PRECISION = 100f; // 速度值舍入精度\n        private const float IMPACT_THRESHOLD = 0.2f; // 冲击力应用的最小阈值\n\n        /// <summary>\n        /// 地面检测计算模式\n        /// </summary>\n        public enum GroundedComputationMode\n        {\n            Simple, // 简单模式：使用 CharacterController.isGrounded\n            Advanced // 高级模式：使用多方向射线检测\n        }\n\n        /// <summary>\n        /// 速度传递模式（用于移动平台交互）\n        /// </summary>\n        public enum VelocityTransferMode\n        {\n            NoTransfer, // 不传递速度\n            InitialVelocity, // 传递初始速度\n            FloorVelocity, // 传递地面速度\n            Relative // 相对速度模式\n        }\n\n        [Header(\"Gravity Settings\")] [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n        public float Gravity = 40f;\n\n        [Tooltip(\"是否激活重力\")] public bool GravityActive = true;\n\n        [Header(\"Raycast Settings\")] [Tooltip(\"障碍物层遮罩\")]\n        public LayerMask ObstaclesLayerMask;\n\n        [Tooltip(\"向下射线检测长度\")] public float GroundedRaycastLength = 5f;\n\n        [Tooltip(\"最小着地距离\")] public float MinimumGroundedDistance = 0.2f;\n\n        [Tooltip(\"地面检测计算模式\")] public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n\n        [Tooltip(\"地面法线高度阈值\")] public float GroundNormalHeightThreshold = 0.2f;\n\n        [Tooltip(\"蹲伏时射线长度倍数\")] public float CrouchedRaycastLengthMultiplier = 1f;\n\n        [Tooltip(\"是否执行基本方向障碍物射线检测\")] public bool PerformCardinalObstacleRaycastDetection = false;\n\n        [Header(\"Movement Settings\")] [Tooltip(\"最大下落速度\")]\n        public float MaximumFallSpeed = 20.0f;\n\n        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速\")] \n        public float HorizontalAcceleration = 20f;\n\n        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速\")] \n        public float HorizontalDeceleration = 20f;\n        \n        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n        public float InitialBurstMultiplier = 2.0f;\n        \n        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n        public float BurstSpeedThreshold = 1.0f;\n\n        [Tooltip(\"斜坡速度倍数曲线\")] public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n            new Keyframe(-90, 1),\n            new Keyframe(0, 1),\n            new Keyframe(90, 0)\n        );\n\n        [Tooltip(\"冲击力衰减速度\")] public float ImpactFalloff = 5f;\n\n        [Header(\"Steep Surface Settings\")] [Tooltip(\"是否在陡峭表面滑动\")]\n        public bool SlideOnSteepSurfaces = true;\n\n        [Tooltip(\"滑动速度\")] public float SlidingSpeed = 15f;\n\n        [Tooltip(\"滑动速度控制\")] public float SlidingSpeedControl = 0.4f;\n\n        [Tooltip(\"滑动方向控制\")] public float SlidingDirectionControl = 1f;\n\n        [Header(\"Moving Platform Settings\")] [Tooltip(\"跳跃时的速度传递方式\")]\n        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Movement Smoothing\")]\n        [Tooltip(\"是否启用移动平滑\")]\n        public bool EnableMovementSmoothing = true;\n        \n        [Tooltip(\"水平移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float HorizontalSmoothTime = 0.03f;\n        \n        [Tooltip(\"垂直移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float VerticalSmoothTime = 0.05f;\n\n        [Header(\"Runtime State - Read Only\")]\n        [SerializeField, ReadOnly] private Vector3 _speed;\n        [SerializeField, ReadOnly] private Vector3 _velocity;\n        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n        [SerializeField, ReadOnly] private Vector3 _acceleration;\n        [SerializeField, ReadOnly] private bool _grounded;\n        [SerializeField, ReadOnly] private bool _justGotGrounded;\n        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n        [SerializeField, ReadOnly] private float _friction;\n        [SerializeField, ReadOnly] private Vector3 _addedForce;\n        [SerializeField, ReadOnly] private bool _freeMovement = true;\n        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n\n        // 公共只读属性\n        public Vector3 Speed => _speed;\n        public Vector3 Velocity => _velocity;\n        public Vector3 VelocityLastFrame => _velocityLastFrame;\n        public Vector3 Acceleration => _acceleration;\n        public bool Grounded => _grounded;\n        public bool JustGotGrounded => _justGotGrounded;\n        public Vector3 CurrentMovement => _currentMovement;\n        public Vector3 CurrentDirection => _currentDirection;\n        public float Friction => _friction;\n        public Vector3 AddedForce => _addedForce;\n        public bool FreeMovement => _freeMovement;\n        public Vector3 GroundNormal => _groundNormal;\n        public Vector3 InputMoveDirection => _inputMoveDirection;\n        public Vector3 TargetVelocity => _targetVelocity;\n\n        // 碰撞器相关属性\n        public Vector3 ColliderCenter => transform.position + _characterController.center;\n\n        public Vector3 ColliderBottom => transform.position + _characterController.center +\n                                         Vector3.down * _characterController.bounds.extents.y;\n\n        public Vector3 ColliderTop => transform.position + _characterController.center +\n                                      Vector3.up * _characterController.bounds.extents.y;\n\n        public Vector3 AppliedImpact => _impact;\n\n        // 环境检测属性\n        public GameObject ObjectBelow { get; set; }\n        public GameObject DetectedObstacleLeft { get; set; }\n        public GameObject DetectedObstacleRight { get; set; }\n        public GameObject DetectedObstacleUp { get; set; }\n        public GameObject DetectedObstacleDown { get; set; }\n        public bool CollidingWithCardinalObstacle { get; set; }\n        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n\n        // 移动平台相关属性\n        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n\n        // 组件引用\n        private Transform _transform;\n        private CharacterController _characterController;\n\n        // 碰撞器原始尺寸\n        private float _originalColliderHeight;\n        private Vector3 _originalColliderCenter;\n\n        // 运动状态追踪\n        private Vector3 _positionLastFrame;\n        private bool _groundedLastFrame;\n        private Vector3 _impact;\n        private Vector3 _lastGroundNormal = Vector3.zero;\n        private bool _detached = false;\n        private bool _tooSteepLastFrame;\n\n        // 移动平台追踪\n        private Transform _movingPlatformHitCollider;\n        private Transform _movingPlatformCurrentHitCollider;\n        private Vector3 _movingPlatformCurrentHitColliderLocal;\n        private Vector3 _movingPlatformCurrentGlobalPoint;\n        private Quaternion _movingPlatformLocalRotation;\n        private Quaternion _movingPlatformGlobalRotation;\n        private Quaternion _lastMoveWithPlatformGlobalRotation;\n        private Matrix4x4 _lastMovingPlatformMatrix;\n        private Vector3 _movingPlatformVelocity;\n        private bool _newMovingPlatform;\n\n        // 碰撞检测\n        private CollisionFlags _collisionFlags;\n        private Vector3 _frameVelocity = Vector3.zero;\n        private Vector3 _hitPoint = Vector3.zero;\n        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n        // 速度计算\n        private Vector3 _newVelocity;\n        private Vector3 _motion;\n        private Vector3 _idealVelocity;\n        private Vector3 _idealDirection;\n        private Vector3 _horizontalVelocityDelta;\n        private float _stickyOffset = 0f;\n\n        // 位置移动\n        private RaycastHit _movePositionHit;\n        private Vector3 _capsulePoint1;\n        private Vector3 _capsulePoint2;\n        private Vector3 _movePositionDirection;\n        private float _movePositionDistance;\n\n        // 障碍物检测\n        private RaycastHit _cardinalRaycast;\n        private float _smallestDistance = Single.MaxValue;\n        private float _longestDistance = Single.MinValue;\n        private RaycastHit _smallestRaycast;\n        private RaycastHit _emptyRaycast = new RaycastHit();\n        private Vector3 _downRaycastsOffset;\n\n        // 平台移动计算\n        private Vector3 _moveWithPlatformMoveDistance;\n        private Vector3 _moveWithPlatformGlobalPoint;\n        private Quaternion _moveWithPlatformRotationDiff;\n        private Quaternion _moveWithPlatformGlobalRotation;\n        private RaycastHit _raycastDownHit;\n        private Vector3 _raycastDownDirection = Vector3.down;\n        private RaycastHit _canGoBackHeadCheck;\n        private Vector3 _originalSizeRaycastOrigin;\n\n        // 协程和可选组件\n        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        \n        // 逻辑帧与渲染帧分离\n        private Vector3 _pendingMotion = Vector3.zero;\n        private float _lastLogicDeltaTime = 0f; // 保存逻辑帧的时间增量\n        \n        // 移动平滑相关\n        private Vector3 _smoothedMotion = Vector3.zero;\n        private Vector3 _motionVelocity = Vector3.zero; // SmoothDamp 速度缓存\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n        /// <summary>\n        /// 检查角色头部是否与物体碰撞\n        /// </summary>\n        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n\n        /// <summary>\n        /// 检查当前地面是否过于陡峭\n        /// </summary>\n        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n\n        /// <summary>\n        /// 初始化组件和缓存引用\n        /// </summary>\n        protected virtual void Awake()\n        {\n            _characterController = GetComponent<CharacterController>();\n            _transform = transform;\n            _rigidBody = GetComponent<Rigidbody>();\n\n            _originalColliderHeight = _characterController.height;\n            _originalColliderCenter = _characterController.center;\n            _currentDirection = _transform.forward;\n        }\n\n        /// <summary>\n        /// 固定时间更新（物理帧，处理物理相关的计算）\n        /// 负责物理模拟、重力计算、碰撞检测等需要固定时间步长的操作\n        /// </summary>\n        protected virtual void FixedUpdate()\n        {\n            // 物理相关的固定更新\n            ProcessFixedUpdate();\n        }\n\n        /// <summary>\n        /// 每帧更新（渲染帧，处理输入和实际移动）\n        /// 负责输入处理、实际移动执行、视觉效果等需要每帧更新的操作\n        /// </summary>\n        protected virtual void Update()\n        {\n            // 渲染帧更新\n            ProcessRenderUpdate();\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 负责游戏逻辑计算，如移动意图、状态机更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 逻辑帧更新\n            ProcessLogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 延迟更新，目前为空方法，保留用于扩展\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            // LateUpdate 不再处理 _velocityLastFrame，改为在 LogicUpdate 中处理\n        }\n\n        /// <summary>\n        /// 固定更新处理（物理帧）\n        /// 处理物理相关的计算，确保物理模拟的一致性\n        /// </summary>\n        protected virtual void ProcessFixedUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 物理相关的固定更新\n            // 1. 重力计算（固定时间步长确保物理一致性）\n            if (GravityActive)\n            {\n                ApplyGravityFixed(Time.fixedDeltaTime);\n            }\n\n            // 2. 移动平台速度计算（物理相关）\n            GetMovingPlatformVelocity();\n            \n            // 3. 应用冲击力（物理相关，固定时间步长）\n            ApplyImpact(Time.fixedDeltaTime);\n        }\n\n        /// <summary>\n        /// 渲染更新处理（每帧）\n        /// 处理实际的移动执行和视觉效果\n        /// </summary>\n        protected virtual void ProcessRenderUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 1. 基于当前速度和渲染帧时间重新计算移动\n            CalculateRenderFrameMotion();\n            \n            // 2. 执行实际的移动（每帧执行，确保视觉流畅）\n            ExecutePendingMove();\n        }\n\n        /// <summary>\n        /// 逻辑更新处理（逻辑帧）\n        /// 处理游戏逻辑计算，如移动意图、状态更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        protected virtual void ProcessLogicUpdate(float deltaTime)\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 保存逻辑帧时间增量，用于渲染帧的移动计算\n            _lastLogicDeltaTime = deltaTime;\n\n            // 保存上一帧状态（在 LogicUpdate 开始时保存，确保时序正确）\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测（逻辑相关）\n            CheckIfGrounded();\n            \n            // 2. 处理摩擦力（逻辑相关）\n            HandleFriction();\n            \n            // 3. 确定移动方向（基于输入）\n            DetermineDirection();\n            \n            // 4. 处理输入移动（逻辑计算，不实际移动）\n            AddInput(deltaTime);\n            \n            // 5. 处理重力（逻辑计算，不包含固定更新中的重力）\n            AddGravityLogic(deltaTime);\n            \n            // 6. 处理移动平台（逻辑计算）\n            MoveWithPlatform();\n            \n            // 7. 计算速度变化（逻辑计算）\n            ComputeVelocityDelta(deltaTime);\n            \n            // 8. 计算新速度（逻辑状态更新）\n            ComputeNewVelocity(deltaTime);\n            \n            // 9. 计算实际速度（基于逻辑帧时间增量）\n            ComputeSpeed(deltaTime);\n        }\n        \n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n                _idealVelocity = _idealVelocity * SlidingSpeed;\n                _targetVelocity = _idealVelocity;\n                _newVelocity = _idealVelocity;\n                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n            }\n            else\n            {\n                _targetVelocity = _currentMovement;\n                \n                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n                \n                Vector3 newHorizontalVelocity;\n                \n                if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                {\n                    float effectiveAcceleration = HorizontalAcceleration;\n                    \n                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n                    {\n                        effectiveAcceleration *= InitialBurstMultiplier;\n                    }\n                    \n                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n                    \n\n                    \n                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n                    {\n                        newHorizontalVelocity = targetHorizontalVelocity;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n                    }\n                }\n                else\n                {\n                    float currentSpeed = currentHorizontalVelocity.magnitude;\n                    float speedReduction = HorizontalDeceleration * deltaTime;\n                    \n\n                    \n                    if (currentSpeed <= speedReduction)\n                    {\n                        newHorizontalVelocity = Vector3.zero;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n                    }\n                }\n                \n                _newVelocity.x = newHorizontalVelocity.x;\n                _newVelocity.z = newHorizontalVelocity.z;\n                \n\n                \n                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    Vector3 floorVelocity = _frameVelocity;\n                    floorVelocity.y = 0;\n                    _newVelocity.x += floorVelocity.x;\n                    _newVelocity.z += floorVelocity.z;\n                }\n                \n                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n                    \n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity.normalized;\n                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n                        \n                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n                        {\n                            projectedDirection.Normalize();\n                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                        }\n                    }\n                    \n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 固定更新中的重力应用（物理帧）\n        /// </summary>\n        /// <param name=\"deltaTime\">固定时间增量</param>\n        protected virtual void ApplyGravityFixed(float deltaTime)\n        {\n            // 固定更新中的重力处理，主要用于物理一致性\n            // 这里可以添加需要在固定时间步长中处理的重力相关逻辑\n        }\n\n        /// <summary>\n        /// 逻辑更新中的重力应用（逻辑帧）\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑时间增量</param>\n        protected virtual void AddGravityLogic(float deltaTime)\n        {\n            if (GravityActive)\n            {\n                if (_grounded)\n                {\n                    _newVelocity.y = -Gravity * deltaTime;\n\n                }\n                else\n                {\n                    float oldY = _newVelocity.y;\n                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n\n                }\n            }\n\n            _newVelocity += _addedForce;\n            _addedForce = Vector3.zero;\n        }\n\n        /// <summary>\n        /// 应用重力到速度（保持向后兼容）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddGravity(float deltaTime)\n        {\n            AddGravityLogic(deltaTime);\n        }\n\n        /// <summary>\n        /// 跟随移动平台移动\n        /// </summary>\n        protected virtual void MoveWithPlatform()\n        {\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _moveWithPlatformMoveDistance = Vector3.zero;\n                _moveWithPlatformGlobalPoint =\n                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n\n                if (_moveWithPlatformMoveDistance != Vector3.zero)\n                {\n                    _characterController.Move(_moveWithPlatformMoveDistance);\n                }\n\n                _moveWithPlatformGlobalRotation =\n                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n            }\n        }\n\n        /// <summary>\n        /// 计算速度增量和粘性偏移\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeVelocityDelta(float deltaTime)\n        {\n            _motion = _newVelocity * deltaTime;\n            _horizontalVelocityDelta.x = _motion.x;\n            _horizontalVelocityDelta.y = 0f;\n            _horizontalVelocityDelta.z = _motion.z;\n            _stickyOffset = Mathf.Max(_characterController.stepOffset, _horizontalVelocityDelta.magnitude);\n\n            if (_grounded)\n            {\n                _motion -= _stickyOffset * Vector3.up;\n            }\n        }\n\n        /// <summary>\n        /// 基于当前速度和渲染帧时间重新计算移动\n        /// Logic 赋值 Velocity，Render 对这个进行插值渲染\n        /// </summary>\n        protected virtual void CalculateRenderFrameMotion()\n        {\n            // 根据速度动态调整时间增量，避免高速时移动幅度过大\n            float speedMagnitude = _velocity.magnitude;\n            float adjustedDeltaTime = Time.deltaTime;\n            \n            // 高速时减少有效时间增量，控制移动幅度\n            if (speedMagnitude > 8f)\n            {\n                // 速度越高，时间增量缩放越小\n                // 扩展速度范围到 100，支持更高的速度\n                float speedFactor = Mathf.InverseLerp(8f, 100f, speedMagnitude);\n                adjustedDeltaTime *= Mathf.Lerp(1f, 0.05f, speedFactor);\n            }\n            \n            // 使用调整后的时间增量计算移动向量\n            Vector3 targetMotion = _velocity * adjustedDeltaTime;\n            \n            // 应用地面接触的粘性偏移（如果需要）\n            if (_grounded)\n            {\n                Vector3 horizontalMotion = new Vector3(targetMotion.x, 0, targetMotion.z);\n                float stickyOffset = Mathf.Max(_characterController.stepOffset * 0.1f, horizontalMotion.magnitude * 0.01f);\n                targetMotion.y -= stickyOffset;\n            }\n            \n            // 应用移动平滑（如果启用）\n            if (EnableMovementSmoothing)\n            {\n                _pendingMotion = CalculateSmoothedMotion(targetMotion);\n            }\n            else\n            {\n                _pendingMotion = targetMotion;\n            }\n        }\n\n        /// <summary>\n        /// 执行待处理的移动（在渲染帧中调用）\n        /// 执行实际的物理移动和碰撞检测\n        /// </summary>\n        protected virtual void ExecutePendingMove()\n        {\n            // 1. 执行实际的 CharacterController 移动\n            MoveCharacterController();\n            \n            // 2. 检测新的移动平台（碰撞相关）\n            DetectNewMovingPlatform();\n            \n            // 3. 手动处理碰撞器碰撞（物理相关）\n            ManualControllerColliderHit();\n            \n            // 4. 处理地面接触状态（物理相关）\n            HandleGroundContact();\n        }\n\n        /// <summary>\n        /// 执行 CharacterController 移动\n        /// </summary>\n        protected virtual void MoveCharacterController()\n        {\n            _groundNormal = Vector3.zero;\n            \n            // 直接使用基于渲染帧时间计算的移动向量\n            _collisionFlags = _characterController.Move(_pendingMotion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n        \n        /// <summary>\n        /// 计算平滑后的移动向量\n        /// 使用简单的 Lerp 进行平滑，避免过度复杂化\n        /// </summary>\n        /// <param name=\"targetMotion\">目标移动向量</param>\n        /// <returns>平滑后的移动向量</returns>\n        protected virtual Vector3 CalculateSmoothedMotion(Vector3 targetMotion)\n        {\n            // 计算目标移动的幅度，用于动态调整平滑强度\n            float targetMagnitude = targetMotion.magnitude;\n            \n            // 基于移动幅度动态调整平滑时间\n            // 移动距离越大，需要更强的平滑\n            float dynamicSmoothTime = 0.016f; // 基础平滑时间（60fps）\n            \n            if (targetMagnitude > 0.1f) // 只对有明显移动时进行调整\n            {\n                // 移动距离越大，平滑时间越长\n                // 这样可以确保高速移动时有足够的平滑\n                dynamicSmoothTime = Mathf.Lerp(0.016f, 0.1f, Mathf.InverseLerp(0.1f, 0.5f, targetMagnitude));\n            }\n            \n            // 使用 SmoothDamp 进行平滑，它能更好地处理不同幅度的移动\n            Vector3 smoothed = Vector3.SmoothDamp(_smoothedMotion, targetMotion, ref _motionVelocity, \n                                                 dynamicSmoothTime, Mathf.Infinity, Time.deltaTime);\n            \n            _smoothedMotion = smoothed;\n            \n            // 防抖动处理\n            if (targetMotion.sqrMagnitude < 0.001f * 0.001f)\n            {\n                _smoothedMotion *= 0.9f;\n                if (_smoothedMotion.sqrMagnitude < 0.0001f)\n                {\n                    _smoothedMotion = Vector3.zero;\n                    _motionVelocity = Vector3.zero;\n                }\n            }\n            \n            return _smoothedMotion;\n        }\n\n        /// <summary>\n        /// 检测是否踩上新的移动平台\n        /// </summary>\n        protected virtual void DetectNewMovingPlatform()\n        {\n            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n            {\n                if (_movingPlatformHitCollider != null)\n                {\n                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n                    _newMovingPlatform = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 计算新速度和加速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeNewVelocity(float deltaTime)\n        {\n            _velocity = _newVelocity;\n            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n        }\n\n        /// <summary>\n        /// 处理地面接触状态和平台速度传递\n        /// </summary>\n        protected virtual void HandleGroundContact()\n        {\n            _grounded = _characterController.isGrounded;\n\n            if (_grounded && !IsGroundedTest())\n            {\n                _grounded = false;\n                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    _frameVelocity = _movingPlatformVelocity;\n                    _velocity += _movingPlatformVelocity;\n                }\n            }\n            else if (!_grounded && IsGroundedTest())\n            {\n                if (_detached && _velocity.y <= 0)\n                {\n                    _grounded = true;\n                    _detached = false;\n                }\n\n                SubtractNewPlatformVelocity();\n            }\n\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _movingPlatformCurrentGlobalPoint = _transform.position;\n                _movingPlatformCurrentHitColliderLocal =\n                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n                _movingPlatformGlobalRotation = _transform.rotation;\n                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n                                               _movingPlatformGlobalRotation;\n            }\n\n            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n            _tooSteepLastFrame = TooSteep();\n        }\n\n        /// <summary>\n        /// 计算当前速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeSpeed(float deltaTime)\n        {\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _positionLastFrame) / deltaTime;\n            }\n\n            // 暂时禁用速度舍入，避免高速时的舍入误差导致抖动\n            // _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            // _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            // _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            \n            _positionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 根据当前移动向量确定方向\n        /// </summary>\n        protected virtual void DetermineDirection()\n        {\n            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n            {\n                _currentDirection = _currentMovement.normalized;\n            }\n        }\n\n        /// <summary>\n        /// 处理摩擦力（预留方法，可在子类中实现）\n        /// </summary>\n        protected virtual void HandleFriction()\n        {\n        }\n\n        /// <summary>\n        /// 检查是否刚刚着地\n        /// </summary>\n        protected virtual void CheckIfGrounded()\n        {\n            _justGotGrounded = !_groundedLastFrame && _grounded;\n            _groundedLastFrame = _grounded;\n        }\n\n        /// <summary>\n        /// 手动触发碰撞器碰撞处理\n        /// </summary>\n        protected virtual void ManualControllerColliderHit()\n        {\n            HandleAdvancedGroundDetection();\n        }\n\n        /// <summary>\n        /// 高级地面检测（使用多方向射线）\n        /// </summary>\n        protected virtual void HandleAdvancedGroundDetection()\n        {\n            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n            {\n                return;\n            }\n\n            _smallestDistance = Single.MaxValue;\n            _longestDistance = Single.MinValue;\n            _smallestRaycast = _emptyRaycast;\n\n            float offset = _characterController.radius;\n\n            _downRaycastsOffset = Vector3.zero;\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, offset);\n            CastRayDownwards();\n\n            if (_smallestRaycast.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n\n                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n                {\n                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n                    {\n                        _groundNormal = _smallestRaycast.normal;\n                    }\n                    else\n                    {\n                        _groundNormal = _lastGroundNormal;\n                    }\n\n                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n                    _hitPoint = _smallestRaycast.point;\n                    _frameVelocity = Vector3.zero;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 向下发射射线检测地面\n        /// </summary>\n        protected virtual void CastRayDownwards()\n        {\n            if (_smallestDistance <= MinimumGroundedDistance)\n            {\n                return;\n            }\n\n            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n                _raycastDownDirection, out _raycastDownHit,\n                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n\n            if (_raycastDownHit.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n\n                if (adjustedDistance < _smallestDistance)\n                {\n                    _smallestDistance = adjustedDistance;\n                    _smallestRaycast = _raycastDownHit;\n                }\n\n                if (adjustedDistance > _longestDistance)\n                {\n                    _longestDistance = adjustedDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n        /// </summary>\n        protected float AdjustDistance(float distance)\n        {\n            return distance - _characterController.height / 2f - _characterController.skinWidth;\n        }\n\n        /// <summary>\n        /// 测试是否真正着地\n        /// </summary>\n        protected virtual bool IsGroundedTest()\n        {\n            bool grounded = false;\n            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n            {\n                if (_smallestDistance <= MinimumGroundedDistance)\n                {\n                    grounded = _groundNormal.y > 0.01f;\n                }\n            }\n            else\n            {\n                grounded = _characterController.isGrounded;\n                _groundNormal = Vector3.up;\n            }\n\n            return grounded;\n        }\n\n        /// <summary>\n        /// 获取移动平台速度\n        /// </summary>\n        protected virtual void GetMovingPlatformVelocity()\n        {\n            if (_movingPlatformCurrentHitCollider != null)\n            {\n                if (!_newMovingPlatform && Time.fixedDeltaTime > SMALL_VALUE)\n                {\n                    _movingPlatformVelocity = (\n                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n                            _movingPlatformCurrentHitColliderLocal)\n                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n                    ) / Time.fixedDeltaTime;\n                }\n\n                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n                _newMovingPlatform = false;\n            }\n            else\n            {\n                _movingPlatformVelocity = Vector3.zero;\n            }\n        }\n\n        /// <summary>\n        /// 减去新平台速度（处理平台切换）\n        /// </summary>\n        protected virtual void SubtractNewPlatformVelocity()\n        {\n            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n            {\n                if (_newMovingPlatform)\n                {\n                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n                }\n                else\n                {\n                    _velocity -= _movingPlatformVelocity;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 协程：延迟减去平台速度\n        /// </summary>\n        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n        {\n            Transform platform = _movingPlatformCurrentHitCollider;\n            yield return _waitForFixedUpdate;\n            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n            {\n                yield return null;\n            }\n\n            _velocity -= _movingPlatformVelocity;\n        }\n\n        /// <summary>\n        /// 判断是否应该跟随平台移动\n        /// </summary>\n        protected virtual bool ShouldMoveWithPlatformThisFrame()\n        {\n            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n                   && _movingPlatformCurrentHitCollider != null;\n        }\n\n        /// <summary>\n        /// 应用冲击力并逐渐衰减\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ApplyImpact(float deltaTime)\n        {\n            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n            {\n                _characterController.Move(_impact * deltaTime);\n            }\n\n            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * deltaTime);\n        }\n\n        /// <summary>\n        /// 从地面分离（用于跳跃等）\n        /// </summary>\n        public virtual void DetachFromGround()\n        {\n            _detached = true;\n        }\n\n        /// <summary>\n        /// 从移动平台分离\n        /// </summary>\n        public virtual void DetachFromMovingPlatform()\n        {\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n        }\n\n        /// <summary>\n        /// 设置重力是否激活\n        /// </summary>\n        public virtual void SetGravityActive(bool status)\n        {\n            GravityActive = status;\n        }\n\n        /// <summary>\n        /// 添加外部力（会在下一帧应用）\n        /// </summary>\n        public virtual void AddForce(Vector3 movement)\n        {\n            _addedForce += movement;\n        }\n\n        /// <summary>\n        /// 施加瞬时冲击力\n        /// </summary>\n        /// <param name=\"direction\">冲击方向</param>\n        /// <param name=\"force\">冲击力大小</param>\n        public virtual void Impact(Vector3 direction, float force)\n        {\n            direction = direction.normalized;\n            if (direction.y < 0)\n            {\n                direction.y = -direction.y;\n            }\n\n            _impact += direction.normalized * force;\n        }\n\n        /// <summary>\n        /// 设置移动向量（通常由输入系统调用）\n        /// </summary>\n        /// <param name=\"movement\">移动向量</param>\n        public virtual void SetMovement(Vector3 movement)\n        {\n            _currentMovement = movement;\n\n            Vector3 directionVector = movement;\n            if (directionVector != Vector3.zero)\n            {\n                float directionLength = directionVector.magnitude;\n                directionVector = directionVector / directionLength;\n                directionLength = Mathf.Min(1, directionLength);\n                // 移除平方操作，保持线性响应，避免高速时的非线性抖动\n                directionVector = directionVector * directionLength;\n            }\n\n            _inputMoveDirection = transform.rotation * directionVector;\n        }\n\n        /// <summary>\n        /// 移动到指定位置（带碰撞检测）\n        /// </summary>\n        /// <param name=\"newPosition\">目标位置</param>\n        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n        {\n            _movePositionDirection = newPosition - transform.position;\n            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n\n            _capsulePoint1 = transform.position\n                             + _characterController.center\n                             - (Vector3.up * _characterController.height / 2f)\n                             + Vector3.up * _characterController.skinWidth\n                             + Vector3.up * _characterController.radius;\n\n            _capsulePoint2 = transform.position\n                             + _characterController.center\n                             + (Vector3.up * _characterController.height / 2f)\n                             - Vector3.up * _characterController.skinWidth\n                             - Vector3.up * _characterController.radius;\n\n            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n            {\n                transform.position = newPosition;\n            }\n        }\n\n        /// <summary>\n        /// 调整碰撞器高度（用于蹲伏等）\n        /// </summary>\n        /// <param name=\"newHeight\">新高度</param>\n        /// <param name=\"translateCenter\">是否平移中心点</param>\n        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n        {\n            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n            _characterController.height = newHeight;\n            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n\n            if (translateCenter)\n            {\n                transform.Translate((newYOffset / 2f) * Vector3.up);\n            }\n        }\n\n        /// <summary>\n        /// 重置碰撞器尺寸到原始大小\n        /// </summary>\n        public virtual void ResetColliderSize()\n        {\n            _characterController.height = _originalColliderHeight;\n            _characterController.center = _originalColliderCenter;\n        }\n\n        /// <summary>\n        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n        /// </summary>\n        public virtual bool CanGoBackToOriginalSize()\n        {\n            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n            {\n                return true;\n            }\n\n            float headCheckDistance =\n                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n\n            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n                ObstaclesLayerMask, Color.cyan, true);\n\n            return _canGoBackHeadCheck.collider == null;\n        }\n\n        /// <summary>\n        /// 启用碰撞\n        /// </summary>\n        public virtual void CollisionsOn()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = true;\n            }\n        }\n\n        /// <summary>\n        /// 禁用碰撞\n        /// </summary>\n        public virtual void CollisionsOff()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = false;\n            }\n        }\n\n        /// <summary>\n        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n        /// </summary>\n        public virtual void SetKinematic(bool state)\n        {\n            _rigidBody.isKinematic = state;\n        }\n\n        /// <summary>\n        /// 设置是否允许自由移动\n        /// </summary>\n        public virtual void SetFreeMovement(bool state)\n        {\n            _freeMovement = state;\n        }\n\n        /// <summary>\n        /// 检测四个基本方向的障碍物\n        /// </summary>\n        /// <param name=\"distance\">检测距离</param>\n        /// <param name=\"offset\">起始偏移</param>\n        public virtual void DetectObstacles(float distance, Vector3 offset)\n        {\n            if (!PerformCardinalObstacleRaycastDetection)\n            {\n                return;\n            }\n\n            CollidingWithCardinalObstacle = false;\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleRight = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleLeft = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleUp = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleDown = null;\n            }\n        }\n\n        /// <summary>\n        /// 重置控制器到初始状态\n        /// </summary>\n        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n            \n            // 重置平滑移动相关变量\n            _pendingMotion = Vector3.zero;\n            _smoothedMotion = Vector3.zero;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n\n            return hit;\n        }\n    }\n}","numLines":1334,"startLine":1,"totalLines":1334}}}
{"parentUuid":"a65e3dc7-bdef-48e7-b64e-e4d8ee3a50d5","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VtDMKcxUjHWqgDpvzrF7hD","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"用户反映 Kcc.cs 脚本存在抖动问题，原因是 logicUpdate 和 Update 的执行时机不同。从代码来看：\n\n1. **当前架构**：\n   - `FixedUpdate()` - 物理帧，调用 `ProcessFixedUpdate()`\n   - `Update()` - 渲染帧，调用 `ProcessRenderUpdate()`\n   - `LogicUpdate(float deltaTime)` - 外部调用的逻辑帧，调用 `ProcessLogicUpdate(deltaTime)`\n\n2. **问题分析**：\n   - 逻辑帧 `LogicUpdate` 由外部（如 GameManager）以可变帧率调用\n   - 渲染帧 `Update` 由 Unity 的渲染循环调用\n   - 两者执行时机不同步，导致移动计算和实际移动之间存在时间差，造成抖动\n\n3. **用户的解决方案**：\n   用户想要移除 `LogicUpdate`，改为在 `Update` 中统一处理所有逻辑，这样逻辑计算和渲染移动在同一帧内完成，理论上可以减少抖动。\n\n让我帮用户修改代码，将 LogicUpdate 的逻辑整合到 Update 中。\n\n修改思路：\n1. 将 `ProcessLogicUpdate` 的逻辑整合到 `ProcessRenderUpdate` 中\n2. 移除或保留 `LogicUpdate` 接口（保留但标记为过时，避免破坏现有调用）\n3. 所有逻辑和渲染在 `Update` 中统一完成\n\n\n4. `FixedUpdate` 继续专注于物理相关的固定更新，保持独立性和稳定性。这样可以确保物理模拟的精确性，同时避免与渲染逻辑产生冲突。","signature":"EvgKCkYIChgCKkBjqy6uRtLh4EAYkE194KtaslWviuy7CGyCp+3CdWoP7jWgNCpZA/EbP+UGRPC/Ai8HHAMs1oQNdOav1zAaRb9PEgx6pBvqcGVYDLZFkKAaDA1fk6yRntBbK/usRSIww/S+5n7sUq4RbuejLQ4B+uRItSj49t1wYMGQ1DznODqhaF463lu7DhzWmnMOIuusKt8Jhw92AHzHEV5r3dwRkspPqAKM6pzw0t8AaN0aPeZrh0gY64WPMGc7K691HtOw1A2mW7EPW7DSM07I+fzFLKdcfhlC4F1jWLzi3wZAK2oUHI7ZTasXFyvK9bKns3//LM9DRj/L1Gnxw5YFICP0C2NVvcQkhtPAyHhx1SKOXuy//JELKvk7WA2K8z2kGRlJsdsPAwiIZawFmwdHVhoehrQa+2gLRjYu+QbP2XKcGu0o9atKizHjJZKcfQ/F1LAS2UC0putgeyd/YdTuaz9i/0lhXlRvcc6LC8kYft5VkLUUCqaBAa84puy9wTzUQN0sZaLk3f7RxWi69zivdcJ936e+sPQSlatm0mDimF4jc8QvA8nT2VZb2jH937Io+b2NeIbMAVesh3u82k2kkq2Zr1AyzW23edLEJB/w5HpMGFoCmAn1zCkHfbzGiiPkQcGHquTCXO0nk95uH0tC2D939/1W1k0cMdDkPwp2E50isoe1uTYlSmY+9L2OraKAOu9XsCPibuAHaqJXd6td2UlAKXZoZxAfPRfCpomyEWxxuwVYofabwJe5ALQy1u9J6NeEmJkPnMAkTZou2wgyOP+Uuu2hPpi/e5YLGtGYVN4r9yt4/xaBtqLdoyPPOsBj7KHGVtbzv8fnHiDrvonw/SKiDcuYS/9Np/LmY1kwAPKCYZis/hfRBNEK6g0+CefdcOkKNB08nVCm5FXL7cSfHAw+gXrtNcAT3b89Fd0jQfybyrj2/JpOkuZFaHf4A/wc3B6PXwg3KOQLSYv8fCsoUQeuAdTLJUV/gW6yopf6hMGTcqNXE3UQ2p6QDxn+QMYbFolznBIwiK8C31u/J3kmRfaf4V+k3yUpb4uwqz3wk+bq0jv1l/kth33cMXtbuhhNO2ywzj6E+F/sFssHbKy28jZJxZIuYK4mnYyc+ZhOAMGiYozERYvDbpZPIYhpi5Rm63GIxvvQ1gg9B+yFSQr+qQ59o6sCUb6WhP0LUKXx2aNhf7dh5aDU4WnHKjwIadfAQ+8nAyg1LFNWHYw9JbnKwKk9/OJU7jQOVGkTmCg1Az5s8imQhUKlLTU1j5CkcWb7zRXC91XDkO0L7f36s/tItXrnARn5c9RxJNWYaSC6KGJgVoFc9ffE8ole7y/Gx4EqPTXM5hMMgSnXn3K2ETUNEpYcowSiyvKb39Q1fl33fIyU6qrGCgLgzycdQimdYemyKP5pdba4He8n+3J4n7bukBfTiu/27lJA4JZE5gdus6wpefS4wkWtlbfM3Tqzk7Y5g+pTPWQNsrRU8bYVwG4qfpZQjBB+84CezOjCTpPqqXN14Vy8bVW8WRwV/lW9fP6btOQzLLdiJUwu8gcjEfNwMW+Lr6nqCgZG9XSmzu2aSjHgwZ5dbY9a35thavjtZZ8YqzjWfDLKcQhkKvAH023X1RTUdoCN3TbAVPPCxoNLHJsEKlGbqutNXGJTYHr04IRuRfzfsRoNGGHqEwUWWic1tfdliSAoT5QK2+slLaliBDqVPRrz62Vo3lyqPXkU+LNy8HkphjN3UyF8s4svKBD3JIirwsu60INt3NJWdcedcyUbaGRpgHpkU/0yDRuG0Q21np7Dppg9nDVFZSMhbZH3iyGZpEVfkuR2RoYwHMeRJrumyR7nMqNedMi4xgcKQ+4T5s61m0kYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":19681,"cache_read_input_tokens":45196,"cache_creation":{"ephemeral_5m_input_tokens":19681,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"cc65e1ed-4c56-4a16-8c0b-5e1cdfada77f","timestamp":"2025-12-15T11:45:11.816Z"}
{"parentUuid":"cc65e1ed-4c56-4a16-8c0b-5e1cdfada77f","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VtDMKcxUjHWqgDpvzrF7hD","type":"message","role":"assistant","content":[{"type":"text","text":"我看到了抖动的根本原因。当前的架构是：\n- **LogicUpdate** (可变帧率) - 计算移动逻辑\n- **ProcessRenderUpdate** (每帧) - 基于 LogicUpdate 的结果重新计算并执行移动\n\n两者执行时机不同导致移动计算和实际移动不同步，产生抖动。\n\n我来帮你修改，将所有逻辑整合到 `Update` 中统一处理，这样逻辑计算和移动执行在同一帧完成。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":19681,"cache_read_input_tokens":45196,"cache_creation":{"ephemeral_5m_input_tokens":19681,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"7ea47453-849c-444a-9222-530e312569d6","timestamp":"2025-12-15T11:45:13.065Z"}
{"parentUuid":"7ea47453-849c-444a-9222-530e312569d6","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VtDMKcxUjHWqgDpvzrF7hD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ThXiAimvP7Rv3ZWU8v5bXb","name":"Edit","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","old_string":"        /// <summary>\n        /// 每帧更新（渲染帧,处理输入和实际移动）\n        /// 负责输入处理、实际移动执行、视觉效果等需要每帧更新的操作\n        /// </summary>\n        protected virtual void Update()\n        {\n            // 渲染帧更新\n            ProcessRenderUpdate();\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 负责游戏逻辑计算，如移动意图、状态机更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 逻辑帧更新\n            ProcessLogicUpdate(deltaTime);\n        }","new_string":"        /// <summary>\n        /// 每帧更新（处理所有逻辑计算和移动执行）\n        /// 统一在 Update 中完成所有操作，避免 LogicUpdate 和 RenderUpdate 分离导致的抖动\n        /// </summary>\n        protected virtual void Update()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            float deltaTime = Time.deltaTime;\n\n            // 保存上一帧状态\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测\n            CheckIfGrounded();\n\n            // 2. 处理摩擦力\n            HandleFriction();\n\n            // 3. 确定移动方向\n            DetermineDirection();\n\n            // 4. 处理输入移动\n            AddInput(deltaTime);\n\n            // 5. 处理重力\n            AddGravityLogic(deltaTime);\n\n            // 6. 处理移动平台\n            MoveWithPlatform();\n\n            // 7. 计算速度变化\n            ComputeVelocityDelta(deltaTime);\n\n            // 8. 计算新速度\n            ComputeNewVelocity(deltaTime);\n\n            // 9. 执行实际移动\n            ExecuteMove(deltaTime);\n\n            // 10. 计算实际速度\n            ComputeSpeed(deltaTime);\n        }\n\n        /// <summary>\n        /// 逻辑更新（保留接口用于向后兼容，但不再使用）\n        /// 现在所有逻辑都在 Update 中处理，避免抖动问题\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        [System.Obsolete(\"LogicUpdate is no longer used. All logic is now handled in Update to avoid jitter.\")]\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 不再处理任何逻辑，所有逻辑已整合到 Update 中\n        }"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":19681,"cache_read_input_tokens":45196,"cache_creation":{"ephemeral_5m_input_tokens":19681,"ephemeral_1h_input_tokens":0},"output_tokens":1605,"service_tier":"standard"}},"type":"assistant","uuid":"cea5a44b-43d8-4da6-9d55-12d1f9defb17","timestamp":"2025-12-15T11:45:27.030Z"}
{"parentUuid":"cea5a44b-43d8-4da6-9d55-12d1f9defb17","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>String to replace not found in file.\nString:         /// <summary>\n        /// 每帧更新（渲染帧,处理输入和实际移动）\n        /// 负责输入处理、实际移动执行、视觉效果等需要每帧更新的操作\n        /// </summary>\n        protected virtual void Update()\n        {\n            // 渲染帧更新\n            ProcessRenderUpdate();\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 负责游戏逻辑计算，如移动意图、状态机更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 逻辑帧更新\n            ProcessLogicUpdate(deltaTime);\n        }</tool_use_error>","is_error":true,"tool_use_id":"toolu_01ThXiAimvP7Rv3ZWU8v5bXb"}]},"uuid":"a3ddb6f1-df75-45e7-b3a2-669dcb82a30d","timestamp":"2025-12-15T11:45:27.081Z","toolUseResult":"Error: String to replace not found in file.\nString:         /// <summary>\n        /// 每帧更新（渲染帧,处理输入和实际移动）\n        /// 负责输入处理、实际移动执行、视觉效果等需要每帧更新的操作\n        /// </summary>\n        protected virtual void Update()\n        {\n            // 渲染帧更新\n            ProcessRenderUpdate();\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 负责游戏逻辑计算，如移动意图、状态机更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 逻辑帧更新\n            ProcessLogicUpdate(deltaTime);\n        }"}
{"parentUuid":"a3ddb6f1-df75-45e7-b3a2-669dcb82a30d","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01EdncsVEgrSXp8V1CAN1z3i","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"需要重新读取代码，找到准确的字符串。让我再次检查代码中的准确格式。","signature":"EosCCkYIChgCKkBJ1OGZZ6d76QO2+gicYNlkkYl8N/8exqS6/Bjsi9wGqeIF/XzSigvGdWQ6hQMNYqgxuBQyW27ckrkYLAKaaR+KEgzOu2R+2c4MIxrjwEAaDLcSkq7w0dJO2VW49yIwZok6EsrDX8cuCt1MeCqQJrqBrgWHjwrkrWt730SLWeP6YYEUuCS6lFPhDhMNJCNTKnP5NzJOu699xQ/ko5As1/VVpM9CG1jJW26gcKnoSxjzf+L4mTk2xYR9wWsN5n9Lg+8QktVWblig+BQkjR37F9/zanGQuXjLzNVLnujbCvNzKZfHaMDEdAHp7UHQl4pfoyU4+EdfqEXN/0O9Ye2DwbKUlCJpGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":1863,"cache_read_input_tokens":64877,"cache_creation":{"ephemeral_5m_input_tokens":1863,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"c6947358-edea-4925-92fe-57de6a0a7c89","timestamp":"2025-12-15T11:45:32.366Z"}
{"parentUuid":"c6947358-edea-4925-92fe-57de6a0a7c89","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01EdncsVEgrSXp8V1CAN1z3i","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VGvHYre9AxV8wuNqfZkbNS","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","offset":285,"limit":25}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":1863,"cache_read_input_tokens":64877,"cache_creation":{"ephemeral_5m_input_tokens":1863,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"38744351-11b5-4dca-9708-afaae0268ef1","timestamp":"2025-12-15T11:45:33.187Z"}
{"parentUuid":"38744351-11b5-4dca-9708-afaae0268ef1","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VGvHYre9AxV8wuNqfZkbNS","type":"tool_result","content":"   285→        /// <summary>\n   286→        /// 每帧更新（渲染帧，处理输入和实际移动）\n   287→        /// 负责输入处理、实际移动执行、视觉效果等需要每帧更新的操作\n   288→        /// </summary>\n   289→        protected virtual void Update()\n   290→        {\n   291→            // 渲染帧更新\n   292→            ProcessRenderUpdate();\n   293→        }\n   294→\n   295→        /// <summary>\n   296→        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n   297→        /// 负责游戏逻辑计算，如移动意图、状态机更新等\n   298→        /// </summary>\n   299→        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n   300→        public virtual void LogicUpdate(float deltaTime)\n   301→        {\n   302→            // 逻辑帧更新\n   303→            ProcessLogicUpdate(deltaTime);\n   304→        }\n   305→\n   306→        /// <summary>\n   307→        /// 延迟更新，目前为空方法，保留用于扩展\n   308→        /// </summary>\n   309→        protected virtual void LateUpdate()\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"525d5813-dbcd-450b-a38d-885dd53e2615","timestamp":"2025-12-15T11:45:34.169Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","content":"        /// <summary>\n        /// 每帧更新（渲染帧，处理输入和实际移动）\n        /// 负责输入处理、实际移动执行、视觉效果等需要每帧更新的操作\n        /// </summary>\n        protected virtual void Update()\n        {\n            // 渲染帧更新\n            ProcessRenderUpdate();\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 负责游戏逻辑计算，如移动意图、状态机更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 逻辑帧更新\n            ProcessLogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 延迟更新，目前为空方法，保留用于扩展\n        /// </summary>\n        protected virtual void LateUpdate()","numLines":25,"startLine":285,"totalLines":1334}}}
{"parentUuid":"525d5813-dbcd-450b-a38d-885dd53e2615","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01My3RzCDQ14Ka8Vox3LBTgz","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，我看到了准确的字符串。让我重新编辑。","signature":"EucBCkYIChgCKkCe1et/IbxesYpdM6hs/CBj76PFCX2fiQcQTy+HaQc1D197WzlCuZVegiZxFjtRjMu+Rqt9eDlRPFoh1smBHrBNEgyp4zxzvpfZ34wTwWMaDGHmA4W4wmf+wr6vFSIwGyKe3nPPXWa0riP+FVwr9cTnBGYOaiZlQrpSSfdODNKwdJQXWG4yKfe5ckxPeHrcKk/FEkS6ii4/jKp6Wcud58EVoVAxR0a2asCi05+n1AyLTtuXpiZJ+b3qqUG3t7X7CTtecrHseLAdvayCTH6a0ulY79xxc/GhGZrXPeOktr+eGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":616,"cache_read_input_tokens":66740,"cache_creation":{"ephemeral_5m_input_tokens":616,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"type":"assistant","uuid":"44c54924-0613-4f3f-b9b3-eb41e556d3cb","timestamp":"2025-12-15T11:45:39.310Z"}
{"parentUuid":"44c54924-0613-4f3f-b9b3-eb41e556d3cb","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01My3RzCDQ14Ka8Vox3LBTgz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BC3z7tiZmFk7G3zg87ye3c","name":"Edit","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","old_string":"        /// <summary>\n        /// 每帧更新（渲染帧，处理输入和实际移动）\n        /// 负责输入处理、实际移动执行、视觉效果等需要每帧更新的操作\n        /// </summary>\n        protected virtual void Update()\n        {\n            // 渲染帧更新\n            ProcessRenderUpdate();\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 负责游戏逻辑计算，如移动意图、状态机更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 逻辑帧更新\n            ProcessLogicUpdate(deltaTime);\n        }","new_string":"        /// <summary>\n        /// 每帧更新（处理所有逻辑计算和移动执行）\n        /// 统一在 Update 中完成所有操作，避免 LogicUpdate 和 RenderUpdate 分离导致的抖动\n        /// </summary>\n        protected virtual void Update()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            float deltaTime = Time.deltaTime;\n\n            // 保存上一帧状态\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测\n            CheckIfGrounded();\n\n            // 2. 处理摩擦力\n            HandleFriction();\n\n            // 3. 确定移动方向\n            DetermineDirection();\n\n            // 4. 处理输入移动\n            AddInput(deltaTime);\n\n            // 5. 处理重力\n            AddGravityLogic(deltaTime);\n\n            // 6. 处理移动平台\n            MoveWithPlatform();\n\n            // 7. 计算速度变化\n            ComputeVelocityDelta(deltaTime);\n\n            // 8. 计算新速度\n            ComputeNewVelocity(deltaTime);\n\n            // 9. 执行实际移动\n            ExecuteMove(deltaTime);\n\n            // 10. 计算实际速度\n            ComputeSpeed(deltaTime);\n        }\n\n        /// <summary>\n        /// 逻辑更新（保留接口用于向后兼容，但不再使用）\n        /// 现在所有逻辑都在 Update 中处理，避免抖动问题\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        [System.Obsolete(\"LogicUpdate is no longer used. All logic is now handled in Update to avoid jitter.\")]\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 不再处理任何逻辑，所有逻辑已整合到 Update 中\n        }"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":616,"cache_read_input_tokens":66740,"cache_creation":{"ephemeral_5m_input_tokens":616,"ephemeral_1h_input_tokens":0},"output_tokens":952,"service_tier":"standard"}},"type":"assistant","uuid":"a3e5cd5d-0adc-4a4a-92b5-d66de09b2429","timestamp":"2025-12-15T11:45:46.690Z"}
{"type":"file-history-snapshot","messageId":"a3e5cd5d-0adc-4a4a-92b5-d66de09b2429","snapshot":{"messageId":"8feb74f9-38fc-4041-8373-79ac17fbe524","trackedFileBackups":{"Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs":{"backupFileName":"b1c9467c2d2e4b63@v1","version":1,"backupTime":"2025-12-15T11:46:50.532Z"}},"timestamp":"2025-12-15T11:44:45.697Z"},"isSnapshotUpdate":true}
{"parentUuid":"a3e5cd5d-0adc-4a4a-92b5-d66de09b2429","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BC3z7tiZmFk7G3zg87ye3c","type":"tool_result","content":"The file E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   281→            // 物理相关的固定更新\n   282→            ProcessFixedUpdate();\n   283→        }\n   284→\n   285→        /// <summary>\n   286→        /// 每帧更新（处理所有逻辑计算和移动执行）\n   287→        /// 统一在 Update 中完成所有操作，避免 LogicUpdate 和 RenderUpdate 分离导致的抖动\n   288→        /// </summary>\n   289→        protected virtual void Update()\n   290→        {\n   291→            if (_transform == null || !_freeMovement)\n   292→            {\n   293→                return;\n   294→            }\n   295→\n   296→            float deltaTime = Time.deltaTime;\n   297→\n   298→            // 保存上一帧状态\n   299→            _velocityLastFrame = _velocity;\n   300→            _newVelocity = _velocity;\n   301→            _positionLastFrame = _transform.position;\n   302→\n   303→            // 1. 地面检测\n   304→            CheckIfGrounded();\n   305→\n   306→            // 2. 处理摩擦力\n   307→            HandleFriction();\n   308→\n   309→            // 3. 确定移动方向\n   310→            DetermineDirection();\n   311→\n   312→            // 4. 处理输入移动\n   313→            AddInput(deltaTime);\n   314→\n   315→            // 5. 处理重力\n   316→            AddGravityLogic(deltaTime);\n   317→\n   318→            // 6. 处理移动平台\n   319→            MoveWithPlatform();\n   320→\n   321→            // 7. 计算速度变化\n   322→            ComputeVelocityDelta(deltaTime);\n   323→\n   324→            // 8. 计算新速度\n   325→            ComputeNewVelocity(deltaTime);\n   326→\n   327→            // 9. 执行实际移动\n   328→            ExecuteMove(deltaTime);\n   329→\n   330→            // 10. 计算实际速度\n   331→            ComputeSpeed(deltaTime);\n   332→        }\n   333→\n   334→        /// <summary>\n   335→        /// 逻辑更新（保留接口用于向后兼容，但不再使用）\n   336→        /// 现在所有逻辑都在 Update 中处理，避免抖动问题\n   337→        /// </summary>\n   338→        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n   339→        [System.Obsolete(\"LogicUpdate is no longer used. All logic is now handled in Update to avoid jitter.\")]\n   340→        public virtual void LogicUpdate(float deltaTime)\n   341→        {\n   342→            // 不再处理任何逻辑，所有逻辑已整合到 Update 中\n   343→        }\n   344→\n   345→        /// <summary>\n   346→        /// 延迟更新，目前为空方法，保留用于扩展\n   347→        /// </summary>"}]},"uuid":"8fa7d1a8-bef4-4697-97b7-03b961f53997","timestamp":"2025-12-15T11:46:50.538Z","toolUseResult":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","oldString":"        /// <summary>\n        /// 每帧更新（渲染帧，处理输入和实际移动）\n        /// 负责输入处理、实际移动执行、视觉效果等需要每帧更新的操作\n        /// </summary>\n        protected virtual void Update()\n        {\n            // 渲染帧更新\n            ProcessRenderUpdate();\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 负责游戏逻辑计算，如移动意图、状态机更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 逻辑帧更新\n            ProcessLogicUpdate(deltaTime);\n        }","newString":"        /// <summary>\n        /// 每帧更新（处理所有逻辑计算和移动执行）\n        /// 统一在 Update 中完成所有操作，避免 LogicUpdate 和 RenderUpdate 分离导致的抖动\n        /// </summary>\n        protected virtual void Update()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            float deltaTime = Time.deltaTime;\n\n            // 保存上一帧状态\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测\n            CheckIfGrounded();\n\n            // 2. 处理摩擦力\n            HandleFriction();\n\n            // 3. 确定移动方向\n            DetermineDirection();\n\n            // 4. 处理输入移动\n            AddInput(deltaTime);\n\n            // 5. 处理重力\n            AddGravityLogic(deltaTime);\n\n            // 6. 处理移动平台\n            MoveWithPlatform();\n\n            // 7. 计算速度变化\n            ComputeVelocityDelta(deltaTime);\n\n            // 8. 计算新速度\n            ComputeNewVelocity(deltaTime);\n\n            // 9. 执行实际移动\n            ExecuteMove(deltaTime);\n\n            // 10. 计算实际速度\n            ComputeSpeed(deltaTime);\n        }\n\n        /// <summary>\n        /// 逻辑更新（保留接口用于向后兼容，但不再使用）\n        /// 现在所有逻辑都在 Update 中处理，避免抖动问题\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        [System.Obsolete(\"LogicUpdate is no longer used. All logic is now handled in Update to avoid jitter.\")]\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 不再处理任何逻辑，所有逻辑已整合到 Update 中\n        }","originalFile":"using System;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing ActionMachine.Runtime.Attributes;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 运动学角色控制器（Kinematic Character Controller）\n    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    /// </summary>\n    [RequireComponent(typeof(CharacterController))]\n    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    public partial class Kcc : MonoBehaviour\n    {\n        private const float SMALL_VALUE = 0.0001f; // 浮点数比较的最小阈值\n        private const float SPEED_ROUNDING_PRECISION = 100f; // 速度值舍入精度\n        private const float IMPACT_THRESHOLD = 0.2f; // 冲击力应用的最小阈值\n\n        /// <summary>\n        /// 地面检测计算模式\n        /// </summary>\n        public enum GroundedComputationMode\n        {\n            Simple, // 简单模式：使用 CharacterController.isGrounded\n            Advanced // 高级模式：使用多方向射线检测\n        }\n\n        /// <summary>\n        /// 速度传递模式（用于移动平台交互）\n        /// </summary>\n        public enum VelocityTransferMode\n        {\n            NoTransfer, // 不传递速度\n            InitialVelocity, // 传递初始速度\n            FloorVelocity, // 传递地面速度\n            Relative // 相对速度模式\n        }\n\n        [Header(\"Gravity Settings\")] [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n        public float Gravity = 40f;\n\n        [Tooltip(\"是否激活重力\")] public bool GravityActive = true;\n\n        [Header(\"Raycast Settings\")] [Tooltip(\"障碍物层遮罩\")]\n        public LayerMask ObstaclesLayerMask;\n\n        [Tooltip(\"向下射线检测长度\")] public float GroundedRaycastLength = 5f;\n\n        [Tooltip(\"最小着地距离\")] public float MinimumGroundedDistance = 0.2f;\n\n        [Tooltip(\"地面检测计算模式\")] public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n\n        [Tooltip(\"地面法线高度阈值\")] public float GroundNormalHeightThreshold = 0.2f;\n\n        [Tooltip(\"蹲伏时射线长度倍数\")] public float CrouchedRaycastLengthMultiplier = 1f;\n\n        [Tooltip(\"是否执行基本方向障碍物射线检测\")] public bool PerformCardinalObstacleRaycastDetection = false;\n\n        [Header(\"Movement Settings\")] [Tooltip(\"最大下落速度\")]\n        public float MaximumFallSpeed = 20.0f;\n\n        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速\")] \n        public float HorizontalAcceleration = 20f;\n\n        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速\")] \n        public float HorizontalDeceleration = 20f;\n        \n        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n        public float InitialBurstMultiplier = 2.0f;\n        \n        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n        public float BurstSpeedThreshold = 1.0f;\n\n        [Tooltip(\"斜坡速度倍数曲线\")] public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n            new Keyframe(-90, 1),\n            new Keyframe(0, 1),\n            new Keyframe(90, 0)\n        );\n\n        [Tooltip(\"冲击力衰减速度\")] public float ImpactFalloff = 5f;\n\n        [Header(\"Steep Surface Settings\")] [Tooltip(\"是否在陡峭表面滑动\")]\n        public bool SlideOnSteepSurfaces = true;\n\n        [Tooltip(\"滑动速度\")] public float SlidingSpeed = 15f;\n\n        [Tooltip(\"滑动速度控制\")] public float SlidingSpeedControl = 0.4f;\n\n        [Tooltip(\"滑动方向控制\")] public float SlidingDirectionControl = 1f;\n\n        [Header(\"Moving Platform Settings\")] [Tooltip(\"跳跃时的速度传递方式\")]\n        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Movement Smoothing\")]\n        [Tooltip(\"是否启用移动平滑\")]\n        public bool EnableMovementSmoothing = true;\n        \n        [Tooltip(\"水平移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float HorizontalSmoothTime = 0.03f;\n        \n        [Tooltip(\"垂直移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float VerticalSmoothTime = 0.05f;\n\n        [Header(\"Runtime State - Read Only\")]\n        [SerializeField, ReadOnly] private Vector3 _speed;\n        [SerializeField, ReadOnly] private Vector3 _velocity;\n        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n        [SerializeField, ReadOnly] private Vector3 _acceleration;\n        [SerializeField, ReadOnly] private bool _grounded;\n        [SerializeField, ReadOnly] private bool _justGotGrounded;\n        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n        [SerializeField, ReadOnly] private float _friction;\n        [SerializeField, ReadOnly] private Vector3 _addedForce;\n        [SerializeField, ReadOnly] private bool _freeMovement = true;\n        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n\n        // 公共只读属性\n        public Vector3 Speed => _speed;\n        public Vector3 Velocity => _velocity;\n        public Vector3 VelocityLastFrame => _velocityLastFrame;\n        public Vector3 Acceleration => _acceleration;\n        public bool Grounded => _grounded;\n        public bool JustGotGrounded => _justGotGrounded;\n        public Vector3 CurrentMovement => _currentMovement;\n        public Vector3 CurrentDirection => _currentDirection;\n        public float Friction => _friction;\n        public Vector3 AddedForce => _addedForce;\n        public bool FreeMovement => _freeMovement;\n        public Vector3 GroundNormal => _groundNormal;\n        public Vector3 InputMoveDirection => _inputMoveDirection;\n        public Vector3 TargetVelocity => _targetVelocity;\n\n        // 碰撞器相关属性\n        public Vector3 ColliderCenter => transform.position + _characterController.center;\n\n        public Vector3 ColliderBottom => transform.position + _characterController.center +\n                                         Vector3.down * _characterController.bounds.extents.y;\n\n        public Vector3 ColliderTop => transform.position + _characterController.center +\n                                      Vector3.up * _characterController.bounds.extents.y;\n\n        public Vector3 AppliedImpact => _impact;\n\n        // 环境检测属性\n        public GameObject ObjectBelow { get; set; }\n        public GameObject DetectedObstacleLeft { get; set; }\n        public GameObject DetectedObstacleRight { get; set; }\n        public GameObject DetectedObstacleUp { get; set; }\n        public GameObject DetectedObstacleDown { get; set; }\n        public bool CollidingWithCardinalObstacle { get; set; }\n        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n\n        // 移动平台相关属性\n        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n\n        // 组件引用\n        private Transform _transform;\n        private CharacterController _characterController;\n\n        // 碰撞器原始尺寸\n        private float _originalColliderHeight;\n        private Vector3 _originalColliderCenter;\n\n        // 运动状态追踪\n        private Vector3 _positionLastFrame;\n        private bool _groundedLastFrame;\n        private Vector3 _impact;\n        private Vector3 _lastGroundNormal = Vector3.zero;\n        private bool _detached = false;\n        private bool _tooSteepLastFrame;\n\n        // 移动平台追踪\n        private Transform _movingPlatformHitCollider;\n        private Transform _movingPlatformCurrentHitCollider;\n        private Vector3 _movingPlatformCurrentHitColliderLocal;\n        private Vector3 _movingPlatformCurrentGlobalPoint;\n        private Quaternion _movingPlatformLocalRotation;\n        private Quaternion _movingPlatformGlobalRotation;\n        private Quaternion _lastMoveWithPlatformGlobalRotation;\n        private Matrix4x4 _lastMovingPlatformMatrix;\n        private Vector3 _movingPlatformVelocity;\n        private bool _newMovingPlatform;\n\n        // 碰撞检测\n        private CollisionFlags _collisionFlags;\n        private Vector3 _frameVelocity = Vector3.zero;\n        private Vector3 _hitPoint = Vector3.zero;\n        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n        // 速度计算\n        private Vector3 _newVelocity;\n        private Vector3 _motion;\n        private Vector3 _idealVelocity;\n        private Vector3 _idealDirection;\n        private Vector3 _horizontalVelocityDelta;\n        private float _stickyOffset = 0f;\n\n        // 位置移动\n        private RaycastHit _movePositionHit;\n        private Vector3 _capsulePoint1;\n        private Vector3 _capsulePoint2;\n        private Vector3 _movePositionDirection;\n        private float _movePositionDistance;\n\n        // 障碍物检测\n        private RaycastHit _cardinalRaycast;\n        private float _smallestDistance = Single.MaxValue;\n        private float _longestDistance = Single.MinValue;\n        private RaycastHit _smallestRaycast;\n        private RaycastHit _emptyRaycast = new RaycastHit();\n        private Vector3 _downRaycastsOffset;\n\n        // 平台移动计算\n        private Vector3 _moveWithPlatformMoveDistance;\n        private Vector3 _moveWithPlatformGlobalPoint;\n        private Quaternion _moveWithPlatformRotationDiff;\n        private Quaternion _moveWithPlatformGlobalRotation;\n        private RaycastHit _raycastDownHit;\n        private Vector3 _raycastDownDirection = Vector3.down;\n        private RaycastHit _canGoBackHeadCheck;\n        private Vector3 _originalSizeRaycastOrigin;\n\n        // 协程和可选组件\n        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        \n        // 逻辑帧与渲染帧分离\n        private Vector3 _pendingMotion = Vector3.zero;\n        private float _lastLogicDeltaTime = 0f; // 保存逻辑帧的时间增量\n        \n        // 移动平滑相关\n        private Vector3 _smoothedMotion = Vector3.zero;\n        private Vector3 _motionVelocity = Vector3.zero; // SmoothDamp 速度缓存\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n        /// <summary>\n        /// 检查角色头部是否与物体碰撞\n        /// </summary>\n        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n\n        /// <summary>\n        /// 检查当前地面是否过于陡峭\n        /// </summary>\n        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n\n        /// <summary>\n        /// 初始化组件和缓存引用\n        /// </summary>\n        protected virtual void Awake()\n        {\n            _characterController = GetComponent<CharacterController>();\n            _transform = transform;\n            _rigidBody = GetComponent<Rigidbody>();\n\n            _originalColliderHeight = _characterController.height;\n            _originalColliderCenter = _characterController.center;\n            _currentDirection = _transform.forward;\n        }\n\n        /// <summary>\n        /// 固定时间更新（物理帧，处理物理相关的计算）\n        /// 负责物理模拟、重力计算、碰撞检测等需要固定时间步长的操作\n        /// </summary>\n        protected virtual void FixedUpdate()\n        {\n            // 物理相关的固定更新\n            ProcessFixedUpdate();\n        }\n\n        /// <summary>\n        /// 每帧更新（渲染帧，处理输入和实际移动）\n        /// 负责输入处理、实际移动执行、视觉效果等需要每帧更新的操作\n        /// </summary>\n        protected virtual void Update()\n        {\n            // 渲染帧更新\n            ProcessRenderUpdate();\n        }\n\n        /// <summary>\n        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）\n        /// 负责游戏逻辑计算，如移动意图、状态机更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 逻辑帧更新\n            ProcessLogicUpdate(deltaTime);\n        }\n\n        /// <summary>\n        /// 延迟更新，目前为空方法，保留用于扩展\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            // LateUpdate 不再处理 _velocityLastFrame，改为在 LogicUpdate 中处理\n        }\n\n        /// <summary>\n        /// 固定更新处理（物理帧）\n        /// 处理物理相关的计算，确保物理模拟的一致性\n        /// </summary>\n        protected virtual void ProcessFixedUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 物理相关的固定更新\n            // 1. 重力计算（固定时间步长确保物理一致性）\n            if (GravityActive)\n            {\n                ApplyGravityFixed(Time.fixedDeltaTime);\n            }\n\n            // 2. 移动平台速度计算（物理相关）\n            GetMovingPlatformVelocity();\n            \n            // 3. 应用冲击力（物理相关，固定时间步长）\n            ApplyImpact(Time.fixedDeltaTime);\n        }\n\n        /// <summary>\n        /// 渲染更新处理（每帧）\n        /// 处理实际的移动执行和视觉效果\n        /// </summary>\n        protected virtual void ProcessRenderUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 1. 基于当前速度和渲染帧时间重新计算移动\n            CalculateRenderFrameMotion();\n            \n            // 2. 执行实际的移动（每帧执行，确保视觉流畅）\n            ExecutePendingMove();\n        }\n\n        /// <summary>\n        /// 逻辑更新处理（逻辑帧）\n        /// 处理游戏逻辑计算，如移动意图、状态更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        protected virtual void ProcessLogicUpdate(float deltaTime)\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 保存逻辑帧时间增量，用于渲染帧的移动计算\n            _lastLogicDeltaTime = deltaTime;\n\n            // 保存上一帧状态（在 LogicUpdate 开始时保存，确保时序正确）\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测（逻辑相关）\n            CheckIfGrounded();\n            \n            // 2. 处理摩擦力（逻辑相关）\n            HandleFriction();\n            \n            // 3. 确定移动方向（基于输入）\n            DetermineDirection();\n            \n            // 4. 处理输入移动（逻辑计算，不实际移动）\n            AddInput(deltaTime);\n            \n            // 5. 处理重力（逻辑计算，不包含固定更新中的重力）\n            AddGravityLogic(deltaTime);\n            \n            // 6. 处理移动平台（逻辑计算）\n            MoveWithPlatform();\n            \n            // 7. 计算速度变化（逻辑计算）\n            ComputeVelocityDelta(deltaTime);\n            \n            // 8. 计算新速度（逻辑状态更新）\n            ComputeNewVelocity(deltaTime);\n            \n            // 9. 计算实际速度（基于逻辑帧时间增量）\n            ComputeSpeed(deltaTime);\n        }\n        \n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n                _idealVelocity = _idealVelocity * SlidingSpeed;\n                _targetVelocity = _idealVelocity;\n                _newVelocity = _idealVelocity;\n                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n            }\n            else\n            {\n                _targetVelocity = _currentMovement;\n                \n                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n                \n                Vector3 newHorizontalVelocity;\n                \n                if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                {\n                    float effectiveAcceleration = HorizontalAcceleration;\n                    \n                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n                    {\n                        effectiveAcceleration *= InitialBurstMultiplier;\n                    }\n                    \n                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n                    \n\n                    \n                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n                    {\n                        newHorizontalVelocity = targetHorizontalVelocity;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n                    }\n                }\n                else\n                {\n                    float currentSpeed = currentHorizontalVelocity.magnitude;\n                    float speedReduction = HorizontalDeceleration * deltaTime;\n                    \n\n                    \n                    if (currentSpeed <= speedReduction)\n                    {\n                        newHorizontalVelocity = Vector3.zero;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n                    }\n                }\n                \n                _newVelocity.x = newHorizontalVelocity.x;\n                _newVelocity.z = newHorizontalVelocity.z;\n                \n\n                \n                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    Vector3 floorVelocity = _frameVelocity;\n                    floorVelocity.y = 0;\n                    _newVelocity.x += floorVelocity.x;\n                    _newVelocity.z += floorVelocity.z;\n                }\n                \n                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n                    \n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity.normalized;\n                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n                        \n                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n                        {\n                            projectedDirection.Normalize();\n                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                        }\n                    }\n                    \n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 固定更新中的重力应用（物理帧）\n        /// </summary>\n        /// <param name=\"deltaTime\">固定时间增量</param>\n        protected virtual void ApplyGravityFixed(float deltaTime)\n        {\n            // 固定更新中的重力处理，主要用于物理一致性\n            // 这里可以添加需要在固定时间步长中处理的重力相关逻辑\n        }\n\n        /// <summary>\n        /// 逻辑更新中的重力应用（逻辑帧）\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑时间增量</param>\n        protected virtual void AddGravityLogic(float deltaTime)\n        {\n            if (GravityActive)\n            {\n                if (_grounded)\n                {\n                    _newVelocity.y = -Gravity * deltaTime;\n\n                }\n                else\n                {\n                    float oldY = _newVelocity.y;\n                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n\n                }\n            }\n\n            _newVelocity += _addedForce;\n            _addedForce = Vector3.zero;\n        }\n\n        /// <summary>\n        /// 应用重力到速度（保持向后兼容）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddGravity(float deltaTime)\n        {\n            AddGravityLogic(deltaTime);\n        }\n\n        /// <summary>\n        /// 跟随移动平台移动\n        /// </summary>\n        protected virtual void MoveWithPlatform()\n        {\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _moveWithPlatformMoveDistance = Vector3.zero;\n                _moveWithPlatformGlobalPoint =\n                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n\n                if (_moveWithPlatformMoveDistance != Vector3.zero)\n                {\n                    _characterController.Move(_moveWithPlatformMoveDistance);\n                }\n\n                _moveWithPlatformGlobalRotation =\n                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n            }\n        }\n\n        /// <summary>\n        /// 计算速度增量和粘性偏移\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeVelocityDelta(float deltaTime)\n        {\n            _motion = _newVelocity * deltaTime;\n            _horizontalVelocityDelta.x = _motion.x;\n            _horizontalVelocityDelta.y = 0f;\n            _horizontalVelocityDelta.z = _motion.z;\n            _stickyOffset = Mathf.Max(_characterController.stepOffset, _horizontalVelocityDelta.magnitude);\n\n            if (_grounded)\n            {\n                _motion -= _stickyOffset * Vector3.up;\n            }\n        }\n\n        /// <summary>\n        /// 基于当前速度和渲染帧时间重新计算移动\n        /// Logic 赋值 Velocity，Render 对这个进行插值渲染\n        /// </summary>\n        protected virtual void CalculateRenderFrameMotion()\n        {\n            // 根据速度动态调整时间增量，避免高速时移动幅度过大\n            float speedMagnitude = _velocity.magnitude;\n            float adjustedDeltaTime = Time.deltaTime;\n            \n            // 高速时减少有效时间增量，控制移动幅度\n            if (speedMagnitude > 8f)\n            {\n                // 速度越高，时间增量缩放越小\n                // 扩展速度范围到 100，支持更高的速度\n                float speedFactor = Mathf.InverseLerp(8f, 100f, speedMagnitude);\n                adjustedDeltaTime *= Mathf.Lerp(1f, 0.05f, speedFactor);\n            }\n            \n            // 使用调整后的时间增量计算移动向量\n            Vector3 targetMotion = _velocity * adjustedDeltaTime;\n            \n            // 应用地面接触的粘性偏移（如果需要）\n            if (_grounded)\n            {\n                Vector3 horizontalMotion = new Vector3(targetMotion.x, 0, targetMotion.z);\n                float stickyOffset = Mathf.Max(_characterController.stepOffset * 0.1f, horizontalMotion.magnitude * 0.01f);\n                targetMotion.y -= stickyOffset;\n            }\n            \n            // 应用移动平滑（如果启用）\n            if (EnableMovementSmoothing)\n            {\n                _pendingMotion = CalculateSmoothedMotion(targetMotion);\n            }\n            else\n            {\n                _pendingMotion = targetMotion;\n            }\n        }\n\n        /// <summary>\n        /// 执行待处理的移动（在渲染帧中调用）\n        /// 执行实际的物理移动和碰撞检测\n        /// </summary>\n        protected virtual void ExecutePendingMove()\n        {\n            // 1. 执行实际的 CharacterController 移动\n            MoveCharacterController();\n            \n            // 2. 检测新的移动平台（碰撞相关）\n            DetectNewMovingPlatform();\n            \n            // 3. 手动处理碰撞器碰撞（物理相关）\n            ManualControllerColliderHit();\n            \n            // 4. 处理地面接触状态（物理相关）\n            HandleGroundContact();\n        }\n\n        /// <summary>\n        /// 执行 CharacterController 移动\n        /// </summary>\n        protected virtual void MoveCharacterController()\n        {\n            _groundNormal = Vector3.zero;\n            \n            // 直接使用基于渲染帧时间计算的移动向量\n            _collisionFlags = _characterController.Move(_pendingMotion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n        \n        /// <summary>\n        /// 计算平滑后的移动向量\n        /// 使用简单的 Lerp 进行平滑，避免过度复杂化\n        /// </summary>\n        /// <param name=\"targetMotion\">目标移动向量</param>\n        /// <returns>平滑后的移动向量</returns>\n        protected virtual Vector3 CalculateSmoothedMotion(Vector3 targetMotion)\n        {\n            // 计算目标移动的幅度，用于动态调整平滑强度\n            float targetMagnitude = targetMotion.magnitude;\n            \n            // 基于移动幅度动态调整平滑时间\n            // 移动距离越大，需要更强的平滑\n            float dynamicSmoothTime = 0.016f; // 基础平滑时间（60fps）\n            \n            if (targetMagnitude > 0.1f) // 只对有明显移动时进行调整\n            {\n                // 移动距离越大，平滑时间越长\n                // 这样可以确保高速移动时有足够的平滑\n                dynamicSmoothTime = Mathf.Lerp(0.016f, 0.1f, Mathf.InverseLerp(0.1f, 0.5f, targetMagnitude));\n            }\n            \n            // 使用 SmoothDamp 进行平滑，它能更好地处理不同幅度的移动\n            Vector3 smoothed = Vector3.SmoothDamp(_smoothedMotion, targetMotion, ref _motionVelocity, \n                                                 dynamicSmoothTime, Mathf.Infinity, Time.deltaTime);\n            \n            _smoothedMotion = smoothed;\n            \n            // 防抖动处理\n            if (targetMotion.sqrMagnitude < 0.001f * 0.001f)\n            {\n                _smoothedMotion *= 0.9f;\n                if (_smoothedMotion.sqrMagnitude < 0.0001f)\n                {\n                    _smoothedMotion = Vector3.zero;\n                    _motionVelocity = Vector3.zero;\n                }\n            }\n            \n            return _smoothedMotion;\n        }\n\n        /// <summary>\n        /// 检测是否踩上新的移动平台\n        /// </summary>\n        protected virtual void DetectNewMovingPlatform()\n        {\n            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n            {\n                if (_movingPlatformHitCollider != null)\n                {\n                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n                    _newMovingPlatform = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 计算新速度和加速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeNewVelocity(float deltaTime)\n        {\n            _velocity = _newVelocity;\n            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n        }\n\n        /// <summary>\n        /// 处理地面接触状态和平台速度传递\n        /// </summary>\n        protected virtual void HandleGroundContact()\n        {\n            _grounded = _characterController.isGrounded;\n\n            if (_grounded && !IsGroundedTest())\n            {\n                _grounded = false;\n                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    _frameVelocity = _movingPlatformVelocity;\n                    _velocity += _movingPlatformVelocity;\n                }\n            }\n            else if (!_grounded && IsGroundedTest())\n            {\n                if (_detached && _velocity.y <= 0)\n                {\n                    _grounded = true;\n                    _detached = false;\n                }\n\n                SubtractNewPlatformVelocity();\n            }\n\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _movingPlatformCurrentGlobalPoint = _transform.position;\n                _movingPlatformCurrentHitColliderLocal =\n                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n                _movingPlatformGlobalRotation = _transform.rotation;\n                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n                                               _movingPlatformGlobalRotation;\n            }\n\n            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n            _tooSteepLastFrame = TooSteep();\n        }\n\n        /// <summary>\n        /// 计算当前速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeSpeed(float deltaTime)\n        {\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _positionLastFrame) / deltaTime;\n            }\n\n            // 暂时禁用速度舍入，避免高速时的舍入误差导致抖动\n            // _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            // _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            // _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            \n            _positionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 根据当前移动向量确定方向\n        /// </summary>\n        protected virtual void DetermineDirection()\n        {\n            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n            {\n                _currentDirection = _currentMovement.normalized;\n            }\n        }\n\n        /// <summary>\n        /// 处理摩擦力（预留方法，可在子类中实现）\n        /// </summary>\n        protected virtual void HandleFriction()\n        {\n        }\n\n        /// <summary>\n        /// 检查是否刚刚着地\n        /// </summary>\n        protected virtual void CheckIfGrounded()\n        {\n            _justGotGrounded = !_groundedLastFrame && _grounded;\n            _groundedLastFrame = _grounded;\n        }\n\n        /// <summary>\n        /// 手动触发碰撞器碰撞处理\n        /// </summary>\n        protected virtual void ManualControllerColliderHit()\n        {\n            HandleAdvancedGroundDetection();\n        }\n\n        /// <summary>\n        /// 高级地面检测（使用多方向射线）\n        /// </summary>\n        protected virtual void HandleAdvancedGroundDetection()\n        {\n            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n            {\n                return;\n            }\n\n            _smallestDistance = Single.MaxValue;\n            _longestDistance = Single.MinValue;\n            _smallestRaycast = _emptyRaycast;\n\n            float offset = _characterController.radius;\n\n            _downRaycastsOffset = Vector3.zero;\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, offset);\n            CastRayDownwards();\n\n            if (_smallestRaycast.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n\n                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n                {\n                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n                    {\n                        _groundNormal = _smallestRaycast.normal;\n                    }\n                    else\n                    {\n                        _groundNormal = _lastGroundNormal;\n                    }\n\n                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n                    _hitPoint = _smallestRaycast.point;\n                    _frameVelocity = Vector3.zero;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 向下发射射线检测地面\n        /// </summary>\n        protected virtual void CastRayDownwards()\n        {\n            if (_smallestDistance <= MinimumGroundedDistance)\n            {\n                return;\n            }\n\n            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n                _raycastDownDirection, out _raycastDownHit,\n                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n\n            if (_raycastDownHit.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n\n                if (adjustedDistance < _smallestDistance)\n                {\n                    _smallestDistance = adjustedDistance;\n                    _smallestRaycast = _raycastDownHit;\n                }\n\n                if (adjustedDistance > _longestDistance)\n                {\n                    _longestDistance = adjustedDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n        /// </summary>\n        protected float AdjustDistance(float distance)\n        {\n            return distance - _characterController.height / 2f - _characterController.skinWidth;\n        }\n\n        /// <summary>\n        /// 测试是否真正着地\n        /// </summary>\n        protected virtual bool IsGroundedTest()\n        {\n            bool grounded = false;\n            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n            {\n                if (_smallestDistance <= MinimumGroundedDistance)\n                {\n                    grounded = _groundNormal.y > 0.01f;\n                }\n            }\n            else\n            {\n                grounded = _characterController.isGrounded;\n                _groundNormal = Vector3.up;\n            }\n\n            return grounded;\n        }\n\n        /// <summary>\n        /// 获取移动平台速度\n        /// </summary>\n        protected virtual void GetMovingPlatformVelocity()\n        {\n            if (_movingPlatformCurrentHitCollider != null)\n            {\n                if (!_newMovingPlatform && Time.fixedDeltaTime > SMALL_VALUE)\n                {\n                    _movingPlatformVelocity = (\n                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n                            _movingPlatformCurrentHitColliderLocal)\n                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n                    ) / Time.fixedDeltaTime;\n                }\n\n                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n                _newMovingPlatform = false;\n            }\n            else\n            {\n                _movingPlatformVelocity = Vector3.zero;\n            }\n        }\n\n        /// <summary>\n        /// 减去新平台速度（处理平台切换）\n        /// </summary>\n        protected virtual void SubtractNewPlatformVelocity()\n        {\n            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n            {\n                if (_newMovingPlatform)\n                {\n                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n                }\n                else\n                {\n                    _velocity -= _movingPlatformVelocity;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 协程：延迟减去平台速度\n        /// </summary>\n        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n        {\n            Transform platform = _movingPlatformCurrentHitCollider;\n            yield return _waitForFixedUpdate;\n            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n            {\n                yield return null;\n            }\n\n            _velocity -= _movingPlatformVelocity;\n        }\n\n        /// <summary>\n        /// 判断是否应该跟随平台移动\n        /// </summary>\n        protected virtual bool ShouldMoveWithPlatformThisFrame()\n        {\n            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n                   && _movingPlatformCurrentHitCollider != null;\n        }\n\n        /// <summary>\n        /// 应用冲击力并逐渐衰减\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ApplyImpact(float deltaTime)\n        {\n            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n            {\n                _characterController.Move(_impact * deltaTime);\n            }\n\n            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * deltaTime);\n        }\n\n        /// <summary>\n        /// 从地面分离（用于跳跃等）\n        /// </summary>\n        public virtual void DetachFromGround()\n        {\n            _detached = true;\n        }\n\n        /// <summary>\n        /// 从移动平台分离\n        /// </summary>\n        public virtual void DetachFromMovingPlatform()\n        {\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n        }\n\n        /// <summary>\n        /// 设置重力是否激活\n        /// </summary>\n        public virtual void SetGravityActive(bool status)\n        {\n            GravityActive = status;\n        }\n\n        /// <summary>\n        /// 添加外部力（会在下一帧应用）\n        /// </summary>\n        public virtual void AddForce(Vector3 movement)\n        {\n            _addedForce += movement;\n        }\n\n        /// <summary>\n        /// 施加瞬时冲击力\n        /// </summary>\n        /// <param name=\"direction\">冲击方向</param>\n        /// <param name=\"force\">冲击力大小</param>\n        public virtual void Impact(Vector3 direction, float force)\n        {\n            direction = direction.normalized;\n            if (direction.y < 0)\n            {\n                direction.y = -direction.y;\n            }\n\n            _impact += direction.normalized * force;\n        }\n\n        /// <summary>\n        /// 设置移动向量（通常由输入系统调用）\n        /// </summary>\n        /// <param name=\"movement\">移动向量</param>\n        public virtual void SetMovement(Vector3 movement)\n        {\n            _currentMovement = movement;\n\n            Vector3 directionVector = movement;\n            if (directionVector != Vector3.zero)\n            {\n                float directionLength = directionVector.magnitude;\n                directionVector = directionVector / directionLength;\n                directionLength = Mathf.Min(1, directionLength);\n                // 移除平方操作，保持线性响应，避免高速时的非线性抖动\n                directionVector = directionVector * directionLength;\n            }\n\n            _inputMoveDirection = transform.rotation * directionVector;\n        }\n\n        /// <summary>\n        /// 移动到指定位置（带碰撞检测）\n        /// </summary>\n        /// <param name=\"newPosition\">目标位置</param>\n        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n        {\n            _movePositionDirection = newPosition - transform.position;\n            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n\n            _capsulePoint1 = transform.position\n                             + _characterController.center\n                             - (Vector3.up * _characterController.height / 2f)\n                             + Vector3.up * _characterController.skinWidth\n                             + Vector3.up * _characterController.radius;\n\n            _capsulePoint2 = transform.position\n                             + _characterController.center\n                             + (Vector3.up * _characterController.height / 2f)\n                             - Vector3.up * _characterController.skinWidth\n                             - Vector3.up * _characterController.radius;\n\n            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n            {\n                transform.position = newPosition;\n            }\n        }\n\n        /// <summary>\n        /// 调整碰撞器高度（用于蹲伏等）\n        /// </summary>\n        /// <param name=\"newHeight\">新高度</param>\n        /// <param name=\"translateCenter\">是否平移中心点</param>\n        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n        {\n            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n            _characterController.height = newHeight;\n            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n\n            if (translateCenter)\n            {\n                transform.Translate((newYOffset / 2f) * Vector3.up);\n            }\n        }\n\n        /// <summary>\n        /// 重置碰撞器尺寸到原始大小\n        /// </summary>\n        public virtual void ResetColliderSize()\n        {\n            _characterController.height = _originalColliderHeight;\n            _characterController.center = _originalColliderCenter;\n        }\n\n        /// <summary>\n        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n        /// </summary>\n        public virtual bool CanGoBackToOriginalSize()\n        {\n            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n            {\n                return true;\n            }\n\n            float headCheckDistance =\n                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n\n            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n                ObstaclesLayerMask, Color.cyan, true);\n\n            return _canGoBackHeadCheck.collider == null;\n        }\n\n        /// <summary>\n        /// 启用碰撞\n        /// </summary>\n        public virtual void CollisionsOn()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = true;\n            }\n        }\n\n        /// <summary>\n        /// 禁用碰撞\n        /// </summary>\n        public virtual void CollisionsOff()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = false;\n            }\n        }\n\n        /// <summary>\n        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n        /// </summary>\n        public virtual void SetKinematic(bool state)\n        {\n            _rigidBody.isKinematic = state;\n        }\n\n        /// <summary>\n        /// 设置是否允许自由移动\n        /// </summary>\n        public virtual void SetFreeMovement(bool state)\n        {\n            _freeMovement = state;\n        }\n\n        /// <summary>\n        /// 检测四个基本方向的障碍物\n        /// </summary>\n        /// <param name=\"distance\">检测距离</param>\n        /// <param name=\"offset\">起始偏移</param>\n        public virtual void DetectObstacles(float distance, Vector3 offset)\n        {\n            if (!PerformCardinalObstacleRaycastDetection)\n            {\n                return;\n            }\n\n            CollidingWithCardinalObstacle = false;\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleRight = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleLeft = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleUp = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleDown = null;\n            }\n        }\n\n        /// <summary>\n        /// 重置控制器到初始状态\n        /// </summary>\n        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n            \n            // 重置平滑移动相关变量\n            _pendingMotion = Vector3.zero;\n            _smoothedMotion = Vector3.zero;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n\n            return hit;\n        }\n    }\n}","structuredPatch":[{"oldStart":283,"oldLines":24,"newStart":283,"newLines":63,"lines":["         }"," ","         /// <summary>","-        /// 每帧更新（渲染帧，处理输入和实际移动）","-        /// 负责输入处理、实际移动执行、视觉效果等需要每帧更新的操作","+        /// 每帧更新（处理所有逻辑计算和移动执行）","+        /// 统一在 Update 中完成所有操作，避免 LogicUpdate 和 RenderUpdate 分离导致的抖动","         /// </summary>","         protected virtual void Update()","         {","-            // 渲染帧更新","-            ProcessRenderUpdate();","+            if (_transform == null || !_freeMovement)","+            {","+                return;","+            }","+","+            float deltaTime = Time.deltaTime;","+","+            // 保存上一帧状态","+            _velocityLastFrame = _velocity;","+            _newVelocity = _velocity;","+            _positionLastFrame = _transform.position;","+","+            // 1. 地面检测","+            CheckIfGrounded();","+","+            // 2. 处理摩擦力","+            HandleFriction();","+","+            // 3. 确定移动方向","+            DetermineDirection();","+","+            // 4. 处理输入移动","+            AddInput(deltaTime);","+","+            // 5. 处理重力","+            AddGravityLogic(deltaTime);","+","+            // 6. 处理移动平台","+            MoveWithPlatform();","+","+            // 7. 计算速度变化","+            ComputeVelocityDelta(deltaTime);","+","+            // 8. 计算新速度","+            ComputeNewVelocity(deltaTime);","+","+            // 9. 执行实际移动","+            ExecuteMove(deltaTime);","+","+            // 10. 计算实际速度","+            ComputeSpeed(deltaTime);","         }"," ","         /// <summary>","-        /// 逻辑更新（由外部调用，如 ActionController.LogicUpdate）","-        /// 负责游戏逻辑计算，如移动意图、状态机更新等","+        /// 逻辑更新（保留接口用于向后兼容，但不再使用）","+        /// 现在所有逻辑都在 Update 中处理，避免抖动问题","         /// </summary>","         /// <param name=\"deltaTime\">逻辑帧时间增量</param>","+        [System.Obsolete(\"LogicUpdate is no longer used. All logic is now handled in Update to avoid jitter.\")]","         public virtual void LogicUpdate(float deltaTime)","         {","-            // 逻辑帧更新","-            ProcessLogicUpdate(deltaTime);","+            // 不再处理任何逻辑，所有逻辑已整合到 Update 中","         }"," ","         /// <summary>"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"8fa7d1a8-bef4-4697-97b7-03b961f53997","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_019cDUTTS7zWH14XDE2y1Mzr","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，现在我需要删除 `ProcessRenderUpdate` 和 `ProcessLogicUpdate` 方法，并创建一个新的 `ExecuteMove` 方法来执行实际移动。让我先删除这两个不再使用的方法。","signature":"EvICCkYIChgCKkBTWSBLQcNG7NyMVmTAZLV1Rp2li+EgJJzdkYF6rauRAzHLTIFAv3A4Xvugo3HSQ8V0wi53GprypjIygqWCDlk9EgxXP4OzycLRQxMW/0QaDDSSK9BJIoZA+oIxuiIwyXaCFviui6aa3mcbKoe1JYQ/3HUNUQv4lGO00I/TDS3YKyW7SjvFwYYm5zACUoRIKtkBzio2EZxsA2aI0nCufGP/85j5sV86pnJKs6L4Wcs1Zdfs1vx8ogE8y+Cda+C/JrxZCluDshaifcPfvz015FIhrRdUxcJBFDA+ZfB5R7i0CrVMjFMgCpronAGoK7SGfKqjHjlUIF70p8E27oeIc78kg/Cju9AuxqBeueGELEJByTw+v1Gk22oqkabWnYnrbFQ8sfNn/5Xhlq/tKKrtqUVUy2an2uvO3Z0vJPoJHwAMwxwJibhKhbypgfmpgSZC0tyg+uS/eA4zabSQcJ1NIdRl8Sj/zBSKQx4WVxgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1874,"cache_read_input_tokens":67356,"cache_creation":{"ephemeral_5m_input_tokens":1874,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"070fd41a-3684-4452-8195-ef808a6188bb","timestamp":"2025-12-15T11:46:56.649Z"}
{"parentUuid":"070fd41a-3684-4452-8195-ef808a6188bb","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_019cDUTTS7zWH14XDE2y1Mzr","type":"message","role":"assistant","content":[{"type":"text","text":"现在我需要删除不再使用的 `ProcessRenderUpdate` 和 `ProcessLogicUpdate` 方法，并添加 `ExecuteMove` 方法来执行实际移动。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1874,"cache_read_input_tokens":67356,"cache_creation":{"ephemeral_5m_input_tokens":1874,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"84a69664-3f4c-42d0-91cd-a34061348643","timestamp":"2025-12-15T11:46:57.575Z"}
{"parentUuid":"84a69664-3f4c-42d0-91cd-a34061348643","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_019cDUTTS7zWH14XDE2y1Mzr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VgDRbhhHdsNNF1mZL3U8HU","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","limit":50,"offset":338}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1874,"cache_read_input_tokens":67356,"cache_creation":{"ephemeral_5m_input_tokens":1874,"ephemeral_1h_input_tokens":0},"output_tokens":252,"service_tier":"standard"}},"type":"assistant","uuid":"c91b4b38-38d2-4401-a62d-a899abad093f","timestamp":"2025-12-15T11:46:58.335Z"}
{"parentUuid":"c91b4b38-38d2-4401-a62d-a899abad093f","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VgDRbhhHdsNNF1mZL3U8HU","type":"tool_result","content":"   338→        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n   339→        [System.Obsolete(\"LogicUpdate is no longer used. All logic is now handled in Update to avoid jitter.\")]\n   340→        public virtual void LogicUpdate(float deltaTime)\n   341→        {\n   342→            // 不再处理任何逻辑，所有逻辑已整合到 Update 中\n   343→        }\n   344→\n   345→        /// <summary>\n   346→        /// 延迟更新，目前为空方法，保留用于扩展\n   347→        /// </summary>\n   348→        protected virtual void LateUpdate()\n   349→        {\n   350→            // LateUpdate 不再处理 _velocityLastFrame，改为在 LogicUpdate 中处理\n   351→        }\n   352→\n   353→        /// <summary>\n   354→        /// 固定更新处理（物理帧）\n   355→        /// 处理物理相关的计算，确保物理模拟的一致性\n   356→        /// </summary>\n   357→        protected virtual void ProcessFixedUpdate()\n   358→        {\n   359→            if (_transform == null || !_freeMovement)\n   360→            {\n   361→                return;\n   362→            }\n   363→\n   364→            // 物理相关的固定更新\n   365→            // 1. 重力计算（固定时间步长确保物理一致性）\n   366→            if (GravityActive)\n   367→            {\n   368→                ApplyGravityFixed(Time.fixedDeltaTime);\n   369→            }\n   370→\n   371→            // 2. 移动平台速度计算（物理相关）\n   372→            GetMovingPlatformVelocity();\n   373→            \n   374→            // 3. 应用冲击力（物理相关，固定时间步长）\n   375→            ApplyImpact(Time.fixedDeltaTime);\n   376→        }\n   377→\n   378→        /// <summary>\n   379→        /// 渲染更新处理（每帧）\n   380→        /// 处理实际的移动执行和视觉效果\n   381→        /// </summary>\n   382→        protected virtual void ProcessRenderUpdate()\n   383→        {\n   384→            if (_transform == null || !_freeMovement)\n   385→            {\n   386→                return;\n   387→            }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"9b9db36a-182f-4ea3-9678-38f4dd24699f","timestamp":"2025-12-15T11:46:59.091Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","content":"        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        [System.Obsolete(\"LogicUpdate is no longer used. All logic is now handled in Update to avoid jitter.\")]\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 不再处理任何逻辑，所有逻辑已整合到 Update 中\n        }\n\n        /// <summary>\n        /// 延迟更新，目前为空方法，保留用于扩展\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            // LateUpdate 不再处理 _velocityLastFrame，改为在 LogicUpdate 中处理\n        }\n\n        /// <summary>\n        /// 固定更新处理（物理帧）\n        /// 处理物理相关的计算，确保物理模拟的一致性\n        /// </summary>\n        protected virtual void ProcessFixedUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 物理相关的固定更新\n            // 1. 重力计算（固定时间步长确保物理一致性）\n            if (GravityActive)\n            {\n                ApplyGravityFixed(Time.fixedDeltaTime);\n            }\n\n            // 2. 移动平台速度计算（物理相关）\n            GetMovingPlatformVelocity();\n            \n            // 3. 应用冲击力（物理相关，固定时间步长）\n            ApplyImpact(Time.fixedDeltaTime);\n        }\n\n        /// <summary>\n        /// 渲染更新处理（每帧）\n        /// 处理实际的移动执行和视觉效果\n        /// </summary>\n        protected virtual void ProcessRenderUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }","numLines":50,"startLine":338,"totalLines":1373}}}
{"parentUuid":"9b9db36a-182f-4ea3-9678-38f4dd24699f","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012HmK1QJhBvDkLe3ybj6aq1","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"我需要找到 ProcessRenderUpdate 和 ProcessLogicUpdate 的完整代码并删除它们。让我继续读取。","signature":"EpoCCkYIChgCKkA3lMoSSlFZGf1XsCnJRF4xalUhTmMF0ldW2w4KaCtG2KUFRWLOP/uJ5p0aqzes0bPpcPViDprnoGdQ0ntRvaolEgz+uYccxGruFcRfycIaDJ/wh35EIp5j/5nmKyIwF4na1G8+7zTJ/ma2p3dvfIlqyvH2FXP5asDyJp08yGl2uQH0/besQ3CQcpa5zy0rKoEBagNhDt2WSMpegCoCGjW9farBgex1B6w6EFrvdkGmGf2DMo6fZruw1wUw0cKyDmyAfxeWLUlFFk8T1JbTPtLZYDyutEiw29SH8Zd7eBBXuITnQKhgb9tcWjjSV3bu0mtTqD74g4YCNeNohX4hTUsMwUeeOJT5aOVkAB7WW/PuvEjgGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1118,"cache_read_input_tokens":69230,"cache_creation":{"ephemeral_5m_input_tokens":1118,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"e05be9c2-d785-4a1e-a446-e3e71eba4060","timestamp":"2025-12-15T11:47:04.906Z"}
{"parentUuid":"e05be9c2-d785-4a1e-a446-e3e71eba4060","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012HmK1QJhBvDkLe3ybj6aq1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VhGvLtZU9MfVt4ZWzTMQTH","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","limit":80,"offset":378}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1118,"cache_read_input_tokens":69230,"cache_creation":{"ephemeral_5m_input_tokens":1118,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"d0d3ecdf-1430-4793-9a8e-aeee2edeebf0","timestamp":"2025-12-15T11:47:05.677Z"}
{"parentUuid":"d0d3ecdf-1430-4793-9a8e-aeee2edeebf0","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VhGvLtZU9MfVt4ZWzTMQTH","type":"tool_result","content":"   378→        /// <summary>\n   379→        /// 渲染更新处理（每帧）\n   380→        /// 处理实际的移动执行和视觉效果\n   381→        /// </summary>\n   382→        protected virtual void ProcessRenderUpdate()\n   383→        {\n   384→            if (_transform == null || !_freeMovement)\n   385→            {\n   386→                return;\n   387→            }\n   388→\n   389→            // 1. 基于当前速度和渲染帧时间重新计算移动\n   390→            CalculateRenderFrameMotion();\n   391→            \n   392→            // 2. 执行实际的移动（每帧执行，确保视觉流畅）\n   393→            ExecutePendingMove();\n   394→        }\n   395→\n   396→        /// <summary>\n   397→        /// 逻辑更新处理（逻辑帧）\n   398→        /// 处理游戏逻辑计算，如移动意图、状态更新等\n   399→        /// </summary>\n   400→        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n   401→        protected virtual void ProcessLogicUpdate(float deltaTime)\n   402→        {\n   403→            if (_transform == null || !_freeMovement)\n   404→            {\n   405→                return;\n   406→            }\n   407→\n   408→            // 保存逻辑帧时间增量，用于渲染帧的移动计算\n   409→            _lastLogicDeltaTime = deltaTime;\n   410→\n   411→            // 保存上一帧状态（在 LogicUpdate 开始时保存，确保时序正确）\n   412→            _velocityLastFrame = _velocity;\n   413→            _newVelocity = _velocity;\n   414→            _positionLastFrame = _transform.position;\n   415→\n   416→            // 1. 地面检测（逻辑相关）\n   417→            CheckIfGrounded();\n   418→            \n   419→            // 2. 处理摩擦力（逻辑相关）\n   420→            HandleFriction();\n   421→            \n   422→            // 3. 确定移动方向（基于输入）\n   423→            DetermineDirection();\n   424→            \n   425→            // 4. 处理输入移动（逻辑计算，不实际移动）\n   426→            AddInput(deltaTime);\n   427→            \n   428→            // 5. 处理重力（逻辑计算，不包含固定更新中的重力）\n   429→            AddGravityLogic(deltaTime);\n   430→            \n   431→            // 6. 处理移动平台（逻辑计算）\n   432→            MoveWithPlatform();\n   433→            \n   434→            // 7. 计算速度变化（逻辑计算）\n   435→            ComputeVelocityDelta(deltaTime);\n   436→            \n   437→            // 8. 计算新速度（逻辑状态更新）\n   438→            ComputeNewVelocity(deltaTime);\n   439→            \n   440→            // 9. 计算实际速度（基于逻辑帧时间增量）\n   441→            ComputeSpeed(deltaTime);\n   442→        }\n   443→        \n   444→        /// <summary>\n   445→        /// 处理输入并计算理想速度（包括滑坡逻辑）\n   446→        /// </summary>\n   447→        /// <param name=\"deltaTime\">时间增量</param>\n   448→        protected virtual void AddInput(float deltaTime)\n   449→        {\n   450→            if (_grounded && TooSteep())\n   451→            {\n   452→                _idealVelocity.x = _groundNormal.x;\n   453→                _idealVelocity.y = 0;\n   454→                _idealVelocity.z = _groundNormal.z;\n   455→                _idealVelocity = _idealVelocity.normalized;\n   456→                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n   457→                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1e69ffa8-def0-42e6-b97f-bbafbb72e8e9","timestamp":"2025-12-15T11:47:06.425Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","content":"        /// <summary>\n        /// 渲染更新处理（每帧）\n        /// 处理实际的移动执行和视觉效果\n        /// </summary>\n        protected virtual void ProcessRenderUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 1. 基于当前速度和渲染帧时间重新计算移动\n            CalculateRenderFrameMotion();\n            \n            // 2. 执行实际的移动（每帧执行，确保视觉流畅）\n            ExecutePendingMove();\n        }\n\n        /// <summary>\n        /// 逻辑更新处理（逻辑帧）\n        /// 处理游戏逻辑计算，如移动意图、状态更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        protected virtual void ProcessLogicUpdate(float deltaTime)\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 保存逻辑帧时间增量，用于渲染帧的移动计算\n            _lastLogicDeltaTime = deltaTime;\n\n            // 保存上一帧状态（在 LogicUpdate 开始时保存，确保时序正确）\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测（逻辑相关）\n            CheckIfGrounded();\n            \n            // 2. 处理摩擦力（逻辑相关）\n            HandleFriction();\n            \n            // 3. 确定移动方向（基于输入）\n            DetermineDirection();\n            \n            // 4. 处理输入移动（逻辑计算，不实际移动）\n            AddInput(deltaTime);\n            \n            // 5. 处理重力（逻辑计算，不包含固定更新中的重力）\n            AddGravityLogic(deltaTime);\n            \n            // 6. 处理移动平台（逻辑计算）\n            MoveWithPlatform();\n            \n            // 7. 计算速度变化（逻辑计算）\n            ComputeVelocityDelta(deltaTime);\n            \n            // 8. 计算新速度（逻辑状态更新）\n            ComputeNewVelocity(deltaTime);\n            \n            // 9. 计算实际速度（基于逻辑帧时间增量）\n            ComputeSpeed(deltaTime);\n        }\n        \n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +","numLines":80,"startLine":378,"totalLines":1373}}}
{"parentUuid":"1e69ffa8-def0-42e6-b97f-bbafbb72e8e9","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0155xe1ZdHjcbzHd2WUXwtxJ","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，现在我找到了这两个方法。我需要删除它们，并创建一个新的 ExecuteMove 方法。让我删除这两个方法。","signature":"ErcCCkYIChgCKkCNIQNiYnUuchqsvqH0Ohj4A81HLjy8TfbYgfgX8xoMHZ4wKkUE59sraZmcf55HmQ7KVU70VBqDneGZHBX/PlScEgykq4HH+ZdSJq6wcuMaDPbCX9Kh02Qwde5a7yIwHRbIx0Go5ZqJSd0HpnQPkT2Eq/8msW4uBj3fmEbndWIkWAtlPczo3nBiinw/yPP0Kp4B5btLhwaLbjYtVoSoM/9bg62bhbHZ/yNb73auvcPcKmoXAUtJve7v69V2O2nuX6ZktEJRq9dCeMxFPEgb9nvhj1rCIBMRKp4rRp1B9AYpnaBbHrksWzI1br81fctyezoVq05LuoVfwEIKX6SUrGpW7CJLr6ttNXOq6ulyb1XZBj8DxOvJRLL7gyOah6gydihthGaWr/ItLgIADovO6bgYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1435,"cache_read_input_tokens":70348,"cache_creation":{"ephemeral_5m_input_tokens":1435,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"4c70254d-f1db-4ad2-af44-307b12004cc4","timestamp":"2025-12-15T11:47:12.036Z"}
{"parentUuid":"4c70254d-f1db-4ad2-af44-307b12004cc4","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0155xe1ZdHjcbzHd2WUXwtxJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EELdPT7JdVDiJsm3kVQroX","name":"Edit","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","old_string":"        /// <summary>\n        /// 渲染更新处理（每帧）\n        /// 处理实际的移动执行和视觉效果\n        /// </summary>\n        protected virtual void ProcessRenderUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 1. 基于当前速度和渲染帧时间重新计算移动\n            CalculateRenderFrameMotion();\n            \n            // 2. 执行实际的移动（每帧执行，确保视觉流畅）\n            ExecutePendingMove();\n        }\n\n        /// <summary>\n        /// 逻辑更新处理（逻辑帧）\n        /// 处理游戏逻辑计算，如移动意图、状态更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        protected virtual void ProcessLogicUpdate(float deltaTime)\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 保存逻辑帧时间增量，用于渲染帧的移动计算\n            _lastLogicDeltaTime = deltaTime;\n\n            // 保存上一帧状态（在 LogicUpdate 开始时保存，确保时序正确）\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测（逻辑相关）\n            CheckIfGrounded();\n            \n            // 2. 处理摩擦力（逻辑相关）\n            HandleFriction();\n            \n            // 3. 确定移动方向（基于输入）\n            DetermineDirection();\n            \n            // 4. 处理输入移动（逻辑计算，不实际移动）\n            AddInput(deltaTime);\n            \n            // 5. 处理重力（逻辑计算，不包含固定更新中的重力）\n            AddGravityLogic(deltaTime);\n            \n            // 6. 处理移动平台（逻辑计算）\n            MoveWithPlatform();\n            \n            // 7. 计算速度变化（逻辑计算）\n            ComputeVelocityDelta(deltaTime);\n            \n            // 8. 计算新速度（逻辑状态更新）\n            ComputeNewVelocity(deltaTime);\n            \n            // 9. 计算实际速度（基于逻辑帧时间增量）\n            ComputeSpeed(deltaTime);\n        }\n        ","new_string":"        /// <summary>\n        /// 执行实际的移动\n        /// 直接使用计算好的 _motion 向量进行移动，不再进行二次计算\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ExecuteMove(float deltaTime)\n        {\n            // 1. 执行 CharacterController 移动\n            MoveCharacterController();\n\n            // 2. 检测新的移动平台\n            DetectNewMovingPlatform();\n\n            // 3. 手动处理碰撞器碰撞\n            ManualControllerColliderHit();\n\n            // 4. 处理地面接触状态\n            HandleGroundContact();\n        }\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1435,"cache_read_input_tokens":70348,"cache_creation":{"ephemeral_5m_input_tokens":1435,"ephemeral_1h_input_tokens":0},"output_tokens":1099,"service_tier":"standard"}},"type":"assistant","uuid":"e91e0626-74e9-4681-89d0-b7475aacd317","timestamp":"2025-12-15T11:47:21.940Z"}
{"parentUuid":"e91e0626-74e9-4681-89d0-b7475aacd317","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EELdPT7JdVDiJsm3kVQroX","type":"tool_result","content":"The file E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   374→            // 3. 应用冲击力（物理相关，固定时间步长）\n   375→            ApplyImpact(Time.fixedDeltaTime);\n   376→        }\n   377→\n   378→        /// <summary>\n   379→        /// 执行实际的移动\n   380→        /// 直接使用计算好的 _motion 向量进行移动，不再进行二次计算\n   381→        /// </summary>\n   382→        /// <param name=\"deltaTime\">时间增量</param>\n   383→        protected virtual void ExecuteMove(float deltaTime)\n   384→        {\n   385→            // 1. 执行 CharacterController 移动\n   386→            MoveCharacterController();\n   387→\n   388→            // 2. 检测新的移动平台\n   389→            DetectNewMovingPlatform();\n   390→\n   391→            // 3. 手动处理碰撞器碰撞\n   392→            ManualControllerColliderHit();\n   393→\n   394→            // 4. 处理地面接触状态\n   395→            HandleGroundContact();\n   396→        }\n   397→\n   398→        /// <summary>\n   399→        /// 处理输入并计算理想速度（包括滑坡逻辑）\n   400→        /// </summary>\n   401→        /// <param name=\"deltaTime\">时间增量</param>"}]},"uuid":"8e96e926-3b64-4781-848f-9286a835ff4d","timestamp":"2025-12-15T11:47:22.949Z","toolUseResult":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","oldString":"        /// <summary>\n        /// 渲染更新处理（每帧）\n        /// 处理实际的移动执行和视觉效果\n        /// </summary>\n        protected virtual void ProcessRenderUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 1. 基于当前速度和渲染帧时间重新计算移动\n            CalculateRenderFrameMotion();\n            \n            // 2. 执行实际的移动（每帧执行，确保视觉流畅）\n            ExecutePendingMove();\n        }\n\n        /// <summary>\n        /// 逻辑更新处理（逻辑帧）\n        /// 处理游戏逻辑计算，如移动意图、状态更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        protected virtual void ProcessLogicUpdate(float deltaTime)\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 保存逻辑帧时间增量，用于渲染帧的移动计算\n            _lastLogicDeltaTime = deltaTime;\n\n            // 保存上一帧状态（在 LogicUpdate 开始时保存，确保时序正确）\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测（逻辑相关）\n            CheckIfGrounded();\n            \n            // 2. 处理摩擦力（逻辑相关）\n            HandleFriction();\n            \n            // 3. 确定移动方向（基于输入）\n            DetermineDirection();\n            \n            // 4. 处理输入移动（逻辑计算，不实际移动）\n            AddInput(deltaTime);\n            \n            // 5. 处理重力（逻辑计算，不包含固定更新中的重力）\n            AddGravityLogic(deltaTime);\n            \n            // 6. 处理移动平台（逻辑计算）\n            MoveWithPlatform();\n            \n            // 7. 计算速度变化（逻辑计算）\n            ComputeVelocityDelta(deltaTime);\n            \n            // 8. 计算新速度（逻辑状态更新）\n            ComputeNewVelocity(deltaTime);\n            \n            // 9. 计算实际速度（基于逻辑帧时间增量）\n            ComputeSpeed(deltaTime);\n        }\n        ","newString":"        /// <summary>\n        /// 执行实际的移动\n        /// 直接使用计算好的 _motion 向量进行移动，不再进行二次计算\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ExecuteMove(float deltaTime)\n        {\n            // 1. 执行 CharacterController 移动\n            MoveCharacterController();\n\n            // 2. 检测新的移动平台\n            DetectNewMovingPlatform();\n\n            // 3. 手动处理碰撞器碰撞\n            ManualControllerColliderHit();\n\n            // 4. 处理地面接触状态\n            HandleGroundContact();\n        }\n","originalFile":"using System;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing ActionMachine.Runtime.Attributes;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 运动学角色控制器（Kinematic Character Controller）\n    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    /// </summary>\n    [RequireComponent(typeof(CharacterController))]\n    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    public partial class Kcc : MonoBehaviour\n    {\n        private const float SMALL_VALUE = 0.0001f; // 浮点数比较的最小阈值\n        private const float SPEED_ROUNDING_PRECISION = 100f; // 速度值舍入精度\n        private const float IMPACT_THRESHOLD = 0.2f; // 冲击力应用的最小阈值\n\n        /// <summary>\n        /// 地面检测计算模式\n        /// </summary>\n        public enum GroundedComputationMode\n        {\n            Simple, // 简单模式：使用 CharacterController.isGrounded\n            Advanced // 高级模式：使用多方向射线检测\n        }\n\n        /// <summary>\n        /// 速度传递模式（用于移动平台交互）\n        /// </summary>\n        public enum VelocityTransferMode\n        {\n            NoTransfer, // 不传递速度\n            InitialVelocity, // 传递初始速度\n            FloorVelocity, // 传递地面速度\n            Relative // 相对速度模式\n        }\n\n        [Header(\"Gravity Settings\")] [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n        public float Gravity = 40f;\n\n        [Tooltip(\"是否激活重力\")] public bool GravityActive = true;\n\n        [Header(\"Raycast Settings\")] [Tooltip(\"障碍物层遮罩\")]\n        public LayerMask ObstaclesLayerMask;\n\n        [Tooltip(\"向下射线检测长度\")] public float GroundedRaycastLength = 5f;\n\n        [Tooltip(\"最小着地距离\")] public float MinimumGroundedDistance = 0.2f;\n\n        [Tooltip(\"地面检测计算模式\")] public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n\n        [Tooltip(\"地面法线高度阈值\")] public float GroundNormalHeightThreshold = 0.2f;\n\n        [Tooltip(\"蹲伏时射线长度倍数\")] public float CrouchedRaycastLengthMultiplier = 1f;\n\n        [Tooltip(\"是否执行基本方向障碍物射线检测\")] public bool PerformCardinalObstacleRaycastDetection = false;\n\n        [Header(\"Movement Settings\")] [Tooltip(\"最大下落速度\")]\n        public float MaximumFallSpeed = 20.0f;\n\n        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速\")] \n        public float HorizontalAcceleration = 20f;\n\n        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速\")] \n        public float HorizontalDeceleration = 20f;\n        \n        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n        public float InitialBurstMultiplier = 2.0f;\n        \n        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n        public float BurstSpeedThreshold = 1.0f;\n\n        [Tooltip(\"斜坡速度倍数曲线\")] public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n            new Keyframe(-90, 1),\n            new Keyframe(0, 1),\n            new Keyframe(90, 0)\n        );\n\n        [Tooltip(\"冲击力衰减速度\")] public float ImpactFalloff = 5f;\n\n        [Header(\"Steep Surface Settings\")] [Tooltip(\"是否在陡峭表面滑动\")]\n        public bool SlideOnSteepSurfaces = true;\n\n        [Tooltip(\"滑动速度\")] public float SlidingSpeed = 15f;\n\n        [Tooltip(\"滑动速度控制\")] public float SlidingSpeedControl = 0.4f;\n\n        [Tooltip(\"滑动方向控制\")] public float SlidingDirectionControl = 1f;\n\n        [Header(\"Moving Platform Settings\")] [Tooltip(\"跳跃时的速度传递方式\")]\n        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Movement Smoothing\")]\n        [Tooltip(\"是否启用移动平滑\")]\n        public bool EnableMovementSmoothing = true;\n        \n        [Tooltip(\"水平移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float HorizontalSmoothTime = 0.03f;\n        \n        [Tooltip(\"垂直移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float VerticalSmoothTime = 0.05f;\n\n        [Header(\"Runtime State - Read Only\")]\n        [SerializeField, ReadOnly] private Vector3 _speed;\n        [SerializeField, ReadOnly] private Vector3 _velocity;\n        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n        [SerializeField, ReadOnly] private Vector3 _acceleration;\n        [SerializeField, ReadOnly] private bool _grounded;\n        [SerializeField, ReadOnly] private bool _justGotGrounded;\n        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n        [SerializeField, ReadOnly] private float _friction;\n        [SerializeField, ReadOnly] private Vector3 _addedForce;\n        [SerializeField, ReadOnly] private bool _freeMovement = true;\n        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n\n        // 公共只读属性\n        public Vector3 Speed => _speed;\n        public Vector3 Velocity => _velocity;\n        public Vector3 VelocityLastFrame => _velocityLastFrame;\n        public Vector3 Acceleration => _acceleration;\n        public bool Grounded => _grounded;\n        public bool JustGotGrounded => _justGotGrounded;\n        public Vector3 CurrentMovement => _currentMovement;\n        public Vector3 CurrentDirection => _currentDirection;\n        public float Friction => _friction;\n        public Vector3 AddedForce => _addedForce;\n        public bool FreeMovement => _freeMovement;\n        public Vector3 GroundNormal => _groundNormal;\n        public Vector3 InputMoveDirection => _inputMoveDirection;\n        public Vector3 TargetVelocity => _targetVelocity;\n\n        // 碰撞器相关属性\n        public Vector3 ColliderCenter => transform.position + _characterController.center;\n\n        public Vector3 ColliderBottom => transform.position + _characterController.center +\n                                         Vector3.down * _characterController.bounds.extents.y;\n\n        public Vector3 ColliderTop => transform.position + _characterController.center +\n                                      Vector3.up * _characterController.bounds.extents.y;\n\n        public Vector3 AppliedImpact => _impact;\n\n        // 环境检测属性\n        public GameObject ObjectBelow { get; set; }\n        public GameObject DetectedObstacleLeft { get; set; }\n        public GameObject DetectedObstacleRight { get; set; }\n        public GameObject DetectedObstacleUp { get; set; }\n        public GameObject DetectedObstacleDown { get; set; }\n        public bool CollidingWithCardinalObstacle { get; set; }\n        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n\n        // 移动平台相关属性\n        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n\n        // 组件引用\n        private Transform _transform;\n        private CharacterController _characterController;\n\n        // 碰撞器原始尺寸\n        private float _originalColliderHeight;\n        private Vector3 _originalColliderCenter;\n\n        // 运动状态追踪\n        private Vector3 _positionLastFrame;\n        private bool _groundedLastFrame;\n        private Vector3 _impact;\n        private Vector3 _lastGroundNormal = Vector3.zero;\n        private bool _detached = false;\n        private bool _tooSteepLastFrame;\n\n        // 移动平台追踪\n        private Transform _movingPlatformHitCollider;\n        private Transform _movingPlatformCurrentHitCollider;\n        private Vector3 _movingPlatformCurrentHitColliderLocal;\n        private Vector3 _movingPlatformCurrentGlobalPoint;\n        private Quaternion _movingPlatformLocalRotation;\n        private Quaternion _movingPlatformGlobalRotation;\n        private Quaternion _lastMoveWithPlatformGlobalRotation;\n        private Matrix4x4 _lastMovingPlatformMatrix;\n        private Vector3 _movingPlatformVelocity;\n        private bool _newMovingPlatform;\n\n        // 碰撞检测\n        private CollisionFlags _collisionFlags;\n        private Vector3 _frameVelocity = Vector3.zero;\n        private Vector3 _hitPoint = Vector3.zero;\n        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n        // 速度计算\n        private Vector3 _newVelocity;\n        private Vector3 _motion;\n        private Vector3 _idealVelocity;\n        private Vector3 _idealDirection;\n        private Vector3 _horizontalVelocityDelta;\n        private float _stickyOffset = 0f;\n\n        // 位置移动\n        private RaycastHit _movePositionHit;\n        private Vector3 _capsulePoint1;\n        private Vector3 _capsulePoint2;\n        private Vector3 _movePositionDirection;\n        private float _movePositionDistance;\n\n        // 障碍物检测\n        private RaycastHit _cardinalRaycast;\n        private float _smallestDistance = Single.MaxValue;\n        private float _longestDistance = Single.MinValue;\n        private RaycastHit _smallestRaycast;\n        private RaycastHit _emptyRaycast = new RaycastHit();\n        private Vector3 _downRaycastsOffset;\n\n        // 平台移动计算\n        private Vector3 _moveWithPlatformMoveDistance;\n        private Vector3 _moveWithPlatformGlobalPoint;\n        private Quaternion _moveWithPlatformRotationDiff;\n        private Quaternion _moveWithPlatformGlobalRotation;\n        private RaycastHit _raycastDownHit;\n        private Vector3 _raycastDownDirection = Vector3.down;\n        private RaycastHit _canGoBackHeadCheck;\n        private Vector3 _originalSizeRaycastOrigin;\n\n        // 协程和可选组件\n        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        \n        // 逻辑帧与渲染帧分离\n        private Vector3 _pendingMotion = Vector3.zero;\n        private float _lastLogicDeltaTime = 0f; // 保存逻辑帧的时间增量\n        \n        // 移动平滑相关\n        private Vector3 _smoothedMotion = Vector3.zero;\n        private Vector3 _motionVelocity = Vector3.zero; // SmoothDamp 速度缓存\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n        /// <summary>\n        /// 检查角色头部是否与物体碰撞\n        /// </summary>\n        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n\n        /// <summary>\n        /// 检查当前地面是否过于陡峭\n        /// </summary>\n        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n\n        /// <summary>\n        /// 初始化组件和缓存引用\n        /// </summary>\n        protected virtual void Awake()\n        {\n            _characterController = GetComponent<CharacterController>();\n            _transform = transform;\n            _rigidBody = GetComponent<Rigidbody>();\n\n            _originalColliderHeight = _characterController.height;\n            _originalColliderCenter = _characterController.center;\n            _currentDirection = _transform.forward;\n        }\n\n        /// <summary>\n        /// 固定时间更新（物理帧，处理物理相关的计算）\n        /// 负责物理模拟、重力计算、碰撞检测等需要固定时间步长的操作\n        /// </summary>\n        protected virtual void FixedUpdate()\n        {\n            // 物理相关的固定更新\n            ProcessFixedUpdate();\n        }\n\n        /// <summary>\n        /// 每帧更新（处理所有逻辑计算和移动执行）\n        /// 统一在 Update 中完成所有操作，避免 LogicUpdate 和 RenderUpdate 分离导致的抖动\n        /// </summary>\n        protected virtual void Update()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            float deltaTime = Time.deltaTime;\n\n            // 保存上一帧状态\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测\n            CheckIfGrounded();\n\n            // 2. 处理摩擦力\n            HandleFriction();\n\n            // 3. 确定移动方向\n            DetermineDirection();\n\n            // 4. 处理输入移动\n            AddInput(deltaTime);\n\n            // 5. 处理重力\n            AddGravityLogic(deltaTime);\n\n            // 6. 处理移动平台\n            MoveWithPlatform();\n\n            // 7. 计算速度变化\n            ComputeVelocityDelta(deltaTime);\n\n            // 8. 计算新速度\n            ComputeNewVelocity(deltaTime);\n\n            // 9. 执行实际移动\n            ExecuteMove(deltaTime);\n\n            // 10. 计算实际速度\n            ComputeSpeed(deltaTime);\n        }\n\n        /// <summary>\n        /// 逻辑更新（保留接口用于向后兼容，但不再使用）\n        /// 现在所有逻辑都在 Update 中处理，避免抖动问题\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        [System.Obsolete(\"LogicUpdate is no longer used. All logic is now handled in Update to avoid jitter.\")]\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 不再处理任何逻辑，所有逻辑已整合到 Update 中\n        }\n\n        /// <summary>\n        /// 延迟更新，目前为空方法，保留用于扩展\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            // LateUpdate 不再处理 _velocityLastFrame，改为在 LogicUpdate 中处理\n        }\n\n        /// <summary>\n        /// 固定更新处理（物理帧）\n        /// 处理物理相关的计算，确保物理模拟的一致性\n        /// </summary>\n        protected virtual void ProcessFixedUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 物理相关的固定更新\n            // 1. 重力计算（固定时间步长确保物理一致性）\n            if (GravityActive)\n            {\n                ApplyGravityFixed(Time.fixedDeltaTime);\n            }\n\n            // 2. 移动平台速度计算（物理相关）\n            GetMovingPlatformVelocity();\n            \n            // 3. 应用冲击力（物理相关，固定时间步长）\n            ApplyImpact(Time.fixedDeltaTime);\n        }\n\n        /// <summary>\n        /// 渲染更新处理（每帧）\n        /// 处理实际的移动执行和视觉效果\n        /// </summary>\n        protected virtual void ProcessRenderUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 1. 基于当前速度和渲染帧时间重新计算移动\n            CalculateRenderFrameMotion();\n            \n            // 2. 执行实际的移动（每帧执行，确保视觉流畅）\n            ExecutePendingMove();\n        }\n\n        /// <summary>\n        /// 逻辑更新处理（逻辑帧）\n        /// 处理游戏逻辑计算，如移动意图、状态更新等\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        protected virtual void ProcessLogicUpdate(float deltaTime)\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 保存逻辑帧时间增量，用于渲染帧的移动计算\n            _lastLogicDeltaTime = deltaTime;\n\n            // 保存上一帧状态（在 LogicUpdate 开始时保存，确保时序正确）\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测（逻辑相关）\n            CheckIfGrounded();\n            \n            // 2. 处理摩擦力（逻辑相关）\n            HandleFriction();\n            \n            // 3. 确定移动方向（基于输入）\n            DetermineDirection();\n            \n            // 4. 处理输入移动（逻辑计算，不实际移动）\n            AddInput(deltaTime);\n            \n            // 5. 处理重力（逻辑计算，不包含固定更新中的重力）\n            AddGravityLogic(deltaTime);\n            \n            // 6. 处理移动平台（逻辑计算）\n            MoveWithPlatform();\n            \n            // 7. 计算速度变化（逻辑计算）\n            ComputeVelocityDelta(deltaTime);\n            \n            // 8. 计算新速度（逻辑状态更新）\n            ComputeNewVelocity(deltaTime);\n            \n            // 9. 计算实际速度（基于逻辑帧时间增量）\n            ComputeSpeed(deltaTime);\n        }\n        \n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n                _idealVelocity = _idealVelocity * SlidingSpeed;\n                _targetVelocity = _idealVelocity;\n                _newVelocity = _idealVelocity;\n                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n            }\n            else\n            {\n                _targetVelocity = _currentMovement;\n                \n                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n                \n                Vector3 newHorizontalVelocity;\n                \n                if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                {\n                    float effectiveAcceleration = HorizontalAcceleration;\n                    \n                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n                    {\n                        effectiveAcceleration *= InitialBurstMultiplier;\n                    }\n                    \n                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n                    \n\n                    \n                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n                    {\n                        newHorizontalVelocity = targetHorizontalVelocity;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n                    }\n                }\n                else\n                {\n                    float currentSpeed = currentHorizontalVelocity.magnitude;\n                    float speedReduction = HorizontalDeceleration * deltaTime;\n                    \n\n                    \n                    if (currentSpeed <= speedReduction)\n                    {\n                        newHorizontalVelocity = Vector3.zero;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n                    }\n                }\n                \n                _newVelocity.x = newHorizontalVelocity.x;\n                _newVelocity.z = newHorizontalVelocity.z;\n                \n\n                \n                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    Vector3 floorVelocity = _frameVelocity;\n                    floorVelocity.y = 0;\n                    _newVelocity.x += floorVelocity.x;\n                    _newVelocity.z += floorVelocity.z;\n                }\n                \n                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n                    \n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity.normalized;\n                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n                        \n                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n                        {\n                            projectedDirection.Normalize();\n                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                        }\n                    }\n                    \n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 固定更新中的重力应用（物理帧）\n        /// </summary>\n        /// <param name=\"deltaTime\">固定时间增量</param>\n        protected virtual void ApplyGravityFixed(float deltaTime)\n        {\n            // 固定更新中的重力处理，主要用于物理一致性\n            // 这里可以添加需要在固定时间步长中处理的重力相关逻辑\n        }\n\n        /// <summary>\n        /// 逻辑更新中的重力应用（逻辑帧）\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑时间增量</param>\n        protected virtual void AddGravityLogic(float deltaTime)\n        {\n            if (GravityActive)\n            {\n                if (_grounded)\n                {\n                    _newVelocity.y = -Gravity * deltaTime;\n\n                }\n                else\n                {\n                    float oldY = _newVelocity.y;\n                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n\n                }\n            }\n\n            _newVelocity += _addedForce;\n            _addedForce = Vector3.zero;\n        }\n\n        /// <summary>\n        /// 应用重力到速度（保持向后兼容）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddGravity(float deltaTime)\n        {\n            AddGravityLogic(deltaTime);\n        }\n\n        /// <summary>\n        /// 跟随移动平台移动\n        /// </summary>\n        protected virtual void MoveWithPlatform()\n        {\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _moveWithPlatformMoveDistance = Vector3.zero;\n                _moveWithPlatformGlobalPoint =\n                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n\n                if (_moveWithPlatformMoveDistance != Vector3.zero)\n                {\n                    _characterController.Move(_moveWithPlatformMoveDistance);\n                }\n\n                _moveWithPlatformGlobalRotation =\n                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n            }\n        }\n\n        /// <summary>\n        /// 计算速度增量和粘性偏移\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeVelocityDelta(float deltaTime)\n        {\n            _motion = _newVelocity * deltaTime;\n            _horizontalVelocityDelta.x = _motion.x;\n            _horizontalVelocityDelta.y = 0f;\n            _horizontalVelocityDelta.z = _motion.z;\n            _stickyOffset = Mathf.Max(_characterController.stepOffset, _horizontalVelocityDelta.magnitude);\n\n            if (_grounded)\n            {\n                _motion -= _stickyOffset * Vector3.up;\n            }\n        }\n\n        /// <summary>\n        /// 基于当前速度和渲染帧时间重新计算移动\n        /// Logic 赋值 Velocity，Render 对这个进行插值渲染\n        /// </summary>\n        protected virtual void CalculateRenderFrameMotion()\n        {\n            // 根据速度动态调整时间增量，避免高速时移动幅度过大\n            float speedMagnitude = _velocity.magnitude;\n            float adjustedDeltaTime = Time.deltaTime;\n            \n            // 高速时减少有效时间增量，控制移动幅度\n            if (speedMagnitude > 8f)\n            {\n                // 速度越高，时间增量缩放越小\n                // 扩展速度范围到 100，支持更高的速度\n                float speedFactor = Mathf.InverseLerp(8f, 100f, speedMagnitude);\n                adjustedDeltaTime *= Mathf.Lerp(1f, 0.05f, speedFactor);\n            }\n            \n            // 使用调整后的时间增量计算移动向量\n            Vector3 targetMotion = _velocity * adjustedDeltaTime;\n            \n            // 应用地面接触的粘性偏移（如果需要）\n            if (_grounded)\n            {\n                Vector3 horizontalMotion = new Vector3(targetMotion.x, 0, targetMotion.z);\n                float stickyOffset = Mathf.Max(_characterController.stepOffset * 0.1f, horizontalMotion.magnitude * 0.01f);\n                targetMotion.y -= stickyOffset;\n            }\n            \n            // 应用移动平滑（如果启用）\n            if (EnableMovementSmoothing)\n            {\n                _pendingMotion = CalculateSmoothedMotion(targetMotion);\n            }\n            else\n            {\n                _pendingMotion = targetMotion;\n            }\n        }\n\n        /// <summary>\n        /// 执行待处理的移动（在渲染帧中调用）\n        /// 执行实际的物理移动和碰撞检测\n        /// </summary>\n        protected virtual void ExecutePendingMove()\n        {\n            // 1. 执行实际的 CharacterController 移动\n            MoveCharacterController();\n            \n            // 2. 检测新的移动平台（碰撞相关）\n            DetectNewMovingPlatform();\n            \n            // 3. 手动处理碰撞器碰撞（物理相关）\n            ManualControllerColliderHit();\n            \n            // 4. 处理地面接触状态（物理相关）\n            HandleGroundContact();\n        }\n\n        /// <summary>\n        /// 执行 CharacterController 移动\n        /// </summary>\n        protected virtual void MoveCharacterController()\n        {\n            _groundNormal = Vector3.zero;\n            \n            // 直接使用基于渲染帧时间计算的移动向量\n            _collisionFlags = _characterController.Move(_pendingMotion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n        \n        /// <summary>\n        /// 计算平滑后的移动向量\n        /// 使用简单的 Lerp 进行平滑，避免过度复杂化\n        /// </summary>\n        /// <param name=\"targetMotion\">目标移动向量</param>\n        /// <returns>平滑后的移动向量</returns>\n        protected virtual Vector3 CalculateSmoothedMotion(Vector3 targetMotion)\n        {\n            // 计算目标移动的幅度，用于动态调整平滑强度\n            float targetMagnitude = targetMotion.magnitude;\n            \n            // 基于移动幅度动态调整平滑时间\n            // 移动距离越大，需要更强的平滑\n            float dynamicSmoothTime = 0.016f; // 基础平滑时间（60fps）\n            \n            if (targetMagnitude > 0.1f) // 只对有明显移动时进行调整\n            {\n                // 移动距离越大，平滑时间越长\n                // 这样可以确保高速移动时有足够的平滑\n                dynamicSmoothTime = Mathf.Lerp(0.016f, 0.1f, Mathf.InverseLerp(0.1f, 0.5f, targetMagnitude));\n            }\n            \n            // 使用 SmoothDamp 进行平滑，它能更好地处理不同幅度的移动\n            Vector3 smoothed = Vector3.SmoothDamp(_smoothedMotion, targetMotion, ref _motionVelocity, \n                                                 dynamicSmoothTime, Mathf.Infinity, Time.deltaTime);\n            \n            _smoothedMotion = smoothed;\n            \n            // 防抖动处理\n            if (targetMotion.sqrMagnitude < 0.001f * 0.001f)\n            {\n                _smoothedMotion *= 0.9f;\n                if (_smoothedMotion.sqrMagnitude < 0.0001f)\n                {\n                    _smoothedMotion = Vector3.zero;\n                    _motionVelocity = Vector3.zero;\n                }\n            }\n            \n            return _smoothedMotion;\n        }\n\n        /// <summary>\n        /// 检测是否踩上新的移动平台\n        /// </summary>\n        protected virtual void DetectNewMovingPlatform()\n        {\n            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n            {\n                if (_movingPlatformHitCollider != null)\n                {\n                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n                    _newMovingPlatform = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 计算新速度和加速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeNewVelocity(float deltaTime)\n        {\n            _velocity = _newVelocity;\n            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n        }\n\n        /// <summary>\n        /// 处理地面接触状态和平台速度传递\n        /// </summary>\n        protected virtual void HandleGroundContact()\n        {\n            _grounded = _characterController.isGrounded;\n\n            if (_grounded && !IsGroundedTest())\n            {\n                _grounded = false;\n                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    _frameVelocity = _movingPlatformVelocity;\n                    _velocity += _movingPlatformVelocity;\n                }\n            }\n            else if (!_grounded && IsGroundedTest())\n            {\n                if (_detached && _velocity.y <= 0)\n                {\n                    _grounded = true;\n                    _detached = false;\n                }\n\n                SubtractNewPlatformVelocity();\n            }\n\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _movingPlatformCurrentGlobalPoint = _transform.position;\n                _movingPlatformCurrentHitColliderLocal =\n                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n                _movingPlatformGlobalRotation = _transform.rotation;\n                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n                                               _movingPlatformGlobalRotation;\n            }\n\n            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n            _tooSteepLastFrame = TooSteep();\n        }\n\n        /// <summary>\n        /// 计算当前速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeSpeed(float deltaTime)\n        {\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _positionLastFrame) / deltaTime;\n            }\n\n            // 暂时禁用速度舍入，避免高速时的舍入误差导致抖动\n            // _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            // _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            // _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            \n            _positionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 根据当前移动向量确定方向\n        /// </summary>\n        protected virtual void DetermineDirection()\n        {\n            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n            {\n                _currentDirection = _currentMovement.normalized;\n            }\n        }\n\n        /// <summary>\n        /// 处理摩擦力（预留方法，可在子类中实现）\n        /// </summary>\n        protected virtual void HandleFriction()\n        {\n        }\n\n        /// <summary>\n        /// 检查是否刚刚着地\n        /// </summary>\n        protected virtual void CheckIfGrounded()\n        {\n            _justGotGrounded = !_groundedLastFrame && _grounded;\n            _groundedLastFrame = _grounded;\n        }\n\n        /// <summary>\n        /// 手动触发碰撞器碰撞处理\n        /// </summary>\n        protected virtual void ManualControllerColliderHit()\n        {\n            HandleAdvancedGroundDetection();\n        }\n\n        /// <summary>\n        /// 高级地面检测（使用多方向射线）\n        /// </summary>\n        protected virtual void HandleAdvancedGroundDetection()\n        {\n            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n            {\n                return;\n            }\n\n            _smallestDistance = Single.MaxValue;\n            _longestDistance = Single.MinValue;\n            _smallestRaycast = _emptyRaycast;\n\n            float offset = _characterController.radius;\n\n            _downRaycastsOffset = Vector3.zero;\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, offset);\n            CastRayDownwards();\n\n            if (_smallestRaycast.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n\n                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n                {\n                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n                    {\n                        _groundNormal = _smallestRaycast.normal;\n                    }\n                    else\n                    {\n                        _groundNormal = _lastGroundNormal;\n                    }\n\n                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n                    _hitPoint = _smallestRaycast.point;\n                    _frameVelocity = Vector3.zero;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 向下发射射线检测地面\n        /// </summary>\n        protected virtual void CastRayDownwards()\n        {\n            if (_smallestDistance <= MinimumGroundedDistance)\n            {\n                return;\n            }\n\n            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n                _raycastDownDirection, out _raycastDownHit,\n                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n\n            if (_raycastDownHit.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n\n                if (adjustedDistance < _smallestDistance)\n                {\n                    _smallestDistance = adjustedDistance;\n                    _smallestRaycast = _raycastDownHit;\n                }\n\n                if (adjustedDistance > _longestDistance)\n                {\n                    _longestDistance = adjustedDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n        /// </summary>\n        protected float AdjustDistance(float distance)\n        {\n            return distance - _characterController.height / 2f - _characterController.skinWidth;\n        }\n\n        /// <summary>\n        /// 测试是否真正着地\n        /// </summary>\n        protected virtual bool IsGroundedTest()\n        {\n            bool grounded = false;\n            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n            {\n                if (_smallestDistance <= MinimumGroundedDistance)\n                {\n                    grounded = _groundNormal.y > 0.01f;\n                }\n            }\n            else\n            {\n                grounded = _characterController.isGrounded;\n                _groundNormal = Vector3.up;\n            }\n\n            return grounded;\n        }\n\n        /// <summary>\n        /// 获取移动平台速度\n        /// </summary>\n        protected virtual void GetMovingPlatformVelocity()\n        {\n            if (_movingPlatformCurrentHitCollider != null)\n            {\n                if (!_newMovingPlatform && Time.fixedDeltaTime > SMALL_VALUE)\n                {\n                    _movingPlatformVelocity = (\n                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n                            _movingPlatformCurrentHitColliderLocal)\n                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n                    ) / Time.fixedDeltaTime;\n                }\n\n                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n                _newMovingPlatform = false;\n            }\n            else\n            {\n                _movingPlatformVelocity = Vector3.zero;\n            }\n        }\n\n        /// <summary>\n        /// 减去新平台速度（处理平台切换）\n        /// </summary>\n        protected virtual void SubtractNewPlatformVelocity()\n        {\n            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n            {\n                if (_newMovingPlatform)\n                {\n                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n                }\n                else\n                {\n                    _velocity -= _movingPlatformVelocity;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 协程：延迟减去平台速度\n        /// </summary>\n        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n        {\n            Transform platform = _movingPlatformCurrentHitCollider;\n            yield return _waitForFixedUpdate;\n            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n            {\n                yield return null;\n            }\n\n            _velocity -= _movingPlatformVelocity;\n        }\n\n        /// <summary>\n        /// 判断是否应该跟随平台移动\n        /// </summary>\n        protected virtual bool ShouldMoveWithPlatformThisFrame()\n        {\n            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n                   && _movingPlatformCurrentHitCollider != null;\n        }\n\n        /// <summary>\n        /// 应用冲击力并逐渐衰减\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ApplyImpact(float deltaTime)\n        {\n            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n            {\n                _characterController.Move(_impact * deltaTime);\n            }\n\n            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * deltaTime);\n        }\n\n        /// <summary>\n        /// 从地面分离（用于跳跃等）\n        /// </summary>\n        public virtual void DetachFromGround()\n        {\n            _detached = true;\n        }\n\n        /// <summary>\n        /// 从移动平台分离\n        /// </summary>\n        public virtual void DetachFromMovingPlatform()\n        {\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n        }\n\n        /// <summary>\n        /// 设置重力是否激活\n        /// </summary>\n        public virtual void SetGravityActive(bool status)\n        {\n            GravityActive = status;\n        }\n\n        /// <summary>\n        /// 添加外部力（会在下一帧应用）\n        /// </summary>\n        public virtual void AddForce(Vector3 movement)\n        {\n            _addedForce += movement;\n        }\n\n        /// <summary>\n        /// 施加瞬时冲击力\n        /// </summary>\n        /// <param name=\"direction\">冲击方向</param>\n        /// <param name=\"force\">冲击力大小</param>\n        public virtual void Impact(Vector3 direction, float force)\n        {\n            direction = direction.normalized;\n            if (direction.y < 0)\n            {\n                direction.y = -direction.y;\n            }\n\n            _impact += direction.normalized * force;\n        }\n\n        /// <summary>\n        /// 设置移动向量（通常由输入系统调用）\n        /// </summary>\n        /// <param name=\"movement\">移动向量</param>\n        public virtual void SetMovement(Vector3 movement)\n        {\n            _currentMovement = movement;\n\n            Vector3 directionVector = movement;\n            if (directionVector != Vector3.zero)\n            {\n                float directionLength = directionVector.magnitude;\n                directionVector = directionVector / directionLength;\n                directionLength = Mathf.Min(1, directionLength);\n                // 移除平方操作，保持线性响应，避免高速时的非线性抖动\n                directionVector = directionVector * directionLength;\n            }\n\n            _inputMoveDirection = transform.rotation * directionVector;\n        }\n\n        /// <summary>\n        /// 移动到指定位置（带碰撞检测）\n        /// </summary>\n        /// <param name=\"newPosition\">目标位置</param>\n        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n        {\n            _movePositionDirection = newPosition - transform.position;\n            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n\n            _capsulePoint1 = transform.position\n                             + _characterController.center\n                             - (Vector3.up * _characterController.height / 2f)\n                             + Vector3.up * _characterController.skinWidth\n                             + Vector3.up * _characterController.radius;\n\n            _capsulePoint2 = transform.position\n                             + _characterController.center\n                             + (Vector3.up * _characterController.height / 2f)\n                             - Vector3.up * _characterController.skinWidth\n                             - Vector3.up * _characterController.radius;\n\n            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n            {\n                transform.position = newPosition;\n            }\n        }\n\n        /// <summary>\n        /// 调整碰撞器高度（用于蹲伏等）\n        /// </summary>\n        /// <param name=\"newHeight\">新高度</param>\n        /// <param name=\"translateCenter\">是否平移中心点</param>\n        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n        {\n            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n            _characterController.height = newHeight;\n            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n\n            if (translateCenter)\n            {\n                transform.Translate((newYOffset / 2f) * Vector3.up);\n            }\n        }\n\n        /// <summary>\n        /// 重置碰撞器尺寸到原始大小\n        /// </summary>\n        public virtual void ResetColliderSize()\n        {\n            _characterController.height = _originalColliderHeight;\n            _characterController.center = _originalColliderCenter;\n        }\n\n        /// <summary>\n        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n        /// </summary>\n        public virtual bool CanGoBackToOriginalSize()\n        {\n            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n            {\n                return true;\n            }\n\n            float headCheckDistance =\n                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n\n            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n                ObstaclesLayerMask, Color.cyan, true);\n\n            return _canGoBackHeadCheck.collider == null;\n        }\n\n        /// <summary>\n        /// 启用碰撞\n        /// </summary>\n        public virtual void CollisionsOn()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = true;\n            }\n        }\n\n        /// <summary>\n        /// 禁用碰撞\n        /// </summary>\n        public virtual void CollisionsOff()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = false;\n            }\n        }\n\n        /// <summary>\n        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n        /// </summary>\n        public virtual void SetKinematic(bool state)\n        {\n            _rigidBody.isKinematic = state;\n        }\n\n        /// <summary>\n        /// 设置是否允许自由移动\n        /// </summary>\n        public virtual void SetFreeMovement(bool state)\n        {\n            _freeMovement = state;\n        }\n\n        /// <summary>\n        /// 检测四个基本方向的障碍物\n        /// </summary>\n        /// <param name=\"distance\">检测距离</param>\n        /// <param name=\"offset\">起始偏移</param>\n        public virtual void DetectObstacles(float distance, Vector3 offset)\n        {\n            if (!PerformCardinalObstacleRaycastDetection)\n            {\n                return;\n            }\n\n            CollidingWithCardinalObstacle = false;\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleRight = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleLeft = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleUp = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleDown = null;\n            }\n        }\n\n        /// <summary>\n        /// 重置控制器到初始状态\n        /// </summary>\n        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n            \n            // 重置平滑移动相关变量\n            _pendingMotion = Vector3.zero;\n            _smoothedMotion = Vector3.zero;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n\n            return hit;\n        }\n    }\n}","structuredPatch":[{"oldStart":376,"oldLines":71,"newStart":376,"newLines":25,"lines":["         }"," ","         /// <summary>","-        /// 渲染更新处理（每帧）","-        /// 处理实际的移动执行和视觉效果","+        /// 执行实际的移动","+        /// 直接使用计算好的 _motion 向量进行移动，不再进行二次计算","         /// </summary>","-        protected virtual void ProcessRenderUpdate()","+        /// <param name=\"deltaTime\">时间增量</param>","+        protected virtual void ExecuteMove(float deltaTime)","         {","-            if (_transform == null || !_freeMovement)","-            {","-                return;","-            }","+            // 1. 执行 CharacterController 移动","+            MoveCharacterController();"," ","-            // 1. 基于当前速度和渲染帧时间重新计算移动","-            CalculateRenderFrameMotion();","-            ","-            // 2. 执行实际的移动（每帧执行，确保视觉流畅）","-            ExecutePendingMove();","-        }","+            // 2. 检测新的移动平台","+            DetectNewMovingPlatform();"," ","-        /// <summary>","-        /// 逻辑更新处理（逻辑帧）","-        /// 处理游戏逻辑计算，如移动意图、状态更新等","-        /// </summary>","-        /// <param name=\"deltaTime\">逻辑帧时间增量</param>","-        protected virtual void ProcessLogicUpdate(float deltaTime)","-        {","-            if (_transform == null || !_freeMovement)","-            {","-                return;","-            }","+            // 3. 手动处理碰撞器碰撞","+            ManualControllerColliderHit();"," ","-            // 保存逻辑帧时间增量，用于渲染帧的移动计算","-            _lastLogicDeltaTime = deltaTime;","-","-            // 保存上一帧状态（在 LogicUpdate 开始时保存，确保时序正确）","-            _velocityLastFrame = _velocity;","-            _newVelocity = _velocity;","-            _positionLastFrame = _transform.position;","-","-            // 1. 地面检测（逻辑相关）","-            CheckIfGrounded();","-            ","-            // 2. 处理摩擦力（逻辑相关）","-            HandleFriction();","-            ","-            // 3. 确定移动方向（基于输入）","-            DetermineDirection();","-            ","-            // 4. 处理输入移动（逻辑计算，不实际移动）","-            AddInput(deltaTime);","-            ","-            // 5. 处理重力（逻辑计算，不包含固定更新中的重力）","-            AddGravityLogic(deltaTime);","-            ","-            // 6. 处理移动平台（逻辑计算）","-            MoveWithPlatform();","-            ","-            // 7. 计算速度变化（逻辑计算）","-            ComputeVelocityDelta(deltaTime);","-            ","-            // 8. 计算新速度（逻辑状态更新）","-            ComputeNewVelocity(deltaTime);","-            ","-            // 9. 计算实际速度（基于逻辑帧时间增量）","-            ComputeSpeed(deltaTime);","+            // 4. 处理地面接触状态","+            HandleGroundContact();","         }","-        ","+","         /// <summary>","         /// 处理输入并计算理想速度（包括滑坡逻辑）","         /// </summary>"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"8e96e926-3b64-4781-848f-9286a835ff4d","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017EHDYgB14NCgBMuvkhsozo","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，现在我需要修改 MoveCharacterController 方法，让它直接使用 _motion 而不是 _pendingMotion，因为我们不再需要分离的渲染帧计算。","signature":"EtICCkYIChgCKkCmTGe2gErAdQ13ktRsaMlylb5bm/kk/BLqQZSTFq9N5yLg36vVk4bFIT4+VqoEEOsE32wEg2bqmdpg6ccGKJPFEgwsigvrCO4u5HDTydcaDC7a2YNnpbqgwQdRfiIwIBZImaYSZfevlo1MDJTuPBf0aSHb5uiyFKYNOCsE73Fj4U+UNtBxP2QROfNWBb9cKrkBxX/N5SkPwRutrJy/Yp0xbBuOf/Oftq60tsBfrxi8+zo2yvgBvqnuL/0PBDxCV/Iqk/OmpixKGdjqXTUF8QpeMLYQRLchsFKbMgHQp0bMuCTxRBvferqXHcH+RHmNLMZ2c/0Y0kLYR0Ex7rpDDJ95fT284MXhEIKZU13kpcE7VfhP3SUIuA/02ryRxhbk43WhdKEBZWwDYJRLu8cX1UTUnueNe2oXTs7J7XEpxXzm13BuDRMHnvFAf4oYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":1555,"cache_read_input_tokens":71783,"cache_creation":{"ephemeral_5m_input_tokens":1555,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"fe6cfafe-e717-459e-b746-7be0996aa9ac","timestamp":"2025-12-15T11:47:29.270Z"}
{"parentUuid":"fe6cfafe-e717-459e-b746-7be0996aa9ac","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017EHDYgB14NCgBMuvkhsozo","type":"message","role":"assistant","content":[{"type":"text","text":"现在我需要修改 `MoveCharacterController` 方法，让它直接使用 `_motion` 向量进行移动。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":1555,"cache_read_input_tokens":71783,"cache_creation":{"ephemeral_5m_input_tokens":1555,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"a42a2d1a-0610-4373-a059-e9c41f4f8092","timestamp":"2025-12-15T11:47:29.806Z"}
{"parentUuid":"a42a2d1a-0610-4373-a059-e9c41f4f8092","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017EHDYgB14NCgBMuvkhsozo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016jKR41buc6qXnFMYLBh7PE","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","limit":30,"offset":595}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":1555,"cache_read_input_tokens":71783,"cache_creation":{"ephemeral_5m_input_tokens":1555,"ephemeral_1h_input_tokens":0},"output_tokens":227,"service_tier":"standard"}},"type":"assistant","uuid":"cd0316d5-8331-4279-b137-b60643f231ab","timestamp":"2025-12-15T11:47:30.714Z"}
{"parentUuid":"cd0316d5-8331-4279-b137-b60643f231ab","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016jKR41buc6qXnFMYLBh7PE","type":"tool_result","content":"   595→        protected virtual void CalculateRenderFrameMotion()\n   596→        {\n   597→            // 根据速度动态调整时间增量，避免高速时移动幅度过大\n   598→            float speedMagnitude = _velocity.magnitude;\n   599→            float adjustedDeltaTime = Time.deltaTime;\n   600→            \n   601→            // 高速时减少有效时间增量，控制移动幅度\n   602→            if (speedMagnitude > 8f)\n   603→            {\n   604→                // 速度越高，时间增量缩放越小\n   605→                // 扩展速度范围到 100，支持更高的速度\n   606→                float speedFactor = Mathf.InverseLerp(8f, 100f, speedMagnitude);\n   607→                adjustedDeltaTime *= Mathf.Lerp(1f, 0.05f, speedFactor);\n   608→            }\n   609→            \n   610→            // 使用调整后的时间增量计算移动向量\n   611→            Vector3 targetMotion = _velocity * adjustedDeltaTime;\n   612→            \n   613→            // 应用地面接触的粘性偏移（如果需要）\n   614→            if (_grounded)\n   615→            {\n   616→                Vector3 horizontalMotion = new Vector3(targetMotion.x, 0, targetMotion.z);\n   617→                float stickyOffset = Mathf.Max(_characterController.stepOffset * 0.1f, horizontalMotion.magnitude * 0.01f);\n   618→                targetMotion.y -= stickyOffset;\n   619→            }\n   620→            \n   621→            // 应用移动平滑（如果启用）\n   622→            if (EnableMovementSmoothing)\n   623→            {\n   624→                _pendingMotion = CalculateSmoothedMotion(targetMotion);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"664989b4-4d9c-4792-aa72-763525d172af","timestamp":"2025-12-15T11:47:31.466Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","content":"        protected virtual void CalculateRenderFrameMotion()\n        {\n            // 根据速度动态调整时间增量，避免高速时移动幅度过大\n            float speedMagnitude = _velocity.magnitude;\n            float adjustedDeltaTime = Time.deltaTime;\n            \n            // 高速时减少有效时间增量，控制移动幅度\n            if (speedMagnitude > 8f)\n            {\n                // 速度越高，时间增量缩放越小\n                // 扩展速度范围到 100，支持更高的速度\n                float speedFactor = Mathf.InverseLerp(8f, 100f, speedMagnitude);\n                adjustedDeltaTime *= Mathf.Lerp(1f, 0.05f, speedFactor);\n            }\n            \n            // 使用调整后的时间增量计算移动向量\n            Vector3 targetMotion = _velocity * adjustedDeltaTime;\n            \n            // 应用地面接触的粘性偏移（如果需要）\n            if (_grounded)\n            {\n                Vector3 horizontalMotion = new Vector3(targetMotion.x, 0, targetMotion.z);\n                float stickyOffset = Mathf.Max(_characterController.stepOffset * 0.1f, horizontalMotion.magnitude * 0.01f);\n                targetMotion.y -= stickyOffset;\n            }\n            \n            // 应用移动平滑（如果启用）\n            if (EnableMovementSmoothing)\n            {\n                _pendingMotion = CalculateSmoothedMotion(targetMotion);","numLines":30,"startLine":595,"totalLines":1327}}}
{"parentUuid":"664989b4-4d9c-4792-aa72-763525d172af","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01WpNjaeZZ3qYhqKLaT2S9Cp","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"我需要删除 CalculateRenderFrameMotion、ExecutePendingMove 和 CalculateSmoothedMotion 这些不再需要的方法，因为我们现在直接在 Update 中使用 _motion 进行移动，不再需要这些复杂的二次计算。让我先找到这些方法的完整代码。","signature":"Er4DCkYIChgCKkC6ge3Czv7NWybPxAAeURTXcnLkoJBjvUUCgcrlNxs16tLApAfVLDHCzBo2UUQq/rVLPBU6c1WTKf0Pav76vwA0EgwipUxtgKDfofWs9nEaDMLe9QMoC0fB5FeVgCIw2s/zk5Grk/5rnbgm09LyUkl0k0DO4aTPORI8P/YLfAB9u3Zyvf9wTGADD+GBtmwDKqUCPw3N6neCR6lM86xdqKfSmvoV0rxRAYOtDsoCTj/RdlifUkOYAad6DYQ4xmhqcRj8elZkf9Ad1IjNfRrkSnz5lLJORsJrWmdxoZdmZMAtucfybSbUTjpkTNflM3v18YpV46g7jstbk2YFde/4dWFOaj9UDmK9wfAVzLfuHx4dm1D+3wBVIIo0S6SFOCFSeQfICWNHV2IgyA2sMOseYyGCUrWp267No7yYpXa4i5ALYeIIransbwpRT/HKf9y87k6QtFV4iKpXKm2gr1pCpZMOZ75JPj5ghgaJPkYThULt5rSAylS4E+WKgcXWS5baoy8elmTF8LZZtg7eCRoXdutNV7SNIFia1GGnmYmHnd/rmOUG1aYRS57GvawcDgIbcHxQAA+idPoYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":9,"cache_creation_input_tokens":949,"cache_read_input_tokens":73338,"cache_creation":{"ephemeral_5m_input_tokens":949,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"3201b538-9ab1-438e-9fcc-dbd0a5d6eb4e","timestamp":"2025-12-15T11:47:38.091Z"}
{"parentUuid":"3201b538-9ab1-438e-9fcc-dbd0a5d6eb4e","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01WpNjaeZZ3qYhqKLaT2S9Cp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PanKnmYg7A7W8mqVEGSd5t","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","limit":100,"offset":590}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":9,"cache_creation_input_tokens":949,"cache_read_input_tokens":73338,"cache_creation":{"ephemeral_5m_input_tokens":949,"ephemeral_1h_input_tokens":0},"output_tokens":226,"service_tier":"standard"}},"type":"assistant","uuid":"f3a45429-ddb7-49bb-af16-9a1541e9c455","timestamp":"2025-12-15T11:47:39.004Z"}
{"parentUuid":"f3a45429-ddb7-49bb-af16-9a1541e9c455","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PanKnmYg7A7W8mqVEGSd5t","type":"tool_result","content":"   590→\n   591→        /// <summary>\n   592→        /// 基于当前速度和渲染帧时间重新计算移动\n   593→        /// Logic 赋值 Velocity，Render 对这个进行插值渲染\n   594→        /// </summary>\n   595→        protected virtual void CalculateRenderFrameMotion()\n   596→        {\n   597→            // 根据速度动态调整时间增量，避免高速时移动幅度过大\n   598→            float speedMagnitude = _velocity.magnitude;\n   599→            float adjustedDeltaTime = Time.deltaTime;\n   600→            \n   601→            // 高速时减少有效时间增量，控制移动幅度\n   602→            if (speedMagnitude > 8f)\n   603→            {\n   604→                // 速度越高，时间增量缩放越小\n   605→                // 扩展速度范围到 100，支持更高的速度\n   606→                float speedFactor = Mathf.InverseLerp(8f, 100f, speedMagnitude);\n   607→                adjustedDeltaTime *= Mathf.Lerp(1f, 0.05f, speedFactor);\n   608→            }\n   609→            \n   610→            // 使用调整后的时间增量计算移动向量\n   611→            Vector3 targetMotion = _velocity * adjustedDeltaTime;\n   612→            \n   613→            // 应用地面接触的粘性偏移（如果需要）\n   614→            if (_grounded)\n   615→            {\n   616→                Vector3 horizontalMotion = new Vector3(targetMotion.x, 0, targetMotion.z);\n   617→                float stickyOffset = Mathf.Max(_characterController.stepOffset * 0.1f, horizontalMotion.magnitude * 0.01f);\n   618→                targetMotion.y -= stickyOffset;\n   619→            }\n   620→            \n   621→            // 应用移动平滑（如果启用）\n   622→            if (EnableMovementSmoothing)\n   623→            {\n   624→                _pendingMotion = CalculateSmoothedMotion(targetMotion);\n   625→            }\n   626→            else\n   627→            {\n   628→                _pendingMotion = targetMotion;\n   629→            }\n   630→        }\n   631→\n   632→        /// <summary>\n   633→        /// 执行待处理的移动（在渲染帧中调用）\n   634→        /// 执行实际的物理移动和碰撞检测\n   635→        /// </summary>\n   636→        protected virtual void ExecutePendingMove()\n   637→        {\n   638→            // 1. 执行实际的 CharacterController 移动\n   639→            MoveCharacterController();\n   640→            \n   641→            // 2. 检测新的移动平台（碰撞相关）\n   642→            DetectNewMovingPlatform();\n   643→            \n   644→            // 3. 手动处理碰撞器碰撞（物理相关）\n   645→            ManualControllerColliderHit();\n   646→            \n   647→            // 4. 处理地面接触状态（物理相关）\n   648→            HandleGroundContact();\n   649→        }\n   650→\n   651→        /// <summary>\n   652→        /// 执行 CharacterController 移动\n   653→        /// </summary>\n   654→        protected virtual void MoveCharacterController()\n   655→        {\n   656→            _groundNormal = Vector3.zero;\n   657→            \n   658→            // 直接使用基于渲染帧时间计算的移动向量\n   659→            _collisionFlags = _characterController.Move(_pendingMotion);\n   660→            _lastHitPoint = _hitPoint;\n   661→            _lastGroundNormal = _groundNormal;\n   662→        }\n   663→        \n   664→        /// <summary>\n   665→        /// 计算平滑后的移动向量\n   666→        /// 使用简单的 Lerp 进行平滑，避免过度复杂化\n   667→        /// </summary>\n   668→        /// <param name=\"targetMotion\">目标移动向量</param>\n   669→        /// <returns>平滑后的移动向量</returns>\n   670→        protected virtual Vector3 CalculateSmoothedMotion(Vector3 targetMotion)\n   671→        {\n   672→            // 计算目标移动的幅度，用于动态调整平滑强度\n   673→            float targetMagnitude = targetMotion.magnitude;\n   674→            \n   675→            // 基于移动幅度动态调整平滑时间\n   676→            // 移动距离越大，需要更强的平滑\n   677→            float dynamicSmoothTime = 0.016f; // 基础平滑时间（60fps）\n   678→            \n   679→            if (targetMagnitude > 0.1f) // 只对有明显移动时进行调整\n   680→            {\n   681→                // 移动距离越大，平滑时间越长\n   682→                // 这样可以确保高速移动时有足够的平滑\n   683→                dynamicSmoothTime = Mathf.Lerp(0.016f, 0.1f, Mathf.InverseLerp(0.1f, 0.5f, targetMagnitude));\n   684→            }\n   685→            \n   686→            // 使用 SmoothDamp 进行平滑，它能更好地处理不同幅度的移动\n   687→            Vector3 smoothed = Vector3.SmoothDamp(_smoothedMotion, targetMotion, ref _motionVelocity, \n   688→                                                 dynamicSmoothTime, Mathf.Infinity, Time.deltaTime);\n   689→            \n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e3069101-c3df-4107-872c-f063995ea99e","timestamp":"2025-12-15T11:47:39.781Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","content":"\n        /// <summary>\n        /// 基于当前速度和渲染帧时间重新计算移动\n        /// Logic 赋值 Velocity，Render 对这个进行插值渲染\n        /// </summary>\n        protected virtual void CalculateRenderFrameMotion()\n        {\n            // 根据速度动态调整时间增量，避免高速时移动幅度过大\n            float speedMagnitude = _velocity.magnitude;\n            float adjustedDeltaTime = Time.deltaTime;\n            \n            // 高速时减少有效时间增量，控制移动幅度\n            if (speedMagnitude > 8f)\n            {\n                // 速度越高，时间增量缩放越小\n                // 扩展速度范围到 100，支持更高的速度\n                float speedFactor = Mathf.InverseLerp(8f, 100f, speedMagnitude);\n                adjustedDeltaTime *= Mathf.Lerp(1f, 0.05f, speedFactor);\n            }\n            \n            // 使用调整后的时间增量计算移动向量\n            Vector3 targetMotion = _velocity * adjustedDeltaTime;\n            \n            // 应用地面接触的粘性偏移（如果需要）\n            if (_grounded)\n            {\n                Vector3 horizontalMotion = new Vector3(targetMotion.x, 0, targetMotion.z);\n                float stickyOffset = Mathf.Max(_characterController.stepOffset * 0.1f, horizontalMotion.magnitude * 0.01f);\n                targetMotion.y -= stickyOffset;\n            }\n            \n            // 应用移动平滑（如果启用）\n            if (EnableMovementSmoothing)\n            {\n                _pendingMotion = CalculateSmoothedMotion(targetMotion);\n            }\n            else\n            {\n                _pendingMotion = targetMotion;\n            }\n        }\n\n        /// <summary>\n        /// 执行待处理的移动（在渲染帧中调用）\n        /// 执行实际的物理移动和碰撞检测\n        /// </summary>\n        protected virtual void ExecutePendingMove()\n        {\n            // 1. 执行实际的 CharacterController 移动\n            MoveCharacterController();\n            \n            // 2. 检测新的移动平台（碰撞相关）\n            DetectNewMovingPlatform();\n            \n            // 3. 手动处理碰撞器碰撞（物理相关）\n            ManualControllerColliderHit();\n            \n            // 4. 处理地面接触状态（物理相关）\n            HandleGroundContact();\n        }\n\n        /// <summary>\n        /// 执行 CharacterController 移动\n        /// </summary>\n        protected virtual void MoveCharacterController()\n        {\n            _groundNormal = Vector3.zero;\n            \n            // 直接使用基于渲染帧时间计算的移动向量\n            _collisionFlags = _characterController.Move(_pendingMotion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n        \n        /// <summary>\n        /// 计算平滑后的移动向量\n        /// 使用简单的 Lerp 进行平滑，避免过度复杂化\n        /// </summary>\n        /// <param name=\"targetMotion\">目标移动向量</param>\n        /// <returns>平滑后的移动向量</returns>\n        protected virtual Vector3 CalculateSmoothedMotion(Vector3 targetMotion)\n        {\n            // 计算目标移动的幅度，用于动态调整平滑强度\n            float targetMagnitude = targetMotion.magnitude;\n            \n            // 基于移动幅度动态调整平滑时间\n            // 移动距离越大，需要更强的平滑\n            float dynamicSmoothTime = 0.016f; // 基础平滑时间（60fps）\n            \n            if (targetMagnitude > 0.1f) // 只对有明显移动时进行调整\n            {\n                // 移动距离越大，平滑时间越长\n                // 这样可以确保高速移动时有足够的平滑\n                dynamicSmoothTime = Mathf.Lerp(0.016f, 0.1f, Mathf.InverseLerp(0.1f, 0.5f, targetMagnitude));\n            }\n            \n            // 使用 SmoothDamp 进行平滑，它能更好地处理不同幅度的移动\n            Vector3 smoothed = Vector3.SmoothDamp(_smoothedMotion, targetMotion, ref _motionVelocity, \n                                                 dynamicSmoothTime, Mathf.Infinity, Time.deltaTime);\n            ","numLines":100,"startLine":590,"totalLines":1327}}}
{"parentUuid":"e3069101-c3df-4107-872c-f063995ea99e","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01HL6iZEwvqG1zKcjjiwce5M","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"我现在需要删除这些不再需要的方法，并简化 MoveCharacterController 使其直接使用 _motion。让我进行编辑。","signature":"ErACCkYIChgCKkBEN0eCBPZZcLaG6t3zFQuBsz98ylz7N8t8vBfzqRTXXn3zYNwMo0EkZoc6Vpco7OIIh4ey9CXKGah4C5Fpxgm8EgzBdSK85G6D5J3EKuMaDNREf7Zjt8d2vwooIyIwR6g7/DpiZU+zbZpPlzQUEFVTl8nIUG4peb2Fpc4yCcQmSXYEyXhcMQlXAyk73KdIKpcB4/1qLB82vUhJwlIQeCmgmoye8YNYj+dFNEBgcM4jnaxvn962DQRKYW9VtncTCW0q5bcxBt35+lxFnaB0BhMg6rqDXTyXFZEt0GuBGRC9XotbgvyLGi3JpzOkPHuLN42JJqslBFT8B7DgOyxXDNjjVYupnSTxk3e6RdWdEbHZHlh4YNyaI9qFrDxDBZDdWVpaC3gNJr39ERgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":9,"cache_creation_input_tokens":1935,"cache_read_input_tokens":74287,"cache_creation":{"ephemeral_5m_input_tokens":1935,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"7f14b824-3fab-47b0-9340-a54aa581f532","timestamp":"2025-12-15T11:47:44.934Z"}
{"parentUuid":"7f14b824-3fab-47b0-9340-a54aa581f532","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01HL6iZEwvqG1zKcjjiwce5M","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019zhWjZYXBxZ4ruGME9kSED","name":"Edit","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","old_string":"\n        /// <summary>\n        /// 基于当前速度和渲染帧时间重新计算移动\n        /// Logic 赋值 Velocity，Render 对这个进行插值渲染\n        /// </summary>\n        protected virtual void CalculateRenderFrameMotion()\n        {\n            // 根据速度动态调整时间增量，避免高速时移动幅度过大\n            float speedMagnitude = _velocity.magnitude;\n            float adjustedDeltaTime = Time.deltaTime;\n            \n            // 高速时减少有效时间增量，控制移动幅度\n            if (speedMagnitude > 8f)\n            {\n                // 速度越高，时间增量缩放越小\n                // 扩展速度范围到 100，支持更高的速度\n                float speedFactor = Mathf.InverseLerp(8f, 100f, speedMagnitude);\n                adjustedDeltaTime *= Mathf.Lerp(1f, 0.05f, speedFactor);\n            }\n            \n            // 使用调整后的时间增量计算移动向量\n            Vector3 targetMotion = _velocity * adjustedDeltaTime;\n            \n            // 应用地面接触的粘性偏移（如果需要）\n            if (_grounded)\n            {\n                Vector3 horizontalMotion = new Vector3(targetMotion.x, 0, targetMotion.z);\n                float stickyOffset = Mathf.Max(_characterController.stepOffset * 0.1f, horizontalMotion.magnitude * 0.01f);\n                targetMotion.y -= stickyOffset;\n            }\n            \n            // 应用移动平滑（如果启用）\n            if (EnableMovementSmoothing)\n            {\n                _pendingMotion = CalculateSmoothedMotion(targetMotion);\n            }\n            else\n            {\n                _pendingMotion = targetMotion;\n            }\n        }\n\n        /// <summary>\n        /// 执行待处理的移动（在渲染帧中调用）\n        /// 执行实际的物理移动和碰撞检测\n        /// </summary>\n        protected virtual void ExecutePendingMove()\n        {\n            // 1. 执行实际的 CharacterController 移动\n            MoveCharacterController();\n            \n            // 2. 检测新的移动平台（碰撞相关）\n            DetectNewMovingPlatform();\n            \n            // 3. 手动处理碰撞器碰撞（物理相关）\n            ManualControllerColliderHit();\n            \n            // 4. 处理地面接触状态（物理相关）\n            HandleGroundContact();\n        }\n\n        /// <summary>\n        /// 执行 CharacterController 移动\n        /// </summary>\n        protected virtual void MoveCharacterController()\n        {\n            _groundNormal = Vector3.zero;\n            \n            // 直接使用基于渲染帧时间计算的移动向量\n            _collisionFlags = _characterController.Move(_pendingMotion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n        \n        /// <summary>\n        /// 计算平滑后的移动向量\n        /// 使用简单的 Lerp 进行平滑，避免过度复杂化\n        /// </summary>\n        /// <param name=\"targetMotion\">目标移动向量</param>\n        /// <returns>平滑后的移动向量</returns>\n        protected virtual Vector3 CalculateSmoothedMotion(Vector3 targetMotion)\n        {\n            // 计算目标移动的幅度，用于动态调整平滑强度\n            float targetMagnitude = targetMotion.magnitude;\n            \n            // 基于移动幅度动态调整平滑时间\n            // 移动距离越大，需要更强的平滑\n            float dynamicSmoothTime = 0.016f; // 基础平滑时间（60fps）\n            \n            if (targetMagnitude > 0.1f) // 只对有明显移动时进行调整\n            {\n                // 移动距离越大，平滑时间越长\n                // 这样可以确保高速移动时有足够的平滑\n                dynamicSmoothTime = Mathf.Lerp(0.016f, 0.1f, Mathf.InverseLerp(0.1f, 0.5f, targetMagnitude));\n            }\n            \n            // 使用 SmoothDamp 进行平滑，它能更好地处理不同幅度的移动\n            Vector3 smoothed = Vector3.SmoothDamp(_smoothedMotion, targetMotion, ref _motionVelocity, \n                                                 dynamicSmoothTime, Mathf.Infinity, Time.deltaTime);\n            \n            _smoothedMotion = smoothed;\n            \n            // 防抖动处理\n            if (targetMotion.sqrMagnitude < 0.001f * 0.001f)\n            {\n                _smoothedMotion *= 0.9f;\n                if (_smoothedMotion.sqrMagnitude < 0.0001f)\n                {\n                    _smoothedMotion = Vector3.zero;\n                    _motionVelocity = Vector3.zero;\n                }\n            }\n            \n            return _smoothedMotion;\n        }","new_string":"\n        /// <summary>\n        /// 执行 CharacterController 移动\n        /// 直接使用 _motion 向量进行移动\n        /// </summary>\n        protected virtual void MoveCharacterController()\n        {\n            _groundNormal = Vector3.zero;\n\n            // 直接使用在 ComputeVelocityDelta 中计算的 _motion\n            _collisionFlags = _characterController.Move(_motion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":9,"cache_creation_input_tokens":1935,"cache_read_input_tokens":74287,"cache_creation":{"ephemeral_5m_input_tokens":1935,"ephemeral_1h_input_tokens":0},"output_tokens":1769,"service_tier":"standard"}},"type":"assistant","uuid":"52e7f700-315e-46ac-afc9-f03476184f58","timestamp":"2025-12-15T11:47:59.521Z"}
{"parentUuid":"52e7f700-315e-46ac-afc9-f03476184f58","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019zhWjZYXBxZ4ruGME9kSED","type":"tool_result","content":"The file E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   586→            {\n   587→                _motion -= _stickyOffset * Vector3.up;\n   588→            }\n   589→        }\n   590→\n   591→        /// <summary>\n   592→        /// 执行 CharacterController 移动\n   593→        /// 直接使用 _motion 向量进行移动\n   594→        /// </summary>\n   595→        protected virtual void MoveCharacterController()\n   596→        {\n   597→            _groundNormal = Vector3.zero;\n   598→\n   599→            // 直接使用在 ComputeVelocityDelta 中计算的 _motion\n   600→            _collisionFlags = _characterController.Move(_motion);\n   601→            _lastHitPoint = _hitPoint;\n   602→            _lastGroundNormal = _groundNormal;\n   603→        }\n   604→\n   605→\n   606→        /// <summary>\n   607→        /// 检测是否踩上新的移动平台\n   608→        /// </summary>"}]},"uuid":"8a676896-0183-427e-939c-3f55b896cff6","timestamp":"2025-12-15T11:48:01.321Z","toolUseResult":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","oldString":"\n        /// <summary>\n        /// 基于当前速度和渲染帧时间重新计算移动\n        /// Logic 赋值 Velocity，Render 对这个进行插值渲染\n        /// </summary>\n        protected virtual void CalculateRenderFrameMotion()\n        {\n            // 根据速度动态调整时间增量，避免高速时移动幅度过大\n            float speedMagnitude = _velocity.magnitude;\n            float adjustedDeltaTime = Time.deltaTime;\n            \n            // 高速时减少有效时间增量，控制移动幅度\n            if (speedMagnitude > 8f)\n            {\n                // 速度越高，时间增量缩放越小\n                // 扩展速度范围到 100，支持更高的速度\n                float speedFactor = Mathf.InverseLerp(8f, 100f, speedMagnitude);\n                adjustedDeltaTime *= Mathf.Lerp(1f, 0.05f, speedFactor);\n            }\n            \n            // 使用调整后的时间增量计算移动向量\n            Vector3 targetMotion = _velocity * adjustedDeltaTime;\n            \n            // 应用地面接触的粘性偏移（如果需要）\n            if (_grounded)\n            {\n                Vector3 horizontalMotion = new Vector3(targetMotion.x, 0, targetMotion.z);\n                float stickyOffset = Mathf.Max(_characterController.stepOffset * 0.1f, horizontalMotion.magnitude * 0.01f);\n                targetMotion.y -= stickyOffset;\n            }\n            \n            // 应用移动平滑（如果启用）\n            if (EnableMovementSmoothing)\n            {\n                _pendingMotion = CalculateSmoothedMotion(targetMotion);\n            }\n            else\n            {\n                _pendingMotion = targetMotion;\n            }\n        }\n\n        /// <summary>\n        /// 执行待处理的移动（在渲染帧中调用）\n        /// 执行实际的物理移动和碰撞检测\n        /// </summary>\n        protected virtual void ExecutePendingMove()\n        {\n            // 1. 执行实际的 CharacterController 移动\n            MoveCharacterController();\n            \n            // 2. 检测新的移动平台（碰撞相关）\n            DetectNewMovingPlatform();\n            \n            // 3. 手动处理碰撞器碰撞（物理相关）\n            ManualControllerColliderHit();\n            \n            // 4. 处理地面接触状态（物理相关）\n            HandleGroundContact();\n        }\n\n        /// <summary>\n        /// 执行 CharacterController 移动\n        /// </summary>\n        protected virtual void MoveCharacterController()\n        {\n            _groundNormal = Vector3.zero;\n            \n            // 直接使用基于渲染帧时间计算的移动向量\n            _collisionFlags = _characterController.Move(_pendingMotion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n        \n        /// <summary>\n        /// 计算平滑后的移动向量\n        /// 使用简单的 Lerp 进行平滑，避免过度复杂化\n        /// </summary>\n        /// <param name=\"targetMotion\">目标移动向量</param>\n        /// <returns>平滑后的移动向量</returns>\n        protected virtual Vector3 CalculateSmoothedMotion(Vector3 targetMotion)\n        {\n            // 计算目标移动的幅度，用于动态调整平滑强度\n            float targetMagnitude = targetMotion.magnitude;\n            \n            // 基于移动幅度动态调整平滑时间\n            // 移动距离越大，需要更强的平滑\n            float dynamicSmoothTime = 0.016f; // 基础平滑时间（60fps）\n            \n            if (targetMagnitude > 0.1f) // 只对有明显移动时进行调整\n            {\n                // 移动距离越大，平滑时间越长\n                // 这样可以确保高速移动时有足够的平滑\n                dynamicSmoothTime = Mathf.Lerp(0.016f, 0.1f, Mathf.InverseLerp(0.1f, 0.5f, targetMagnitude));\n            }\n            \n            // 使用 SmoothDamp 进行平滑，它能更好地处理不同幅度的移动\n            Vector3 smoothed = Vector3.SmoothDamp(_smoothedMotion, targetMotion, ref _motionVelocity, \n                                                 dynamicSmoothTime, Mathf.Infinity, Time.deltaTime);\n            \n            _smoothedMotion = smoothed;\n            \n            // 防抖动处理\n            if (targetMotion.sqrMagnitude < 0.001f * 0.001f)\n            {\n                _smoothedMotion *= 0.9f;\n                if (_smoothedMotion.sqrMagnitude < 0.0001f)\n                {\n                    _smoothedMotion = Vector3.zero;\n                    _motionVelocity = Vector3.zero;\n                }\n            }\n            \n            return _smoothedMotion;\n        }","newString":"\n        /// <summary>\n        /// 执行 CharacterController 移动\n        /// 直接使用 _motion 向量进行移动\n        /// </summary>\n        protected virtual void MoveCharacterController()\n        {\n            _groundNormal = Vector3.zero;\n\n            // 直接使用在 ComputeVelocityDelta 中计算的 _motion\n            _collisionFlags = _characterController.Move(_motion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n","originalFile":"using System;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing ActionMachine.Runtime.Attributes;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 运动学角色控制器（Kinematic Character Controller）\n    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    /// </summary>\n    [RequireComponent(typeof(CharacterController))]\n    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    public partial class Kcc : MonoBehaviour\n    {\n        private const float SMALL_VALUE = 0.0001f; // 浮点数比较的最小阈值\n        private const float SPEED_ROUNDING_PRECISION = 100f; // 速度值舍入精度\n        private const float IMPACT_THRESHOLD = 0.2f; // 冲击力应用的最小阈值\n\n        /// <summary>\n        /// 地面检测计算模式\n        /// </summary>\n        public enum GroundedComputationMode\n        {\n            Simple, // 简单模式：使用 CharacterController.isGrounded\n            Advanced // 高级模式：使用多方向射线检测\n        }\n\n        /// <summary>\n        /// 速度传递模式（用于移动平台交互）\n        /// </summary>\n        public enum VelocityTransferMode\n        {\n            NoTransfer, // 不传递速度\n            InitialVelocity, // 传递初始速度\n            FloorVelocity, // 传递地面速度\n            Relative // 相对速度模式\n        }\n\n        [Header(\"Gravity Settings\")] [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n        public float Gravity = 40f;\n\n        [Tooltip(\"是否激活重力\")] public bool GravityActive = true;\n\n        [Header(\"Raycast Settings\")] [Tooltip(\"障碍物层遮罩\")]\n        public LayerMask ObstaclesLayerMask;\n\n        [Tooltip(\"向下射线检测长度\")] public float GroundedRaycastLength = 5f;\n\n        [Tooltip(\"最小着地距离\")] public float MinimumGroundedDistance = 0.2f;\n\n        [Tooltip(\"地面检测计算模式\")] public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n\n        [Tooltip(\"地面法线高度阈值\")] public float GroundNormalHeightThreshold = 0.2f;\n\n        [Tooltip(\"蹲伏时射线长度倍数\")] public float CrouchedRaycastLengthMultiplier = 1f;\n\n        [Tooltip(\"是否执行基本方向障碍物射线检测\")] public bool PerformCardinalObstacleRaycastDetection = false;\n\n        [Header(\"Movement Settings\")] [Tooltip(\"最大下落速度\")]\n        public float MaximumFallSpeed = 20.0f;\n\n        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速\")] \n        public float HorizontalAcceleration = 20f;\n\n        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速\")] \n        public float HorizontalDeceleration = 20f;\n        \n        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n        public float InitialBurstMultiplier = 2.0f;\n        \n        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n        public float BurstSpeedThreshold = 1.0f;\n\n        [Tooltip(\"斜坡速度倍数曲线\")] public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n            new Keyframe(-90, 1),\n            new Keyframe(0, 1),\n            new Keyframe(90, 0)\n        );\n\n        [Tooltip(\"冲击力衰减速度\")] public float ImpactFalloff = 5f;\n\n        [Header(\"Steep Surface Settings\")] [Tooltip(\"是否在陡峭表面滑动\")]\n        public bool SlideOnSteepSurfaces = true;\n\n        [Tooltip(\"滑动速度\")] public float SlidingSpeed = 15f;\n\n        [Tooltip(\"滑动速度控制\")] public float SlidingSpeedControl = 0.4f;\n\n        [Tooltip(\"滑动方向控制\")] public float SlidingDirectionControl = 1f;\n\n        [Header(\"Moving Platform Settings\")] [Tooltip(\"跳跃时的速度传递方式\")]\n        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Movement Smoothing\")]\n        [Tooltip(\"是否启用移动平滑\")]\n        public bool EnableMovementSmoothing = true;\n        \n        [Tooltip(\"水平移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float HorizontalSmoothTime = 0.03f;\n        \n        [Tooltip(\"垂直移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float VerticalSmoothTime = 0.05f;\n\n        [Header(\"Runtime State - Read Only\")]\n        [SerializeField, ReadOnly] private Vector3 _speed;\n        [SerializeField, ReadOnly] private Vector3 _velocity;\n        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n        [SerializeField, ReadOnly] private Vector3 _acceleration;\n        [SerializeField, ReadOnly] private bool _grounded;\n        [SerializeField, ReadOnly] private bool _justGotGrounded;\n        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n        [SerializeField, ReadOnly] private float _friction;\n        [SerializeField, ReadOnly] private Vector3 _addedForce;\n        [SerializeField, ReadOnly] private bool _freeMovement = true;\n        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n\n        // 公共只读属性\n        public Vector3 Speed => _speed;\n        public Vector3 Velocity => _velocity;\n        public Vector3 VelocityLastFrame => _velocityLastFrame;\n        public Vector3 Acceleration => _acceleration;\n        public bool Grounded => _grounded;\n        public bool JustGotGrounded => _justGotGrounded;\n        public Vector3 CurrentMovement => _currentMovement;\n        public Vector3 CurrentDirection => _currentDirection;\n        public float Friction => _friction;\n        public Vector3 AddedForce => _addedForce;\n        public bool FreeMovement => _freeMovement;\n        public Vector3 GroundNormal => _groundNormal;\n        public Vector3 InputMoveDirection => _inputMoveDirection;\n        public Vector3 TargetVelocity => _targetVelocity;\n\n        // 碰撞器相关属性\n        public Vector3 ColliderCenter => transform.position + _characterController.center;\n\n        public Vector3 ColliderBottom => transform.position + _characterController.center +\n                                         Vector3.down * _characterController.bounds.extents.y;\n\n        public Vector3 ColliderTop => transform.position + _characterController.center +\n                                      Vector3.up * _characterController.bounds.extents.y;\n\n        public Vector3 AppliedImpact => _impact;\n\n        // 环境检测属性\n        public GameObject ObjectBelow { get; set; }\n        public GameObject DetectedObstacleLeft { get; set; }\n        public GameObject DetectedObstacleRight { get; set; }\n        public GameObject DetectedObstacleUp { get; set; }\n        public GameObject DetectedObstacleDown { get; set; }\n        public bool CollidingWithCardinalObstacle { get; set; }\n        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n\n        // 移动平台相关属性\n        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n\n        // 组件引用\n        private Transform _transform;\n        private CharacterController _characterController;\n\n        // 碰撞器原始尺寸\n        private float _originalColliderHeight;\n        private Vector3 _originalColliderCenter;\n\n        // 运动状态追踪\n        private Vector3 _positionLastFrame;\n        private bool _groundedLastFrame;\n        private Vector3 _impact;\n        private Vector3 _lastGroundNormal = Vector3.zero;\n        private bool _detached = false;\n        private bool _tooSteepLastFrame;\n\n        // 移动平台追踪\n        private Transform _movingPlatformHitCollider;\n        private Transform _movingPlatformCurrentHitCollider;\n        private Vector3 _movingPlatformCurrentHitColliderLocal;\n        private Vector3 _movingPlatformCurrentGlobalPoint;\n        private Quaternion _movingPlatformLocalRotation;\n        private Quaternion _movingPlatformGlobalRotation;\n        private Quaternion _lastMoveWithPlatformGlobalRotation;\n        private Matrix4x4 _lastMovingPlatformMatrix;\n        private Vector3 _movingPlatformVelocity;\n        private bool _newMovingPlatform;\n\n        // 碰撞检测\n        private CollisionFlags _collisionFlags;\n        private Vector3 _frameVelocity = Vector3.zero;\n        private Vector3 _hitPoint = Vector3.zero;\n        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n        // 速度计算\n        private Vector3 _newVelocity;\n        private Vector3 _motion;\n        private Vector3 _idealVelocity;\n        private Vector3 _idealDirection;\n        private Vector3 _horizontalVelocityDelta;\n        private float _stickyOffset = 0f;\n\n        // 位置移动\n        private RaycastHit _movePositionHit;\n        private Vector3 _capsulePoint1;\n        private Vector3 _capsulePoint2;\n        private Vector3 _movePositionDirection;\n        private float _movePositionDistance;\n\n        // 障碍物检测\n        private RaycastHit _cardinalRaycast;\n        private float _smallestDistance = Single.MaxValue;\n        private float _longestDistance = Single.MinValue;\n        private RaycastHit _smallestRaycast;\n        private RaycastHit _emptyRaycast = new RaycastHit();\n        private Vector3 _downRaycastsOffset;\n\n        // 平台移动计算\n        private Vector3 _moveWithPlatformMoveDistance;\n        private Vector3 _moveWithPlatformGlobalPoint;\n        private Quaternion _moveWithPlatformRotationDiff;\n        private Quaternion _moveWithPlatformGlobalRotation;\n        private RaycastHit _raycastDownHit;\n        private Vector3 _raycastDownDirection = Vector3.down;\n        private RaycastHit _canGoBackHeadCheck;\n        private Vector3 _originalSizeRaycastOrigin;\n\n        // 协程和可选组件\n        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        \n        // 逻辑帧与渲染帧分离\n        private Vector3 _pendingMotion = Vector3.zero;\n        private float _lastLogicDeltaTime = 0f; // 保存逻辑帧的时间增量\n        \n        // 移动平滑相关\n        private Vector3 _smoothedMotion = Vector3.zero;\n        private Vector3 _motionVelocity = Vector3.zero; // SmoothDamp 速度缓存\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n        /// <summary>\n        /// 检查角色头部是否与物体碰撞\n        /// </summary>\n        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n\n        /// <summary>\n        /// 检查当前地面是否过于陡峭\n        /// </summary>\n        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n\n        /// <summary>\n        /// 初始化组件和缓存引用\n        /// </summary>\n        protected virtual void Awake()\n        {\n            _characterController = GetComponent<CharacterController>();\n            _transform = transform;\n            _rigidBody = GetComponent<Rigidbody>();\n\n            _originalColliderHeight = _characterController.height;\n            _originalColliderCenter = _characterController.center;\n            _currentDirection = _transform.forward;\n        }\n\n        /// <summary>\n        /// 固定时间更新（物理帧，处理物理相关的计算）\n        /// 负责物理模拟、重力计算、碰撞检测等需要固定时间步长的操作\n        /// </summary>\n        protected virtual void FixedUpdate()\n        {\n            // 物理相关的固定更新\n            ProcessFixedUpdate();\n        }\n\n        /// <summary>\n        /// 每帧更新（处理所有逻辑计算和移动执行）\n        /// 统一在 Update 中完成所有操作，避免 LogicUpdate 和 RenderUpdate 分离导致的抖动\n        /// </summary>\n        protected virtual void Update()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            float deltaTime = Time.deltaTime;\n\n            // 保存上一帧状态\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测\n            CheckIfGrounded();\n\n            // 2. 处理摩擦力\n            HandleFriction();\n\n            // 3. 确定移动方向\n            DetermineDirection();\n\n            // 4. 处理输入移动\n            AddInput(deltaTime);\n\n            // 5. 处理重力\n            AddGravityLogic(deltaTime);\n\n            // 6. 处理移动平台\n            MoveWithPlatform();\n\n            // 7. 计算速度变化\n            ComputeVelocityDelta(deltaTime);\n\n            // 8. 计算新速度\n            ComputeNewVelocity(deltaTime);\n\n            // 9. 执行实际移动\n            ExecuteMove(deltaTime);\n\n            // 10. 计算实际速度\n            ComputeSpeed(deltaTime);\n        }\n\n        /// <summary>\n        /// 逻辑更新（保留接口用于向后兼容，但不再使用）\n        /// 现在所有逻辑都在 Update 中处理，避免抖动问题\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        [System.Obsolete(\"LogicUpdate is no longer used. All logic is now handled in Update to avoid jitter.\")]\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 不再处理任何逻辑，所有逻辑已整合到 Update 中\n        }\n\n        /// <summary>\n        /// 延迟更新，目前为空方法，保留用于扩展\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            // LateUpdate 不再处理 _velocityLastFrame，改为在 LogicUpdate 中处理\n        }\n\n        /// <summary>\n        /// 固定更新处理（物理帧）\n        /// 处理物理相关的计算，确保物理模拟的一致性\n        /// </summary>\n        protected virtual void ProcessFixedUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 物理相关的固定更新\n            // 1. 重力计算（固定时间步长确保物理一致性）\n            if (GravityActive)\n            {\n                ApplyGravityFixed(Time.fixedDeltaTime);\n            }\n\n            // 2. 移动平台速度计算（物理相关）\n            GetMovingPlatformVelocity();\n            \n            // 3. 应用冲击力（物理相关，固定时间步长）\n            ApplyImpact(Time.fixedDeltaTime);\n        }\n\n        /// <summary>\n        /// 执行实际的移动\n        /// 直接使用计算好的 _motion 向量进行移动，不再进行二次计算\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ExecuteMove(float deltaTime)\n        {\n            // 1. 执行 CharacterController 移动\n            MoveCharacterController();\n\n            // 2. 检测新的移动平台\n            DetectNewMovingPlatform();\n\n            // 3. 手动处理碰撞器碰撞\n            ManualControllerColliderHit();\n\n            // 4. 处理地面接触状态\n            HandleGroundContact();\n        }\n\n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n                _idealVelocity = _idealVelocity * SlidingSpeed;\n                _targetVelocity = _idealVelocity;\n                _newVelocity = _idealVelocity;\n                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n            }\n            else\n            {\n                _targetVelocity = _currentMovement;\n                \n                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n                \n                Vector3 newHorizontalVelocity;\n                \n                if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                {\n                    float effectiveAcceleration = HorizontalAcceleration;\n                    \n                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n                    {\n                        effectiveAcceleration *= InitialBurstMultiplier;\n                    }\n                    \n                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n                    \n\n                    \n                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n                    {\n                        newHorizontalVelocity = targetHorizontalVelocity;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n                    }\n                }\n                else\n                {\n                    float currentSpeed = currentHorizontalVelocity.magnitude;\n                    float speedReduction = HorizontalDeceleration * deltaTime;\n                    \n\n                    \n                    if (currentSpeed <= speedReduction)\n                    {\n                        newHorizontalVelocity = Vector3.zero;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n                    }\n                }\n                \n                _newVelocity.x = newHorizontalVelocity.x;\n                _newVelocity.z = newHorizontalVelocity.z;\n                \n\n                \n                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    Vector3 floorVelocity = _frameVelocity;\n                    floorVelocity.y = 0;\n                    _newVelocity.x += floorVelocity.x;\n                    _newVelocity.z += floorVelocity.z;\n                }\n                \n                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n                    \n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity.normalized;\n                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n                        \n                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n                        {\n                            projectedDirection.Normalize();\n                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                        }\n                    }\n                    \n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 固定更新中的重力应用（物理帧）\n        /// </summary>\n        /// <param name=\"deltaTime\">固定时间增量</param>\n        protected virtual void ApplyGravityFixed(float deltaTime)\n        {\n            // 固定更新中的重力处理，主要用于物理一致性\n            // 这里可以添加需要在固定时间步长中处理的重力相关逻辑\n        }\n\n        /// <summary>\n        /// 逻辑更新中的重力应用（逻辑帧）\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑时间增量</param>\n        protected virtual void AddGravityLogic(float deltaTime)\n        {\n            if (GravityActive)\n            {\n                if (_grounded)\n                {\n                    _newVelocity.y = -Gravity * deltaTime;\n\n                }\n                else\n                {\n                    float oldY = _newVelocity.y;\n                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n\n                }\n            }\n\n            _newVelocity += _addedForce;\n            _addedForce = Vector3.zero;\n        }\n\n        /// <summary>\n        /// 应用重力到速度（保持向后兼容）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddGravity(float deltaTime)\n        {\n            AddGravityLogic(deltaTime);\n        }\n\n        /// <summary>\n        /// 跟随移动平台移动\n        /// </summary>\n        protected virtual void MoveWithPlatform()\n        {\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _moveWithPlatformMoveDistance = Vector3.zero;\n                _moveWithPlatformGlobalPoint =\n                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n\n                if (_moveWithPlatformMoveDistance != Vector3.zero)\n                {\n                    _characterController.Move(_moveWithPlatformMoveDistance);\n                }\n\n                _moveWithPlatformGlobalRotation =\n                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n            }\n        }\n\n        /// <summary>\n        /// 计算速度增量和粘性偏移\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeVelocityDelta(float deltaTime)\n        {\n            _motion = _newVelocity * deltaTime;\n            _horizontalVelocityDelta.x = _motion.x;\n            _horizontalVelocityDelta.y = 0f;\n            _horizontalVelocityDelta.z = _motion.z;\n            _stickyOffset = Mathf.Max(_characterController.stepOffset, _horizontalVelocityDelta.magnitude);\n\n            if (_grounded)\n            {\n                _motion -= _stickyOffset * Vector3.up;\n            }\n        }\n\n        /// <summary>\n        /// 基于当前速度和渲染帧时间重新计算移动\n        /// Logic 赋值 Velocity，Render 对这个进行插值渲染\n        /// </summary>\n        protected virtual void CalculateRenderFrameMotion()\n        {\n            // 根据速度动态调整时间增量，避免高速时移动幅度过大\n            float speedMagnitude = _velocity.magnitude;\n            float adjustedDeltaTime = Time.deltaTime;\n            \n            // 高速时减少有效时间增量，控制移动幅度\n            if (speedMagnitude > 8f)\n            {\n                // 速度越高，时间增量缩放越小\n                // 扩展速度范围到 100，支持更高的速度\n                float speedFactor = Mathf.InverseLerp(8f, 100f, speedMagnitude);\n                adjustedDeltaTime *= Mathf.Lerp(1f, 0.05f, speedFactor);\n            }\n            \n            // 使用调整后的时间增量计算移动向量\n            Vector3 targetMotion = _velocity * adjustedDeltaTime;\n            \n            // 应用地面接触的粘性偏移（如果需要）\n            if (_grounded)\n            {\n                Vector3 horizontalMotion = new Vector3(targetMotion.x, 0, targetMotion.z);\n                float stickyOffset = Mathf.Max(_characterController.stepOffset * 0.1f, horizontalMotion.magnitude * 0.01f);\n                targetMotion.y -= stickyOffset;\n            }\n            \n            // 应用移动平滑（如果启用）\n            if (EnableMovementSmoothing)\n            {\n                _pendingMotion = CalculateSmoothedMotion(targetMotion);\n            }\n            else\n            {\n                _pendingMotion = targetMotion;\n            }\n        }\n\n        /// <summary>\n        /// 执行待处理的移动（在渲染帧中调用）\n        /// 执行实际的物理移动和碰撞检测\n        /// </summary>\n        protected virtual void ExecutePendingMove()\n        {\n            // 1. 执行实际的 CharacterController 移动\n            MoveCharacterController();\n            \n            // 2. 检测新的移动平台（碰撞相关）\n            DetectNewMovingPlatform();\n            \n            // 3. 手动处理碰撞器碰撞（物理相关）\n            ManualControllerColliderHit();\n            \n            // 4. 处理地面接触状态（物理相关）\n            HandleGroundContact();\n        }\n\n        /// <summary>\n        /// 执行 CharacterController 移动\n        /// </summary>\n        protected virtual void MoveCharacterController()\n        {\n            _groundNormal = Vector3.zero;\n            \n            // 直接使用基于渲染帧时间计算的移动向量\n            _collisionFlags = _characterController.Move(_pendingMotion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n        \n        /// <summary>\n        /// 计算平滑后的移动向量\n        /// 使用简单的 Lerp 进行平滑，避免过度复杂化\n        /// </summary>\n        /// <param name=\"targetMotion\">目标移动向量</param>\n        /// <returns>平滑后的移动向量</returns>\n        protected virtual Vector3 CalculateSmoothedMotion(Vector3 targetMotion)\n        {\n            // 计算目标移动的幅度，用于动态调整平滑强度\n            float targetMagnitude = targetMotion.magnitude;\n            \n            // 基于移动幅度动态调整平滑时间\n            // 移动距离越大，需要更强的平滑\n            float dynamicSmoothTime = 0.016f; // 基础平滑时间（60fps）\n            \n            if (targetMagnitude > 0.1f) // 只对有明显移动时进行调整\n            {\n                // 移动距离越大，平滑时间越长\n                // 这样可以确保高速移动时有足够的平滑\n                dynamicSmoothTime = Mathf.Lerp(0.016f, 0.1f, Mathf.InverseLerp(0.1f, 0.5f, targetMagnitude));\n            }\n            \n            // 使用 SmoothDamp 进行平滑，它能更好地处理不同幅度的移动\n            Vector3 smoothed = Vector3.SmoothDamp(_smoothedMotion, targetMotion, ref _motionVelocity, \n                                                 dynamicSmoothTime, Mathf.Infinity, Time.deltaTime);\n            \n            _smoothedMotion = smoothed;\n            \n            // 防抖动处理\n            if (targetMotion.sqrMagnitude < 0.001f * 0.001f)\n            {\n                _smoothedMotion *= 0.9f;\n                if (_smoothedMotion.sqrMagnitude < 0.0001f)\n                {\n                    _smoothedMotion = Vector3.zero;\n                    _motionVelocity = Vector3.zero;\n                }\n            }\n            \n            return _smoothedMotion;\n        }\n\n        /// <summary>\n        /// 检测是否踩上新的移动平台\n        /// </summary>\n        protected virtual void DetectNewMovingPlatform()\n        {\n            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n            {\n                if (_movingPlatformHitCollider != null)\n                {\n                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n                    _newMovingPlatform = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 计算新速度和加速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeNewVelocity(float deltaTime)\n        {\n            _velocity = _newVelocity;\n            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n        }\n\n        /// <summary>\n        /// 处理地面接触状态和平台速度传递\n        /// </summary>\n        protected virtual void HandleGroundContact()\n        {\n            _grounded = _characterController.isGrounded;\n\n            if (_grounded && !IsGroundedTest())\n            {\n                _grounded = false;\n                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    _frameVelocity = _movingPlatformVelocity;\n                    _velocity += _movingPlatformVelocity;\n                }\n            }\n            else if (!_grounded && IsGroundedTest())\n            {\n                if (_detached && _velocity.y <= 0)\n                {\n                    _grounded = true;\n                    _detached = false;\n                }\n\n                SubtractNewPlatformVelocity();\n            }\n\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _movingPlatformCurrentGlobalPoint = _transform.position;\n                _movingPlatformCurrentHitColliderLocal =\n                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n                _movingPlatformGlobalRotation = _transform.rotation;\n                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n                                               _movingPlatformGlobalRotation;\n            }\n\n            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n            _tooSteepLastFrame = TooSteep();\n        }\n\n        /// <summary>\n        /// 计算当前速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeSpeed(float deltaTime)\n        {\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _positionLastFrame) / deltaTime;\n            }\n\n            // 暂时禁用速度舍入，避免高速时的舍入误差导致抖动\n            // _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            // _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            // _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            \n            _positionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 根据当前移动向量确定方向\n        /// </summary>\n        protected virtual void DetermineDirection()\n        {\n            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n            {\n                _currentDirection = _currentMovement.normalized;\n            }\n        }\n\n        /// <summary>\n        /// 处理摩擦力（预留方法，可在子类中实现）\n        /// </summary>\n        protected virtual void HandleFriction()\n        {\n        }\n\n        /// <summary>\n        /// 检查是否刚刚着地\n        /// </summary>\n        protected virtual void CheckIfGrounded()\n        {\n            _justGotGrounded = !_groundedLastFrame && _grounded;\n            _groundedLastFrame = _grounded;\n        }\n\n        /// <summary>\n        /// 手动触发碰撞器碰撞处理\n        /// </summary>\n        protected virtual void ManualControllerColliderHit()\n        {\n            HandleAdvancedGroundDetection();\n        }\n\n        /// <summary>\n        /// 高级地面检测（使用多方向射线）\n        /// </summary>\n        protected virtual void HandleAdvancedGroundDetection()\n        {\n            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n            {\n                return;\n            }\n\n            _smallestDistance = Single.MaxValue;\n            _longestDistance = Single.MinValue;\n            _smallestRaycast = _emptyRaycast;\n\n            float offset = _characterController.radius;\n\n            _downRaycastsOffset = Vector3.zero;\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, offset);\n            CastRayDownwards();\n\n            if (_smallestRaycast.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n\n                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n                {\n                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n                    {\n                        _groundNormal = _smallestRaycast.normal;\n                    }\n                    else\n                    {\n                        _groundNormal = _lastGroundNormal;\n                    }\n\n                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n                    _hitPoint = _smallestRaycast.point;\n                    _frameVelocity = Vector3.zero;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 向下发射射线检测地面\n        /// </summary>\n        protected virtual void CastRayDownwards()\n        {\n            if (_smallestDistance <= MinimumGroundedDistance)\n            {\n                return;\n            }\n\n            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n                _raycastDownDirection, out _raycastDownHit,\n                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n\n            if (_raycastDownHit.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n\n                if (adjustedDistance < _smallestDistance)\n                {\n                    _smallestDistance = adjustedDistance;\n                    _smallestRaycast = _raycastDownHit;\n                }\n\n                if (adjustedDistance > _longestDistance)\n                {\n                    _longestDistance = adjustedDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n        /// </summary>\n        protected float AdjustDistance(float distance)\n        {\n            return distance - _characterController.height / 2f - _characterController.skinWidth;\n        }\n\n        /// <summary>\n        /// 测试是否真正着地\n        /// </summary>\n        protected virtual bool IsGroundedTest()\n        {\n            bool grounded = false;\n            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n            {\n                if (_smallestDistance <= MinimumGroundedDistance)\n                {\n                    grounded = _groundNormal.y > 0.01f;\n                }\n            }\n            else\n            {\n                grounded = _characterController.isGrounded;\n                _groundNormal = Vector3.up;\n            }\n\n            return grounded;\n        }\n\n        /// <summary>\n        /// 获取移动平台速度\n        /// </summary>\n        protected virtual void GetMovingPlatformVelocity()\n        {\n            if (_movingPlatformCurrentHitCollider != null)\n            {\n                if (!_newMovingPlatform && Time.fixedDeltaTime > SMALL_VALUE)\n                {\n                    _movingPlatformVelocity = (\n                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n                            _movingPlatformCurrentHitColliderLocal)\n                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n                    ) / Time.fixedDeltaTime;\n                }\n\n                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n                _newMovingPlatform = false;\n            }\n            else\n            {\n                _movingPlatformVelocity = Vector3.zero;\n            }\n        }\n\n        /// <summary>\n        /// 减去新平台速度（处理平台切换）\n        /// </summary>\n        protected virtual void SubtractNewPlatformVelocity()\n        {\n            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n            {\n                if (_newMovingPlatform)\n                {\n                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n                }\n                else\n                {\n                    _velocity -= _movingPlatformVelocity;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 协程：延迟减去平台速度\n        /// </summary>\n        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n        {\n            Transform platform = _movingPlatformCurrentHitCollider;\n            yield return _waitForFixedUpdate;\n            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n            {\n                yield return null;\n            }\n\n            _velocity -= _movingPlatformVelocity;\n        }\n\n        /// <summary>\n        /// 判断是否应该跟随平台移动\n        /// </summary>\n        protected virtual bool ShouldMoveWithPlatformThisFrame()\n        {\n            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n                   && _movingPlatformCurrentHitCollider != null;\n        }\n\n        /// <summary>\n        /// 应用冲击力并逐渐衰减\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ApplyImpact(float deltaTime)\n        {\n            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n            {\n                _characterController.Move(_impact * deltaTime);\n            }\n\n            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * deltaTime);\n        }\n\n        /// <summary>\n        /// 从地面分离（用于跳跃等）\n        /// </summary>\n        public virtual void DetachFromGround()\n        {\n            _detached = true;\n        }\n\n        /// <summary>\n        /// 从移动平台分离\n        /// </summary>\n        public virtual void DetachFromMovingPlatform()\n        {\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n        }\n\n        /// <summary>\n        /// 设置重力是否激活\n        /// </summary>\n        public virtual void SetGravityActive(bool status)\n        {\n            GravityActive = status;\n        }\n\n        /// <summary>\n        /// 添加外部力（会在下一帧应用）\n        /// </summary>\n        public virtual void AddForce(Vector3 movement)\n        {\n            _addedForce += movement;\n        }\n\n        /// <summary>\n        /// 施加瞬时冲击力\n        /// </summary>\n        /// <param name=\"direction\">冲击方向</param>\n        /// <param name=\"force\">冲击力大小</param>\n        public virtual void Impact(Vector3 direction, float force)\n        {\n            direction = direction.normalized;\n            if (direction.y < 0)\n            {\n                direction.y = -direction.y;\n            }\n\n            _impact += direction.normalized * force;\n        }\n\n        /// <summary>\n        /// 设置移动向量（通常由输入系统调用）\n        /// </summary>\n        /// <param name=\"movement\">移动向量</param>\n        public virtual void SetMovement(Vector3 movement)\n        {\n            _currentMovement = movement;\n\n            Vector3 directionVector = movement;\n            if (directionVector != Vector3.zero)\n            {\n                float directionLength = directionVector.magnitude;\n                directionVector = directionVector / directionLength;\n                directionLength = Mathf.Min(1, directionLength);\n                // 移除平方操作，保持线性响应，避免高速时的非线性抖动\n                directionVector = directionVector * directionLength;\n            }\n\n            _inputMoveDirection = transform.rotation * directionVector;\n        }\n\n        /// <summary>\n        /// 移动到指定位置（带碰撞检测）\n        /// </summary>\n        /// <param name=\"newPosition\">目标位置</param>\n        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n        {\n            _movePositionDirection = newPosition - transform.position;\n            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n\n            _capsulePoint1 = transform.position\n                             + _characterController.center\n                             - (Vector3.up * _characterController.height / 2f)\n                             + Vector3.up * _characterController.skinWidth\n                             + Vector3.up * _characterController.radius;\n\n            _capsulePoint2 = transform.position\n                             + _characterController.center\n                             + (Vector3.up * _characterController.height / 2f)\n                             - Vector3.up * _characterController.skinWidth\n                             - Vector3.up * _characterController.radius;\n\n            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n            {\n                transform.position = newPosition;\n            }\n        }\n\n        /// <summary>\n        /// 调整碰撞器高度（用于蹲伏等）\n        /// </summary>\n        /// <param name=\"newHeight\">新高度</param>\n        /// <param name=\"translateCenter\">是否平移中心点</param>\n        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n        {\n            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n            _characterController.height = newHeight;\n            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n\n            if (translateCenter)\n            {\n                transform.Translate((newYOffset / 2f) * Vector3.up);\n            }\n        }\n\n        /// <summary>\n        /// 重置碰撞器尺寸到原始大小\n        /// </summary>\n        public virtual void ResetColliderSize()\n        {\n            _characterController.height = _originalColliderHeight;\n            _characterController.center = _originalColliderCenter;\n        }\n\n        /// <summary>\n        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n        /// </summary>\n        public virtual bool CanGoBackToOriginalSize()\n        {\n            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n            {\n                return true;\n            }\n\n            float headCheckDistance =\n                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n\n            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n                ObstaclesLayerMask, Color.cyan, true);\n\n            return _canGoBackHeadCheck.collider == null;\n        }\n\n        /// <summary>\n        /// 启用碰撞\n        /// </summary>\n        public virtual void CollisionsOn()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = true;\n            }\n        }\n\n        /// <summary>\n        /// 禁用碰撞\n        /// </summary>\n        public virtual void CollisionsOff()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = false;\n            }\n        }\n\n        /// <summary>\n        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n        /// </summary>\n        public virtual void SetKinematic(bool state)\n        {\n            _rigidBody.isKinematic = state;\n        }\n\n        /// <summary>\n        /// 设置是否允许自由移动\n        /// </summary>\n        public virtual void SetFreeMovement(bool state)\n        {\n            _freeMovement = state;\n        }\n\n        /// <summary>\n        /// 检测四个基本方向的障碍物\n        /// </summary>\n        /// <param name=\"distance\">检测距离</param>\n        /// <param name=\"offset\">起始偏移</param>\n        public virtual void DetectObstacles(float distance, Vector3 offset)\n        {\n            if (!PerformCardinalObstacleRaycastDetection)\n            {\n                return;\n            }\n\n            CollidingWithCardinalObstacle = false;\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleRight = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleLeft = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleUp = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleDown = null;\n            }\n        }\n\n        /// <summary>\n        /// 重置控制器到初始状态\n        /// </summary>\n        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n            \n            // 重置平滑移动相关变量\n            _pendingMotion = Vector3.zero;\n            _smoothedMotion = Vector3.zero;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n\n            return hit;\n        }\n    }\n}","structuredPatch":[{"oldStart":589,"oldLines":120,"newStart":589,"newLines":20,"lines":["         }"," ","         /// <summary>","-        /// 基于当前速度和渲染帧时间重新计算移动","-        /// Logic 赋值 Velocity，Render 对这个进行插值渲染","-        /// </summary>","-        protected virtual void CalculateRenderFrameMotion()","-        {","-            // 根据速度动态调整时间增量，避免高速时移动幅度过大","-            float speedMagnitude = _velocity.magnitude;","-            float adjustedDeltaTime = Time.deltaTime;","-            ","-            // 高速时减少有效时间增量，控制移动幅度","-            if (speedMagnitude > 8f)","-            {","-                // 速度越高，时间增量缩放越小","-                // 扩展速度范围到 100，支持更高的速度","-                float speedFactor = Mathf.InverseLerp(8f, 100f, speedMagnitude);","-                adjustedDeltaTime *= Mathf.Lerp(1f, 0.05f, speedFactor);","-            }","-            ","-            // 使用调整后的时间增量计算移动向量","-            Vector3 targetMotion = _velocity * adjustedDeltaTime;","-            ","-            // 应用地面接触的粘性偏移（如果需要）","-            if (_grounded)","-            {","-                Vector3 horizontalMotion = new Vector3(targetMotion.x, 0, targetMotion.z);","-                float stickyOffset = Mathf.Max(_characterController.stepOffset * 0.1f, horizontalMotion.magnitude * 0.01f);","-                targetMotion.y -= stickyOffset;","-            }","-            ","-            // 应用移动平滑（如果启用）","-            if (EnableMovementSmoothing)","-            {","-                _pendingMotion = CalculateSmoothedMotion(targetMotion);","-            }","-            else","-            {","-                _pendingMotion = targetMotion;","-            }","-        }","-","-        /// <summary>","-        /// 执行待处理的移动（在渲染帧中调用）","-        /// 执行实际的物理移动和碰撞检测","-        /// </summary>","-        protected virtual void ExecutePendingMove()","-        {","-            // 1. 执行实际的 CharacterController 移动","-            MoveCharacterController();","-            ","-            // 2. 检测新的移动平台（碰撞相关）","-            DetectNewMovingPlatform();","-            ","-            // 3. 手动处理碰撞器碰撞（物理相关）","-            ManualControllerColliderHit();","-            ","-            // 4. 处理地面接触状态（物理相关）","-            HandleGroundContact();","-        }","-","-        /// <summary>","         /// 执行 CharacterController 移动","+        /// 直接使用 _motion 向量进行移动","         /// </summary>","         protected virtual void MoveCharacterController()","         {","             _groundNormal = Vector3.zero;","-            ","-            // 直接使用基于渲染帧时间计算的移动向量","-            _collisionFlags = _characterController.Move(_pendingMotion);","+","+            // 直接使用在 ComputeVelocityDelta 中计算的 _motion","+            _collisionFlags = _characterController.Move(_motion);","             _lastHitPoint = _hitPoint;","             _lastGroundNormal = _groundNormal;","         }","-        ","-        /// <summary>","-        /// 计算平滑后的移动向量","-        /// 使用简单的 Lerp 进行平滑，避免过度复杂化","-        /// </summary>","-        /// <param name=\"targetMotion\">目标移动向量</param>","-        /// <returns>平滑后的移动向量</returns>","-        protected virtual Vector3 CalculateSmoothedMotion(Vector3 targetMotion)","-        {","-            // 计算目标移动的幅度，用于动态调整平滑强度","-            float targetMagnitude = targetMotion.magnitude;","-            ","-            // 基于移动幅度动态调整平滑时间","-            // 移动距离越大，需要更强的平滑","-            float dynamicSmoothTime = 0.016f; // 基础平滑时间（60fps）","-            ","-            if (targetMagnitude > 0.1f) // 只对有明显移动时进行调整","-            {","-                // 移动距离越大，平滑时间越长","-                // 这样可以确保高速移动时有足够的平滑","-                dynamicSmoothTime = Mathf.Lerp(0.016f, 0.1f, Mathf.InverseLerp(0.1f, 0.5f, targetMagnitude));","-            }","-            ","-            // 使用 SmoothDamp 进行平滑，它能更好地处理不同幅度的移动","-            Vector3 smoothed = Vector3.SmoothDamp(_smoothedMotion, targetMotion, ref _motionVelocity, ","-                                                 dynamicSmoothTime, Mathf.Infinity, Time.deltaTime);","-            ","-            _smoothedMotion = smoothed;","-            ","-            // 防抖动处理","-            if (targetMotion.sqrMagnitude < 0.001f * 0.001f)","-            {","-                _smoothedMotion *= 0.9f;","-                if (_smoothedMotion.sqrMagnitude < 0.0001f)","-                {","-                    _smoothedMotion = Vector3.zero;","-                    _motionVelocity = Vector3.zero;","-                }","-            }","-            ","-            return _smoothedMotion;","-        }"," ","+","         /// <summary>","         /// 检测是否踩上新的移动平台","         /// </summary>"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"8a676896-0183-427e-939c-3f55b896cff6","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01R1KZEH4Z4BeiALugzgJ2vE","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"很好，现在我需要删除不再使用的私有字段，比如 _pendingMotion、_lastLogicDeltaTime、_smoothedMotion、_motionVelocity 等。让我先找到这些字段的定义。","signature":"EuICCkYIChgCKkBRkNGsWhtcTSkZ8m/Hwj1S8l7eAsW6pD7JUxD08/EQqVAjT+tAuo4ehxkDgTx9VG1UHWoaah7tXDTU6JS+RxPwEgzK9ckoQy8emm+yOS0aDE6bPpemhNytQ0jSUyIwqHHSkwuj5YeT5lVf1pCBrczI7nrUeJtIICAS3uzZNrVVxmNq5BdO/1DG+I8zMALmKskBTpZSHT9JdwEUaTEAIzvmAt2itGcc/JqOcMQ2sz0PAdHecPYkCG3BkRbhg7jc1YKK+Cf/BTkGrA0AgJRPyqyBdFQTFz0kx6BFW03OHksi7nDMWehoX5RF9dr+JvCPChrEZveZPC7sxr0QFuFYEMXXC5UyGl9ZeYQ/mVjP8AFZHjyhS4pxvT1T6255q/SjWTToSI6QsvU0FWN3bPoItavk+LhNwU3mbgFJiUUFe2n/x2WGF2JJGrZv4eJjTyY2ICM4Sh09y+zzUlalGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":2112,"cache_read_input_tokens":76222,"cache_creation":{"ephemeral_5m_input_tokens":2112,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"9d36027f-7541-472f-9ee9-d84d83f2c7f0","timestamp":"2025-12-15T11:48:08.289Z"}
{"parentUuid":"9d36027f-7541-472f-9ee9-d84d83f2c7f0","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01R1KZEH4Z4BeiALugzgJ2vE","type":"message","role":"assistant","content":[{"type":"text","text":"现在我需要删除不再使用的私有字段，因为我们已经简化了移动逻辑。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":2112,"cache_read_input_tokens":76222,"cache_creation":{"ephemeral_5m_input_tokens":2112,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"22739aa1-c334-48cc-92ad-b2f7aa71b7c1","timestamp":"2025-12-15T11:48:09.070Z"}
{"parentUuid":"22739aa1-c334-48cc-92ad-b2f7aa71b7c1","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01R1KZEH4Z4BeiALugzgJ2vE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HZMvy2YnDYTtevfucQKyoj","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","limit":15,"offset":235}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":2112,"cache_read_input_tokens":76222,"cache_creation":{"ephemeral_5m_input_tokens":2112,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"9e220246-3a1f-40b0-8740-d55ab8315cf5","timestamp":"2025-12-15T11:48:09.976Z"}
{"parentUuid":"9e220246-3a1f-40b0-8740-d55ab8315cf5","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HZMvy2YnDYTtevfucQKyoj","type":"tool_result","content":"   235→        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n   236→        private Rigidbody _rigidBody;\n   237→        \n   238→        // 逻辑帧与渲染帧分离\n   239→        private Vector3 _pendingMotion = Vector3.zero;\n   240→        private float _lastLogicDeltaTime = 0f; // 保存逻辑帧的时间增量\n   241→        \n   242→        // 移动平滑相关\n   243→        private Vector3 _smoothedMotion = Vector3.zero;\n   244→        private Vector3 _motionVelocity = Vector3.zero; // SmoothDamp 速度缓存\n   245→\n   246→        /// <summary>\n   247→        /// 检查角色是否正在滑动\n   248→        /// </summary>\n   249→        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b06248d2-29b4-4a9f-a9e0-661948db0c8c","timestamp":"2025-12-15T11:48:10.801Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","content":"        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        \n        // 逻辑帧与渲染帧分离\n        private Vector3 _pendingMotion = Vector3.zero;\n        private float _lastLogicDeltaTime = 0f; // 保存逻辑帧的时间增量\n        \n        // 移动平滑相关\n        private Vector3 _smoothedMotion = Vector3.zero;\n        private Vector3 _motionVelocity = Vector3.zero; // SmoothDamp 速度缓存\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();","numLines":15,"startLine":235,"totalLines":1227}}}
{"parentUuid":"b06248d2-29b4-4a9f-a9e0-661948db0c8c","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01CurRqEud9k1vzqdx81rFFu","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，我找到了这些不再需要的字段。让我删除它们。","signature":"EvABCkYIChgCKkCStovLrDWIwNwbNnX6s6OZKw/RFPPCVJmNNwrkZaLgxp8oJ5w/EI2SYUToNw701nIwqfhRmuBC0RScVaCLbGKwEgyrxc/8WzICZk/C7OEaDPG5a75GxVcBf6oLhSIwS5fPVC+k5sd0gMb/PvrFKY3/YjqBLwsFsBIouYP/QcYNN/Lrcdq90rdWYeHZOwQoKligd/P9ajFOTFHwKUNHAfwid6yRTxazKccRE2NjHxTfGZCtMwlK7S3fd8u1lQ7RfXeX16DGYx3VkXbvKJPWB29IeBhZCVYT0s1bQLadabzuvJdAjrSHeBpZGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":699,"cache_read_input_tokens":78334,"cache_creation":{"ephemeral_5m_input_tokens":699,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"d429195f-a182-4b8f-958a-c703c5f0565d","timestamp":"2025-12-15T11:48:16.404Z"}
{"parentUuid":"d429195f-a182-4b8f-958a-c703c5f0565d","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01CurRqEud9k1vzqdx81rFFu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013HXioWnHHuWJmuFuhif82v","name":"Edit","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","old_string":"        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        \n        // 逻辑帧与渲染帧分离\n        private Vector3 _pendingMotion = Vector3.zero;\n        private float _lastLogicDeltaTime = 0f; // 保存逻辑帧的时间增量\n        \n        // 移动平滑相关\n        private Vector3 _smoothedMotion = Vector3.zero;\n        private Vector3 _motionVelocity = Vector3.zero; // SmoothDamp 速度缓存\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();","new_string":"        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":699,"cache_read_input_tokens":78334,"cache_creation":{"ephemeral_5m_input_tokens":699,"ephemeral_1h_input_tokens":0},"output_tokens":469,"service_tier":"standard"}},"type":"assistant","uuid":"62969c04-47d0-42b4-a057-238b3805b6cc","timestamp":"2025-12-15T11:48:20.109Z"}
{"parentUuid":"62969c04-47d0-42b4-a057-238b3805b6cc","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013HXioWnHHuWJmuFuhif82v","type":"tool_result","content":"The file E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   231→        private RaycastHit _canGoBackHeadCheck;\n   232→        private Vector3 _originalSizeRaycastOrigin;\n   233→\n   234→        // 协程和可选组件\n   235→        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n   236→        private Rigidbody _rigidBody;\n   237→\n   238→        /// <summary>\n   239→        /// 检查角色是否正在滑动\n   240→        /// </summary>\n   241→        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n   242→\n   243→        /// <summary>\n   244→        /// 检查角色头部是否与物体碰撞\n   245→        /// </summary>"}]},"uuid":"3326d30f-5fa8-417e-a3eb-ec22ac34b5d9","timestamp":"2025-12-15T11:48:21.866Z","toolUseResult":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","oldString":"        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        \n        // 逻辑帧与渲染帧分离\n        private Vector3 _pendingMotion = Vector3.zero;\n        private float _lastLogicDeltaTime = 0f; // 保存逻辑帧的时间增量\n        \n        // 移动平滑相关\n        private Vector3 _smoothedMotion = Vector3.zero;\n        private Vector3 _motionVelocity = Vector3.zero; // SmoothDamp 速度缓存\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();","newString":"        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();","originalFile":"using System;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing ActionMachine.Runtime.Attributes;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 运动学角色控制器（Kinematic Character Controller）\n    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    /// </summary>\n    [RequireComponent(typeof(CharacterController))]\n    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    public partial class Kcc : MonoBehaviour\n    {\n        private const float SMALL_VALUE = 0.0001f; // 浮点数比较的最小阈值\n        private const float SPEED_ROUNDING_PRECISION = 100f; // 速度值舍入精度\n        private const float IMPACT_THRESHOLD = 0.2f; // 冲击力应用的最小阈值\n\n        /// <summary>\n        /// 地面检测计算模式\n        /// </summary>\n        public enum GroundedComputationMode\n        {\n            Simple, // 简单模式：使用 CharacterController.isGrounded\n            Advanced // 高级模式：使用多方向射线检测\n        }\n\n        /// <summary>\n        /// 速度传递模式（用于移动平台交互）\n        /// </summary>\n        public enum VelocityTransferMode\n        {\n            NoTransfer, // 不传递速度\n            InitialVelocity, // 传递初始速度\n            FloorVelocity, // 传递地面速度\n            Relative // 相对速度模式\n        }\n\n        [Header(\"Gravity Settings\")] [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n        public float Gravity = 40f;\n\n        [Tooltip(\"是否激活重力\")] public bool GravityActive = true;\n\n        [Header(\"Raycast Settings\")] [Tooltip(\"障碍物层遮罩\")]\n        public LayerMask ObstaclesLayerMask;\n\n        [Tooltip(\"向下射线检测长度\")] public float GroundedRaycastLength = 5f;\n\n        [Tooltip(\"最小着地距离\")] public float MinimumGroundedDistance = 0.2f;\n\n        [Tooltip(\"地面检测计算模式\")] public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n\n        [Tooltip(\"地面法线高度阈值\")] public float GroundNormalHeightThreshold = 0.2f;\n\n        [Tooltip(\"蹲伏时射线长度倍数\")] public float CrouchedRaycastLengthMultiplier = 1f;\n\n        [Tooltip(\"是否执行基本方向障碍物射线检测\")] public bool PerformCardinalObstacleRaycastDetection = false;\n\n        [Header(\"Movement Settings\")] [Tooltip(\"最大下落速度\")]\n        public float MaximumFallSpeed = 20.0f;\n\n        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速\")] \n        public float HorizontalAcceleration = 20f;\n\n        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速\")] \n        public float HorizontalDeceleration = 20f;\n        \n        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n        public float InitialBurstMultiplier = 2.0f;\n        \n        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n        public float BurstSpeedThreshold = 1.0f;\n\n        [Tooltip(\"斜坡速度倍数曲线\")] public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n            new Keyframe(-90, 1),\n            new Keyframe(0, 1),\n            new Keyframe(90, 0)\n        );\n\n        [Tooltip(\"冲击力衰减速度\")] public float ImpactFalloff = 5f;\n\n        [Header(\"Steep Surface Settings\")] [Tooltip(\"是否在陡峭表面滑动\")]\n        public bool SlideOnSteepSurfaces = true;\n\n        [Tooltip(\"滑动速度\")] public float SlidingSpeed = 15f;\n\n        [Tooltip(\"滑动速度控制\")] public float SlidingSpeedControl = 0.4f;\n\n        [Tooltip(\"滑动方向控制\")] public float SlidingDirectionControl = 1f;\n\n        [Header(\"Moving Platform Settings\")] [Tooltip(\"跳跃时的速度传递方式\")]\n        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Movement Smoothing\")]\n        [Tooltip(\"是否启用移动平滑\")]\n        public bool EnableMovementSmoothing = true;\n        \n        [Tooltip(\"水平移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float HorizontalSmoothTime = 0.03f;\n        \n        [Tooltip(\"垂直移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float VerticalSmoothTime = 0.05f;\n\n        [Header(\"Runtime State - Read Only\")]\n        [SerializeField, ReadOnly] private Vector3 _speed;\n        [SerializeField, ReadOnly] private Vector3 _velocity;\n        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n        [SerializeField, ReadOnly] private Vector3 _acceleration;\n        [SerializeField, ReadOnly] private bool _grounded;\n        [SerializeField, ReadOnly] private bool _justGotGrounded;\n        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n        [SerializeField, ReadOnly] private float _friction;\n        [SerializeField, ReadOnly] private Vector3 _addedForce;\n        [SerializeField, ReadOnly] private bool _freeMovement = true;\n        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n\n        // 公共只读属性\n        public Vector3 Speed => _speed;\n        public Vector3 Velocity => _velocity;\n        public Vector3 VelocityLastFrame => _velocityLastFrame;\n        public Vector3 Acceleration => _acceleration;\n        public bool Grounded => _grounded;\n        public bool JustGotGrounded => _justGotGrounded;\n        public Vector3 CurrentMovement => _currentMovement;\n        public Vector3 CurrentDirection => _currentDirection;\n        public float Friction => _friction;\n        public Vector3 AddedForce => _addedForce;\n        public bool FreeMovement => _freeMovement;\n        public Vector3 GroundNormal => _groundNormal;\n        public Vector3 InputMoveDirection => _inputMoveDirection;\n        public Vector3 TargetVelocity => _targetVelocity;\n\n        // 碰撞器相关属性\n        public Vector3 ColliderCenter => transform.position + _characterController.center;\n\n        public Vector3 ColliderBottom => transform.position + _characterController.center +\n                                         Vector3.down * _characterController.bounds.extents.y;\n\n        public Vector3 ColliderTop => transform.position + _characterController.center +\n                                      Vector3.up * _characterController.bounds.extents.y;\n\n        public Vector3 AppliedImpact => _impact;\n\n        // 环境检测属性\n        public GameObject ObjectBelow { get; set; }\n        public GameObject DetectedObstacleLeft { get; set; }\n        public GameObject DetectedObstacleRight { get; set; }\n        public GameObject DetectedObstacleUp { get; set; }\n        public GameObject DetectedObstacleDown { get; set; }\n        public bool CollidingWithCardinalObstacle { get; set; }\n        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n\n        // 移动平台相关属性\n        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n\n        // 组件引用\n        private Transform _transform;\n        private CharacterController _characterController;\n\n        // 碰撞器原始尺寸\n        private float _originalColliderHeight;\n        private Vector3 _originalColliderCenter;\n\n        // 运动状态追踪\n        private Vector3 _positionLastFrame;\n        private bool _groundedLastFrame;\n        private Vector3 _impact;\n        private Vector3 _lastGroundNormal = Vector3.zero;\n        private bool _detached = false;\n        private bool _tooSteepLastFrame;\n\n        // 移动平台追踪\n        private Transform _movingPlatformHitCollider;\n        private Transform _movingPlatformCurrentHitCollider;\n        private Vector3 _movingPlatformCurrentHitColliderLocal;\n        private Vector3 _movingPlatformCurrentGlobalPoint;\n        private Quaternion _movingPlatformLocalRotation;\n        private Quaternion _movingPlatformGlobalRotation;\n        private Quaternion _lastMoveWithPlatformGlobalRotation;\n        private Matrix4x4 _lastMovingPlatformMatrix;\n        private Vector3 _movingPlatformVelocity;\n        private bool _newMovingPlatform;\n\n        // 碰撞检测\n        private CollisionFlags _collisionFlags;\n        private Vector3 _frameVelocity = Vector3.zero;\n        private Vector3 _hitPoint = Vector3.zero;\n        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n        // 速度计算\n        private Vector3 _newVelocity;\n        private Vector3 _motion;\n        private Vector3 _idealVelocity;\n        private Vector3 _idealDirection;\n        private Vector3 _horizontalVelocityDelta;\n        private float _stickyOffset = 0f;\n\n        // 位置移动\n        private RaycastHit _movePositionHit;\n        private Vector3 _capsulePoint1;\n        private Vector3 _capsulePoint2;\n        private Vector3 _movePositionDirection;\n        private float _movePositionDistance;\n\n        // 障碍物检测\n        private RaycastHit _cardinalRaycast;\n        private float _smallestDistance = Single.MaxValue;\n        private float _longestDistance = Single.MinValue;\n        private RaycastHit _smallestRaycast;\n        private RaycastHit _emptyRaycast = new RaycastHit();\n        private Vector3 _downRaycastsOffset;\n\n        // 平台移动计算\n        private Vector3 _moveWithPlatformMoveDistance;\n        private Vector3 _moveWithPlatformGlobalPoint;\n        private Quaternion _moveWithPlatformRotationDiff;\n        private Quaternion _moveWithPlatformGlobalRotation;\n        private RaycastHit _raycastDownHit;\n        private Vector3 _raycastDownDirection = Vector3.down;\n        private RaycastHit _canGoBackHeadCheck;\n        private Vector3 _originalSizeRaycastOrigin;\n\n        // 协程和可选组件\n        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n        \n        // 逻辑帧与渲染帧分离\n        private Vector3 _pendingMotion = Vector3.zero;\n        private float _lastLogicDeltaTime = 0f; // 保存逻辑帧的时间增量\n        \n        // 移动平滑相关\n        private Vector3 _smoothedMotion = Vector3.zero;\n        private Vector3 _motionVelocity = Vector3.zero; // SmoothDamp 速度缓存\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n        /// <summary>\n        /// 检查角色头部是否与物体碰撞\n        /// </summary>\n        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n\n        /// <summary>\n        /// 检查当前地面是否过于陡峭\n        /// </summary>\n        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n\n        /// <summary>\n        /// 初始化组件和缓存引用\n        /// </summary>\n        protected virtual void Awake()\n        {\n            _characterController = GetComponent<CharacterController>();\n            _transform = transform;\n            _rigidBody = GetComponent<Rigidbody>();\n\n            _originalColliderHeight = _characterController.height;\n            _originalColliderCenter = _characterController.center;\n            _currentDirection = _transform.forward;\n        }\n\n        /// <summary>\n        /// 固定时间更新（物理帧，处理物理相关的计算）\n        /// 负责物理模拟、重力计算、碰撞检测等需要固定时间步长的操作\n        /// </summary>\n        protected virtual void FixedUpdate()\n        {\n            // 物理相关的固定更新\n            ProcessFixedUpdate();\n        }\n\n        /// <summary>\n        /// 每帧更新（处理所有逻辑计算和移动执行）\n        /// 统一在 Update 中完成所有操作，避免 LogicUpdate 和 RenderUpdate 分离导致的抖动\n        /// </summary>\n        protected virtual void Update()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            float deltaTime = Time.deltaTime;\n\n            // 保存上一帧状态\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测\n            CheckIfGrounded();\n\n            // 2. 处理摩擦力\n            HandleFriction();\n\n            // 3. 确定移动方向\n            DetermineDirection();\n\n            // 4. 处理输入移动\n            AddInput(deltaTime);\n\n            // 5. 处理重力\n            AddGravityLogic(deltaTime);\n\n            // 6. 处理移动平台\n            MoveWithPlatform();\n\n            // 7. 计算速度变化\n            ComputeVelocityDelta(deltaTime);\n\n            // 8. 计算新速度\n            ComputeNewVelocity(deltaTime);\n\n            // 9. 执行实际移动\n            ExecuteMove(deltaTime);\n\n            // 10. 计算实际速度\n            ComputeSpeed(deltaTime);\n        }\n\n        /// <summary>\n        /// 逻辑更新（保留接口用于向后兼容，但不再使用）\n        /// 现在所有逻辑都在 Update 中处理，避免抖动问题\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        [System.Obsolete(\"LogicUpdate is no longer used. All logic is now handled in Update to avoid jitter.\")]\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 不再处理任何逻辑，所有逻辑已整合到 Update 中\n        }\n\n        /// <summary>\n        /// 延迟更新，目前为空方法，保留用于扩展\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            // LateUpdate 不再处理 _velocityLastFrame，改为在 LogicUpdate 中处理\n        }\n\n        /// <summary>\n        /// 固定更新处理（物理帧）\n        /// 处理物理相关的计算，确保物理模拟的一致性\n        /// </summary>\n        protected virtual void ProcessFixedUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 物理相关的固定更新\n            // 1. 重力计算（固定时间步长确保物理一致性）\n            if (GravityActive)\n            {\n                ApplyGravityFixed(Time.fixedDeltaTime);\n            }\n\n            // 2. 移动平台速度计算（物理相关）\n            GetMovingPlatformVelocity();\n            \n            // 3. 应用冲击力（物理相关，固定时间步长）\n            ApplyImpact(Time.fixedDeltaTime);\n        }\n\n        /// <summary>\n        /// 执行实际的移动\n        /// 直接使用计算好的 _motion 向量进行移动，不再进行二次计算\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ExecuteMove(float deltaTime)\n        {\n            // 1. 执行 CharacterController 移动\n            MoveCharacterController();\n\n            // 2. 检测新的移动平台\n            DetectNewMovingPlatform();\n\n            // 3. 手动处理碰撞器碰撞\n            ManualControllerColliderHit();\n\n            // 4. 处理地面接触状态\n            HandleGroundContact();\n        }\n\n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n                _idealVelocity = _idealVelocity * SlidingSpeed;\n                _targetVelocity = _idealVelocity;\n                _newVelocity = _idealVelocity;\n                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n            }\n            else\n            {\n                _targetVelocity = _currentMovement;\n                \n                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n                \n                Vector3 newHorizontalVelocity;\n                \n                if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                {\n                    float effectiveAcceleration = HorizontalAcceleration;\n                    \n                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n                    {\n                        effectiveAcceleration *= InitialBurstMultiplier;\n                    }\n                    \n                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n                    \n\n                    \n                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n                    {\n                        newHorizontalVelocity = targetHorizontalVelocity;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n                    }\n                }\n                else\n                {\n                    float currentSpeed = currentHorizontalVelocity.magnitude;\n                    float speedReduction = HorizontalDeceleration * deltaTime;\n                    \n\n                    \n                    if (currentSpeed <= speedReduction)\n                    {\n                        newHorizontalVelocity = Vector3.zero;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n                    }\n                }\n                \n                _newVelocity.x = newHorizontalVelocity.x;\n                _newVelocity.z = newHorizontalVelocity.z;\n                \n\n                \n                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    Vector3 floorVelocity = _frameVelocity;\n                    floorVelocity.y = 0;\n                    _newVelocity.x += floorVelocity.x;\n                    _newVelocity.z += floorVelocity.z;\n                }\n                \n                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n                    \n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity.normalized;\n                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n                        \n                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n                        {\n                            projectedDirection.Normalize();\n                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                        }\n                    }\n                    \n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 固定更新中的重力应用（物理帧）\n        /// </summary>\n        /// <param name=\"deltaTime\">固定时间增量</param>\n        protected virtual void ApplyGravityFixed(float deltaTime)\n        {\n            // 固定更新中的重力处理，主要用于物理一致性\n            // 这里可以添加需要在固定时间步长中处理的重力相关逻辑\n        }\n\n        /// <summary>\n        /// 逻辑更新中的重力应用（逻辑帧）\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑时间增量</param>\n        protected virtual void AddGravityLogic(float deltaTime)\n        {\n            if (GravityActive)\n            {\n                if (_grounded)\n                {\n                    _newVelocity.y = -Gravity * deltaTime;\n\n                }\n                else\n                {\n                    float oldY = _newVelocity.y;\n                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n\n                }\n            }\n\n            _newVelocity += _addedForce;\n            _addedForce = Vector3.zero;\n        }\n\n        /// <summary>\n        /// 应用重力到速度（保持向后兼容）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddGravity(float deltaTime)\n        {\n            AddGravityLogic(deltaTime);\n        }\n\n        /// <summary>\n        /// 跟随移动平台移动\n        /// </summary>\n        protected virtual void MoveWithPlatform()\n        {\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _moveWithPlatformMoveDistance = Vector3.zero;\n                _moveWithPlatformGlobalPoint =\n                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n\n                if (_moveWithPlatformMoveDistance != Vector3.zero)\n                {\n                    _characterController.Move(_moveWithPlatformMoveDistance);\n                }\n\n                _moveWithPlatformGlobalRotation =\n                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n            }\n        }\n\n        /// <summary>\n        /// 计算速度增量和粘性偏移\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeVelocityDelta(float deltaTime)\n        {\n            _motion = _newVelocity * deltaTime;\n            _horizontalVelocityDelta.x = _motion.x;\n            _horizontalVelocityDelta.y = 0f;\n            _horizontalVelocityDelta.z = _motion.z;\n            _stickyOffset = Mathf.Max(_characterController.stepOffset, _horizontalVelocityDelta.magnitude);\n\n            if (_grounded)\n            {\n                _motion -= _stickyOffset * Vector3.up;\n            }\n        }\n\n        /// <summary>\n        /// 执行 CharacterController 移动\n        /// 直接使用 _motion 向量进行移动\n        /// </summary>\n        protected virtual void MoveCharacterController()\n        {\n            _groundNormal = Vector3.zero;\n\n            // 直接使用在 ComputeVelocityDelta 中计算的 _motion\n            _collisionFlags = _characterController.Move(_motion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n\n\n        /// <summary>\n        /// 检测是否踩上新的移动平台\n        /// </summary>\n        protected virtual void DetectNewMovingPlatform()\n        {\n            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n            {\n                if (_movingPlatformHitCollider != null)\n                {\n                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n                    _newMovingPlatform = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 计算新速度和加速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeNewVelocity(float deltaTime)\n        {\n            _velocity = _newVelocity;\n            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n        }\n\n        /// <summary>\n        /// 处理地面接触状态和平台速度传递\n        /// </summary>\n        protected virtual void HandleGroundContact()\n        {\n            _grounded = _characterController.isGrounded;\n\n            if (_grounded && !IsGroundedTest())\n            {\n                _grounded = false;\n                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    _frameVelocity = _movingPlatformVelocity;\n                    _velocity += _movingPlatformVelocity;\n                }\n            }\n            else if (!_grounded && IsGroundedTest())\n            {\n                if (_detached && _velocity.y <= 0)\n                {\n                    _grounded = true;\n                    _detached = false;\n                }\n\n                SubtractNewPlatformVelocity();\n            }\n\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _movingPlatformCurrentGlobalPoint = _transform.position;\n                _movingPlatformCurrentHitColliderLocal =\n                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n                _movingPlatformGlobalRotation = _transform.rotation;\n                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n                                               _movingPlatformGlobalRotation;\n            }\n\n            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n            _tooSteepLastFrame = TooSteep();\n        }\n\n        /// <summary>\n        /// 计算当前速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeSpeed(float deltaTime)\n        {\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _positionLastFrame) / deltaTime;\n            }\n\n            // 暂时禁用速度舍入，避免高速时的舍入误差导致抖动\n            // _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            // _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            // _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            \n            _positionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 根据当前移动向量确定方向\n        /// </summary>\n        protected virtual void DetermineDirection()\n        {\n            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n            {\n                _currentDirection = _currentMovement.normalized;\n            }\n        }\n\n        /// <summary>\n        /// 处理摩擦力（预留方法，可在子类中实现）\n        /// </summary>\n        protected virtual void HandleFriction()\n        {\n        }\n\n        /// <summary>\n        /// 检查是否刚刚着地\n        /// </summary>\n        protected virtual void CheckIfGrounded()\n        {\n            _justGotGrounded = !_groundedLastFrame && _grounded;\n            _groundedLastFrame = _grounded;\n        }\n\n        /// <summary>\n        /// 手动触发碰撞器碰撞处理\n        /// </summary>\n        protected virtual void ManualControllerColliderHit()\n        {\n            HandleAdvancedGroundDetection();\n        }\n\n        /// <summary>\n        /// 高级地面检测（使用多方向射线）\n        /// </summary>\n        protected virtual void HandleAdvancedGroundDetection()\n        {\n            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n            {\n                return;\n            }\n\n            _smallestDistance = Single.MaxValue;\n            _longestDistance = Single.MinValue;\n            _smallestRaycast = _emptyRaycast;\n\n            float offset = _characterController.radius;\n\n            _downRaycastsOffset = Vector3.zero;\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, offset);\n            CastRayDownwards();\n\n            if (_smallestRaycast.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n\n                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n                {\n                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n                    {\n                        _groundNormal = _smallestRaycast.normal;\n                    }\n                    else\n                    {\n                        _groundNormal = _lastGroundNormal;\n                    }\n\n                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n                    _hitPoint = _smallestRaycast.point;\n                    _frameVelocity = Vector3.zero;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 向下发射射线检测地面\n        /// </summary>\n        protected virtual void CastRayDownwards()\n        {\n            if (_smallestDistance <= MinimumGroundedDistance)\n            {\n                return;\n            }\n\n            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n                _raycastDownDirection, out _raycastDownHit,\n                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n\n            if (_raycastDownHit.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n\n                if (adjustedDistance < _smallestDistance)\n                {\n                    _smallestDistance = adjustedDistance;\n                    _smallestRaycast = _raycastDownHit;\n                }\n\n                if (adjustedDistance > _longestDistance)\n                {\n                    _longestDistance = adjustedDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n        /// </summary>\n        protected float AdjustDistance(float distance)\n        {\n            return distance - _characterController.height / 2f - _characterController.skinWidth;\n        }\n\n        /// <summary>\n        /// 测试是否真正着地\n        /// </summary>\n        protected virtual bool IsGroundedTest()\n        {\n            bool grounded = false;\n            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n            {\n                if (_smallestDistance <= MinimumGroundedDistance)\n                {\n                    grounded = _groundNormal.y > 0.01f;\n                }\n            }\n            else\n            {\n                grounded = _characterController.isGrounded;\n                _groundNormal = Vector3.up;\n            }\n\n            return grounded;\n        }\n\n        /// <summary>\n        /// 获取移动平台速度\n        /// </summary>\n        protected virtual void GetMovingPlatformVelocity()\n        {\n            if (_movingPlatformCurrentHitCollider != null)\n            {\n                if (!_newMovingPlatform && Time.fixedDeltaTime > SMALL_VALUE)\n                {\n                    _movingPlatformVelocity = (\n                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n                            _movingPlatformCurrentHitColliderLocal)\n                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n                    ) / Time.fixedDeltaTime;\n                }\n\n                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n                _newMovingPlatform = false;\n            }\n            else\n            {\n                _movingPlatformVelocity = Vector3.zero;\n            }\n        }\n\n        /// <summary>\n        /// 减去新平台速度（处理平台切换）\n        /// </summary>\n        protected virtual void SubtractNewPlatformVelocity()\n        {\n            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n            {\n                if (_newMovingPlatform)\n                {\n                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n                }\n                else\n                {\n                    _velocity -= _movingPlatformVelocity;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 协程：延迟减去平台速度\n        /// </summary>\n        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n        {\n            Transform platform = _movingPlatformCurrentHitCollider;\n            yield return _waitForFixedUpdate;\n            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n            {\n                yield return null;\n            }\n\n            _velocity -= _movingPlatformVelocity;\n        }\n\n        /// <summary>\n        /// 判断是否应该跟随平台移动\n        /// </summary>\n        protected virtual bool ShouldMoveWithPlatformThisFrame()\n        {\n            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n                   && _movingPlatformCurrentHitCollider != null;\n        }\n\n        /// <summary>\n        /// 应用冲击力并逐渐衰减\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ApplyImpact(float deltaTime)\n        {\n            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n            {\n                _characterController.Move(_impact * deltaTime);\n            }\n\n            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * deltaTime);\n        }\n\n        /// <summary>\n        /// 从地面分离（用于跳跃等）\n        /// </summary>\n        public virtual void DetachFromGround()\n        {\n            _detached = true;\n        }\n\n        /// <summary>\n        /// 从移动平台分离\n        /// </summary>\n        public virtual void DetachFromMovingPlatform()\n        {\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n        }\n\n        /// <summary>\n        /// 设置重力是否激活\n        /// </summary>\n        public virtual void SetGravityActive(bool status)\n        {\n            GravityActive = status;\n        }\n\n        /// <summary>\n        /// 添加外部力（会在下一帧应用）\n        /// </summary>\n        public virtual void AddForce(Vector3 movement)\n        {\n            _addedForce += movement;\n        }\n\n        /// <summary>\n        /// 施加瞬时冲击力\n        /// </summary>\n        /// <param name=\"direction\">冲击方向</param>\n        /// <param name=\"force\">冲击力大小</param>\n        public virtual void Impact(Vector3 direction, float force)\n        {\n            direction = direction.normalized;\n            if (direction.y < 0)\n            {\n                direction.y = -direction.y;\n            }\n\n            _impact += direction.normalized * force;\n        }\n\n        /// <summary>\n        /// 设置移动向量（通常由输入系统调用）\n        /// </summary>\n        /// <param name=\"movement\">移动向量</param>\n        public virtual void SetMovement(Vector3 movement)\n        {\n            _currentMovement = movement;\n\n            Vector3 directionVector = movement;\n            if (directionVector != Vector3.zero)\n            {\n                float directionLength = directionVector.magnitude;\n                directionVector = directionVector / directionLength;\n                directionLength = Mathf.Min(1, directionLength);\n                // 移除平方操作，保持线性响应，避免高速时的非线性抖动\n                directionVector = directionVector * directionLength;\n            }\n\n            _inputMoveDirection = transform.rotation * directionVector;\n        }\n\n        /// <summary>\n        /// 移动到指定位置（带碰撞检测）\n        /// </summary>\n        /// <param name=\"newPosition\">目标位置</param>\n        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n        {\n            _movePositionDirection = newPosition - transform.position;\n            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n\n            _capsulePoint1 = transform.position\n                             + _characterController.center\n                             - (Vector3.up * _characterController.height / 2f)\n                             + Vector3.up * _characterController.skinWidth\n                             + Vector3.up * _characterController.radius;\n\n            _capsulePoint2 = transform.position\n                             + _characterController.center\n                             + (Vector3.up * _characterController.height / 2f)\n                             - Vector3.up * _characterController.skinWidth\n                             - Vector3.up * _characterController.radius;\n\n            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n            {\n                transform.position = newPosition;\n            }\n        }\n\n        /// <summary>\n        /// 调整碰撞器高度（用于蹲伏等）\n        /// </summary>\n        /// <param name=\"newHeight\">新高度</param>\n        /// <param name=\"translateCenter\">是否平移中心点</param>\n        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n        {\n            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n            _characterController.height = newHeight;\n            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n\n            if (translateCenter)\n            {\n                transform.Translate((newYOffset / 2f) * Vector3.up);\n            }\n        }\n\n        /// <summary>\n        /// 重置碰撞器尺寸到原始大小\n        /// </summary>\n        public virtual void ResetColliderSize()\n        {\n            _characterController.height = _originalColliderHeight;\n            _characterController.center = _originalColliderCenter;\n        }\n\n        /// <summary>\n        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n        /// </summary>\n        public virtual bool CanGoBackToOriginalSize()\n        {\n            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n            {\n                return true;\n            }\n\n            float headCheckDistance =\n                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n\n            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n                ObstaclesLayerMask, Color.cyan, true);\n\n            return _canGoBackHeadCheck.collider == null;\n        }\n\n        /// <summary>\n        /// 启用碰撞\n        /// </summary>\n        public virtual void CollisionsOn()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = true;\n            }\n        }\n\n        /// <summary>\n        /// 禁用碰撞\n        /// </summary>\n        public virtual void CollisionsOff()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = false;\n            }\n        }\n\n        /// <summary>\n        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n        /// </summary>\n        public virtual void SetKinematic(bool state)\n        {\n            _rigidBody.isKinematic = state;\n        }\n\n        /// <summary>\n        /// 设置是否允许自由移动\n        /// </summary>\n        public virtual void SetFreeMovement(bool state)\n        {\n            _freeMovement = state;\n        }\n\n        /// <summary>\n        /// 检测四个基本方向的障碍物\n        /// </summary>\n        /// <param name=\"distance\">检测距离</param>\n        /// <param name=\"offset\">起始偏移</param>\n        public virtual void DetectObstacles(float distance, Vector3 offset)\n        {\n            if (!PerformCardinalObstacleRaycastDetection)\n            {\n                return;\n            }\n\n            CollidingWithCardinalObstacle = false;\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleRight = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleLeft = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleUp = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleDown = null;\n            }\n        }\n\n        /// <summary>\n        /// 重置控制器到初始状态\n        /// </summary>\n        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n            \n            // 重置平滑移动相关变量\n            _pendingMotion = Vector3.zero;\n            _smoothedMotion = Vector3.zero;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n\n            return hit;\n        }\n    }\n}","structuredPatch":[{"oldStart":234,"oldLines":14,"newStart":234,"newLines":6,"lines":["         // 协程和可选组件","         private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();","         private Rigidbody _rigidBody;","-        ","-        // 逻辑帧与渲染帧分离","-        private Vector3 _pendingMotion = Vector3.zero;","-        private float _lastLogicDeltaTime = 0f; // 保存逻辑帧的时间增量","-        ","-        // 移动平滑相关","-        private Vector3 _smoothedMotion = Vector3.zero;","-        private Vector3 _motionVelocity = Vector3.zero; // SmoothDamp 速度缓存"," ","         /// <summary>","         /// 检查角色是否正在滑动"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"3326d30f-5fa8-417e-a3eb-ec22ac34b5d9","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YHtceYBbudxUnDyhivxGZf","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"很好，现在我还需要更新 ResetController 方法，删除对这些不再使用的字段的重置。让我找到并更新这个方法。","signature":"ErgCCkYIChgCKkBOX1DY2wvxXF0xUtQYHlA3yag+DMZ/xGaZfdTPtbG2A4em3aWlm9y/AtrvMcVsCV3En7O7Q84ey0tCiNfK1ZYcEgwqFTKoMVeCN1QT7PYaDF2qcg05HLw/T/XytiIw3H3Fdu2gBlwUaH3I+PL65CE1WtwNBHdjDdnUnD5/TN+NuEE8hInmVppfylQOmt7hKp8B7nwEpiX1+X/o0rULUbLk2C0uZBhPoGGmjaH0FMZJN96bDPysjNKmbspqZX9FCUJgEghgeOZ0XdatIfkIpjYXiOuYfK0SzT/v9ug6TohHlQWs3Cqyy9vMpLNescwzqx0VgtfrigMt+vx+r8FkKya6Ze9xuvIQbC0nr9QVlpsygyqMWYpR11aTl4fQ8fwGpknrP29CCibBfdpYsA1mbHwkGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":763,"cache_read_input_tokens":79033,"cache_creation":{"ephemeral_5m_input_tokens":763,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"6d63fb0e-f200-4e8e-9d22-b14716e614d0","timestamp":"2025-12-15T11:48:27.785Z"}
{"parentUuid":"6d63fb0e-f200-4e8e-9d22-b14716e614d0","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YHtceYBbudxUnDyhivxGZf","type":"message","role":"assistant","content":[{"type":"text","text":"现在我需要更新 `ResetController` 方法，删除对不再使用字段的重置。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":763,"cache_read_input_tokens":79033,"cache_creation":{"ephemeral_5m_input_tokens":763,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"43778aac-b6db-4da4-8d6f-24bbc8867b1f","timestamp":"2025-12-15T11:48:28.377Z"}
{"parentUuid":"43778aac-b6db-4da4-8d6f-24bbc8867b1f","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YHtceYBbudxUnDyhivxGZf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NH4nBpXt1Z3VtwmfhACnCr","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","limit":50,"offset":1260}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":763,"cache_read_input_tokens":79033,"cache_creation":{"ephemeral_5m_input_tokens":763,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"59301efb-1940-41cd-bb25-a0cfa17cc698","timestamp":"2025-12-15T11:48:29.138Z"}
{"parentUuid":"59301efb-1940-41cd-bb25-a0cfa17cc698","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NH4nBpXt1Z3VtwmfhACnCr","type":"tool_result","content":"<system-reminder>Warning: the file exists but is shorter than the provided offset (1260). The file has 1219 lines.</system-reminder>"}]},"uuid":"7c605782-c24a-4eea-b6f0-03c8409dbf95","timestamp":"2025-12-15T11:48:29.908Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","content":"","numLines":0,"startLine":1260,"totalLines":1219}}}
{"parentUuid":"7c605782-c24a-4eea-b6f0-03c8409dbf95","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01EAeH9QwStNooVFifLf1smF","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"文件现在变短了，让我重新查找 ResetController 方法的位置。","signature":"EvUBCkYIChgCKkB0GtEB0QjoDDePopyKgKSPF19IMB6mTFmLAY8a8wkl6wvvYdSizBuLQ7HJ6OD+7Rlhw1+4VM6YF7K+iTqXQ+HSEgy67WuSCEDhITHt26waDFYiw7ENL8T+MSqCyCIwzA6Ew8TS2scue1RVKrdHY/rqKvsiOXn1sCvoaXnDHHdPMImYh5gMm1MZXF6nxx0kKl0t/woN74Dkmy/0XR42wculWLxpgLFnsEAcwYStFr2WotAr+K/WPP7uXMKaw8RxVvVsVdI6d1ZuPgElgG7u0al5tDI0KR8CURjg4wPdaYoBZ+3S/5PV8seNqvXsXAQYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":364,"cache_read_input_tokens":79796,"cache_creation":{"ephemeral_5m_input_tokens":364,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"317b0b90-40d3-4b27-a154-9d05234695be","timestamp":"2025-12-15T11:48:35.423Z"}
{"parentUuid":"317b0b90-40d3-4b27-a154-9d05234695be","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01EAeH9QwStNooVFifLf1smF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C9KmKFhE2nhsnUMmCzaR36","name":"Grep","input":{"pattern":"ResetController","path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":364,"cache_read_input_tokens":79796,"cache_creation":{"ephemeral_5m_input_tokens":364,"ephemeral_1h_input_tokens":0},"output_tokens":175,"service_tier":"standard"}},"type":"assistant","uuid":"06174b05-d647-4d84-ba4e-8e3b0d8373d0","timestamp":"2025-12-15T11:48:36.768Z"}
{"parentUuid":"06174b05-d647-4d84-ba4e-8e3b0d8373d0","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C9KmKFhE2nhsnUMmCzaR36","type":"tool_result","content":"1163:        public virtual void ResetController()"}]},"uuid":"1c40ed06-986f-42f7-a5f1-aa9a7ccb21f6","timestamp":"2025-12-15T11:48:37.492Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"1163:        public virtual void ResetController()","numLines":1}}
{"parentUuid":"1c40ed06-986f-42f7-a5f1-aa9a7ccb21f6","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BpErSnX2NoiC4h2gmM3Lon","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"找到了，在 1163 行。让我读取这个方法。","signature":"Et4BCkYIChgCKkAgsvwbExou0Ouokur2i7L6epyhYCosOAIAhC1pwtA3xhulmxFkjFqq4rIsZJ68ffiurs1wRJN7N9LWPNk9NjVuEgzo+ekiYxu17dmrjoAaDMw02Q0YhK197XJJziIw0jGVShK+KHqSWzlzNmbgPycscFqSEhUCzN3hQjr75smxN5IdHSXO8dgIF0q51q2FKkZf+PL9KiSxPMNqJqMEyHCkPWUdALvPR4bnivQe/ONNL+gDFxbJ2O0KfcNxzhLf1xNqGqSQ6/St4ivL3A9kThluL9yds0z8GAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":205,"cache_read_input_tokens":80160,"cache_creation":{"ephemeral_5m_input_tokens":205,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"84629bd9-0bf7-4b7f-9c4e-a0160a9f5834","timestamp":"2025-12-15T11:48:42.842Z"}
{"parentUuid":"84629bd9-0bf7-4b7f-9c4e-a0160a9f5834","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BpErSnX2NoiC4h2gmM3Lon","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016ZWu16ncDG7Hu9dWCz5zpV","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","limit":60,"offset":1163}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":205,"cache_read_input_tokens":80160,"cache_creation":{"ephemeral_5m_input_tokens":205,"ephemeral_1h_input_tokens":0},"output_tokens":150,"service_tier":"standard"}},"type":"assistant","uuid":"8e7c09d0-74dd-4139-8abb-7e80949bbc20","timestamp":"2025-12-15T11:48:43.592Z"}
{"parentUuid":"8e7c09d0-74dd-4139-8abb-7e80949bbc20","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016ZWu16ncDG7Hu9dWCz5zpV","type":"tool_result","content":"  1163→        public virtual void ResetController()\n  1164→        {\n  1165→            _impact = Vector3.zero;\n  1166→            GravityActive = true;\n  1167→            _speed = Vector3.zero;\n  1168→            _velocity = Vector3.zero;\n  1169→            _velocityLastFrame = Vector3.zero;\n  1170→            _acceleration = Vector3.zero;\n  1171→            _grounded = true;\n  1172→            _justGotGrounded = false;\n  1173→            _currentMovement = Vector3.zero;\n  1174→            _currentDirection = Vector3.zero;\n  1175→            _addedForce = Vector3.zero;\n  1176→            _idealDirection = Vector3.zero;\n  1177→            _idealVelocity = Vector3.zero;\n  1178→            _newVelocity = Vector3.zero;\n  1179→            _movingPlatformVelocity = Vector3.zero;\n  1180→            _movingPlatformCurrentHitCollider = null;\n  1181→            _movingPlatformHitCollider = null;\n  1182→            _lastGroundNormal = Vector3.zero;\n  1183→            _detached = false;\n  1184→            _frameVelocity = Vector3.zero;\n  1185→            _hitPoint = Vector3.zero;\n  1186→            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n  1187→            \n  1188→            // 重置平滑移动相关变量\n  1189→            _pendingMotion = Vector3.zero;\n  1190→            _smoothedMotion = Vector3.zero;\n  1191→\n  1192→            if (_rigidBody != null)\n  1193→            {\n  1194→                bool isKinematic = _rigidBody.isKinematic;\n  1195→                _rigidBody.isKinematic = false;\n  1196→                _rigidBody.linearVelocity = Vector3.zero;\n  1197→                _rigidBody.angularVelocity = Vector3.zero;\n  1198→                _rigidBody.isKinematic = isKinematic;\n  1199→            }\n  1200→        }\n  1201→\n  1202→        /// <summary>\n  1203→        /// 3D 射线检测辅助方法（带可视化调试）\n  1204→        /// </summary>\n  1205→        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n  1206→            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n  1207→        {\n  1208→            RaycastHit hit;\n  1209→            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n  1210→\n  1211→            if (Camera.current != null && (drawInSceneView || drawInGameView))\n  1212→            {\n  1213→                Debug.DrawRay(origin, direction * distance, color);\n  1214→            }\n  1215→\n  1216→            return hit;\n  1217→        }\n  1218→    }\n  1219→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"93a4e4ee-4159-46ab-aeac-3f7f5f0004b4","timestamp":"2025-12-15T11:48:44.356Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","content":"        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n            \n            // 重置平滑移动相关变量\n            _pendingMotion = Vector3.zero;\n            _smoothedMotion = Vector3.zero;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n\n            return hit;\n        }\n    }\n}","numLines":57,"startLine":1163,"totalLines":1219}}}
{"parentUuid":"93a4e4ee-4159-46ab-aeac-3f7f5f0004b4","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UgzvDwkY6FTuaYk4V5GLpG","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"好的，我需要删除 ResetController 方法中对 _pendingMotion 和 _smoothedMotion 的重置，因为这些字段已经被删除了。","signature":"ErUCCkYIChgCKkC60e24H7YqAMGmj09IdPbwzqUPvG8pevl48gFjftl1p+2reu21ds8909CfGNvnbxysTq5yavAUqhl/AtzVZ7p0EgzZ6NfVCCj6y0PhzioaDKyZNhmkOO6mbmofXCIwGOoUW5xmC3c8LjbZFBhbTyKtmR/BtCSdOL1NyIIxMLOUq7ERvxlzUeUPY7ApOkuqKpwBH3950kaLxUKrb3dXZ4GlMHd0J3MAws/8T3JiV+c69+61Hb3/kELZJslwkiixuR2bO7jFwYapz3kIWQnxLhAG8lHgnOL22hi6M3cICuIzzpYvEm8d5kmsUawXebyFdULEaFMyFJPm9foDGBuP7nNq5+mk+fRe8HcMf81Yjo9zC4uSilamLomkGXJpg9I52GYD+76Sj5foJuicWa3IGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1103,"cache_read_input_tokens":80365,"cache_creation":{"ephemeral_5m_input_tokens":1103,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"type":"assistant","uuid":"18e2f809-de73-470a-9c16-c8523b3c2355","timestamp":"2025-12-15T11:48:50.620Z"}
{"parentUuid":"18e2f809-de73-470a-9c16-c8523b3c2355","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01UgzvDwkY6FTuaYk4V5GLpG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RWS6mKFrx8ng3Qkn31C67M","name":"Edit","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","old_string":"        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n            \n            // 重置平滑移动相关变量\n            _pendingMotion = Vector3.zero;\n            _smoothedMotion = Vector3.zero;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }","new_string":"        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1103,"cache_read_input_tokens":80365,"cache_creation":{"ephemeral_5m_input_tokens":1103,"ephemeral_1h_input_tokens":0},"output_tokens":1009,"service_tier":"standard"}},"type":"assistant","uuid":"0153ce73-c1ec-4873-a664-5ab0d7a35399","timestamp":"2025-12-15T11:48:58.127Z"}
{"parentUuid":"0153ce73-c1ec-4873-a664-5ab0d7a35399","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RWS6mKFrx8ng3Qkn31C67M","type":"tool_result","content":"The file E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1159→\n  1160→        /// <summary>\n  1161→        /// 重置控制器到初始状态\n  1162→        /// </summary>\n  1163→        public virtual void ResetController()\n  1164→        {\n  1165→            _impact = Vector3.zero;\n  1166→            GravityActive = true;\n  1167→            _speed = Vector3.zero;\n  1168→            _velocity = Vector3.zero;\n  1169→            _velocityLastFrame = Vector3.zero;\n  1170→            _acceleration = Vector3.zero;\n  1171→            _grounded = true;\n  1172→            _justGotGrounded = false;\n  1173→            _currentMovement = Vector3.zero;\n  1174→            _currentDirection = Vector3.zero;\n  1175→            _addedForce = Vector3.zero;\n  1176→            _idealDirection = Vector3.zero;\n  1177→            _idealVelocity = Vector3.zero;\n  1178→            _newVelocity = Vector3.zero;\n  1179→            _movingPlatformVelocity = Vector3.zero;\n  1180→            _movingPlatformCurrentHitCollider = null;\n  1181→            _movingPlatformHitCollider = null;\n  1182→            _lastGroundNormal = Vector3.zero;\n  1183→            _detached = false;\n  1184→            _frameVelocity = Vector3.zero;\n  1185→            _hitPoint = Vector3.zero;\n  1186→            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n  1187→\n  1188→            if (_rigidBody != null)\n  1189→            {\n  1190→                bool isKinematic = _rigidBody.isKinematic;\n  1191→                _rigidBody.isKinematic = false;\n  1192→                _rigidBody.linearVelocity = Vector3.zero;\n  1193→                _rigidBody.angularVelocity = Vector3.zero;\n  1194→                _rigidBody.isKinematic = isKinematic;\n  1195→            }\n  1196→        }\n  1197→\n  1198→        /// <summary>\n  1199→        /// 3D 射线检测辅助方法（带可视化调试）\n  1200→        /// </summary>"}]},"uuid":"20610855-b92f-491c-80be-334b7ddac6e1","timestamp":"2025-12-15T11:49:03.779Z","toolUseResult":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","oldString":"        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n            \n            // 重置平滑移动相关变量\n            _pendingMotion = Vector3.zero;\n            _smoothedMotion = Vector3.zero;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }","newString":"        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }","originalFile":"using System;\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\nusing ActionMachine.Runtime.Attributes;\n\nnamespace ActionMachine.Runtime.Controller\n{\n    /// <summary>\n    /// 运动学角色控制器（Kinematic Character Controller）\n    /// 基于 Unity CharacterController 的高级角色移动控制系统\n    /// 支持重力、地面检测、斜坡滑动、移动平台等功能\n    /// </summary>\n    [RequireComponent(typeof(CharacterController))]\n    [AddComponentMenu(\"ActionMachine/Controller/Kcc\")]\n    public partial class Kcc : MonoBehaviour\n    {\n        private const float SMALL_VALUE = 0.0001f; // 浮点数比较的最小阈值\n        private const float SPEED_ROUNDING_PRECISION = 100f; // 速度值舍入精度\n        private const float IMPACT_THRESHOLD = 0.2f; // 冲击力应用的最小阈值\n\n        /// <summary>\n        /// 地面检测计算模式\n        /// </summary>\n        public enum GroundedComputationMode\n        {\n            Simple, // 简单模式：使用 CharacterController.isGrounded\n            Advanced // 高级模式：使用多方向射线检测\n        }\n\n        /// <summary>\n        /// 速度传递模式（用于移动平台交互）\n        /// </summary>\n        public enum VelocityTransferMode\n        {\n            NoTransfer, // 不传递速度\n            InitialVelocity, // 传递初始速度\n            FloorVelocity, // 传递地面速度\n            Relative // 相对速度模式\n        }\n\n        [Header(\"Gravity Settings\")] [Tooltip(\"重力值（正值向下，负值向上，数值越大加速度越大）\")]\n        public float Gravity = 40f;\n\n        [Tooltip(\"是否激活重力\")] public bool GravityActive = true;\n\n        [Header(\"Raycast Settings\")] [Tooltip(\"障碍物层遮罩\")]\n        public LayerMask ObstaclesLayerMask;\n\n        [Tooltip(\"向下射线检测长度\")] public float GroundedRaycastLength = 5f;\n\n        [Tooltip(\"最小着地距离\")] public float MinimumGroundedDistance = 0.2f;\n\n        [Tooltip(\"地面检测计算模式\")] public GroundedComputationMode GroundDetectionMode = GroundedComputationMode.Advanced;\n\n        [Tooltip(\"地面法线高度阈值\")] public float GroundNormalHeightThreshold = 0.2f;\n\n        [Tooltip(\"蹲伏时射线长度倍数\")] public float CrouchedRaycastLengthMultiplier = 1f;\n\n        [Tooltip(\"是否执行基本方向障碍物射线检测\")] public bool PerformCardinalObstacleRaycastDetection = false;\n\n        [Header(\"Movement Settings\")] [Tooltip(\"最大下落速度\")]\n        public float MaximumFallSpeed = 20.0f;\n\n        [Tooltip(\"角色水平移动加速率（单位/秒²），控制从静止到目标速度的加速\")] \n        public float HorizontalAcceleration = 20f;\n\n        [Tooltip(\"角色水平移动减速率（单位/秒²），控制从移动到静止的减速\")] \n        public float HorizontalDeceleration = 20f;\n        \n        [Tooltip(\"起步爆发加速倍数，用于改善低速启动手感（1.0表示无爆发加速）\")]\n        public float InitialBurstMultiplier = 2.0f;\n        \n        [Tooltip(\"爆发加速生效的速度阈值，当速度低于此值时应用爆发加速\")]\n        public float BurstSpeedThreshold = 1.0f;\n\n        [Tooltip(\"斜坡速度倍数曲线\")] public AnimationCurve SlopeSpeedMultiplier = new AnimationCurve(\n            new Keyframe(-90, 1),\n            new Keyframe(0, 1),\n            new Keyframe(90, 0)\n        );\n\n        [Tooltip(\"冲击力衰减速度\")] public float ImpactFalloff = 5f;\n\n        [Header(\"Steep Surface Settings\")] [Tooltip(\"是否在陡峭表面滑动\")]\n        public bool SlideOnSteepSurfaces = true;\n\n        [Tooltip(\"滑动速度\")] public float SlidingSpeed = 15f;\n\n        [Tooltip(\"滑动速度控制\")] public float SlidingSpeedControl = 0.4f;\n\n        [Tooltip(\"滑动方向控制\")] public float SlidingDirectionControl = 1f;\n\n        [Header(\"Moving Platform Settings\")] [Tooltip(\"跳跃时的速度传递方式\")]\n        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Movement Smoothing\")]\n        [Tooltip(\"是否启用移动平滑\")]\n        public bool EnableMovementSmoothing = true;\n        \n        [Tooltip(\"水平移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float HorizontalSmoothTime = 0.03f;\n        \n        [Tooltip(\"垂直移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float VerticalSmoothTime = 0.05f;\n\n        [Header(\"Runtime State - Read Only\")]\n        [SerializeField, ReadOnly] private Vector3 _speed;\n        [SerializeField, ReadOnly] private Vector3 _velocity;\n        [SerializeField, ReadOnly] private Vector3 _velocityLastFrame;\n        [SerializeField, ReadOnly] private Vector3 _acceleration;\n        [SerializeField, ReadOnly] private bool _grounded;\n        [SerializeField, ReadOnly] private bool _justGotGrounded;\n        [SerializeField, ReadOnly] private Vector3 _currentMovement;\n        [SerializeField, ReadOnly] private Vector3 _currentDirection;\n        [SerializeField, ReadOnly] private float _friction;\n        [SerializeField, ReadOnly] private Vector3 _addedForce;\n        [SerializeField, ReadOnly] private bool _freeMovement = true;\n        [SerializeField, ReadOnly] private Vector3 _groundNormal = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _inputMoveDirection = Vector3.zero;\n        [SerializeField, ReadOnly] private Vector3 _targetVelocity = Vector3.zero;\n\n        // 公共只读属性\n        public Vector3 Speed => _speed;\n        public Vector3 Velocity => _velocity;\n        public Vector3 VelocityLastFrame => _velocityLastFrame;\n        public Vector3 Acceleration => _acceleration;\n        public bool Grounded => _grounded;\n        public bool JustGotGrounded => _justGotGrounded;\n        public Vector3 CurrentMovement => _currentMovement;\n        public Vector3 CurrentDirection => _currentDirection;\n        public float Friction => _friction;\n        public Vector3 AddedForce => _addedForce;\n        public bool FreeMovement => _freeMovement;\n        public Vector3 GroundNormal => _groundNormal;\n        public Vector3 InputMoveDirection => _inputMoveDirection;\n        public Vector3 TargetVelocity => _targetVelocity;\n\n        // 碰撞器相关属性\n        public Vector3 ColliderCenter => transform.position + _characterController.center;\n\n        public Vector3 ColliderBottom => transform.position + _characterController.center +\n                                         Vector3.down * _characterController.bounds.extents.y;\n\n        public Vector3 ColliderTop => transform.position + _characterController.center +\n                                      Vector3.up * _characterController.bounds.extents.y;\n\n        public Vector3 AppliedImpact => _impact;\n\n        // 环境检测属性\n        public GameObject ObjectBelow { get; set; }\n        public GameObject DetectedObstacleLeft { get; set; }\n        public GameObject DetectedObstacleRight { get; set; }\n        public GameObject DetectedObstacleUp { get; set; }\n        public GameObject DetectedObstacleDown { get; set; }\n        public bool CollidingWithCardinalObstacle { get; set; }\n        public bool ExitedTooSteepSlopeThisFrame { get; set; }\n\n        // 移动平台相关属性\n        public bool OnAMovingPlatform => ShouldMoveWithPlatformThisFrame();\n        public Vector3 MovingPlatformSpeed => _movingPlatformVelocity;\n        public Quaternion MoveWithPlatformGlobalRotation => _moveWithPlatformGlobalRotation;\n        public Quaternion MoveWithPlatformRotationDiff => _moveWithPlatformRotationDiff;\n\n        // 组件引用\n        private Transform _transform;\n        private CharacterController _characterController;\n\n        // 碰撞器原始尺寸\n        private float _originalColliderHeight;\n        private Vector3 _originalColliderCenter;\n\n        // 运动状态追踪\n        private Vector3 _positionLastFrame;\n        private bool _groundedLastFrame;\n        private Vector3 _impact;\n        private Vector3 _lastGroundNormal = Vector3.zero;\n        private bool _detached = false;\n        private bool _tooSteepLastFrame;\n\n        // 移动平台追踪\n        private Transform _movingPlatformHitCollider;\n        private Transform _movingPlatformCurrentHitCollider;\n        private Vector3 _movingPlatformCurrentHitColliderLocal;\n        private Vector3 _movingPlatformCurrentGlobalPoint;\n        private Quaternion _movingPlatformLocalRotation;\n        private Quaternion _movingPlatformGlobalRotation;\n        private Quaternion _lastMoveWithPlatformGlobalRotation;\n        private Matrix4x4 _lastMovingPlatformMatrix;\n        private Vector3 _movingPlatformVelocity;\n        private bool _newMovingPlatform;\n\n        // 碰撞检测\n        private CollisionFlags _collisionFlags;\n        private Vector3 _frameVelocity = Vector3.zero;\n        private Vector3 _hitPoint = Vector3.zero;\n        private Vector3 _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n\n        // 速度计算\n        private Vector3 _newVelocity;\n        private Vector3 _motion;\n        private Vector3 _idealVelocity;\n        private Vector3 _idealDirection;\n        private Vector3 _horizontalVelocityDelta;\n        private float _stickyOffset = 0f;\n\n        // 位置移动\n        private RaycastHit _movePositionHit;\n        private Vector3 _capsulePoint1;\n        private Vector3 _capsulePoint2;\n        private Vector3 _movePositionDirection;\n        private float _movePositionDistance;\n\n        // 障碍物检测\n        private RaycastHit _cardinalRaycast;\n        private float _smallestDistance = Single.MaxValue;\n        private float _longestDistance = Single.MinValue;\n        private RaycastHit _smallestRaycast;\n        private RaycastHit _emptyRaycast = new RaycastHit();\n        private Vector3 _downRaycastsOffset;\n\n        // 平台移动计算\n        private Vector3 _moveWithPlatformMoveDistance;\n        private Vector3 _moveWithPlatformGlobalPoint;\n        private Quaternion _moveWithPlatformRotationDiff;\n        private Quaternion _moveWithPlatformGlobalRotation;\n        private RaycastHit _raycastDownHit;\n        private Vector3 _raycastDownDirection = Vector3.down;\n        private RaycastHit _canGoBackHeadCheck;\n        private Vector3 _originalSizeRaycastOrigin;\n\n        // 协程和可选组件\n        private WaitForFixedUpdate _waitForFixedUpdate = new WaitForFixedUpdate();\n        private Rigidbody _rigidBody;\n\n        /// <summary>\n        /// 检查角色是否正在滑动\n        /// </summary>\n        public bool IsSliding() => _grounded && SlideOnSteepSurfaces && TooSteep();\n\n        /// <summary>\n        /// 检查角色头部是否与物体碰撞\n        /// </summary>\n        public bool CollidingAbove() => (_collisionFlags & CollisionFlags.CollidedAbove) != 0;\n\n        /// <summary>\n        /// 检查当前地面是否过于陡峭\n        /// </summary>\n        public bool TooSteep() => _groundNormal.y <= Mathf.Cos(_characterController.slopeLimit * Mathf.Deg2Rad);\n\n        /// <summary>\n        /// 初始化组件和缓存引用\n        /// </summary>\n        protected virtual void Awake()\n        {\n            _characterController = GetComponent<CharacterController>();\n            _transform = transform;\n            _rigidBody = GetComponent<Rigidbody>();\n\n            _originalColliderHeight = _characterController.height;\n            _originalColliderCenter = _characterController.center;\n            _currentDirection = _transform.forward;\n        }\n\n        /// <summary>\n        /// 固定时间更新（物理帧，处理物理相关的计算）\n        /// 负责物理模拟、重力计算、碰撞检测等需要固定时间步长的操作\n        /// </summary>\n        protected virtual void FixedUpdate()\n        {\n            // 物理相关的固定更新\n            ProcessFixedUpdate();\n        }\n\n        /// <summary>\n        /// 每帧更新（处理所有逻辑计算和移动执行）\n        /// 统一在 Update 中完成所有操作，避免 LogicUpdate 和 RenderUpdate 分离导致的抖动\n        /// </summary>\n        protected virtual void Update()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            float deltaTime = Time.deltaTime;\n\n            // 保存上一帧状态\n            _velocityLastFrame = _velocity;\n            _newVelocity = _velocity;\n            _positionLastFrame = _transform.position;\n\n            // 1. 地面检测\n            CheckIfGrounded();\n\n            // 2. 处理摩擦力\n            HandleFriction();\n\n            // 3. 确定移动方向\n            DetermineDirection();\n\n            // 4. 处理输入移动\n            AddInput(deltaTime);\n\n            // 5. 处理重力\n            AddGravityLogic(deltaTime);\n\n            // 6. 处理移动平台\n            MoveWithPlatform();\n\n            // 7. 计算速度变化\n            ComputeVelocityDelta(deltaTime);\n\n            // 8. 计算新速度\n            ComputeNewVelocity(deltaTime);\n\n            // 9. 执行实际移动\n            ExecuteMove(deltaTime);\n\n            // 10. 计算实际速度\n            ComputeSpeed(deltaTime);\n        }\n\n        /// <summary>\n        /// 逻辑更新（保留接口用于向后兼容，但不再使用）\n        /// 现在所有逻辑都在 Update 中处理，避免抖动问题\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑帧时间增量</param>\n        [System.Obsolete(\"LogicUpdate is no longer used. All logic is now handled in Update to avoid jitter.\")]\n        public virtual void LogicUpdate(float deltaTime)\n        {\n            // 不再处理任何逻辑，所有逻辑已整合到 Update 中\n        }\n\n        /// <summary>\n        /// 延迟更新，目前为空方法，保留用于扩展\n        /// </summary>\n        protected virtual void LateUpdate()\n        {\n            // LateUpdate 不再处理 _velocityLastFrame，改为在 LogicUpdate 中处理\n        }\n\n        /// <summary>\n        /// 固定更新处理（物理帧）\n        /// 处理物理相关的计算，确保物理模拟的一致性\n        /// </summary>\n        protected virtual void ProcessFixedUpdate()\n        {\n            if (_transform == null || !_freeMovement)\n            {\n                return;\n            }\n\n            // 物理相关的固定更新\n            // 1. 重力计算（固定时间步长确保物理一致性）\n            if (GravityActive)\n            {\n                ApplyGravityFixed(Time.fixedDeltaTime);\n            }\n\n            // 2. 移动平台速度计算（物理相关）\n            GetMovingPlatformVelocity();\n            \n            // 3. 应用冲击力（物理相关，固定时间步长）\n            ApplyImpact(Time.fixedDeltaTime);\n        }\n\n        /// <summary>\n        /// 执行实际的移动\n        /// 直接使用计算好的 _motion 向量进行移动，不再进行二次计算\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ExecuteMove(float deltaTime)\n        {\n            // 1. 执行 CharacterController 移动\n            MoveCharacterController();\n\n            // 2. 检测新的移动平台\n            DetectNewMovingPlatform();\n\n            // 3. 手动处理碰撞器碰撞\n            ManualControllerColliderHit();\n\n            // 4. 处理地面接触状态\n            HandleGroundContact();\n        }\n\n        /// <summary>\n        /// 处理输入并计算理想速度（包括滑坡逻辑）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddInput(float deltaTime)\n        {\n            if (_grounded && TooSteep())\n            {\n                _idealVelocity.x = _groundNormal.x;\n                _idealVelocity.y = 0;\n                _idealVelocity.z = _groundNormal.z;\n                _idealVelocity = _idealVelocity.normalized;\n                _idealDirection = Vector3.Project(_inputMoveDirection, _idealVelocity);\n                _idealVelocity = _idealVelocity + (_idealDirection * SlidingSpeedControl) +\n                                 (_inputMoveDirection - _idealDirection) * SlidingDirectionControl;\n                _idealVelocity = _idealVelocity * SlidingSpeed;\n                _targetVelocity = _idealVelocity;\n                _newVelocity = _idealVelocity;\n                _newVelocity.y = _grounded ? Mathf.Min(_newVelocity.y, 0) : _newVelocity.y;\n            }\n            else\n            {\n                _targetVelocity = _currentMovement;\n                \n                Vector3 currentHorizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                Vector3 targetHorizontalVelocity = new Vector3(_targetVelocity.x, 0, _targetVelocity.z);\n                \n                Vector3 newHorizontalVelocity;\n                \n                if (targetHorizontalVelocity.sqrMagnitude > SMALL_VALUE * SMALL_VALUE)\n                {\n                    float effectiveAcceleration = HorizontalAcceleration;\n                    \n                    if (currentHorizontalVelocity.sqrMagnitude < BurstSpeedThreshold * BurstSpeedThreshold)\n                    {\n                        effectiveAcceleration *= InitialBurstMultiplier;\n                    }\n                    \n                    Vector3 velocityDiff = targetHorizontalVelocity - currentHorizontalVelocity;\n                    float maxSpeedChange = effectiveAcceleration * deltaTime;\n                    \n\n                    \n                    if (velocityDiff.sqrMagnitude <= maxSpeedChange * maxSpeedChange)\n                    {\n                        newHorizontalVelocity = targetHorizontalVelocity;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity + velocityDiff.normalized * maxSpeedChange;\n                    }\n                }\n                else\n                {\n                    float currentSpeed = currentHorizontalVelocity.magnitude;\n                    float speedReduction = HorizontalDeceleration * deltaTime;\n                    \n\n                    \n                    if (currentSpeed <= speedReduction)\n                    {\n                        newHorizontalVelocity = Vector3.zero;\n                    }\n                    else\n                    {\n                        newHorizontalVelocity = currentHorizontalVelocity * ((currentSpeed - speedReduction) / currentSpeed);\n                    }\n                }\n                \n                _newVelocity.x = newHorizontalVelocity.x;\n                _newVelocity.z = newHorizontalVelocity.z;\n                \n\n                \n                if (VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    Vector3 floorVelocity = _frameVelocity;\n                    floorVelocity.y = 0;\n                    _newVelocity.x += floorVelocity.x;\n                    _newVelocity.z += floorVelocity.z;\n                }\n                \n                if (_grounded)\n                {\n                    Vector3 horizontalVelocity = new Vector3(_newVelocity.x, 0, _newVelocity.z);\n                    float velocityMagnitude = horizontalVelocity.magnitude;\n                    \n                    if (velocityMagnitude > SMALL_VALUE)\n                    {\n                        Vector3 velocityDirection = horizontalVelocity.normalized;\n                        Vector3 projectedDirection = Vector3.ProjectOnPlane(velocityDirection, _groundNormal);\n                        \n                        if (projectedDirection.sqrMagnitude > SMALL_VALUE)\n                        {\n                            projectedDirection.Normalize();\n                            _newVelocity.x = projectedDirection.x * velocityMagnitude;\n                            _newVelocity.z = projectedDirection.z * velocityMagnitude;\n                        }\n                    }\n                    \n                    _newVelocity.y = Mathf.Min(_newVelocity.y, 0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// 固定更新中的重力应用（物理帧）\n        /// </summary>\n        /// <param name=\"deltaTime\">固定时间增量</param>\n        protected virtual void ApplyGravityFixed(float deltaTime)\n        {\n            // 固定更新中的重力处理，主要用于物理一致性\n            // 这里可以添加需要在固定时间步长中处理的重力相关逻辑\n        }\n\n        /// <summary>\n        /// 逻辑更新中的重力应用（逻辑帧）\n        /// </summary>\n        /// <param name=\"deltaTime\">逻辑时间增量</param>\n        protected virtual void AddGravityLogic(float deltaTime)\n        {\n            if (GravityActive)\n            {\n                if (_grounded)\n                {\n                    _newVelocity.y = -Gravity * deltaTime;\n\n                }\n                else\n                {\n                    float oldY = _newVelocity.y;\n                    _newVelocity.y = _velocity.y - Gravity * deltaTime;\n                    _newVelocity.y = Mathf.Max(_newVelocity.y, -MaximumFallSpeed);\n\n                }\n            }\n\n            _newVelocity += _addedForce;\n            _addedForce = Vector3.zero;\n        }\n\n        /// <summary>\n        /// 应用重力到速度（保持向后兼容）\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void AddGravity(float deltaTime)\n        {\n            AddGravityLogic(deltaTime);\n        }\n\n        /// <summary>\n        /// 跟随移动平台移动\n        /// </summary>\n        protected virtual void MoveWithPlatform()\n        {\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _moveWithPlatformMoveDistance = Vector3.zero;\n                _moveWithPlatformGlobalPoint =\n                    _movingPlatformCurrentHitCollider.TransformPoint(_movingPlatformCurrentHitColliderLocal);\n                _moveWithPlatformMoveDistance = _moveWithPlatformGlobalPoint - _movingPlatformCurrentGlobalPoint;\n\n                if (_moveWithPlatformMoveDistance != Vector3.zero)\n                {\n                    _characterController.Move(_moveWithPlatformMoveDistance);\n                }\n\n                _moveWithPlatformGlobalRotation =\n                    _movingPlatformCurrentHitCollider.rotation * _movingPlatformLocalRotation;\n                _moveWithPlatformRotationDiff = _moveWithPlatformGlobalRotation *\n                                                Quaternion.Inverse(_lastMoveWithPlatformGlobalRotation);\n                _lastMoveWithPlatformGlobalRotation = _moveWithPlatformGlobalRotation;\n            }\n        }\n\n        /// <summary>\n        /// 计算速度增量和粘性偏移\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeVelocityDelta(float deltaTime)\n        {\n            _motion = _newVelocity * deltaTime;\n            _horizontalVelocityDelta.x = _motion.x;\n            _horizontalVelocityDelta.y = 0f;\n            _horizontalVelocityDelta.z = _motion.z;\n            _stickyOffset = Mathf.Max(_characterController.stepOffset, _horizontalVelocityDelta.magnitude);\n\n            if (_grounded)\n            {\n                _motion -= _stickyOffset * Vector3.up;\n            }\n        }\n\n        /// <summary>\n        /// 执行 CharacterController 移动\n        /// 直接使用 _motion 向量进行移动\n        /// </summary>\n        protected virtual void MoveCharacterController()\n        {\n            _groundNormal = Vector3.zero;\n\n            // 直接使用在 ComputeVelocityDelta 中计算的 _motion\n            _collisionFlags = _characterController.Move(_motion);\n            _lastHitPoint = _hitPoint;\n            _lastGroundNormal = _groundNormal;\n        }\n\n\n        /// <summary>\n        /// 检测是否踩上新的移动平台\n        /// </summary>\n        protected virtual void DetectNewMovingPlatform()\n        {\n            if (_movingPlatformCurrentHitCollider != _movingPlatformHitCollider)\n            {\n                if (_movingPlatformHitCollider != null)\n                {\n                    _movingPlatformCurrentHitCollider = _movingPlatformHitCollider;\n                    _lastMovingPlatformMatrix = _movingPlatformHitCollider.localToWorldMatrix;\n                    _newMovingPlatform = true;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 计算新速度和加速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeNewVelocity(float deltaTime)\n        {\n            _velocity = _newVelocity;\n            _acceleration = (_velocity - _velocityLastFrame) / deltaTime;\n        }\n\n        /// <summary>\n        /// 处理地面接触状态和平台速度传递\n        /// </summary>\n        protected virtual void HandleGroundContact()\n        {\n            _grounded = _characterController.isGrounded;\n\n            if (_grounded && !IsGroundedTest())\n            {\n                _grounded = false;\n                if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                    VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n                {\n                    _frameVelocity = _movingPlatformVelocity;\n                    _velocity += _movingPlatformVelocity;\n                }\n            }\n            else if (!_grounded && IsGroundedTest())\n            {\n                if (_detached && _velocity.y <= 0)\n                {\n                    _grounded = true;\n                    _detached = false;\n                }\n\n                SubtractNewPlatformVelocity();\n            }\n\n            if (ShouldMoveWithPlatformThisFrame())\n            {\n                _movingPlatformCurrentGlobalPoint = _transform.position;\n                _movingPlatformCurrentHitColliderLocal =\n                    _movingPlatformCurrentHitCollider.InverseTransformPoint(_movingPlatformCurrentGlobalPoint);\n                _movingPlatformGlobalRotation = _transform.rotation;\n                _movingPlatformLocalRotation = Quaternion.Inverse(_movingPlatformCurrentHitCollider.rotation) *\n                                               _movingPlatformGlobalRotation;\n            }\n\n            ExitedTooSteepSlopeThisFrame = _tooSteepLastFrame && !TooSteep();\n            _tooSteepLastFrame = TooSteep();\n        }\n\n        /// <summary>\n        /// 计算当前速度\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ComputeSpeed(float deltaTime)\n        {\n            if (deltaTime > SMALL_VALUE)\n            {\n                _speed = (_transform.position - _positionLastFrame) / deltaTime;\n            }\n\n            // 暂时禁用速度舍入，避免高速时的舍入误差导致抖动\n            // _speed.x = Mathf.Round(_speed.x * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            // _speed.y = Mathf.Round(_speed.y * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            // _speed.z = Mathf.Round(_speed.z * SPEED_ROUNDING_PRECISION) / SPEED_ROUNDING_PRECISION;\n            \n            _positionLastFrame = _transform.position;\n        }\n\n        /// <summary>\n        /// 根据当前移动向量确定方向\n        /// </summary>\n        protected virtual void DetermineDirection()\n        {\n            if (_currentMovement.sqrMagnitude > SMALL_VALUE)\n            {\n                _currentDirection = _currentMovement.normalized;\n            }\n        }\n\n        /// <summary>\n        /// 处理摩擦力（预留方法，可在子类中实现）\n        /// </summary>\n        protected virtual void HandleFriction()\n        {\n        }\n\n        /// <summary>\n        /// 检查是否刚刚着地\n        /// </summary>\n        protected virtual void CheckIfGrounded()\n        {\n            _justGotGrounded = !_groundedLastFrame && _grounded;\n            _groundedLastFrame = _grounded;\n        }\n\n        /// <summary>\n        /// 手动触发碰撞器碰撞处理\n        /// </summary>\n        protected virtual void ManualControllerColliderHit()\n        {\n            HandleAdvancedGroundDetection();\n        }\n\n        /// <summary>\n        /// 高级地面检测（使用多方向射线）\n        /// </summary>\n        protected virtual void HandleAdvancedGroundDetection()\n        {\n            if (GroundDetectionMode != GroundedComputationMode.Advanced)\n            {\n                return;\n            }\n\n            _smallestDistance = Single.MaxValue;\n            _longestDistance = Single.MinValue;\n            _smallestRaycast = _emptyRaycast;\n\n            float offset = _characterController.radius;\n\n            _downRaycastsOffset = Vector3.zero;\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(-offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, -offset);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(offset, offset, 0f);\n            CastRayDownwards();\n            _downRaycastsOffset = new Vector3(0f, offset, offset);\n            CastRayDownwards();\n\n            if (_smallestRaycast.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_smallestRaycast.distance);\n\n                if (_smallestRaycast.normal.y > 0 && _smallestRaycast.normal.y > _groundNormal.y)\n                {\n                    if ((Mathf.Abs(_smallestRaycast.point.y - _lastHitPoint.y) < GroundNormalHeightThreshold) &&\n                        ((_smallestRaycast.point != _lastHitPoint) || (_lastGroundNormal == Vector3.zero)))\n                    {\n                        _groundNormal = _smallestRaycast.normal;\n                    }\n                    else\n                    {\n                        _groundNormal = _lastGroundNormal;\n                    }\n\n                    _movingPlatformHitCollider = _smallestRaycast.collider.transform;\n                    _hitPoint = _smallestRaycast.point;\n                    _frameVelocity = Vector3.zero;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 向下发射射线检测地面\n        /// </summary>\n        protected virtual void CastRayDownwards()\n        {\n            if (_smallestDistance <= MinimumGroundedDistance)\n            {\n                return;\n            }\n\n            Physics.Raycast(_transform.position + _characterController.center + _downRaycastsOffset,\n                _raycastDownDirection, out _raycastDownHit,\n                _characterController.height / 2f + GroundedRaycastLength, ObstaclesLayerMask);\n\n            if (_raycastDownHit.collider != null)\n            {\n                float adjustedDistance = AdjustDistance(_raycastDownHit.distance);\n\n                if (adjustedDistance < _smallestDistance)\n                {\n                    _smallestDistance = adjustedDistance;\n                    _smallestRaycast = _raycastDownHit;\n                }\n\n                if (adjustedDistance > _longestDistance)\n                {\n                    _longestDistance = adjustedDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 调整射线距离（考虑碰撞器高度和皮肤宽度）\n        /// </summary>\n        protected float AdjustDistance(float distance)\n        {\n            return distance - _characterController.height / 2f - _characterController.skinWidth;\n        }\n\n        /// <summary>\n        /// 测试是否真正着地\n        /// </summary>\n        protected virtual bool IsGroundedTest()\n        {\n            bool grounded = false;\n            if (GroundDetectionMode == GroundedComputationMode.Advanced)\n            {\n                if (_smallestDistance <= MinimumGroundedDistance)\n                {\n                    grounded = _groundNormal.y > 0.01f;\n                }\n            }\n            else\n            {\n                grounded = _characterController.isGrounded;\n                _groundNormal = Vector3.up;\n            }\n\n            return grounded;\n        }\n\n        /// <summary>\n        /// 获取移动平台速度\n        /// </summary>\n        protected virtual void GetMovingPlatformVelocity()\n        {\n            if (_movingPlatformCurrentHitCollider != null)\n            {\n                if (!_newMovingPlatform && Time.fixedDeltaTime > SMALL_VALUE)\n                {\n                    _movingPlatformVelocity = (\n                        _movingPlatformCurrentHitCollider.localToWorldMatrix.MultiplyPoint3x4(\n                            _movingPlatformCurrentHitColliderLocal)\n                        - _lastMovingPlatformMatrix.MultiplyPoint3x4(_movingPlatformCurrentHitColliderLocal)\n                    ) / Time.fixedDeltaTime;\n                }\n\n                _lastMovingPlatformMatrix = _movingPlatformCurrentHitCollider.localToWorldMatrix;\n                _newMovingPlatform = false;\n            }\n            else\n            {\n                _movingPlatformVelocity = Vector3.zero;\n            }\n        }\n\n        /// <summary>\n        /// 减去新平台速度（处理平台切换）\n        /// </summary>\n        protected virtual void SubtractNewPlatformVelocity()\n        {\n            if (VelocityTransferMethod == VelocityTransferMode.InitialVelocity ||\n                VelocityTransferMethod == VelocityTransferMode.FloorVelocity)\n            {\n                if (_newMovingPlatform)\n                {\n                    StartCoroutine(SubtractNewPlatformVelocityCoroutine());\n                }\n                else\n                {\n                    _velocity -= _movingPlatformVelocity;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 协程：延迟减去平台速度\n        /// </summary>\n        protected virtual IEnumerator SubtractNewPlatformVelocityCoroutine()\n        {\n            Transform platform = _movingPlatformCurrentHitCollider;\n            yield return _waitForFixedUpdate;\n            if (_grounded && platform == _movingPlatformCurrentHitCollider)\n            {\n                yield return null;\n            }\n\n            _velocity -= _movingPlatformVelocity;\n        }\n\n        /// <summary>\n        /// 判断是否应该跟随平台移动\n        /// </summary>\n        protected virtual bool ShouldMoveWithPlatformThisFrame()\n        {\n            return (_grounded || VelocityTransferMethod == VelocityTransferMode.Relative)\n                   && _movingPlatformCurrentHitCollider != null;\n        }\n\n        /// <summary>\n        /// 应用冲击力并逐渐衰减\n        /// </summary>\n        /// <param name=\"deltaTime\">时间增量</param>\n        protected virtual void ApplyImpact(float deltaTime)\n        {\n            if (_impact.sqrMagnitude > IMPACT_THRESHOLD * IMPACT_THRESHOLD)\n            {\n                _characterController.Move(_impact * deltaTime);\n            }\n\n            _impact = Vector3.Lerp(_impact, Vector3.zero, ImpactFalloff * deltaTime);\n        }\n\n        /// <summary>\n        /// 从地面分离（用于跳跃等）\n        /// </summary>\n        public virtual void DetachFromGround()\n        {\n            _detached = true;\n        }\n\n        /// <summary>\n        /// 从移动平台分离\n        /// </summary>\n        public virtual void DetachFromMovingPlatform()\n        {\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n        }\n\n        /// <summary>\n        /// 设置重力是否激活\n        /// </summary>\n        public virtual void SetGravityActive(bool status)\n        {\n            GravityActive = status;\n        }\n\n        /// <summary>\n        /// 添加外部力（会在下一帧应用）\n        /// </summary>\n        public virtual void AddForce(Vector3 movement)\n        {\n            _addedForce += movement;\n        }\n\n        /// <summary>\n        /// 施加瞬时冲击力\n        /// </summary>\n        /// <param name=\"direction\">冲击方向</param>\n        /// <param name=\"force\">冲击力大小</param>\n        public virtual void Impact(Vector3 direction, float force)\n        {\n            direction = direction.normalized;\n            if (direction.y < 0)\n            {\n                direction.y = -direction.y;\n            }\n\n            _impact += direction.normalized * force;\n        }\n\n        /// <summary>\n        /// 设置移动向量（通常由输入系统调用）\n        /// </summary>\n        /// <param name=\"movement\">移动向量</param>\n        public virtual void SetMovement(Vector3 movement)\n        {\n            _currentMovement = movement;\n\n            Vector3 directionVector = movement;\n            if (directionVector != Vector3.zero)\n            {\n                float directionLength = directionVector.magnitude;\n                directionVector = directionVector / directionLength;\n                directionLength = Mathf.Min(1, directionLength);\n                // 移除平方操作，保持线性响应，避免高速时的非线性抖动\n                directionVector = directionVector * directionLength;\n            }\n\n            _inputMoveDirection = transform.rotation * directionVector;\n        }\n\n        /// <summary>\n        /// 移动到指定位置（带碰撞检测）\n        /// </summary>\n        /// <param name=\"newPosition\">目标位置</param>\n        /// <param name=\"targetTransform\">是否作用于 Transform</param>\n        public virtual void MovePosition(Vector3 newPosition, bool targetTransform = false)\n        {\n            _movePositionDirection = newPosition - transform.position;\n            _movePositionDistance = Vector3.Distance(transform.position, newPosition);\n\n            _capsulePoint1 = transform.position\n                             + _characterController.center\n                             - (Vector3.up * _characterController.height / 2f)\n                             + Vector3.up * _characterController.skinWidth\n                             + Vector3.up * _characterController.radius;\n\n            _capsulePoint2 = transform.position\n                             + _characterController.center\n                             + (Vector3.up * _characterController.height / 2f)\n                             - Vector3.up * _characterController.skinWidth\n                             - Vector3.up * _characterController.radius;\n\n            if (!Physics.CapsuleCast(_capsulePoint1, _capsulePoint2, _characterController.radius,\n                    _movePositionDirection, out _movePositionHit, _movePositionDistance, ObstaclesLayerMask))\n            {\n                transform.position = newPosition;\n            }\n        }\n\n        /// <summary>\n        /// 调整碰撞器高度（用于蹲伏等）\n        /// </summary>\n        /// <param name=\"newHeight\">新高度</param>\n        /// <param name=\"translateCenter\">是否平移中心点</param>\n        public virtual void ResizeColliderHeight(float newHeight, bool translateCenter = false)\n        {\n            float newYOffset = _originalColliderCenter.y - (_originalColliderHeight - newHeight) / 2;\n            _characterController.height = newHeight;\n            _characterController.center = ((_originalColliderHeight - newHeight) / 2) * Vector3.up;\n\n            if (translateCenter)\n            {\n                transform.Translate((newYOffset / 2f) * Vector3.up);\n            }\n        }\n\n        /// <summary>\n        /// 重置碰撞器尺寸到原始大小\n        /// </summary>\n        public virtual void ResetColliderSize()\n        {\n            _characterController.height = _originalColliderHeight;\n            _characterController.center = _originalColliderCenter;\n        }\n\n        /// <summary>\n        /// 检查是否可以恢复到原始碰撞器尺寸（头部无障碍物）\n        /// </summary>\n        public virtual bool CanGoBackToOriginalSize()\n        {\n            if (_characterController.bounds.size.y >= _originalColliderHeight - SMALL_VALUE)\n            {\n                return true;\n            }\n\n            float headCheckDistance =\n                _originalColliderHeight * transform.localScale.y * CrouchedRaycastLengthMultiplier;\n            _originalSizeRaycastOrigin = ColliderTop + transform.up * SMALL_VALUE;\n\n            _canGoBackHeadCheck = Raycast3D(_originalSizeRaycastOrigin, transform.up, headCheckDistance,\n                ObstaclesLayerMask, Color.cyan, true);\n\n            return _canGoBackHeadCheck.collider == null;\n        }\n\n        /// <summary>\n        /// 启用碰撞\n        /// </summary>\n        public virtual void CollisionsOn()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = true;\n            }\n        }\n\n        /// <summary>\n        /// 禁用碰撞\n        /// </summary>\n        public virtual void CollisionsOff()\n        {\n            if (_characterController != null)\n            {\n                _characterController.enabled = false;\n            }\n        }\n\n        /// <summary>\n        /// 设置 Rigidbody 的运动学状态（需要有 Rigidbody 组件）\n        /// </summary>\n        public virtual void SetKinematic(bool state)\n        {\n            _rigidBody.isKinematic = state;\n        }\n\n        /// <summary>\n        /// 设置是否允许自由移动\n        /// </summary>\n        public virtual void SetFreeMovement(bool state)\n        {\n            _freeMovement = state;\n        }\n\n        /// <summary>\n        /// 检测四个基本方向的障碍物\n        /// </summary>\n        /// <param name=\"distance\">检测距离</param>\n        /// <param name=\"offset\">起始偏移</param>\n        public virtual void DetectObstacles(float distance, Vector3 offset)\n        {\n            if (!PerformCardinalObstacleRaycastDetection)\n            {\n                return;\n            }\n\n            CollidingWithCardinalObstacle = false;\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.right, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleRight = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleRight = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.left, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleLeft = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleLeft = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.forward, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleUp = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleUp = null;\n            }\n\n            _cardinalRaycast = Raycast3D(transform.position + offset, Vector3.back, distance,\n                ObstaclesLayerMask, Color.yellow, true);\n            if (_cardinalRaycast.collider != null)\n            {\n                DetectedObstacleDown = _cardinalRaycast.collider.gameObject;\n                CollidingWithCardinalObstacle = true;\n            }\n            else\n            {\n                DetectedObstacleDown = null;\n            }\n        }\n\n        /// <summary>\n        /// 重置控制器到初始状态\n        /// </summary>\n        public virtual void ResetController()\n        {\n            _impact = Vector3.zero;\n            GravityActive = true;\n            _speed = Vector3.zero;\n            _velocity = Vector3.zero;\n            _velocityLastFrame = Vector3.zero;\n            _acceleration = Vector3.zero;\n            _grounded = true;\n            _justGotGrounded = false;\n            _currentMovement = Vector3.zero;\n            _currentDirection = Vector3.zero;\n            _addedForce = Vector3.zero;\n            _idealDirection = Vector3.zero;\n            _idealVelocity = Vector3.zero;\n            _newVelocity = Vector3.zero;\n            _movingPlatformVelocity = Vector3.zero;\n            _movingPlatformCurrentHitCollider = null;\n            _movingPlatformHitCollider = null;\n            _lastGroundNormal = Vector3.zero;\n            _detached = false;\n            _frameVelocity = Vector3.zero;\n            _hitPoint = Vector3.zero;\n            _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);\n            \n            // 重置平滑移动相关变量\n            _pendingMotion = Vector3.zero;\n            _smoothedMotion = Vector3.zero;\n\n            if (_rigidBody != null)\n            {\n                bool isKinematic = _rigidBody.isKinematic;\n                _rigidBody.isKinematic = false;\n                _rigidBody.linearVelocity = Vector3.zero;\n                _rigidBody.angularVelocity = Vector3.zero;\n                _rigidBody.isKinematic = isKinematic;\n            }\n        }\n\n        /// <summary>\n        /// 3D 射线检测辅助方法（带可视化调试）\n        /// </summary>\n        private static RaycastHit Raycast3D(Vector3 origin, Vector3 direction, float distance, LayerMask layerMask,\n            Color color, bool drawInSceneView = false, bool drawInGameView = true)\n        {\n            RaycastHit hit;\n            Physics.Raycast(origin, direction, out hit, distance, layerMask);\n\n            if (Camera.current != null && (drawInSceneView || drawInGameView))\n            {\n                Debug.DrawRay(origin, direction * distance, color);\n            }\n\n            return hit;\n        }\n    }\n}","structuredPatch":[{"oldStart":1184,"oldLines":10,"newStart":1184,"newLines":6,"lines":["             _frameVelocity = Vector3.zero;","             _hitPoint = Vector3.zero;","             _lastHitPoint = new Vector3(Mathf.Infinity, 0, 0);","-            ","-            // 重置平滑移动相关变量","-            _pendingMotion = Vector3.zero;","-            _smoothedMotion = Vector3.zero;"," ","             if (_rigidBody != null)","             {"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"20610855-b92f-491c-80be-334b7ddac6e1","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0177a6UwBxpe3KeU4LvCygJp","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"很好，现在我还需要删除不再使用的参数字段，比如 EnableMovementSmoothing、HorizontalSmoothTime、VerticalSmoothTime，因为我们已经移除了移动平滑功能。让我查找这些字段。","signature":"EoADCkYIChgCKkASrkubYc0r3taShJE00TCqe0f+2hsMfJEsWXaJMTP7jpLrqs1FK/bM/nOQXi9/p41dywewQvqxqaye0X++cxRhEgw5cRwMS29TGc32q1AaDP2HprWmuokPQPKrCyIwDvpwH/gdE3W3jinlq2O8KooJfqGotb49KygbFO++PMGEmq2/XeR28CeuDLsYVqpZKucBILwMsPqd1k9Tar6rnBc8PycUkqv1rzi4SEN9FUVzzHTDxdMEh4CL0bkPNZ5CmEu4QKxZSF0/55ERTcy7hASa+uG0YlfqdLr7oMwN584cft3z08TMfZJvrcv0Rpf5EzZlRDvtw0LTrh6xrij2IGitnTtiyx35+Imu+SfRsgCECKB86AChenlFSWnAEiSgSBEauOLvGu5Yxw5SOJD9S71XWqf++cXQMQyROLr0tVzEfKbeCako8oxkFrq1+tHbIFFIp8wOiLd9XzcD+5YeHzxkxJX0nlWx2olL9cruNfdEhOElphxDV6qVGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1819,"cache_read_input_tokens":81468,"cache_creation":{"ephemeral_5m_input_tokens":1819,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"8abfd045-52b9-45c3-9b67-d96965a32999","timestamp":"2025-12-15T11:49:10.332Z"}
{"parentUuid":"8abfd045-52b9-45c3-9b67-d96965a32999","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0177a6UwBxpe3KeU4LvCygJp","type":"message","role":"assistant","content":[{"type":"text","text":"现在我需要删除不再使用的移动平滑相关的参数字段。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1819,"cache_read_input_tokens":81468,"cache_creation":{"ephemeral_5m_input_tokens":1819,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"835b5030-5c5a-489d-8e9a-68ffdc75a1cf","timestamp":"2025-12-15T11:49:10.852Z"}
{"parentUuid":"835b5030-5c5a-489d-8e9a-68ffdc75a1cf","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_0177a6UwBxpe3KeU4LvCygJp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0124iuEyBuyWUYq4tu8vmJEd","name":"Read","input":{"file_path":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","limit":15,"offset":95}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1819,"cache_read_input_tokens":81468,"cache_creation":{"ephemeral_5m_input_tokens":1819,"ephemeral_1h_input_tokens":0},"output_tokens":228,"service_tier":"standard"}},"type":"assistant","uuid":"7554c287-a050-4d2f-a793-3d37a7bab332","timestamp":"2025-12-15T11:49:12.351Z"}
{"parentUuid":"7554c287-a050-4d2f-a793-3d37a7bab332","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0124iuEyBuyWUYq4tu8vmJEd","type":"tool_result","content":"    95→        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n    96→\n    97→        [Header(\"Movement Smoothing\")]\n    98→        [Tooltip(\"是否启用移动平滑\")]\n    99→        public bool EnableMovementSmoothing = true;\n   100→        \n   101→        [Tooltip(\"水平移动平滑时间（秒）\")]\n   102→        [Range(0.01f, 0.1f)]\n   103→        public float HorizontalSmoothTime = 0.03f;\n   104→        \n   105→        [Tooltip(\"垂直移动平滑时间（秒）\")]\n   106→        [Range(0.01f, 0.1f)]\n   107→        public float VerticalSmoothTime = 0.05f;\n   108→\n   109→        [Header(\"Runtime State - Read Only\")]\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"33263ce6-600e-497f-9a29-e2f57273cc8a","timestamp":"2025-12-15T11:49:13.259Z","toolUseResult":{"type":"text","file":{"filePath":"E:\\Project\\Demo\\MonsterHunter\\Assets\\_Game\\Scripts\\ActionMachine\\Runtime\\Controller\\Kcc\\Kcc.cs","content":"        public VelocityTransferMode VelocityTransferMethod = VelocityTransferMode.FloorVelocity;\n\n        [Header(\"Movement Smoothing\")]\n        [Tooltip(\"是否启用移动平滑\")]\n        public bool EnableMovementSmoothing = true;\n        \n        [Tooltip(\"水平移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float HorizontalSmoothTime = 0.03f;\n        \n        [Tooltip(\"垂直移动平滑时间（秒）\")]\n        [Range(0.01f, 0.1f)]\n        public float VerticalSmoothTime = 0.05f;\n\n        [Header(\"Runtime State - Read Only\")]","numLines":15,"startLine":95,"totalLines":1215}}}
{"parentUuid":"33263ce6-600e-497f-9a29-e2f57273cc8a","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Qf9hjPJ8DzpVy8tMa9pHP2","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"这些平滑相关的参数已经不再使用了，但我觉得先不删除它们，以防有人在外部引用这些参数。让我们保留这些参数但不使用它们。这样可以保持向后兼容性。\n\n现在让我创建一个总结，说明我做了哪些修改，并告诉用户测试一下是否解决了抖动问题。","signature":"EvMDCkYIChgCKkD5iFTDZqgKkZLc4GpstlyR0DajkK7uBB0q01hw/sOrBKWGceXSm1AwRd5UDi+Qwmzy8oPQPqccUI1hL7p8ughuEgx+TwpTXZ63CM6XeiEaDKVUmYkI2nSPFGrGWSIw5GrKUu9CYzz3JnEanZaX51v3fWvOtFg1gl1YNRYzo+a6OqEoukTbMvKJEidScqJpKtoCEbHCe7SNcoNyuEaOp129XMVg3RbmIMhat79iIkNQezoa9AwBx5V6wwbmFU5nt5jQKCg3hsUAeoTJPkmhDbTRBKlUFQUB8YuXYtxbq5USTpvAE599P1Rvx78aSXpfDQVSnmzPNGQ7kWA3wgivLPGyU9KiwfqFtVXO3S4FDG/mwoWY/XNZZ8Ik0D+IsrQJSvEMM1E77HSnqjnPd7IYXA6zegWxbbv8sJ1gh54WkmN3Whyb/GVbMgvMjvWvvw+f1Re5EHlhTiVyPryRzRBae6qI6QEp0dXAVHCF1kQcli2VINOENGdnWG7+51EQaW/aSU3BYtKw3QCRPRbnY3uGJq34o+znxTPMO29xPZ3Xb64X6sScx7gGqBkxXNZs9fUfg7HG0Hz9xRM1CCxH7Dls4TD8nRyyAVw5hEP20bFxDI8uPXL5vK5+G5Bnw5Emcn0o0ftOvwb08by6absdTxgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":569,"cache_read_input_tokens":83287,"cache_creation":{"ephemeral_5m_input_tokens":569,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"e2b642fc-186e-4631-90f1-aa89f7a5fb96","timestamp":"2025-12-15T11:49:20.137Z"}
{"parentUuid":"e2b642fc-186e-4631-90f1-aa89f7a5fb96","isSidechain":false,"userType":"external","cwd":"E:\\Project\\Demo\\MonsterHunter","sessionId":"a5a109b9-cebd-4551-be19-7dc387ec0a20","version":"2.0.69","gitBranch":"master","slug":"sleepy-humming-tiger","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Qf9hjPJ8DzpVy8tMa9pHP2","type":"message","role":"assistant","content":[{"type":"text","text":"完成了修改。我将 Kcc.cs 的架构从**分离的逻辑帧和渲染帧**改为了**统一的 Update 帧**，这样可以消除 LogicUpdate 和 RenderUpdate 执行时机不同步导致的抖动。\n\n## 主要修改内容\n\n### 1. **统一 Update 执行流程** (Kcc.cs:285-332)\n- 所有逻辑计算和移动执行现在都在 `Update()` 中完成\n- 按顺序执行：地面检测 → 摩擦力 → 移动方向 → 输入处理 → 重力 → 移动平台 → 速度计算 → 实际移动\n\n### 2. **移除复杂的渲染帧计算**\n- 删除了 `ProcessRenderUpdate()` - 不再需要基于渲染帧重新计算移动\n- 删除了 `ProcessLogicUpdate()` - 逻辑已整合到 Update 中\n- 删除了 `CalculateRenderFrameMotion()` - 不再需要二次计算\n- 删除了 `ExecutePendingMove()` - 替换为更简单的 `ExecuteMove()`\n- 删除了 `CalculateSmoothedMotion()` - 移除了过度复杂的平滑逻辑\n\n### 3. **简化移动执行** (Kcc.cs:378-396, 591-603)\n- `ExecuteMove()` - 直接执行移动和碰撞检测\n- `MoveCharacterController()` - 直接使用 `_motion` 向量，不再使用 `_pendingMotion`\n\n### 4. **保留向后兼容性** (Kcc.cs:334-343)\n- `LogicUpdate()` 标记为 `[Obsolete]`，但保留接口避免编译错误\n- 外部调用不会报错，但内部不再处理任何逻辑\n\n### 5. **清理不再使用的字段**\n- 删除了 `_pendingMotion`、`_lastLogicDeltaTime`、`_smoothedMotion`、`_motionVelocity`\n- 保留了 `EnableMovementSmoothing` 等公共参数（向后兼容）\n\n## 优势\n\n1. **消除时间差抖动**：逻辑计算和实际移动在同一帧完成\n2. **简化代码**：移除了复杂的帧间插值和平滑逻辑\n3. **更好的同步性**：速度计算和移动执行紧密关联\n4. **保持兼容性**：外部代码仍可调用 `LogicUpdate`（虽然不会执行）\n\n## 测试建议\n\n在 Unity 中测试高速移动场景，观察是否还有抖动。如果仍有抖动，可能需要调整：\n- `HorizontalAcceleration` / `HorizontalDeceleration` 参数\n- 关闭 `EnableMovementSmoothing`（虽然现在不使用，但字段保留了）"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":569,"cache_read_input_tokens":83287,"cache_creation":{"ephemeral_5m_input_tokens":569,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"e686fdd7-e082-4012-9442-41048e0096a3","timestamp":"2025-12-15T11:49:36.334Z"}
