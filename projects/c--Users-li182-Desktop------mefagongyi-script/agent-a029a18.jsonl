{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","type":"user","message":{"role":"user","content":"请读取 战斗系统文档 文件夹下的所有文档，特别关注：\n1. 技能系统的详细实现\n2. 单位系统的详细实现\n3. 伤害计算系统的实现\n4. 核心架构设计\n\n重点了解子弹和魔法相关的：\n- 移动机制\n- 生命周期管理\n- 伤害处理\n- Mono层交互方式\n- DOTS系统架构\n\n请提供详细的总结。"},"uuid":"56317943-86ef-46ac-b3c0-b336719657e0","timestamp":"2025-12-18T11:34:19.635Z"}
{"parentUuid":"56317943-86ef-46ac-b3c0-b336719657e0","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01M8L7oVJkSG9mQzCoKqr9Q1","type":"message","role":"assistant","content":[{"type":"text","text":"我来帮您读取\"战斗系统文档\"文件夹下的所有文档。首先，让我找到这个文件夹。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":34504,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":34504,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"15c7ea3a-c27a-4db8-a41d-f742d85eff9e","timestamp":"2025-12-18T11:34:31.875Z"}
{"parentUuid":"15c7ea3a-c27a-4db8-a41d-f742d85eff9e","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01M8L7oVJkSG9mQzCoKqr9Q1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01196eFEqqgrj8sRQUbMHUVB","name":"Glob","input":{"pattern":"**/战斗系统文档/**"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":34504,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":34504,"ephemeral_1h_input_tokens":0},"output_tokens":104,"service_tier":"standard"}},"type":"assistant","uuid":"a774425f-038a-44e7-9d8e-1c29def5d8d7","timestamp":"2025-12-18T11:34:31.988Z"}
{"parentUuid":"a774425f-038a-44e7-9d8e-1c29def5d8d7","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01196eFEqqgrj8sRQUbMHUVB","type":"tool_result","content":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\01-战斗系统核心架构.md\nc:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\02-伤害计算系统详细.md\nc:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\03-技能系统详细文档.md\nc:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\04-单位系统详细文档.md\nc:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\05-AI战斗逻辑详细文档.md"}]},"uuid":"b28bc7cd-e4d3-48d2-9098-b277a8e76ebf","timestamp":"2025-12-18T11:34:35.512Z","toolUseResult":{"filenames":["c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\01-战斗系统核心架构.md","c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\02-伤害计算系统详细.md","c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\03-技能系统详细文档.md","c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\04-单位系统详细文档.md","c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\05-AI战斗逻辑详细文档.md"],"durationMs":1249,"numFiles":5,"truncated":false}}
{"parentUuid":"b28bc7cd-e4d3-48d2-9098-b277a8e76ebf","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019NdmKxJ1SfPV4DYR3EjUtg","type":"message","role":"assistant","content":[{"type":"text","text":"很好！找到了5个文档文件。现在让我读取所有这些文档。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":374,"cache_read_input_tokens":34504,"cache_creation":{"ephemeral_5m_input_tokens":374,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"898ab4b0-5a15-498d-90d0-165d2cb81e3f","timestamp":"2025-12-18T11:34:39.831Z"}
{"parentUuid":"898ab4b0-5a15-498d-90d0-165d2cb81e3f","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019NdmKxJ1SfPV4DYR3EjUtg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NK17eHHKzajoi79nC3amYP","name":"Read","input":{"file_path":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\01-战斗系统核心架构.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":374,"cache_read_input_tokens":34504,"cache_creation":{"ephemeral_5m_input_tokens":374,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"9c2178e7-9b0d-4262-a2e5-c941c8477fd2","timestamp":"2025-12-18T11:34:40.418Z"}
{"parentUuid":"9c2178e7-9b0d-4262-a2e5-c941c8477fd2","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019NdmKxJ1SfPV4DYR3EjUtg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013px8eMDZTAnGQF5VuRWm71","name":"Read","input":{"file_path":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\02-伤害计算系统详细.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":374,"cache_read_input_tokens":34504,"cache_creation":{"ephemeral_5m_input_tokens":374,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"77413bb5-4dea-4f8d-b9a2-e6212fec079e","timestamp":"2025-12-18T11:34:40.494Z"}
{"parentUuid":"77413bb5-4dea-4f8d-b9a2-e6212fec079e","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019NdmKxJ1SfPV4DYR3EjUtg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LmaYq43YDj7aRkkVX7fQfg","name":"Read","input":{"file_path":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\03-技能系统详细文档.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":374,"cache_read_input_tokens":34504,"cache_creation":{"ephemeral_5m_input_tokens":374,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"b23daf60-a164-4ba4-97cf-14c8fe1c7a89","timestamp":"2025-12-18T11:34:40.743Z"}
{"parentUuid":"b23daf60-a164-4ba4-97cf-14c8fe1c7a89","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019NdmKxJ1SfPV4DYR3EjUtg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BGkbzakR4792kXyFFSMWtn","name":"Read","input":{"file_path":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\04-单位系统详细文档.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":374,"cache_read_input_tokens":34504,"cache_creation":{"ephemeral_5m_input_tokens":374,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"83386ff9-0605-4ea4-9f7d-af9df2cce8a7","timestamp":"2025-12-18T11:34:40.929Z"}
{"parentUuid":"83386ff9-0605-4ea4-9f7d-af9df2cce8a7","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019NdmKxJ1SfPV4DYR3EjUtg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UNx9EdxLrySFNATx6hvkYY","name":"Read","input":{"file_path":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\05-AI战斗逻辑详细文档.md"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":374,"cache_read_input_tokens":34504,"cache_creation":{"ephemeral_5m_input_tokens":374,"ephemeral_1h_input_tokens":0},"output_tokens":440,"service_tier":"standard"}},"type":"assistant","uuid":"0e70e96d-7ad2-4971-b5e9-d52b3c41d9fa","timestamp":"2025-12-18T11:34:41.405Z"}
{"parentUuid":"6e636e81-4e26-4981-b6e1-d1256d8e6f15","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (29593 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01NK17eHHKzajoi79nC3amYP"}]},"uuid":"e187157f-ba62-4c00-9e5f-48da869365e5","timestamp":"2025-12-18T11:34:53.305Z","toolUseResult":"Error: File content (29593 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"parentUuid":"e187157f-ba62-4c00-9e5f-48da869365e5","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (29131 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01LmaYq43YDj7aRkkVX7fQfg"}]},"uuid":"fbfdae01-a81a-490f-937d-4d8664ceebec","timestamp":"2025-12-18T11:34:53.305Z","toolUseResult":"Error: File content (29131 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"parentUuid":"fbfdae01-a81a-490f-937d-4d8664ceebec","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013px8eMDZTAnGQF5VuRWm71","type":"tool_result","content":"     1→# 伤害计算系统详细文档\n     2→\n     3→## 目录\n     4→1. [系统概述](#系统概述)\n     5→2. [伤害信息结构 (TakeDamageInfo)](#伤害信息结构-takedamageinfo)\n     6→3. [伤害计算流程](#伤害计算流程)\n     7→4. [伤害预处理系统](#伤害预处理系统)\n     8→5. [受伤前处理系统](#受伤前处理系统)\n     9→6. [受伤后处理系统](#受伤后处理系统)\n    10→7. [死亡判定系统](#死亡判定系统)\n    11→8. [护盾系统](#护盾系统)\n    12→9. [暴击系统](#暴击系统)\n    13→10. [特殊伤害类型](#特殊伤害类型)\n    14→11. [伤害修正系统](#伤害修正系统)\n    15→12. [伤害公式总结](#伤害公式总结)\n    16→\n    17→---\n    18→\n    19→## 系统概述\n    20→\n    21→伤害计算系统是战斗系统的核心,负责处理所有单位受到的伤害。该系统采用**多阶段流水线架构**,每个阶段负责不同的处理逻辑。\n    22→\n    23→### 设计原则\n    24→\n    25→1. **数据驱动**: 所有伤害数据封装在 `TakeDamageInfo_Dots` 结构体中\n    26→2. **流水线处理**: 伤害信息经过多个 System 依次处理\n    27→3. **可中断性**: 任何阶段都可以将伤害标记为免疫 (`immuneDamage`)\n    28→4. **可扩展性**: 遗物/诅咒效果可以在各个阶段插入逻辑\n    29→\n    30→### 系统架构\n    31→\n    32→```\n    33→[技能碰撞]\n    34→    ↓ 创建 TakeDamageInfo_Dots\n    35→[TakeDamageInfoPreProcessSystem]   预处理伤害\n    36→    ↓ 计算暴击、应用遗物/诅咒修正\n    37→[UnitBeforeTakeDamageSystem]       受伤前处理\n    38→    ↓ 无敌帧、闪避、反弹\n    39→[UnitPropertySystem]                属性更新\n    40→    ↓ 扣除护盾和生命值\n    41→[UnitAfterTakeDamageSystem]        受伤后处理\n    42→    ↓ 击退、特效、音效\n    43→[UnitTakeDamageDeadSystem]         死亡判定\n    44→    ↓ 检查死亡、触发死亡事件\n    45→[DamageRecordSystem]               伤害记录\n    46→    ↓ 统计伤害数据\n    47→[UnitTakeDamageClearSystem]        清除伤害信息\n    48→    ↓ 清空本帧的伤害缓冲区\n    49→```\n    50→\n    51→### System 执行顺序\n    52→\n    53→**文件位置**: 各个System文件头部的 `[UpdateInGroup]` 和 `[UpdateBefore/After]` 特性\n    54→\n    55→```csharp\n    56→[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n    57→[UpdateBefore(typeof(UnitBeforeTakeDamageSystem))]\n    58→[UpdateAfter(typeof(UnitEnvironmentSystem))]\n    59→public struct TakeDamageInfoPreProcessSystem : ISystem\n    60→\n    61→[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n    62→[UpdateBefore(typeof(UnitPropertySystem))]\n    63→public struct UnitBeforeTakeDamageSystem : ISystem\n    64→\n    65→[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n    66→[UpdateAfter(typeof(UnitPropertySystem))]\n    67→[UpdateBefore(typeof(UnitTakeDamageDeadSystem))]\n    68→public struct UnitAfterTakeDamageSystem : ISystem\n    69→\n    70→[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n    71→[UpdateAfter(typeof(UnitAfterTakeDamageSystem))]\n    72→[UpdateBefore(typeof(SpellTakeDamageResultSystem))]\n    73→public class UnitTakeDamageDeadSystem : SystemBase\n    74→```\n    75→\n    76→---\n    77→\n    78→## 伤害信息结构 (TakeDamageInfo)\n    79→\n    80→**文件位置**: [TakeDamageInfo.cs](TakeDamageInfo.cs:1)\n    81→\n    82→### 数据结构\n    83→\n    84→伤害系统使用两个版本的数据结构:\n    85→- **TakeDamageInfo**: MonoBehaviour 使用的版本\n    86→- **TakeDamageInfo_Dots**: DOTS/ECS 使用的版本\n    87→\n    88→#### TakeDamageInfo (MonoBehaviour版本)\n    89→\n    90→```csharp\n    91→public class TakeDamageInfo\n    92→{\n    93→    // ========== 攻击者信息 ==========\n    94→    public AttackerType attackerType;        // 攻击者类型\n    95→    public UnitProperty attackerPpt;         // 攻击者单位属性\n    96→\n    97→    // ========== 被击者信息 ==========\n    98→    public UnitProperty beHitPpt;            // 被击者单位属性\n    99→\n   100→    // ========== 伤害数值 ==========\n   101→    public float damage;                     // 伤害值\n   102→    public float criticalChance;             // 暴击率\n   103→    public bool isCriticalDamage;            // 是否暴击\n   104→\n   105→    // ========== 击退信息 ==========\n   106→    public Vector3 knockbackForce;           // 击退力度\n   107→\n   108→    // ========== 控制标志 ==========\n   109→    public bool considerPlayerInInvincibleFrame = true;   // 是否考虑玩家无敌帧\n   110→    public bool considerUmbrella = true;                  // 是否考虑雨伞格挡\n   111→    public bool considerRelicDodge = true;                // 是否考虑遗物闪避\n   112→    public bool considerRelicOrCurseDamageRatioChange = true;  // 是否应用遗物/诅咒伤害修正\n   113→\n   114→    // ========== 特效控制 ==========\n   115→    public bool isPlayHitSE = true;          // 是否播放受击音效\n   116→    public bool isPlayDeadSE = true;         // 是否播放死亡音效\n   117→    public bool isCreateDeadEF = true;       // 是否创建死亡特效\n   118→    public bool isCreatebloodSplat = true;   // 是否创建血迹\n   119→    public bool beHitColor = true;           // 是否显示受击变色\n   120→    public bool beHitShake = true;           // 是否镜头震动\n   121→    public bool isFloatText = true;          // 是否显示浮动伤害数字\n   122→\n   123→    // ========== 特殊标志 ==========\n   124→    public bool immuneDamage;                // 是否免疫此伤害\n   125→    public bool isTargetDead;                // 目标是否死亡\n   126→    public bool isTrapDamage;                // 是否为陷阱伤害\n   127→    public bool canRebound;                  // 是否可以反弹\n   128→    public bool stopAnnouncedDeath;          // 是否阻止宣布死亡\n   129→    public bool isUndifferDamage;            // 是否为真实伤害\n   130→    public bool isPercentageDamage;          // 是否为百分比伤害\n   131→    public bool isTeammateThrough;           // 是否穿透队友\n   132→\n   133→    // ========== 伤害来源 ==========\n   134→    public SpellBase spellBase;              // 技能对象引用\n   135→\n   136→    // ========== 充能数据 ==========\n   137→    public WandPostSlotChargeData wandChargeData;  // 魔杖后置槽位充能数据\n   138→\n   139→    // ========== 伤害比例 ==========\n   140→    public float playerTakeDamageRatio = 1f;       // 玩家受伤比例\n   141→    public float teammateTakeDamageRatio = 1f;     // 队友受伤比例\n   142→\n   143→    // ========== 触发器 ==========\n   144→    public bool postSlotSpellTakeDamageTrigger = true;  // 是否触发后置槽位技能\n   145→}\n   146→```\n   147→\n   148→#### TakeDamageInfo_Dots (DOTS版本)\n   149→\n   150→**文件位置**: [TakeDamageInfo_Dots.cs](TakeDamageInfo_Dots.cs:1)\n   151→\n   152→```csharp\n   153→public struct TakeDamageInfo_Dots : IBufferElementData\n   154→{\n   155→    // ========== Entity引用 ==========\n   156→    public Entity attackerEntity;            // 攻击者Entity\n   157→    public Entity targetEntity;              // 目标Entity\n   158→\n   159→    // ========== 攻击者类型 ==========\n   160→    public AttackerType attackerType;\n   161→\n   162→    // ========== 伤害数值 ==========\n   163→    public float damage;                     // 原始伤害\n   164→    public float realDamage;                 // 实际造成的伤害(扣除护盾后)\n   165→    public float hitMagicShieldDamage;       // 击中魔法盾的伤害\n   166→\n   167→    // ========== 暴击系统 ==========\n   168→    public float extraCriticalChance;        // 额外暴击率\n   169→    public bool isDamageCritical;            // 是否暴击\n   170→\n   171→    // ========== 击退 ==========\n   172→    public float3 knockbackForce;            // 击退力(Unity.Mathematics)\n   173→\n   174→    // ========== 技能信息 ==========\n   175→    public SpellInfo spell;                  // 技能信息(DOTS版本)\n   176→\n   177→    // ========== 标志位(与MonoBehaviour版本类似) ==========\n   178→    public bool immuneDamage;\n   179→    public bool ignorePlayerInvincibleFrame;\n   180→    public bool ignoreRelicDodge;\n   181→    public bool ignoreUmbrella;\n   182→    public bool ignoreRelicOrCurseDamageRatioChange;\n   183→    public bool isTrapDamage;\n   184→    public bool isUndifferDamage;\n   185→    public bool isPercentageDamage;\n   186→    public bool isTeammateThrough;\n   187→    public bool stopAnnouncedDeath;\n   188→    public bool targetAlreadyDeadBeforeDamage;\n   189→\n   190→    // ========== 特效控制 ==========\n   191→    public bool dontCreateDeadEF;\n   192→    public bool dontCreatebloodSplat;\n   193→    public bool dontPlayDeadSE;\n   194→    public bool dontPlayHitSE;\n   195→    public bool dontPlayBeHitColor;\n   196→    public bool dontPlayBeHitShake;\n   197→    public bool dontFloatText;\n   198→\n   199→    // ========== 伤害比例 ==========\n   200→    public float playerTakeDamageRatio;\n   201→    public float teammateTakeDamageRatio;\n   202→\n   203→    // ========== 充能相关 ==========\n   204→    public bool chargeWand;                  // 是否充能魔杖\n   205→    public float chargeValue;                // 充能值\n   206→}\n   207→```\n   208→\n   209→### AttackerType 枚举\n   210→\n   211→**文件位置**: [AttackerType.cs](AttackerType.cs:1)\n   212→\n   213→```csharp\n   214→public enum AttackerType\n   215→{\n   216→    NothingSpecial,      // 普通攻击\n   217→    FromUI,              // 来自UI(点击返回营地按钮)\n   218→    FromRelic,           // 来自遗物效果\n   219→    FromCurse,           // 来自诅咒效果\n   220→    FromEnvironment,     // 来自环境(陷阱、地刺等)\n   221→    FromSpell,           // 来自技能\n   222→    FromSummon           // 来自召唤物\n   223→}\n   224→```\n   225→\n   226→---\n   227→\n   228→## 伤害计算流程\n   229→\n   230→### 完整流程图\n   231→\n   232→```\n   233→┌─────────────────────────────────────────────────┐\n   234→│ 阶段 0: 伤害信息创建                            │\n   235→│ 触发: 技能碰撞、技能持续伤害、环境伤害         │\n   236→├─────────────────────────────────────────────────┤\n   237→│ 创建 TakeDamageInfo_Dots 对象                   │\n   238→│ - attackerEntity = spell.ownerEntity            │\n   239→│ - targetEntity = hitUnit.entity                 │\n   240→│ - damage = spell.damage                         │\n   241→│ - criticalChance = spell.criticalChance         │\n   242→│ - knockbackForce = spell.knockback * direction  │\n   243→│                                                  │\n   244→│ 添加到目标Entity的 DynamicBuffer                │\n   245→│ entityMgr.GetBuffer<TakeDamageInfo_Dots>(target)│\n   246→│           .Add(damageInfo);                      │\n   247→└─────────────────────────────────────────────────┘\n   248→                    ↓\n   249→┌─────────────────────────────────────────────────┐\n   250→│ 阶段 1: 伤害预处理                              │\n   251→│ System: TakeDamageInfoPreProcessSystem          │\n   252→│ 文件: TakeDamageInfoPreProcessSystem.cs:157-336 │\n   253→├─────────────────────────────────────────────────┤\n   254→│ 1.1 检查无敌/禁用状态                           │\n   255→│   if (unitPpt.IsInvincible)                     │\n   256→│       info.immuneDamage = true                  │\n   257→│   if (unitPpt.isSolidObj && !info.isUndifferDamage)│\n   258→│       info.immuneDamage = true                  │\n   259→│                                                  │\n   260→│ 1.2 特殊技能伤害修正                            │\n   261→│   - Boss技能对队友伤害 x2~x3                    │\n   262→│   - 特定技能对玩家伤害 x0.05                    │\n   263→│                                                  │\n   264→│ 1.3 根据目标类型应用修正                        │\n   265→│   switch (unitPpt.unitType):                    │\n   266→│     case Player:                                │\n   267→│       - 检查无敌帧                              │\n   268→│       - 应用闪避遗物                            │\n   269→│       - 应用减伤遗物                            │\n   270→│       - 应用增伤诅咒                            │\n   271→│       - 应用玩家受伤比例                        │\n   272→│     case Teammate:                              │\n   273→│       - 应用队友受伤比例                        │\n   274→│     case Monster/Elite/Boss:                    │\n   275→│       - 应用敌人减伤诅咒                        │\n   276→│                                                  │\n   277→│ 1.4 暴击判定                                    │\n   278→│   if (Random.value <= criticalChance)           │\n   279→│       info.isDamageCritical = true              │\n   280→│       info.damage *= criticalDamageRatio        │\n   281→│                                                  │\n   282→│ 1.5 伤害取整                                    │\n   283→│   info.damage = ceil(info.damage)               │\n   284→└─────────────────────────────────────────────────┘\n   285→                    ↓\n   286→┌─────────────────────────────────────────────────┐\n   287→│ 阶段 2: 受伤前处理 (MonoBehaviour)              │\n   288→│ System: UnitBeforeTakeDamageSystem              │\n   289→│ 文件: UnitBeforeTakeDamageSystem.cs:255-276     │\n   290→├─────────────────────────────────────────────────┤\n   291→│ 调用 MonoBehaviour 的 BeforeTakeDamage() 方法  │\n   292→│   unitPpt.UnitBas.BeforeTakeDamage_Dots(info)   │\n   293→│                                                  │\n   294→│ 此阶段由各个单位的 UnitBase 子类实现           │\n   295→│ 常见逻辑:                                       │\n   296→│ - Boss特殊阶段判定                              │\n   297→│ - Elite特殊技能触发                             │\n   298→│ - 遗物/诅咒特殊效果                             │\n   299→└─────────────────────────────────────────────────┘\n   300→                    ↓\n   301→┌─────────────────────────────────────────────────┐\n   302→│ 阶段 3: 属性更新 (护盾和生命值扣除)            │\n   303→│ System: UnitPropertySystem                      │\n   304→│ 文件: UnitPropertySystem.cs (DOTS Job)          │\n   305→├─────────────────────────────────────────────────┤\n   306→│ 3.1 扣除护盾                                    │\n   307→│   if (shield > 0)                               │\n   308→│       damageToShield = min(damage, shield)      │\n   309→│       shield -= damageToShield                  │\n   310→│       damage -= damageToShield                  │\n   311→│       realDamage = 0                            │\n   312→│                                                  │\n   313→│ 3.2 扣除临时护盾                                │\n   314→│   if (shieldTemp > 0 && damage > 0)             │\n   315→│       damageToTempShield = min(damage, shieldTemp)│\n   316→│       shieldTemp -= damageToTempShield          │\n   317→│       damage -= damageToTempShield              │\n   318→│       realDamage += damageToTempShield          │\n   319→│                                                  │\n   320→│ 3.3 扣除生命值                                  │\n   321→│   if (damage > 0)                               │\n   322→│       currentHP -= damage                       │\n   323→│       realDamage += damage                      │\n   324→│                                                  │\n   325→│ 3.4 应用击退                                    │\n   326→│   if (!IsImmuneKnockback)                       │\n   327→│       AddForce(knockbackForce * knockbackRatio) │\n   328→│                                                  │\n   329→│ 3.5 检查死亡                                    │\n   330→│   if (currentHP <= 0)                           │\n   331→│       isDead = true                             │\n   332→└─────────────────────────────────────────────────┘\n   333→                    ↓\n   334→┌─────────────────────────────────────────────────┐\n   335→│ 阶段 4: 受伤后处理 (特效和音效)                │\n   336→│ System: UnitAfterTakeDamageSystem               │\n   337→│ 文件: UnitAfterTakeDamageSystem.cs:271-357      │\n   338→├─────────────────────────────────────────────────┤\n   339→│ 4.1 调用 MonoBehaviour 的 AfterTakeDamage()    │\n   340→│   unitPpt.UnitBas.AfterTakeDamage_Dots(info)    │\n   341→│                                                  │\n   342→│ 4.2 播放受击音效                                │\n   343→│   - 玩家: 根据外观播放不同音效                 │\n   344→│     (Huang/Dave/Frog/Normal)                    │\n   345→│   - 敌人: 播放配置的 beHitSE                    │\n   346→│                                                  │\n   347→│ 4.3 更新UI                                      │\n   348→│   - 玩家: 更新HP条                              │\n   349→│   - 玩家: 播放受击闪红动画                     │\n   350→│                                                  │\n   351→│ 4.4 触发遗物/诅咒效果                           │\n   352→│   - OnTakeDamage 事件                           │\n   353→│   - OnPlayerTakeDamage 事件                     │\n   354→└─────────────────────────────────────────────────┘\n   355→                    ↓\n   356→┌─────────────────────────────────────────────────┐\n   357→│ 阶段 5: 死亡判定                                │\n   358→│ System: UnitTakeDamageDeadSystem                │\n   359→│ 文件: UnitTakeDamageDeadSystem.cs:224-410       │\n   360→├─────────────────────────────────────────────────┤\n   361→│ 5.1 检查是否死亡                                │\n   362→│   if (!unitPpt.isDead) continue                 │\n   363→│                                                  │\n   364→│ 5.2 根据单位类型处理死亡                        │\n   365→│   switch (unitType):                            │\n   366→│     case Player:                                │\n   367→│       - 记录死亡日志                            │\n   368→│       - 显示死亡UI                              │\n   369→│       - 触发 GameOver 事件                      │\n   370→│                                                  │\n   371→│     case Teammate:                              │\n   372→│       - 添加 TeammateDeadTag 组件               │\n   373→│       - 从房间管理器注销                        │\n   374→│                                                  │\n   375→│     case Monster/Elite/Boss:                    │\n   376→│       - 掉落物品                                │\n   377→│       - 创建死亡特效                            │\n   378→│       - 播放死亡音效                            │\n   379→│       - 创建尸体                                │\n   380→│       - 创建血迹                                │\n   381→│       - 从房间管理器注销                        │\n   382→│       - 触发死亡事件                            │\n   383→│                                                  │\n   384→│ 5.3 特殊死亡效果                                │\n   385→│   - 虚空爆炸 (Spell3129VoidExplosion)           │\n   386→│   - 死亡蠕虫生成                                │\n   387→│   - 召唤物死亡爆炸                              │\n   388→└─────────────────────────────────────────────────┘\n   389→                    ↓\n   390→┌─────────────────────────────────────────────────┐\n   391→│ 阶段 6: 伤害记录                                │\n   392→│ System: DamageRecordSystem                      │\n   393→│ 文件: DamageRecordSystem.cs                     │\n   394→├─────────────────────────────────────────────────┤\n   395→│ 记录伤害到 DamageRecorder                       │\n   396→│ - 按攻击者统计总伤害                            │\n   397→│ - 按技能统计使用次数                            │\n   398→│ - 更新伤害排行榜                                │\n   399→│ - 更新UI显示                                    │\n   400→└─────────────────────────────────────────────────┘\n   401→                    ↓\n   402→┌─────────────────────────────────────────────────┐\n   403→│ 阶段 7: 清除伤害信息                            │\n   404→│ System: UnitTakeDamageClearSystem               │\n   405→│ 文件: UnitTakeDamageClearSystem.cs              │\n   406→├─────────────────────────────────────────────────┤\n   407→│ 清空所有 Entity 的 TakeDamageInfo_Dots Buffer  │\n   408→│ foreach (entity in allUnits)                    │\n   409→│     GetBuffer<TakeDamageInfo_Dots>(entity).Clear()│\n   410→└─────────────────────────────────────────────────┘\n   411→```\n   412→\n   413→---\n   414→\n   415→## 伤害预处理系统\n   416→\n   417→**文件位置**: [TakeDamageInfoPreProcessSystem.cs](TakeDamageInfoPreProcessSystem.cs:1)\n   418→\n   419→这是伤害计算的第一个阶段,负责计算最终伤害值。\n   420→\n   421→### 主要职责\n   422→\n   423→1. 检查无敌状态\n   424→2. 特殊技能伤害修正\n   425→3. 应用遗物/诅咒修正\n   426→4. 暴击判定\n   427→5. 伤害取整\n   428→\n   429→### Execute 方法解析\n   430→\n   431→**位置**: [TakeDamageInfoPreProcessSystem.cs:157-336](TakeDamageInfoPreProcessSystem.cs:157-336)\n   432→\n   433→```csharp\n   434→private void Execute(DynamicBuffer<TakeDamageInfo_Dots> takeDamageBuffer,\n   435→                     ref UnitProperty_Dots unitPpt,\n   436→                     Entity entity,\n   437→                     [ChunkIndexInQuery] int index)\n   438→{\n   439→    // 1. 检查单位是否禁用\n   440→    if (unitPpt.disabled)\n   441→        return;\n   442→\n   443→    // 获取单位位置(用于闪避文字显示)\n   444→    RefRO<LocalTransform> transform = cluLocalTsf.GetRefRO(entity);\n   445→\n   446→    // 遍历所有伤害信息\n   447→    for (int i = 0; i < takeDamageBuffer.Length; i++)\n   448→    {\n   449→        ref TakeDamageInfo_Dots info = ref takeDamageBuffer.ElementAt(i);\n   450→\n   451→        // ========== 1. 基础免疫检查 ==========\n   452→\n   453→        // 1.1 无敌状态\n   454→        if (unitPpt.IsInvincible)\n   455→        {\n   456→            info.immuneDamage = true;\n   457→        }\n   458→\n   459→        // 1.2 固体物体免疫(除非是真实伤害)\n   460→        if (unitPpt.unitCfg.isSolidObj && !info.isUndifferDamage)\n   461→        {\n   462→            info.immuneDamage = true;\n   463→        }\n   464→\n   465→        // 1.3 已经死亡\n   466→        if (unitPpt.isDead)\n   467→        {\n   468→            info.targetAlreadyDeadBeforeDamage = true;\n   469→            continue;\n   470→        }\n   471→\n   472→        // ========== 2. 特殊技能伤害修正 ==========\n   473→\n   474→        if (info.spell.Entity != Entity.Null)\n   475→        {\n   476→            int spellBaseID = info.spell.Config.Id / 10;\n   477→\n   478→            switch (spellBaseID)\n   479→            {\n   480→                // Boss技能对队友伤害 x2\n   481→                case 9002: case 9004: case 9006: case 9017: case 9045:\n   482→                    if (unitPpt.unitCfg.unitType == UnitType.Teammate ||\n   483→                        unitPpt.unitCfg.unitType == UnitType.TeammateNotAttack)\n   484→                    {\n   485→                        info.damage *= 2f;\n   486→                    }\n   487→                    break;\n   488→\n   489→                // Boss技能对队友伤害 x3\n   490→                case 9012: case 9020: case 9043:\n   491→                case 9021: case 9022: case 9026: case 9027: case 9044:\n   492→                    if (unitPpt.unitCfg.unitType == UnitType.Teammate ||\n   493→                        unitPpt.unitCfg.unitType == UnitType.TeammateNotAttack)\n   494→                    {\n   495→                        info.damage *= 3f;\n   496→                    }\n   497→                    break;\n   498→\n   499→                // Boss15技能对玩家伤害 x0.05\n   500→                case 9015:\n   501→                    if (unitPpt.unitCfg.unitType == UnitType.Player)\n   502→                    {\n   503→                        info.damage *= 0.05f;\n   504→                    }\n   505→                    break;\n   506→            }\n   507→        }\n   508→\n   509→        // ========== 3. 根据目标类型应用修正 ==========\n   510→\n   511→        switch (unitPpt.unitCfg.unitType)\n   512→        {\n   513→            case UnitType.Player:\n   514→                ProcessPlayerDamage(ref info, unitPpt, transform, index);\n   515→                break;\n   516→\n   517→            case UnitType.Teammate:\n   518→            case UnitType.TeammateNotAttack:\n   519→                ProcessTeammateDamage(ref info);\n   520→                break;\n   521→\n   522→            case UnitType.Monster:\n   523→            case UnitType.Elite:\n   524→            case UnitType.Boss:\n   525→            case UnitType.WillAttack:\n   526→            case UnitType.NotAttack:\n   527→            case UnitType.Brittleness:\n   528→                ProcessEnemyDamage(ref info);\n   529→                break;\n   530→        }\n   531→\n   532→        // ========== 4. 易伤效果 ==========\n   533→\n   534→        if (unitPpt.DamageReciveIncresePercent > 0f &&\n   535→            !info.isPercentageDamage)\n   536→        {\n   537→            info.damage *= unitPpt.DamageReciveIncresePercent;\n   538→        }\n   539→\n   540→        // ========== 5. 暴击判定 ==========\n   541→\n   542→        if (!info.isDamageCritical)\n   543→        {\n   544→            float critChance = info.extraCriticalChance;\n   545→            if (info.spell.Entity != Entity.Null)\n   546→            {\n   547→                critChance = info.spell.Config.CriticalChance;\n   548→            }\n   549→\n   550→            if (critChance > 0f &&\n   551→                DTool.RandomValue(ref gRandom.ValueRW.random) <= critChance)\n   552→            {\n   553→                info.isDamageCritical = true;\n   554→\n   555→                // 暴击伤害倍率\n   556→                if (IsPlayerAttack(info) && relic_AddCriticleDamageRatio > 0f)\n   557→                {\n   558→                    // 玩家有暴击伤害遗物\n   559→                    info.damage *= relic_AddCriticleDamageRatio;\n   560→                }\n   561→                else\n   562→                {\n   563→                    // 默认暴击伤害 x2\n   564→                    info.damage *= 2f;\n   565→                }\n   566→            }\n   567→        }\n   568→\n   569→        // ========== 6. 伤害取整 ==========\n   570→\n   571→        info.damage = (int)math.ceil(info.damage);\n   572→    }\n   573→}\n   574→```\n   575→\n   576→### 玩家伤害处理 (ProcessPlayerDamage)\n   577→\n   578→```csharp\n   579→private void ProcessPlayerDamage(ref TakeDamageInfo_Dots info,\n   580→                                  UnitProperty_Dots unitPpt,\n   581→                                  RefRO<LocalTransform> transform,\n   582→                                  int index)\n   583→{\n   584→    // 1. 特殊攻击类型: 来自UI(返回营地)\n   585→    if (info.attackerType == AttackerType.FromUI)\n   586→    {\n   587→        // 直接清空生命值和护盾\n   588→        unitPpt.unitCfg.currentHP = 0f;\n   589→        unitPpt.unitCfg.shield = 0f;\n   590→        unitPpt.unitCfg.shieldTemp = 0f;\n   591→        return;\n   592→    }\n   593→\n   594→    // 2. 无敌帧检查\n   595→    if (!info.ignorePlayerInvincibleFrame &&\n   596→        unitPpt.IsPlayerInInvincibleFrame)\n   597→    {\n   598→        info.knockbackForce = Vector3.zero;\n   599→        info.immuneDamage = true;\n   600→    }\n   601→\n   602→    // 3. 陷阱伤害加成 (诅咒: 陷阱目标)\n   603→    if (info.isTrapDamage && curse_TargetedTrapExtraDamageRatio > 0f)\n   604→    {\n   605→        info.damage *= 1f + curse_TargetedTrapExtraDamageRatio;\n   606→    }\n   607→\n   608→    // 4. 闪避检查 (遗物)\n   609→    if (relic_DodgeChance > 0f &&\n   610→        !info.ignoreRelicDodge &&\n   611→        DTool.RandomValue(ref gRandom.ValueRW.random) <= relic_DodgeChance)\n   612→    {\n   613→        info.knockbackForce = Vector3.zero;\n   614→        info.immuneDamage = true;\n   615→\n   616→        // 显示\"闪避\"浮动文字\n   617→        ecb.AppendToBuffer(index, uiTextFloatByJobEtt,\n   618→            new UITextFloatByJobBED\n   619→            {\n   620→                textID = 1002001,  // \"闪避\"\n   621→                type = UITextFloatType.Normal,\n   622→                worldPos = transform.ValueRO.Position\n   623→            });\n   624→    }\n   625→\n   626→    // 5. 减伤遗物\n   627→    if (relic_ReduceDamageRatio > 0f &&\n   628→        !info.ignoreRelicOrCurseDamageRatioChange)\n   629→    {\n   630→        info.damage *= 1f - relic_ReduceDamageRatio;\n   631→    }\n   632→\n   633→    // 6. 增伤遗物: 强者\n   634→    if (relic_PowerfulManIncreaseDamage > 0f &&\n   635→        !info.ignoreRelicOrCurseDamageRatioChange)\n   636→    {\n   637→        info.damage *= 1f + relic_PowerfulManIncreaseDamage;\n   638→    }\n   639→\n   640→    // 7. 增伤诅咒: 脆弱\n   641→    if (curse_VulnerabilityExtraDamageRatio > 0f &&\n   642→        !info.ignoreRelicOrCurseDamageRatioChange)\n   643→    {\n   644→        info.damage *= 1f + curse_VulnerabilityExtraDamageRatio;\n   645→    }\n   646→\n   647→    // 8. 增伤诅咒: 金币越多受伤越高\n   648→    if (curse_MoreMoneyMoreInjuredExtraDamageRatio > 0f &&\n   649→        !info.ignoreRelicOrCurseDamageRatioChange)\n   650→    {\n   651→        info.damage *= 1f + curse_MoreMoneyMoreInjuredExtraDamageRatio;\n   652→    }\n   653→\n   654→    // 9. 应用玩家受伤比例\n   655→    if (info.playerTakeDamageRatio != 1f)\n   656→    {\n   657→        info.damage *= info.playerTakeDamageRatio;\n   658→    }\n   659→\n   660→    // 10. 真实伤害特殊处理\n   661→    if (info.isUndifferDamage)\n   662→    {\n   663→        if (info.spell.Entity != Entity.Null)\n   664→        {\n   665→            // 限制真实伤害最多为33.33%\n   666→            info.damage *= math.min(\n   667→                info.spell.Config.UndifferDamageRatio,\n   668→                0.3333f\n   669→            );\n   670→        }\n   671→        else\n   672→        {\n   673→            info.damage *= 0.3333f;\n   674→        }\n   675→    }\n   676→}\n   677→```\n   678→\n   679→### 队友伤害处理\n   680→\n   681→```csharp\n   682→private void ProcessTeammateDamage(ref TakeDamageInfo_Dots info)\n   683→{\n   684→    // 1. 陷阱伤害加成\n   685→    if (info.isTrapDamage && curse_TargetedTrapExtraDamageRatio > 0f)\n   686→    {\n   687→        info.damage *= 1f + curse_TargetedTrapExtraDamageRatio;\n   688→    }\n   689→\n   690→    // 2. 应用队友受伤比例\n   691→    info.damage *= info.teammateTakeDamageRatio;\n   692→}\n   693→```\n   694→\n   695→### 敌人伤害处理\n   696→\n   697→```csharp\n   698→private void ProcessEnemyDamage(ref TakeDamageInfo_Dots info)\n   699→{\n   700→    // 诅咒: 敌人减伤\n   701→    if (curse_EnemyReduceDamageRatio > 0f &&\n   702→        !info.isPercentageDamage)\n   703→    {\n   704→        info.damage *= 1f - curse_EnemyReduceDamageRatio;\n   705→    }\n   706→}\n   707→```\n   708→\n   709→---\n   710→\n   711→## 受伤前处理系统\n   712→\n   713→**文件位置**: [UnitBeforeTakeDamageSystem.cs](UnitBeforeTakeDamageSystem.cs:1)\n   714→\n   715→这个系统在伤害应用前调用各个单位的 `BeforeTakeDamage_Dots` 方法,允许单位进行自定义处理。\n   716→\n   717→### OnUpdate 方法\n   718→\n   719→**位置**: [UnitBeforeTakeDamageSystem.cs:255-286](UnitBeforeTakeDamageSystem.cs:255-286)\n   720→\n   721→```csharp\n   722→public void OnUpdate(ref SystemState state)\n   723→{\n   724→    // 特殊处理: Boss6第二阶段\n   725→    bool isBoss6Stage2 = false;\n   726→    if (Boss6_Stage2.Inst != null &&\n   727→        !Boss6_Stage2.Inst.myPpt.AlreadyDead &&\n   728→        UnitDotsSyncSystem.EntityIsValid(Boss6_Stage2.Inst.myPpt.myEntity))\n   729→    {\n   730→        isBoss6Stage2 = true;\n   731→        Boss6_Stage2.Inst.takeDamageInfoBuffer =\n   732→            state.EntityManager.GetBuffer<TakeDamageInfo_Dots>(\n   733→                Boss6_Stage2.Inst.myPpt.myEntity);\n   734→    }\n   735→\n   736→    // 遍历所有有伤害信息的单位\n   737→    foreach (var (unitPptReference, damageBuffer) in Query(...))\n   738→    {\n   739→        if (damageBuffer.Length <= 0)\n   740→            continue;\n   741→\n   742→        // 遍历该单位的所有伤害信息\n   743→        for (int i = 0; i < damageBuffer.Length; i++)\n   744→        {\n   745→            // 特殊排除: 某个特定单位ID\n   746→            if (unitPptReference.unitPpt.unitCfg.id != 500621)\n   747→            {\n   748→                // 调用 MonoBehaviour 的受伤前处理\n   749→                unitPptReference.unitPpt.UnitBas.BeforeTakeDamage_Dots(\n   750→                    ref damageBuffer.ElementAt(i)\n   751→                );\n   752→            }\n   753→        }\n   754→    }\n   755→\n   756→    // Boss6特殊处理\n   757→    if (isBoss6Stage2)\n   758→    {\n   759→        DynamicBuffer<TakeDamageInfo_Dots> buffer =\n   760→            state.EntityManager.GetBuffer<TakeDamageInfo_Dots>(\n   761→                Boss6_Stage2.Inst.myPpt.myEntity);\n   762→\n   763→        for (int j = 0; j < buffer.Length; j++)\n   764→        {\n   765→            Boss6_Stage2.Inst.BeforeTakeDamage_Dots(\n   766→                ref buffer.ElementAt(j)\n   767→            );\n   768→        }\n   769→    }\n   770→}\n   771→```\n   772→\n   773→### UnitBase.BeforeTakeDamage_Dots 虚方法\n   774→\n   775→**文件位置**: [UnitBase.cs:453-455](UnitBase.cs:453-455)\n   776→\n   777→```csharp\n   778→public virtual void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n   779→{\n   780→    // 默认为空,由子类重写\n   781→    // 例如:\n   782→    // - Boss进入特殊阶段\n   783→    // - Elite触发特殊技能\n   784→    // - 遗物效果触发\n   785→}\n   786→```\n   787→\n   788→### 常见用途示例\n   789→\n   790→#### 示例 1: Boss阶段切换\n   791→\n   792→```csharp\n   793→// Boss1.cs\n   794→public override void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n   795→{\n   796→    UnitProperty_Dots ppt = GetComponentData<UnitProperty_Dots>();\n   797→\n   798→    // 当HP低于50%时进入狂暴阶段\n   799→    if (!isEnraged && ppt.unitCfg.currentHP < ppt.unitCfg.maxHP * 0.5f)\n   800→    {\n   801→        isEnraged = true;\n   802→        EnterEnragedPhase();\n   803→    }\n   804→}\n   805→```\n   806→\n   807→#### 示例 2: 遗物触发\n   808→\n   809→```csharp\n   810→// PlayerController.cs\n   811→public override void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n   812→{\n   813→    // 遗物: 受伤时获得护盾\n   814→    if (PlayerMgr.Inst.ItemCtrller.relic_ShieldOnHit != null)\n   815→    {\n   816→        float shieldAmount = info.damage * 0.2f;\n   817→        PlayerMgr.Inst.ChangeShield(shieldAmount);\n   818→    }\n   819→\n   820→    // 遗物: 受伤时触发反击\n   821→    if (PlayerMgr.Inst.ItemCtrller.relic_CounterAttack != null)\n   822→    {\n   823→        LaunchCounterAttack(info.attackerEntity);\n   824→    }\n   825→}\n   826→```\n   827→\n   828→---\n   829→\n   830→## 受伤后处理系统\n   831→\n   832→**文件位置**: [UnitAfterTakeDamageSystem.cs](UnitAfterTakeDamageSystem.cs:1)\n   833→\n   834→这个系统在伤害应用后处理特效、音效和UI更新。\n   835→\n   836→### OnUpdate 方法\n   837→\n   838→**位置**: [UnitAfterTakeDamageSystem.cs:271-357](UnitAfterTakeDamageSystem.cs:271-357)\n   839→\n   840→```csharp\n   841→public void OnUpdate(ref SystemState state)\n   842→{\n   843→    foreach (var (unitDead, unitPpt, damageBuffer, entity) in Query(...))\n   844→    {\n   845→        if (damageBuffer.Length <= 0)\n   846→            continue;\n   847→\n   848→        bool hasRealDamage = false;\n   849→\n   850→        // ========== 1. 检查是否有实际伤害 ==========\n   851→\n   852→        if (unitPpt.ValueRO.unitCfg.isHybirdUnit)\n   853→        {\n   854→            // 混合单位(Mono + DOTS)\n   855→            UnitPptReference unitPptRef = null;\n   856→\n   857→            for (int i = 0; i < damageBuffer.Length; i++)\n   858→            {\n   859→                if (!damageBuffer[i].immuneDamage &&\n   860→                    damageBuffer[i].realDamage > 0f)\n   861→                {\n   862→                    hasRealDamage = true;\n   863→\n   864→                    if (unitPptRef == null)\n   865→                    {\n   866→                        unitPptRef = state.EntityManager\n   867→                            .GetComponentObject<UnitPptReference>(entity);\n   868→                    }\n   869→\n   870→                    if (!unitPpt.ValueRO.isDead)\n   871→                    {\n   872→                        // 调用 MonoBehaviour 的受伤后处理\n   873→                        unitPptRef.unitPpt.UnitBas.AfterTakeDamage_Dots(\n   874→                            ref damageBuffer.ElementAt(i)\n   875→                        );\n   876→                    }\n   877→                }\n   878→            }\n   879→        }\n   880→        else\n   881→        {\n   882→            // 纯 DOTS 单位\n   883→            for (int j = 0; j < damageBuffer.Length; j++)\n   884→            {\n   885→                if (!damageBuffer[j].immuneDamage &&\n   886→                    damageBuffer[j].realDamage > 0f)\n   887→                {\n   888→                    hasRealDamage = true;\n   889→                    break;\n   890→                }\n   891→            }\n   892→        }\n   893→\n   894→        // ========== 2. 播放受击音效 ==========\n   895→\n   896→        if (unitPpt.ValueRO.unitCfg.id == 800001)  // 玩家\n   897→        {\n   898→            ref PlayerController_Dots playerCtrl =\n   899→                ref GetComponentRW<PlayerController_Dots>(entity).ValueRW;\n   900→\n   901→            if (playerCtrl.isHurtThisFrameForPlayer)\n   902→            {\n   903→                playerCtrl.isHurtThisFrameForPlayer = false;\n   904→\n   905→                // 更新HP UI\n   906→                UIPlayerDataMgr.Inst.UpdateHP();\n   907→\n   908→                // 根据外观播放不同音效\n   909→                if (PlayerMgr.Inst.ItemCtrller.relic_Huang != null)\n   910→                {\n   911→                    SEMgr.Inst.injured_Huang.PlaySE();\n   912→                }\n   913→                else if (PlayerMgr.Inst.ItemCtrller.uiRelic_DaveHarpoons != null)\n   914→                {\n   915→                    SEMgr.Inst.injured_Dave.PlaySE();\n   916→                }\n   917→                else if (DataMgr.selectedWorldData.playerLook == PlayerLook.Frog)\n   918→                {\n   919→                    SEMgr.Inst.injured_Frog.PlaySE();\n   920→                }\n   921→                else\n   922→                {\n   923→                    SEMgr.Inst.injured_Player.PlaySE();\n   924→                }\n   925→\n   926→                // 播放受击闪红动画\n   927→                if (!GameMgr.IsHarmony_Static)\n   928→                {\n   929→                    UIPlayerDataMgr.Inst.UIPlayerInjuredPlay();\n   930→                }\n   931→            }\n   932→        }\n   933→        else if (hasRealDamage && unitPpt.ValueRO.unitCfg.id != 800001)  // 敌人\n   934→        {\n   935→            // 播放敌人受击音效\n   936→            UnitConfig.map[unitPpt.ValueRO.unitCfg.id]\n   937→                .beHitSE.Value.PlaySE(SEPlayMode.Unique, 3, 0.2f);\n   938→        }\n   939→    }\n   940→\n   941→    // ========== 3. 玩家特殊处理 ==========\n   942→\n   943→    DynamicBuffer<TakeDamageInfo_Dots> playerDamageBuffer =\n   944→        GetBuffer<TakeDamageInfo_Dots>(PlayerMgr.Inst.PlayerEtt);\n   945→    UnitProperty_Dots playerPpt =\n   946→        GetComponent<UnitProperty_Dots>(PlayerMgr.Inst.PlayerEtt);\n   947→\n   948→    for (int k = 0; k < playerDamageBuffer.Length; k++)\n   949→    {\n   950→        TakeDamageInfo_Dots info = playerDamageBuffer[k];\n   951→\n   952→        if (!info.immuneDamage &&\n   953→            (info.realDamage > 0f || info.hitMagicShieldDamage > 0f) &&\n   954→            !playerPpt.isDead)\n   955→        {\n   956→            // 调用玩家控制器的受伤后处理\n   957→            PlayerMgr.Inst.PlayerCtrller.AfterTakeDamage(\n   958→                ref playerDamageBuffer.ElementAt(k)\n   959→            );\n   960→        }\n   961→    }\n   962→}\n   963→```\n   964→\n   965→### UnitBase.AfterTakeDamage_Dots 虚方法\n   966→\n   967→**文件位置**: [UnitBase.cs:461-463](UnitBase.cs:461-463)\n   968→\n   969→```csharp\n   970→public virtual void AfterTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n   971→{\n   972→    // 默认为空,由子类重写\n   973→    // 例如:\n   974→    // - 播放受击动画\n   975→    // - 创建受击特效\n   976→    // - 触发反弹\n   977→    // - 生成血液粒子\n   978→}\n   979→```\n   980→\n   981→---\n   982→\n   983→## 死亡判定系统\n   984→\n   985→**文件位置**: [UnitTakeDamageDeadSystem.cs](UnitTakeDamageDeadSystem.cs:1)\n   986→\n   987→### OnUpdate 方法\n   988→\n   989→**位置**: [UnitTakeDamageDeadSystem.cs:210-410](UnitTakeDamageDeadSystem.cs:210-410)\n   990→\n   991→```csharp\n   992→protected unsafe override void OnUpdate()\n   993→{\n   994→    EntityCommandBuffer ecb = GetSingleton<EndSimulationECBSystem.Singleton>()\n   995→        .CreateCommandBuffer(World.Unmanaged);\n   996→\n   997→    Entity uiTextFloatEntity = GetSingletonEntity<UITextFloatByJobSingleton>();\n   998→\n   999→    // 清理缓存\n  1000→    _deadPpts.Clear();\n  1001→    _deadInfos.Clear();\n  1002→    _deadInfoIndex.Clear();\n  1003→    deadEntities.Clear();\n  1004→\n  1005→    // 遍历所有已死亡的单位\n  1006→    foreach (var (unitDead, unitPpt, transform, entity) in Query(...))\n  1007→    {\n  1008→        if (!unitPpt.ValueRO.isDead)\n  1009→            continue;\n  1010→\n  1011→        ref UnitDead deadData = ref unitDead.ValueRW;\n  1012→        LocalTransform pos = transform.ValueRO;\n  1013→\n  1014→        // 玩家最终死亡检查\n  1015→        if (deadData.playerFinallyDead)\n  1016→            break;\n  1017→\n  1018→        // ========== 1. 队友死亡处理 ==========\n  1019→\n  1020→        if (unitPpt.ValueRO.unitCfg.unitType == UnitType.Teammate ||\n  1021→            unitPpt.ValueRO.unitCfg.unitType == UnitType.TeammateNotAttack)\n  1022→        {\n  1023→            // 添加队友死亡标签\n  1024→            SetComponentEnabled<TeammateDeadTag>(entity, true);\n  1025→            continue;\n  1026→        }\n  1027→\n  1028→        // ========== 2. 掉落物品 ==========\n  1029→\n  1030→        if (unitPpt.ValueRO.deadDropItemInfos.IsCreated &&\n  1031→            unitPpt.ValueRO.deadDropItemInfos.Value.Length > 0)\n  1032→        {\n  1033→            QuickCreateSystem.Inst.CreateItemDrop(\n  1034→                LevelMgr.Inst.CurrentRoomMapPos,\n  1035→                unitPpt.ValueRO.deadDropItemInfos,\n  1036→                Tool2D.IgnoreZPoint(pos.Position),\n  1037→                0.2f\n  1038→            );\n  1039→        }\n  1040→\n  1041→        // ========== 3. 虚空爆炸检查 ==========\n  1042→\n  1043→        if ((unitPpt.ValueRO.unitCfg.triggerDeadEvent ||\n  1044→             IsSpecialVoidExplosionUnit(unitPpt.ValueRO.unitCfg.id)) &&\n  1045→            unitPpt.ValueRO.voidExplosionData.InstantKillRatio > 0f)\n  1046→        {\n  1047→            // 创建虚空爆炸\n  1048→            GameObject voidExplosion = ObjPoolMgr.Inst.GetGO(\n  1049→                \"Prefabs/Spell/\" + 31291,\n  1050→                pos.Position,\n  1051→                2.5f\n  1052→            );\n  1053→            voidExplosion.transform.localScale = Vector3.one;\n  1054→            voidExplosion.GetComponent<Spell3129VoidExplosion>()\n  1055→                .DataInitialize_Dots(\n  1056→                    unitPpt.ValueRO.unitCfg.maxHP,\n  1057→                    unitPpt.ValueRO.voidExplosionData\n  1058→                );\n  1059→\n  1060→            // 创建爆炸粒子\n  1061→            ecb.AppendToBuffer(uiTextFloatEntity,\n  1062→                new GlobalParticleEmitParams(\n  1063→                    GlobalParticleType.Spell,\n  1064→                    \"3129_Explosion\",\n  1065→                    pos.Position\n  1066→                )\n  1067→                { Size = 0.417f }\n  1068→            );\n  1069→        }\n  1070→\n  1071→        // ========== 4. 死亡特效 ==========\n  1072→\n  1073→        if (!deadData.deadlyInfo.dontCreateDeadEF)\n  1074→        {\n  1075→            if (unitPpt.ValueRO.unitCfg.deadEF != \"\")\n  1076→            {\n  1077→                bool isSummonTransparent =\n  1078→                    (unitPpt.ValueRO.unitCfg.unitType == UnitType.Teammate ||\n  1079→                     unitPpt.ValueRO.unitCfg.unitType == UnitType.TeammateNotAttack) &&\n  1080→                    DataMgr.settingData.FinalSummonTransparent <= 0.01f;\n  1081→\n  1082→                if (!isSummonTransparent)\n  1083→                {\n  1084→                    string effectPath = \"Prefabs/EF/\" +\n  1085→                        unitPpt.ValueRO.unitCfg.deadEF.ToString();\n  1086→\n  1087→                    // 特殊处理: 血液/幽灵死亡特效有多个变体\n  1088→                    if (unitPpt.ValueRO.unitCfg.deadEF == \"EF_Dead_Blood\" ||\n  1089→                        unitPpt.ValueRO.unitCfg.deadEF == \"EF_Dead_Ghost\")\n  1090→                    {\n  1091→                        effectPath += \"_\" + UnityEngine.Random.Range(0, 2);\n  1092→\n  1093→                        // 使用精灵特效系统\n  1094→                        SpriteEffectAnima anima =\n  1095→                            ABResources.LoadAsset<SpriteEffectAnima>(effectPath);\n  1096→\n  1097→                        float3 offset = new float3(\n  1098→                            UnityEngine.Random.Range(-0.1f, 0.1f),\n  1099→                            0.3f + UnityEngine.Random.Range(-0.1f, 0.1f),\n  1100→                            0f\n  1101→                        );\n  1102→\n  1103→                        float radius = GetEntityRadius(entity);\n  1104→\n  1105→                        SpellSpriteEffectController.Inst.PlayEffect(anima,\n  1106→                            new EffectPlayParam\n  1107→                            {\n  1108→                                Position = pos.Position + offset,\n  1109→                                Scale = Vector3.one * Mathf.Max(1f, radius * 2f + 0.3f),\n  1110→                                FilpX = (UnityEngine.Random.Range(0, 2) == 0),\n  1111→                                Unlit = false\n  1112→                            }\n  1113→                        );\n  1114→                    }\n  1115→                    else\n  1116→                    {\n  1117→                        ObjPoolMgr.Inst.GetGO(effectPath, pos.Position, 5f);\n  1118→                    }\n  1119→                }\n  1120→            }\n  1121→        }\n  1122→\n  1123→        // ========== 5. 永久死亡特效 ==========\n  1124→\n  1125→        if (unitPpt.ValueRO.unitCfg.deadPermanentEF.ToString() != \"\")\n  1126→        {\n  1127→            ObjPoolMgr.Inst.GetGO(\n  1128→                \"Prefabs/EF/\" + unitPpt.ValueRO.unitCfg.deadPermanentEF.ToString(),\n  1129→                pos.Position\n  1130→            );\n  1131→        }\n  1132→\n  1133→        // ========== 6. 血迹 ==========\n  1134→\n  1135→        if (!deadData.deadlyInfo.dontCreatebloodSplat &&\n  1136→            unitPpt.ValueRO.unitCfg.bloodSplatSize > 0f)\n  1137→        {\n  1138→            if (deadData.deadlyInfo.knockbackForce == Vector3.zero)\n  1139→            {\n  1140→                // 无方向血迹\n  1141→                ObjPoolMgr.Inst.GetGO(\"Prefabs/EF/EF_BloodSplat\",\n  1142→                    Tool2D.IgnoreZPoint(pos.Position))\n  1143→                    .GetComponent<BloodSplat>()\n  1144→                    .Initialize(unitPpt.ValueRO.unitCfg.bloodSplatSize);\n  1145→            }\n  1146→            else\n  1147→            {\n  1148→                // 有方向血迹\n  1149→                ObjPoolMgr.Inst.GetGO(\"Prefabs/EF/EF_BloodSplatDirect\",\n  1150→                    Tool2D.IgnoreZPoint(pos.Position))\n  1151→                    .GetComponent<BloodSplat>()\n  1152→                    .Initialize(\n  1153→                        unitPpt.ValueRO.unitCfg.bloodSplatSize,\n  1154→                        deadData.deadlyInfo.knockbackForce\n  1155→                    );\n  1156→            }\n  1157→        }\n  1158→\n  1159→        // ========== 7. 尸体 ==========\n  1160→\n  1161→        int corpseCount = unitPpt.ValueRO.unitCfg.corpseCount;\n  1162→        if (GameMgr.IsMobile_Static)\n  1163→        {\n  1164→            corpseCount = (int)(corpseCount * 0.5);  // 移动端减半\n  1165→        }\n  1166→\n  1167→        if (unitPpt.ValueRO.unitCfg.corpseType != CorpseType.None)\n  1168→        {\n  1169→            for (int i = 0; i < corpseCount; i++)\n  1170→            {\n  1171→                CorpseSystem.Inst.CreateCorpse(\n  1172→                    unitPpt.ValueRO.unitCfg.corpseType,\n  1173→                    pos.Position,\n  1174→                    deadData.deadlyInfo.knockbackForce\n  1175→                );\n  1176→            }\n  1177→        }\n  1178→\n  1179→        // ========== 8. 死亡音效 ==========\n  1180→\n  1181→        if (!deadData.deadlyInfo.dontPlayDeadSE)\n  1182→        {\n  1183→            if (unitPpt.ValueRO.unitCfg.isDeadSE3D)\n  1184→            {\n  1185→                unitPpt.ValueRO.unitCfg.deadSEs.Value.PlaySE(pos.Position);\n  1186→            }\n  1187→            else\n  1188→            {\n  1189→                unitPpt.ValueRO.unitCfg.deadSEs.Value.PlaySE();\n  1190→            }\n  1191→        }\n  1192→\n  1193→        // ========== 9. 根据单位类型处理死亡 ==========\n  1194→\n  1195→        switch (unitPpt.ValueRO.unitCfg.unitType)\n  1196→        {\n  1197→            case UnitType.Player:\n  1198→                HandlePlayerDeath(ref deadData, entity);\n  1199→                break;\n  1200→\n  1201→            case UnitType.Teammate:\n  1202→            case UnitType.TeammateNotAttack:\n  1203→                LevelMgr.Inst.CurrentRoomCtrller.UnitUnregister(entity);\n  1204→                break;\n  1205→\n  1206→            case UnitType.Monster:\n  1207→            case UnitType.Elite:\n  1208→            case UnitType.Boss:\n  1209→            case UnitType.WillAttack:\n  1210→            case UnitType.NotAttack:\n  1211→            case UnitType.Brittleness:\n  1212→                if (!unitPpt.ValueRO.unitCfg.isHybirdUnit)\n  1213→                {\n  1214→                    LevelMgr.Inst.CurrentRoomCtrller.UnitUnregister(entity);\n  1215→                }\n  1216→                break;\n  1217→        }\n  1218→    }\n  1219→}\n  1220→```\n  1221→\n  1222→### 玩家死亡处理\n  1223→\n  1224→```csharp\n  1225→private void HandlePlayerDeath(ref UnitDead deadData, Entity entity)\n  1226→{\n  1227→    Debug.Log(\"Player Dead\");\n  1228→\n  1229→    // 记录死亡次数\n  1230→    DataMgr.selectedWorldData.deadCount++;\n  1231→\n  1232→    TakeDamageInfo_Dots deadlyInfo = deadData.deadlyInfo;\n  1233→\n  1234→    // 记录击杀者\n  1235→    if (deadlyInfo.attackerEntity != Entity.Null)\n  1236→    {\n  1237→        if (HasComponent<UnitProperty_Dots>(deadlyInfo.attackerEntity))\n  1238→        {\n  1239→            int killerID = GetComponent<UnitProperty_Dots>(\n  1240→                deadlyInfo.attackerEntity\n  1241→            ).unitCfg.id;\n  1242→            Debug.Log(\"击杀者id: \" + killerID);\n  1243→        }\n  1244→        else\n  1245→        {\n  1246→            Debug.Log(\"击杀者id已经不可考证\");\n  1247→        }\n  1248→    }\n  1249→\n  1250→    // 标记玩家最终死亡\n  1251→    deadData.playerFinallyDead = true;\n  1252→\n  1253→    // 记录死亡日志\n  1254→    PlayerDeathLogger logger = new PlayerDeathLogger();\n  1255→    logger.death_counter = DataMgr.selectedWorldData.deadCount;\n  1256→    logger.equips = PlayerEquips.CreateAuto();\n  1257→    logger.monsters = LevelMgr.Inst.CurrentRoomCtrller.MonsterPpts\n  1258→        .Select(e => e.unitCfg.id).ToList();\n  1259→    logger.resources = ResourcesStatus.CreateAuto();\n  1260→    logger.click_return_camp =\n  1261→        (deadlyInfo.attackerType == AttackerType.FromUI);\n  1262→    logger.Report();\n  1263→\n  1264→    // 移动端数据上报\n  1265→    if (GameMgr.IsMobile_Static)\n  1266→    {\n  1267→        MobileMgr.inst.PluginActivity.UploadItemSnapshot(1);\n  1268→    }\n  1269→\n  1270→    // 触发玩家死亡事件\n  1271→    EventMgr.PlayerDead?.Invoke();\n  1272→\n  1273→    // 显示死亡UI\n  1274→    GameUISingletonMono<UIPlayerDead>.ShowInit();\n  1275→}\n  1276→```\n  1277→\n  1278→---\n  1279→\n  1280→## 护盾系统\n  1281→\n  1282→护盾分为两种类型:\n  1283→1. **永久护盾 (shield)**: 不会随时间消失\n  1284→2. **临时护盾 (shieldTemp)**: 进门时清除\n  1285→\n  1286→### 护盾扣除顺序\n  1287→\n  1288→**位置**: [UnitPropertySystem.cs](UnitPropertySystem.cs:1) (DOTS Job)\n  1289→\n  1290→```\n  1291→伤害应用顺序:\n  1292→1. 永久护盾 (shield)\n  1293→2. 临时护盾 (shieldTemp)\n  1294→3. 生命值 (currentHP)\n  1295→```\n  1296→\n  1297→### 护盾计算伪代码\n  1298→\n  1299→```csharp\n  1300→float originalDamage = damageInfo.damage;\n  1301→float remainingDamage = originalDamage;\n  1302→float realDamage = 0f;  // 实际造成的伤害(用于统计)\n  1303→\n  1304→// 1. 扣除永久护盾\n  1305→if (shield > 0 && remainingDamage > 0)\n  1306→{\n  1307→    float damageToShield = Min(remainingDamage, shield);\n  1308→    shield -= damageToShield;\n  1309→    remainingDamage -= damageToShield;\n  1310→    // 注意: 护盾吸收的伤害不计入realDamage\n  1311→}\n  1312→\n  1313→// 2. 扣除临时护盾\n  1314→if (shieldTemp > 0 && remainingDamage > 0)\n  1315→{\n  1316→    float damageToTempShield = Min(remainingDamage, shieldTemp);\n  1317→    shieldTemp -= damageToTempShield;\n  1318→    remainingDamage -= damageToTempShield;\n  1319→    realDamage += damageToTempShield;  // 临时护盾计入实际伤害\n  1320→}\n  1321→\n  1322→// 3. 扣除生命值\n  1323→if (remainingDamage > 0)\n  1324→{\n  1325→    currentHP -= remainingDamage;\n  1326→    realDamage += remainingDamage;\n  1327→\n  1328→    if (currentHP < 0)\n  1329→    {\n  1330→        currentHP = 0;\n  1331→    }\n  1332→}\n  1333→\n  1334→// 4. 检查死亡\n  1335→if (currentHP <= 0 && !isDead)\n  1336→{\n  1337→    isDead = true;\n  1338→}\n  1339→```\n  1340→\n  1341→### 护盾来源\n  1342→\n  1343→#### 1. 遗物提供的护盾\n  1344→\n  1345→```csharp\n  1346→// 遗物: 进门获得护盾\n  1347→if (ItemCtrller.relicCfg_FloorShield != null)\n  1348→{\n  1349→    PlayerMgr.Inst.ChangeShield(relicCfg_FloorShield.int1.result);\n  1350→}\n  1351→\n  1352→// 遗物: 临时护盾\n  1353→if (ItemCtrller.relicCfg_TempShield != null)\n  1354→{\n  1355→    PlayerMgr.Inst.ChangeShieldTemp(relicCfg_TempShield.int1.result);\n  1356→}\n  1357→```\n  1358→\n  1359→#### 2. 遗物组提供的护盾\n  1360→\n  1361→```csharp\n  1362→// 遗物组1: 临时护盾转永久护盾\n  1363→if (ItemCtrller.relicGroupConfigs.TryGetValue(1, out var config))\n  1364→{\n  1365→    float shieldPercent = config.int1.result / 100f;\n  1366→    float permanentShield = playerPpt.unitCfg.shieldTemp * shieldPercent;\n  1367→    PlayerMgr.Inst.ChangeShield(permanentShield);\n  1368→}\n  1369→```\n  1370→\n  1371→### ChangeShield 方法\n  1372→\n  1373→**位置**: [PlayerMgr.cs](PlayerMgr.cs:1)\n  1374→\n  1375→```csharp\n  1376→public void ChangeShield(float value)\n  1377→{\n  1378→    EntityManager ettMgr = World.DefaultGameObjectInjectionWorld.EntityManager;\n  1379→    UnitProperty_Dots ppt = ettMgr.GetComponentData<UnitProperty_Dots>(PlayerEtt);\n  1380→\n  1381→    ppt.unitCfg.shield += value;\n  1382→\n  1383→    // 限制护盾上限\n  1384→    float maxShield = ppt.unitCfg.maxHP * 0.5f;  // 最大护盾为最大HP的50%\n  1385→    if (ppt.unitCfg.shield > maxShield)\n  1386→    {\n  1387→        ppt.unitCfg.shield = maxShield;\n  1388→    }\n  1389→\n  1390→    ettMgr.SetComponentData(PlayerEtt, ppt);\n  1391→\n  1392→    // 更新UI\n  1393→    UIPlayerDataMgr.Inst.UpdateHP();\n  1394→}\n  1395→```\n  1396→\n  1397→---\n  1398→\n  1399→## 暴击系统\n  1400→\n  1401→### 暴击判定流程\n  1402→\n  1403→```\n  1404→1. 获取暴击率\n  1405→   ├─ 技能配置的暴击率 (SpellConfig.criticalChance)\n  1406→   ├─ 额外暴击率 (TakeDamageInfo.extraCriticalChance)\n  1407→   └─ 玩家属性加成 (PlayerMgr.ExtraCriticalRatio)\n  1408→\n  1409→2. 随机判定\n  1410→   if (Random.value <= totalCriticalChance)\n  1411→       触发暴击\n  1412→\n  1413→3. 暴击伤害倍率\n  1414→   ├─ 默认: x2.0\n  1415→   └─ 遗物加成: x (2.0 + relic_AddCriticleDamageRatio)\n  1416→```\n  1417→\n  1418→### 暴击率计算\n  1419→\n  1420→**位置**: [PlayerMgr.cs:198-213](PlayerMgr.cs:198-213)\n  1421→\n  1422→```csharp\n  1423→public float ExtraCriticalRatio\n  1424→{\n  1425→    get\n  1426→    {\n  1427→        float ratio = BaData.extraCriticalChance;  // 基础额外暴击率\n  1428→\n  1429→        // 遗物: 增加暴击率\n  1430→        if (ItemCtrller.relicCfg_AddCriticalChance != null)\n  1431→        {\n  1432→            ratio += (float)relicCfg_AddCriticalChance.int1.result / 100f;\n  1433→        }\n  1434→\n  1435→        // 诅咒: 减少暴击率\n  1436→        if (ItemCtrller.curseCfg_ReduceCriticalRatio != null)\n  1437→        {\n  1438→            ratio += (float)curseCfg_ReduceCriticalRatio.int1.result / 100f;\n  1439→        }\n  1440→\n  1441→        return ratio;\n  1442→    }\n  1443→}\n  1444→```\n  1445→\n  1446→### 暴击判定代码\n  1447→\n  1448→**位置**: [TakeDamageInfoPreProcessSystem.cs:315-334](TakeDamageInfoPreProcessSystem.cs:315-334)\n  1449→\n  1450→```csharp\n  1451→if (!info.isDamageCritical)\n  1452→{\n  1453→    // 获取暴击率\n  1454→    float critChance = info.extraCriticalChance;\n  1455→    if (info.spell.Entity != Entity.Null)\n  1456→    {\n  1457→        critChance = info.spell.Config.CriticalChance;\n  1458→    }\n  1459→\n  1460→    // 暴击判定\n  1461→    if (critChance > 0f &&\n  1462→        DTool.RandomValue(ref gRandom.ValueRW.random) <= critChance)\n  1463→    {\n  1464→        info.isDamageCritical = true;\n  1465→\n  1466→        // 计算暴击伤害\n  1467→        if (IsPlayerAttack(info) && relic_AddCriticleDamageRatio > 0f)\n  1468→        {\n  1469→            // 玩家有暴击伤害遗物\n  1470→            info.damage *= relic_AddCriticleDamageRatio;\n  1471→        }\n  1472→        else\n  1473→        {\n  1474→            // 默认暴击伤害 x2\n  1475→            info.damage *= 2f;\n  1476→        }\n  1477→    }\n  1478→}\n  1479→```\n  1480→\n  1481→### 暴击显示\n  1482→\n  1483→```csharp\n  1484→// 创建伤害数字时检查暴击标志\n  1485→if (info.isDamageCritical)\n  1486→{\n  1487→    // 显示黄色大号字体\n  1488→    CreateFloatText(\n  1489→        damage,\n  1490→        position,\n  1491→        Color.yellow,\n  1492→        scale: 1.5f\n  1493→    );\n  1494→}\n  1495→else\n  1496→{\n  1497→    // 显示白色普通字体\n  1498→    CreateFloatText(\n  1499→        damage,\n  1500→        position,\n  1501→        Color.white,\n  1502→        scale: 1.0f\n  1503→    );\n  1504→}\n  1505→```\n  1506→\n  1507→---\n  1508→\n  1509→## 特殊伤害类型\n  1510→\n  1511→### 1. 真实伤害 (isUndifferDamage)\n  1512→\n  1513→真实伤害无视大部分防御机制,但有特殊限制。\n  1514→\n  1515→**特点**:\n  1516→- 无视固体物体免疫\n  1517→- 对玩家伤害限制在33.33%\n  1518→- 不受诅咒减伤影响\n  1519→\n  1520→**应用代码**: [TakeDamageInfoPreProcessSystem.cs:279-289](TakeDamageInfoPreProcessSystem.cs:279-289)\n  1521→\n  1522→```csharp\n  1523→if (info.isUndifferDamage)\n  1524→{\n  1525→    if (info.spell.Entity != Entity.Null)\n  1526→    {\n  1527→        // 限制真实伤害最多为配置值或33.33%,取较小值\n  1528→        info.damage *= math.min(\n  1529→            info.spell.Config.UndifferDamageRatio,\n  1530→            0.3333f\n  1531→        );\n  1532→    }\n  1533→    else\n  1534→    {\n  1535→        // 默认33.33%\n  1536→        info.damage *= 0.3333f;\n  1537→    }\n  1538→}\n  1539→```\n  1540→\n  1541→### 2. 百分比伤害 (isPercentageDamage)\n  1542→\n  1543→按目标最大生命值百分比造成伤害。\n  1544→\n  1545→**特点**:\n  1546→- 不受伤害加成/减免影响\n  1547→- 不受易伤效果影响\n  1548→- 适合对高血量敌人\n  1549→\n  1550→**计算代码**:\n  1551→\n  1552→```csharp\n  1553→if (info.isPercentageDamage)\n  1554→{\n  1555→    float maxHP = unitPpt.unitCfg.maxHP;\n  1556→    info.damage = maxHP * damagePercent;\n  1557→\n  1558→    // 注意: 百分比伤害不受以下影响\n  1559→    // - relic_ReduceDamageRatio\n  1560→    // - curse_VulnerabilityExtraDamageRatio\n  1561→    // - DamageReciveIncresePercent\n  1562→}\n  1563→```\n  1564→\n  1565→### 3. 陷阱伤害 (isTrapDamage)\n  1566→\n  1567→来自环境陷阱的伤害。\n  1568→\n  1569→**特点**:\n  1570→- 受诅咒\"陷阱目标\"影响\n  1571→- 可以同时伤害玩家和队友\n  1572→\n  1573→**修正代码**: [TakeDamageInfoPreProcessSystem.cs:244-247](TakeDamageInfoPreProcessSystem.cs:244-247)\n  1574→\n  1575→```csharp\n  1576→// 诅咒: 陷阱目标\n  1577→if (info.isTrapDamage && curse_TargetedTrapExtraDamageRatio > 0f)\n  1578→{\n  1579→    info.damage *= 1f + curse_TargetedTrapExtraDamageRatio;\n  1580→}\n  1581→```\n  1582→\n  1583→### 4. 穿透队友伤害 (isTeammateThrough)\n  1584→\n  1585→特殊技能可以穿透队友而不造成伤害。\n  1586→\n  1587→**应用场景**:\n  1588→- 某些特殊技能\n  1589→- 召唤物死亡爆炸\n  1590→\n  1591→**检查代码**:\n  1592→\n  1593→```csharp\n  1594→if (info.isTeammateThrough &&\n  1595→    targetPpt.unitCfg.unitType == UnitType.Teammate)\n  1596→{\n  1597→    info.immuneDamage = true;\n  1598→}\n  1599→```\n  1600→\n  1601→---\n  1602→\n  1603→## 伤害修正系统\n  1604→\n  1605→伤害修正分为多个层次:\n  1606→\n  1607→### 1. 基础伤害修正\n  1608→\n  1609→```\n  1610→基础伤害 = 技能配置伤害 * (1 + ExtraDamageRatio)\n  1611→\n  1612→ExtraDamageRatio 来源:\n  1613→- BattleData.extraDamageRatio          基础额外伤害\n  1614→- 遗物: 诅咒战士                       +5% per 诅咒\n  1615→- 遗物: 金钱即力量                     +X% per Y金币\n  1616→- 遗物: 增伤                           +固定%\n  1617→- 遗物: 强者                           +固定%\n  1618→- 遗物: 疯眼                           动态增长\n  1619→- 遗物: 狂战士                         低血增伤\n  1620→- 诅咒: 降低伤害和速度                 -固定%\n  1621→- 诅咒: 满血增伤                       动态变化\n  1622→```\n  1623→\n  1624→**计算位置**: [PlayerMgr.cs:157-196](PlayerMgr.cs:157-196)\n  1625→\n  1626→### 2. 受伤减免修正\n  1627→\n  1628→```\n  1629→最终伤害 = 基础伤害 * DamageReductionRatio\n  1630→\n  1631→DamageReductionRatio 来源:\n  1632→- 遗物: 减伤                           * (1 - X%)\n  1633→- 遗物: 强者增伤 (敌人)                * (1 + X%)\n  1634→- 诅咒: 脆弱                           * (1 + X%)\n  1635→- 诅咒: 金币增伤                       * (1 + X%)\n  1636→- 诅咒: 敌人减伤                       * (1 - X%)\n  1637→```\n  1638→\n  1639→### 3. 特殊比例修正\n  1640→\n  1641→```\n  1642→playerTakeDamageRatio:\n  1643→- 默认: 1.0\n  1644→- 特定技能可以修改\n  1645→\n  1646→teammateTakeDamageRatio:\n  1647→- 默认: 1.0\n  1648→- Boss技能对队友: 2.0 或 3.0\n  1649→```\n  1650→\n  1651→### 修正优先级\n  1652→\n  1653→```\n  1654→Priority 1: 特殊技能修正 (Boss技能对队友)\n  1655→    ↓\n  1656→Priority 2: 玩家基础修正 (无敌帧、闪避)\n  1657→    ↓\n  1658→Priority 3: 遗物/诅咒伤害比例\n  1659→    ↓\n  1660→Priority 4: 受伤比例 (playerTakeDamageRatio)\n  1661→    ↓\n  1662→Priority 5: 真实伤害特殊处理\n  1663→    ↓\n  1664→Priority 6: 易伤效果\n  1665→    ↓\n  1666→Priority 7: 暴击判定\n  1667→    ↓\n  1668→Priority 8: 伤害取整\n  1669→```\n  1670→\n  1671→---\n  1672→\n  1673→## 伤害公式总结\n  1674→\n  1675→### 完整伤害计算公式\n  1676→\n  1677→```\n  1678→最终伤害 = ⌈基础伤害 * 修正1 * 修正2 * ... * 修正N * 暴击倍率⌉\n  1679→\n  1680→其中:\n  1681→基础伤害 = 技能伤害 * (1 + ExtraDamageRatio)\n  1682→\n  1683→修正因子包括(按顺序):\n  1684→1. 特殊技能修正 (BossSpellModifier)\n  1685→2. 无敌帧检查 (→ immuneDamage)\n  1686→3. 闪避检查 (→ immuneDamage)\n  1687→4. 减伤遗物 (* (1 - relic_ReduceDamageRatio))\n  1688→5. 增伤遗物 (* (1 + relic_PowerfulManIncreaseDamage))\n  1689→6. 增伤诅咒 (* (1 + curse_VulnerabilityExtraDamageRatio))\n  1690→7. 金币增伤诅咒 (* (1 + curse_MoreMoneyMoreInjured))\n  1691→8. 受伤比例 (* playerTakeDamageRatio or teammateTakeDamageRatio)\n  1692→9. 真实伤害限制 (* min(undifferRatio, 0.3333))\n  1693→10. 易伤效果 (* DamageReciveIncresePercent)\n  1694→11. 暴击判定 (* criticalDamageRatio)\n  1695→\n  1696→⌈x⌉ = ceil(x)  // 向上取整\n  1697→```\n  1698→\n  1699→### 示例计算\n  1700→\n  1701→#### 场景: 玩家被敌人技能击中\n  1702→\n  1703→```\n  1704→技能原始伤害: 100\n  1705→玩家ExtraDamageRatio: 0  (敌人攻击不受玩家加成影响)\n  1706→遗物减伤20%\n  1707→诅咒脆弱+30%\n  1708→临时易伤+50%\n  1709→暴击率: 0.3 (30%)\n  1710→暴击判定: 成功\n  1711→\n  1712→计算过程:\n  1713→1. 基础伤害 = 100\n  1714→2. 应用减伤遗物: 100 * (1 - 0.2) = 80\n  1715→3. 应用脆弱诅咒: 80 * (1 + 0.3) = 104\n  1716→4. 应用易伤效果: 104 * 1.5 = 156\n  1717→5. 暴击判定成功: 156 * 2.0 = 312\n  1718→6. 向上取整: ⌈312⌉ = 312\n  1719→\n  1720→最终伤害: 312\n  1721→```\n  1722→\n  1723→#### 场景: 玩家攻击Boss\n  1724→\n  1725→```\n  1726→技能原始伤害: 50\n  1727→玩家ExtraDamageRatio: +50% (各种遗物)\n  1728→玩家ExtraCriticalRatio: +20%\n  1729→技能暴击率: 10%\n  1730→诅咒敌人减伤: -20%\n  1731→暴击判定: 失败\n  1732→\n  1733→计算过程:\n  1734→1. 基础伤害 = 50 * (1 + 0.5) = 75\n  1735→2. 敌人减伤诅咒: 75 * (1 - 0.2) = 60\n  1736→3. 暴击率 = 10% + 20% = 30%\n  1737→4. 暴击判定失败: 伤害不变\n  1738→5. 向上取整: ⌈60⌉ = 60\n  1739→\n  1740→最终伤害: 60\n  1741→```\n  1742→\n  1743→---\n  1744→\n  1745→## 总结\n  1746→\n  1747→### 关键特性\n  1748→\n  1749→1. **多阶段流水线**: 伤害经过7个系统依次处理\n  1750→2. **可中断性**: 任何阶段都可以将伤害设为免疫\n  1751→3. **护盾双重机制**: 永久护盾 + 临时护盾\n  1752→4. **暴击系统**: 默认x2,可通过遗物提升\n  1753→5. **特殊伤害类型**: 真实伤害、百分比伤害、陷阱伤害\n  1754→6. **伤害修正**: 遗物/诅咒/易伤多层修正\n  1755→\n  1756→### 性能优化\n  1757→\n  1758→1. **DOTS架构**: 使用Burst编译的Job进行并行处理\n  1759→2. **Buffer机制**: 每个Entity维护伤害信息缓冲区\n  1760→3. **每帧清理**: 避免内存泄漏\n  1761→\n  1762→### 扩展点\n  1763→\n  1764→1. **BeforeTakeDamage**: 受伤前自定义逻辑\n  1765→2. **AfterTakeDamage**: 受伤后自定义逻辑\n  1766→3. **遗物效果**: 在预处理阶段注入修正\n  1767→4. **诅咒效果**: 在预处理阶段注入修正\n  1768→\n  1769→---\n  1770→\n  1771→**文档版本**: 1.0\n  1772→**最后更新**: 2025-12-17\n  1773→**作者**: AI 代码分析助手\n  1774→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f9ea4e09-0190-4dbf-9604-2e1a11502695","timestamp":"2025-12-18T11:34:53.303Z","toolUseResult":{"type":"text","file":{"filePath":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\02-伤害计算系统详细.md","content":"# 伤害计算系统详细文档\n\n## 目录\n1. [系统概述](#系统概述)\n2. [伤害信息结构 (TakeDamageInfo)](#伤害信息结构-takedamageinfo)\n3. [伤害计算流程](#伤害计算流程)\n4. [伤害预处理系统](#伤害预处理系统)\n5. [受伤前处理系统](#受伤前处理系统)\n6. [受伤后处理系统](#受伤后处理系统)\n7. [死亡判定系统](#死亡判定系统)\n8. [护盾系统](#护盾系统)\n9. [暴击系统](#暴击系统)\n10. [特殊伤害类型](#特殊伤害类型)\n11. [伤害修正系统](#伤害修正系统)\n12. [伤害公式总结](#伤害公式总结)\n\n---\n\n## 系统概述\n\n伤害计算系统是战斗系统的核心,负责处理所有单位受到的伤害。该系统采用**多阶段流水线架构**,每个阶段负责不同的处理逻辑。\n\n### 设计原则\n\n1. **数据驱动**: 所有伤害数据封装在 `TakeDamageInfo_Dots` 结构体中\n2. **流水线处理**: 伤害信息经过多个 System 依次处理\n3. **可中断性**: 任何阶段都可以将伤害标记为免疫 (`immuneDamage`)\n4. **可扩展性**: 遗物/诅咒效果可以在各个阶段插入逻辑\n\n### 系统架构\n\n```\n[技能碰撞]\n    ↓ 创建 TakeDamageInfo_Dots\n[TakeDamageInfoPreProcessSystem]   预处理伤害\n    ↓ 计算暴击、应用遗物/诅咒修正\n[UnitBeforeTakeDamageSystem]       受伤前处理\n    ↓ 无敌帧、闪避、反弹\n[UnitPropertySystem]                属性更新\n    ↓ 扣除护盾和生命值\n[UnitAfterTakeDamageSystem]        受伤后处理\n    ↓ 击退、特效、音效\n[UnitTakeDamageDeadSystem]         死亡判定\n    ↓ 检查死亡、触发死亡事件\n[DamageRecordSystem]               伤害记录\n    ↓ 统计伤害数据\n[UnitTakeDamageClearSystem]        清除伤害信息\n    ↓ 清空本帧的伤害缓冲区\n```\n\n### System 执行顺序\n\n**文件位置**: 各个System文件头部的 `[UpdateInGroup]` 和 `[UpdateBefore/After]` 特性\n\n```csharp\n[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n[UpdateBefore(typeof(UnitBeforeTakeDamageSystem))]\n[UpdateAfter(typeof(UnitEnvironmentSystem))]\npublic struct TakeDamageInfoPreProcessSystem : ISystem\n\n[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n[UpdateBefore(typeof(UnitPropertySystem))]\npublic struct UnitBeforeTakeDamageSystem : ISystem\n\n[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n[UpdateAfter(typeof(UnitPropertySystem))]\n[UpdateBefore(typeof(UnitTakeDamageDeadSystem))]\npublic struct UnitAfterTakeDamageSystem : ISystem\n\n[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n[UpdateAfter(typeof(UnitAfterTakeDamageSystem))]\n[UpdateBefore(typeof(SpellTakeDamageResultSystem))]\npublic class UnitTakeDamageDeadSystem : SystemBase\n```\n\n---\n\n## 伤害信息结构 (TakeDamageInfo)\n\n**文件位置**: [TakeDamageInfo.cs](TakeDamageInfo.cs:1)\n\n### 数据结构\n\n伤害系统使用两个版本的数据结构:\n- **TakeDamageInfo**: MonoBehaviour 使用的版本\n- **TakeDamageInfo_Dots**: DOTS/ECS 使用的版本\n\n#### TakeDamageInfo (MonoBehaviour版本)\n\n```csharp\npublic class TakeDamageInfo\n{\n    // ========== 攻击者信息 ==========\n    public AttackerType attackerType;        // 攻击者类型\n    public UnitProperty attackerPpt;         // 攻击者单位属性\n\n    // ========== 被击者信息 ==========\n    public UnitProperty beHitPpt;            // 被击者单位属性\n\n    // ========== 伤害数值 ==========\n    public float damage;                     // 伤害值\n    public float criticalChance;             // 暴击率\n    public bool isCriticalDamage;            // 是否暴击\n\n    // ========== 击退信息 ==========\n    public Vector3 knockbackForce;           // 击退力度\n\n    // ========== 控制标志 ==========\n    public bool considerPlayerInInvincibleFrame = true;   // 是否考虑玩家无敌帧\n    public bool considerUmbrella = true;                  // 是否考虑雨伞格挡\n    public bool considerRelicDodge = true;                // 是否考虑遗物闪避\n    public bool considerRelicOrCurseDamageRatioChange = true;  // 是否应用遗物/诅咒伤害修正\n\n    // ========== 特效控制 ==========\n    public bool isPlayHitSE = true;          // 是否播放受击音效\n    public bool isPlayDeadSE = true;         // 是否播放死亡音效\n    public bool isCreateDeadEF = true;       // 是否创建死亡特效\n    public bool isCreatebloodSplat = true;   // 是否创建血迹\n    public bool beHitColor = true;           // 是否显示受击变色\n    public bool beHitShake = true;           // 是否镜头震动\n    public bool isFloatText = true;          // 是否显示浮动伤害数字\n\n    // ========== 特殊标志 ==========\n    public bool immuneDamage;                // 是否免疫此伤害\n    public bool isTargetDead;                // 目标是否死亡\n    public bool isTrapDamage;                // 是否为陷阱伤害\n    public bool canRebound;                  // 是否可以反弹\n    public bool stopAnnouncedDeath;          // 是否阻止宣布死亡\n    public bool isUndifferDamage;            // 是否为真实伤害\n    public bool isPercentageDamage;          // 是否为百分比伤害\n    public bool isTeammateThrough;           // 是否穿透队友\n\n    // ========== 伤害来源 ==========\n    public SpellBase spellBase;              // 技能对象引用\n\n    // ========== 充能数据 ==========\n    public WandPostSlotChargeData wandChargeData;  // 魔杖后置槽位充能数据\n\n    // ========== 伤害比例 ==========\n    public float playerTakeDamageRatio = 1f;       // 玩家受伤比例\n    public float teammateTakeDamageRatio = 1f;     // 队友受伤比例\n\n    // ========== 触发器 ==========\n    public bool postSlotSpellTakeDamageTrigger = true;  // 是否触发后置槽位技能\n}\n```\n\n#### TakeDamageInfo_Dots (DOTS版本)\n\n**文件位置**: [TakeDamageInfo_Dots.cs](TakeDamageInfo_Dots.cs:1)\n\n```csharp\npublic struct TakeDamageInfo_Dots : IBufferElementData\n{\n    // ========== Entity引用 ==========\n    public Entity attackerEntity;            // 攻击者Entity\n    public Entity targetEntity;              // 目标Entity\n\n    // ========== 攻击者类型 ==========\n    public AttackerType attackerType;\n\n    // ========== 伤害数值 ==========\n    public float damage;                     // 原始伤害\n    public float realDamage;                 // 实际造成的伤害(扣除护盾后)\n    public float hitMagicShieldDamage;       // 击中魔法盾的伤害\n\n    // ========== 暴击系统 ==========\n    public float extraCriticalChance;        // 额外暴击率\n    public bool isDamageCritical;            // 是否暴击\n\n    // ========== 击退 ==========\n    public float3 knockbackForce;            // 击退力(Unity.Mathematics)\n\n    // ========== 技能信息 ==========\n    public SpellInfo spell;                  // 技能信息(DOTS版本)\n\n    // ========== 标志位(与MonoBehaviour版本类似) ==========\n    public bool immuneDamage;\n    public bool ignorePlayerInvincibleFrame;\n    public bool ignoreRelicDodge;\n    public bool ignoreUmbrella;\n    public bool ignoreRelicOrCurseDamageRatioChange;\n    public bool isTrapDamage;\n    public bool isUndifferDamage;\n    public bool isPercentageDamage;\n    public bool isTeammateThrough;\n    public bool stopAnnouncedDeath;\n    public bool targetAlreadyDeadBeforeDamage;\n\n    // ========== 特效控制 ==========\n    public bool dontCreateDeadEF;\n    public bool dontCreatebloodSplat;\n    public bool dontPlayDeadSE;\n    public bool dontPlayHitSE;\n    public bool dontPlayBeHitColor;\n    public bool dontPlayBeHitShake;\n    public bool dontFloatText;\n\n    // ========== 伤害比例 ==========\n    public float playerTakeDamageRatio;\n    public float teammateTakeDamageRatio;\n\n    // ========== 充能相关 ==========\n    public bool chargeWand;                  // 是否充能魔杖\n    public float chargeValue;                // 充能值\n}\n```\n\n### AttackerType 枚举\n\n**文件位置**: [AttackerType.cs](AttackerType.cs:1)\n\n```csharp\npublic enum AttackerType\n{\n    NothingSpecial,      // 普通攻击\n    FromUI,              // 来自UI(点击返回营地按钮)\n    FromRelic,           // 来自遗物效果\n    FromCurse,           // 来自诅咒效果\n    FromEnvironment,     // 来自环境(陷阱、地刺等)\n    FromSpell,           // 来自技能\n    FromSummon           // 来自召唤物\n}\n```\n\n---\n\n## 伤害计算流程\n\n### 完整流程图\n\n```\n┌─────────────────────────────────────────────────┐\n│ 阶段 0: 伤害信息创建                            │\n│ 触发: 技能碰撞、技能持续伤害、环境伤害         │\n├─────────────────────────────────────────────────┤\n│ 创建 TakeDamageInfo_Dots 对象                   │\n│ - attackerEntity = spell.ownerEntity            │\n│ - targetEntity = hitUnit.entity                 │\n│ - damage = spell.damage                         │\n│ - criticalChance = spell.criticalChance         │\n│ - knockbackForce = spell.knockback * direction  │\n│                                                  │\n│ 添加到目标Entity的 DynamicBuffer                │\n│ entityMgr.GetBuffer<TakeDamageInfo_Dots>(target)│\n│           .Add(damageInfo);                      │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 1: 伤害预处理                              │\n│ System: TakeDamageInfoPreProcessSystem          │\n│ 文件: TakeDamageInfoPreProcessSystem.cs:157-336 │\n├─────────────────────────────────────────────────┤\n│ 1.1 检查无敌/禁用状态                           │\n│   if (unitPpt.IsInvincible)                     │\n│       info.immuneDamage = true                  │\n│   if (unitPpt.isSolidObj && !info.isUndifferDamage)│\n│       info.immuneDamage = true                  │\n│                                                  │\n│ 1.2 特殊技能伤害修正                            │\n│   - Boss技能对队友伤害 x2~x3                    │\n│   - 特定技能对玩家伤害 x0.05                    │\n│                                                  │\n│ 1.3 根据目标类型应用修正                        │\n│   switch (unitPpt.unitType):                    │\n│     case Player:                                │\n│       - 检查无敌帧                              │\n│       - 应用闪避遗物                            │\n│       - 应用减伤遗物                            │\n│       - 应用增伤诅咒                            │\n│       - 应用玩家受伤比例                        │\n│     case Teammate:                              │\n│       - 应用队友受伤比例                        │\n│     case Monster/Elite/Boss:                    │\n│       - 应用敌人减伤诅咒                        │\n│                                                  │\n│ 1.4 暴击判定                                    │\n│   if (Random.value <= criticalChance)           │\n│       info.isDamageCritical = true              │\n│       info.damage *= criticalDamageRatio        │\n│                                                  │\n│ 1.5 伤害取整                                    │\n│   info.damage = ceil(info.damage)               │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 2: 受伤前处理 (MonoBehaviour)              │\n│ System: UnitBeforeTakeDamageSystem              │\n│ 文件: UnitBeforeTakeDamageSystem.cs:255-276     │\n├─────────────────────────────────────────────────┤\n│ 调用 MonoBehaviour 的 BeforeTakeDamage() 方法  │\n│   unitPpt.UnitBas.BeforeTakeDamage_Dots(info)   │\n│                                                  │\n│ 此阶段由各个单位的 UnitBase 子类实现           │\n│ 常见逻辑:                                       │\n│ - Boss特殊阶段判定                              │\n│ - Elite特殊技能触发                             │\n│ - 遗物/诅咒特殊效果                             │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 3: 属性更新 (护盾和生命值扣除)            │\n│ System: UnitPropertySystem                      │\n│ 文件: UnitPropertySystem.cs (DOTS Job)          │\n├─────────────────────────────────────────────────┤\n│ 3.1 扣除护盾                                    │\n│   if (shield > 0)                               │\n│       damageToShield = min(damage, shield)      │\n│       shield -= damageToShield                  │\n│       damage -= damageToShield                  │\n│       realDamage = 0                            │\n│                                                  │\n│ 3.2 扣除临时护盾                                │\n│   if (shieldTemp > 0 && damage > 0)             │\n│       damageToTempShield = min(damage, shieldTemp)│\n│       shieldTemp -= damageToTempShield          │\n│       damage -= damageToTempShield              │\n│       realDamage += damageToTempShield          │\n│                                                  │\n│ 3.3 扣除生命值                                  │\n│   if (damage > 0)                               │\n│       currentHP -= damage                       │\n│       realDamage += damage                      │\n│                                                  │\n│ 3.4 应用击退                                    │\n│   if (!IsImmuneKnockback)                       │\n│       AddForce(knockbackForce * knockbackRatio) │\n│                                                  │\n│ 3.5 检查死亡                                    │\n│   if (currentHP <= 0)                           │\n│       isDead = true                             │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 4: 受伤后处理 (特效和音效)                │\n│ System: UnitAfterTakeDamageSystem               │\n│ 文件: UnitAfterTakeDamageSystem.cs:271-357      │\n├─────────────────────────────────────────────────┤\n│ 4.1 调用 MonoBehaviour 的 AfterTakeDamage()    │\n│   unitPpt.UnitBas.AfterTakeDamage_Dots(info)    │\n│                                                  │\n│ 4.2 播放受击音效                                │\n│   - 玩家: 根据外观播放不同音效                 │\n│     (Huang/Dave/Frog/Normal)                    │\n│   - 敌人: 播放配置的 beHitSE                    │\n│                                                  │\n│ 4.3 更新UI                                      │\n│   - 玩家: 更新HP条                              │\n│   - 玩家: 播放受击闪红动画                     │\n│                                                  │\n│ 4.4 触发遗物/诅咒效果                           │\n│   - OnTakeDamage 事件                           │\n│   - OnPlayerTakeDamage 事件                     │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 5: 死亡判定                                │\n│ System: UnitTakeDamageDeadSystem                │\n│ 文件: UnitTakeDamageDeadSystem.cs:224-410       │\n├─────────────────────────────────────────────────┤\n│ 5.1 检查是否死亡                                │\n│   if (!unitPpt.isDead) continue                 │\n│                                                  │\n│ 5.2 根据单位类型处理死亡                        │\n│   switch (unitType):                            │\n│     case Player:                                │\n│       - 记录死亡日志                            │\n│       - 显示死亡UI                              │\n│       - 触发 GameOver 事件                      │\n│                                                  │\n│     case Teammate:                              │\n│       - 添加 TeammateDeadTag 组件               │\n│       - 从房间管理器注销                        │\n│                                                  │\n│     case Monster/Elite/Boss:                    │\n│       - 掉落物品                                │\n│       - 创建死亡特效                            │\n│       - 播放死亡音效                            │\n│       - 创建尸体                                │\n│       - 创建血迹                                │\n│       - 从房间管理器注销                        │\n│       - 触发死亡事件                            │\n│                                                  │\n│ 5.3 特殊死亡效果                                │\n│   - 虚空爆炸 (Spell3129VoidExplosion)           │\n│   - 死亡蠕虫生成                                │\n│   - 召唤物死亡爆炸                              │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 6: 伤害记录                                │\n│ System: DamageRecordSystem                      │\n│ 文件: DamageRecordSystem.cs                     │\n├─────────────────────────────────────────────────┤\n│ 记录伤害到 DamageRecorder                       │\n│ - 按攻击者统计总伤害                            │\n│ - 按技能统计使用次数                            │\n│ - 更新伤害排行榜                                │\n│ - 更新UI显示                                    │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 7: 清除伤害信息                            │\n│ System: UnitTakeDamageClearSystem               │\n│ 文件: UnitTakeDamageClearSystem.cs              │\n├─────────────────────────────────────────────────┤\n│ 清空所有 Entity 的 TakeDamageInfo_Dots Buffer  │\n│ foreach (entity in allUnits)                    │\n│     GetBuffer<TakeDamageInfo_Dots>(entity).Clear()│\n└─────────────────────────────────────────────────┘\n```\n\n---\n\n## 伤害预处理系统\n\n**文件位置**: [TakeDamageInfoPreProcessSystem.cs](TakeDamageInfoPreProcessSystem.cs:1)\n\n这是伤害计算的第一个阶段,负责计算最终伤害值。\n\n### 主要职责\n\n1. 检查无敌状态\n2. 特殊技能伤害修正\n3. 应用遗物/诅咒修正\n4. 暴击判定\n5. 伤害取整\n\n### Execute 方法解析\n\n**位置**: [TakeDamageInfoPreProcessSystem.cs:157-336](TakeDamageInfoPreProcessSystem.cs:157-336)\n\n```csharp\nprivate void Execute(DynamicBuffer<TakeDamageInfo_Dots> takeDamageBuffer,\n                     ref UnitProperty_Dots unitPpt,\n                     Entity entity,\n                     [ChunkIndexInQuery] int index)\n{\n    // 1. 检查单位是否禁用\n    if (unitPpt.disabled)\n        return;\n\n    // 获取单位位置(用于闪避文字显示)\n    RefRO<LocalTransform> transform = cluLocalTsf.GetRefRO(entity);\n\n    // 遍历所有伤害信息\n    for (int i = 0; i < takeDamageBuffer.Length; i++)\n    {\n        ref TakeDamageInfo_Dots info = ref takeDamageBuffer.ElementAt(i);\n\n        // ========== 1. 基础免疫检查 ==========\n\n        // 1.1 无敌状态\n        if (unitPpt.IsInvincible)\n        {\n            info.immuneDamage = true;\n        }\n\n        // 1.2 固体物体免疫(除非是真实伤害)\n        if (unitPpt.unitCfg.isSolidObj && !info.isUndifferDamage)\n        {\n            info.immuneDamage = true;\n        }\n\n        // 1.3 已经死亡\n        if (unitPpt.isDead)\n        {\n            info.targetAlreadyDeadBeforeDamage = true;\n            continue;\n        }\n\n        // ========== 2. 特殊技能伤害修正 ==========\n\n        if (info.spell.Entity != Entity.Null)\n        {\n            int spellBaseID = info.spell.Config.Id / 10;\n\n            switch (spellBaseID)\n            {\n                // Boss技能对队友伤害 x2\n                case 9002: case 9004: case 9006: case 9017: case 9045:\n                    if (unitPpt.unitCfg.unitType == UnitType.Teammate ||\n                        unitPpt.unitCfg.unitType == UnitType.TeammateNotAttack)\n                    {\n                        info.damage *= 2f;\n                    }\n                    break;\n\n                // Boss技能对队友伤害 x3\n                case 9012: case 9020: case 9043:\n                case 9021: case 9022: case 9026: case 9027: case 9044:\n                    if (unitPpt.unitCfg.unitType == UnitType.Teammate ||\n                        unitPpt.unitCfg.unitType == UnitType.TeammateNotAttack)\n                    {\n                        info.damage *= 3f;\n                    }\n                    break;\n\n                // Boss15技能对玩家伤害 x0.05\n                case 9015:\n                    if (unitPpt.unitCfg.unitType == UnitType.Player)\n                    {\n                        info.damage *= 0.05f;\n                    }\n                    break;\n            }\n        }\n\n        // ========== 3. 根据目标类型应用修正 ==========\n\n        switch (unitPpt.unitCfg.unitType)\n        {\n            case UnitType.Player:\n                ProcessPlayerDamage(ref info, unitPpt, transform, index);\n                break;\n\n            case UnitType.Teammate:\n            case UnitType.TeammateNotAttack:\n                ProcessTeammateDamage(ref info);\n                break;\n\n            case UnitType.Monster:\n            case UnitType.Elite:\n            case UnitType.Boss:\n            case UnitType.WillAttack:\n            case UnitType.NotAttack:\n            case UnitType.Brittleness:\n                ProcessEnemyDamage(ref info);\n                break;\n        }\n\n        // ========== 4. 易伤效果 ==========\n\n        if (unitPpt.DamageReciveIncresePercent > 0f &&\n            !info.isPercentageDamage)\n        {\n            info.damage *= unitPpt.DamageReciveIncresePercent;\n        }\n\n        // ========== 5. 暴击判定 ==========\n\n        if (!info.isDamageCritical)\n        {\n            float critChance = info.extraCriticalChance;\n            if (info.spell.Entity != Entity.Null)\n            {\n                critChance = info.spell.Config.CriticalChance;\n            }\n\n            if (critChance > 0f &&\n                DTool.RandomValue(ref gRandom.ValueRW.random) <= critChance)\n            {\n                info.isDamageCritical = true;\n\n                // 暴击伤害倍率\n                if (IsPlayerAttack(info) && relic_AddCriticleDamageRatio > 0f)\n                {\n                    // 玩家有暴击伤害遗物\n                    info.damage *= relic_AddCriticleDamageRatio;\n                }\n                else\n                {\n                    // 默认暴击伤害 x2\n                    info.damage *= 2f;\n                }\n            }\n        }\n\n        // ========== 6. 伤害取整 ==========\n\n        info.damage = (int)math.ceil(info.damage);\n    }\n}\n```\n\n### 玩家伤害处理 (ProcessPlayerDamage)\n\n```csharp\nprivate void ProcessPlayerDamage(ref TakeDamageInfo_Dots info,\n                                  UnitProperty_Dots unitPpt,\n                                  RefRO<LocalTransform> transform,\n                                  int index)\n{\n    // 1. 特殊攻击类型: 来自UI(返回营地)\n    if (info.attackerType == AttackerType.FromUI)\n    {\n        // 直接清空生命值和护盾\n        unitPpt.unitCfg.currentHP = 0f;\n        unitPpt.unitCfg.shield = 0f;\n        unitPpt.unitCfg.shieldTemp = 0f;\n        return;\n    }\n\n    // 2. 无敌帧检查\n    if (!info.ignorePlayerInvincibleFrame &&\n        unitPpt.IsPlayerInInvincibleFrame)\n    {\n        info.knockbackForce = Vector3.zero;\n        info.immuneDamage = true;\n    }\n\n    // 3. 陷阱伤害加成 (诅咒: 陷阱目标)\n    if (info.isTrapDamage && curse_TargetedTrapExtraDamageRatio > 0f)\n    {\n        info.damage *= 1f + curse_TargetedTrapExtraDamageRatio;\n    }\n\n    // 4. 闪避检查 (遗物)\n    if (relic_DodgeChance > 0f &&\n        !info.ignoreRelicDodge &&\n        DTool.RandomValue(ref gRandom.ValueRW.random) <= relic_DodgeChance)\n    {\n        info.knockbackForce = Vector3.zero;\n        info.immuneDamage = true;\n\n        // 显示\"闪避\"浮动文字\n        ecb.AppendToBuffer(index, uiTextFloatByJobEtt,\n            new UITextFloatByJobBED\n            {\n                textID = 1002001,  // \"闪避\"\n                type = UITextFloatType.Normal,\n                worldPos = transform.ValueRO.Position\n            });\n    }\n\n    // 5. 减伤遗物\n    if (relic_ReduceDamageRatio > 0f &&\n        !info.ignoreRelicOrCurseDamageRatioChange)\n    {\n        info.damage *= 1f - relic_ReduceDamageRatio;\n    }\n\n    // 6. 增伤遗物: 强者\n    if (relic_PowerfulManIncreaseDamage > 0f &&\n        !info.ignoreRelicOrCurseDamageRatioChange)\n    {\n        info.damage *= 1f + relic_PowerfulManIncreaseDamage;\n    }\n\n    // 7. 增伤诅咒: 脆弱\n    if (curse_VulnerabilityExtraDamageRatio > 0f &&\n        !info.ignoreRelicOrCurseDamageRatioChange)\n    {\n        info.damage *= 1f + curse_VulnerabilityExtraDamageRatio;\n    }\n\n    // 8. 增伤诅咒: 金币越多受伤越高\n    if (curse_MoreMoneyMoreInjuredExtraDamageRatio > 0f &&\n        !info.ignoreRelicOrCurseDamageRatioChange)\n    {\n        info.damage *= 1f + curse_MoreMoneyMoreInjuredExtraDamageRatio;\n    }\n\n    // 9. 应用玩家受伤比例\n    if (info.playerTakeDamageRatio != 1f)\n    {\n        info.damage *= info.playerTakeDamageRatio;\n    }\n\n    // 10. 真实伤害特殊处理\n    if (info.isUndifferDamage)\n    {\n        if (info.spell.Entity != Entity.Null)\n        {\n            // 限制真实伤害最多为33.33%\n            info.damage *= math.min(\n                info.spell.Config.UndifferDamageRatio,\n                0.3333f\n            );\n        }\n        else\n        {\n            info.damage *= 0.3333f;\n        }\n    }\n}\n```\n\n### 队友伤害处理\n\n```csharp\nprivate void ProcessTeammateDamage(ref TakeDamageInfo_Dots info)\n{\n    // 1. 陷阱伤害加成\n    if (info.isTrapDamage && curse_TargetedTrapExtraDamageRatio > 0f)\n    {\n        info.damage *= 1f + curse_TargetedTrapExtraDamageRatio;\n    }\n\n    // 2. 应用队友受伤比例\n    info.damage *= info.teammateTakeDamageRatio;\n}\n```\n\n### 敌人伤害处理\n\n```csharp\nprivate void ProcessEnemyDamage(ref TakeDamageInfo_Dots info)\n{\n    // 诅咒: 敌人减伤\n    if (curse_EnemyReduceDamageRatio > 0f &&\n        !info.isPercentageDamage)\n    {\n        info.damage *= 1f - curse_EnemyReduceDamageRatio;\n    }\n}\n```\n\n---\n\n## 受伤前处理系统\n\n**文件位置**: [UnitBeforeTakeDamageSystem.cs](UnitBeforeTakeDamageSystem.cs:1)\n\n这个系统在伤害应用前调用各个单位的 `BeforeTakeDamage_Dots` 方法,允许单位进行自定义处理。\n\n### OnUpdate 方法\n\n**位置**: [UnitBeforeTakeDamageSystem.cs:255-286](UnitBeforeTakeDamageSystem.cs:255-286)\n\n```csharp\npublic void OnUpdate(ref SystemState state)\n{\n    // 特殊处理: Boss6第二阶段\n    bool isBoss6Stage2 = false;\n    if (Boss6_Stage2.Inst != null &&\n        !Boss6_Stage2.Inst.myPpt.AlreadyDead &&\n        UnitDotsSyncSystem.EntityIsValid(Boss6_Stage2.Inst.myPpt.myEntity))\n    {\n        isBoss6Stage2 = true;\n        Boss6_Stage2.Inst.takeDamageInfoBuffer =\n            state.EntityManager.GetBuffer<TakeDamageInfo_Dots>(\n                Boss6_Stage2.Inst.myPpt.myEntity);\n    }\n\n    // 遍历所有有伤害信息的单位\n    foreach (var (unitPptReference, damageBuffer) in Query(...))\n    {\n        if (damageBuffer.Length <= 0)\n            continue;\n\n        // 遍历该单位的所有伤害信息\n        for (int i = 0; i < damageBuffer.Length; i++)\n        {\n            // 特殊排除: 某个特定单位ID\n            if (unitPptReference.unitPpt.unitCfg.id != 500621)\n            {\n                // 调用 MonoBehaviour 的受伤前处理\n                unitPptReference.unitPpt.UnitBas.BeforeTakeDamage_Dots(\n                    ref damageBuffer.ElementAt(i)\n                );\n            }\n        }\n    }\n\n    // Boss6特殊处理\n    if (isBoss6Stage2)\n    {\n        DynamicBuffer<TakeDamageInfo_Dots> buffer =\n            state.EntityManager.GetBuffer<TakeDamageInfo_Dots>(\n                Boss6_Stage2.Inst.myPpt.myEntity);\n\n        for (int j = 0; j < buffer.Length; j++)\n        {\n            Boss6_Stage2.Inst.BeforeTakeDamage_Dots(\n                ref buffer.ElementAt(j)\n            );\n        }\n    }\n}\n```\n\n### UnitBase.BeforeTakeDamage_Dots 虚方法\n\n**文件位置**: [UnitBase.cs:453-455](UnitBase.cs:453-455)\n\n```csharp\npublic virtual void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n{\n    // 默认为空,由子类重写\n    // 例如:\n    // - Boss进入特殊阶段\n    // - Elite触发特殊技能\n    // - 遗物效果触发\n}\n```\n\n### 常见用途示例\n\n#### 示例 1: Boss阶段切换\n\n```csharp\n// Boss1.cs\npublic override void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n{\n    UnitProperty_Dots ppt = GetComponentData<UnitProperty_Dots>();\n\n    // 当HP低于50%时进入狂暴阶段\n    if (!isEnraged && ppt.unitCfg.currentHP < ppt.unitCfg.maxHP * 0.5f)\n    {\n        isEnraged = true;\n        EnterEnragedPhase();\n    }\n}\n```\n\n#### 示例 2: 遗物触发\n\n```csharp\n// PlayerController.cs\npublic override void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n{\n    // 遗物: 受伤时获得护盾\n    if (PlayerMgr.Inst.ItemCtrller.relic_ShieldOnHit != null)\n    {\n        float shieldAmount = info.damage * 0.2f;\n        PlayerMgr.Inst.ChangeShield(shieldAmount);\n    }\n\n    // 遗物: 受伤时触发反击\n    if (PlayerMgr.Inst.ItemCtrller.relic_CounterAttack != null)\n    {\n        LaunchCounterAttack(info.attackerEntity);\n    }\n}\n```\n\n---\n\n## 受伤后处理系统\n\n**文件位置**: [UnitAfterTakeDamageSystem.cs](UnitAfterTakeDamageSystem.cs:1)\n\n这个系统在伤害应用后处理特效、音效和UI更新。\n\n### OnUpdate 方法\n\n**位置**: [UnitAfterTakeDamageSystem.cs:271-357](UnitAfterTakeDamageSystem.cs:271-357)\n\n```csharp\npublic void OnUpdate(ref SystemState state)\n{\n    foreach (var (unitDead, unitPpt, damageBuffer, entity) in Query(...))\n    {\n        if (damageBuffer.Length <= 0)\n            continue;\n\n        bool hasRealDamage = false;\n\n        // ========== 1. 检查是否有实际伤害 ==========\n\n        if (unitPpt.ValueRO.unitCfg.isHybirdUnit)\n        {\n            // 混合单位(Mono + DOTS)\n            UnitPptReference unitPptRef = null;\n\n            for (int i = 0; i < damageBuffer.Length; i++)\n            {\n                if (!damageBuffer[i].immuneDamage &&\n                    damageBuffer[i].realDamage > 0f)\n                {\n                    hasRealDamage = true;\n\n                    if (unitPptRef == null)\n                    {\n                        unitPptRef = state.EntityManager\n                            .GetComponentObject<UnitPptReference>(entity);\n                    }\n\n                    if (!unitPpt.ValueRO.isDead)\n                    {\n                        // 调用 MonoBehaviour 的受伤后处理\n                        unitPptRef.unitPpt.UnitBas.AfterTakeDamage_Dots(\n                            ref damageBuffer.ElementAt(i)\n                        );\n                    }\n                }\n            }\n        }\n        else\n        {\n            // 纯 DOTS 单位\n            for (int j = 0; j < damageBuffer.Length; j++)\n            {\n                if (!damageBuffer[j].immuneDamage &&\n                    damageBuffer[j].realDamage > 0f)\n                {\n                    hasRealDamage = true;\n                    break;\n                }\n            }\n        }\n\n        // ========== 2. 播放受击音效 ==========\n\n        if (unitPpt.ValueRO.unitCfg.id == 800001)  // 玩家\n        {\n            ref PlayerController_Dots playerCtrl =\n                ref GetComponentRW<PlayerController_Dots>(entity).ValueRW;\n\n            if (playerCtrl.isHurtThisFrameForPlayer)\n            {\n                playerCtrl.isHurtThisFrameForPlayer = false;\n\n                // 更新HP UI\n                UIPlayerDataMgr.Inst.UpdateHP();\n\n                // 根据外观播放不同音效\n                if (PlayerMgr.Inst.ItemCtrller.relic_Huang != null)\n                {\n                    SEMgr.Inst.injured_Huang.PlaySE();\n                }\n                else if (PlayerMgr.Inst.ItemCtrller.uiRelic_DaveHarpoons != null)\n                {\n                    SEMgr.Inst.injured_Dave.PlaySE();\n                }\n                else if (DataMgr.selectedWorldData.playerLook == PlayerLook.Frog)\n                {\n                    SEMgr.Inst.injured_Frog.PlaySE();\n                }\n                else\n                {\n                    SEMgr.Inst.injured_Player.PlaySE();\n                }\n\n                // 播放受击闪红动画\n                if (!GameMgr.IsHarmony_Static)\n                {\n                    UIPlayerDataMgr.Inst.UIPlayerInjuredPlay();\n                }\n            }\n        }\n        else if (hasRealDamage && unitPpt.ValueRO.unitCfg.id != 800001)  // 敌人\n        {\n            // 播放敌人受击音效\n            UnitConfig.map[unitPpt.ValueRO.unitCfg.id]\n                .beHitSE.Value.PlaySE(SEPlayMode.Unique, 3, 0.2f);\n        }\n    }\n\n    // ========== 3. 玩家特殊处理 ==========\n\n    DynamicBuffer<TakeDamageInfo_Dots> playerDamageBuffer =\n        GetBuffer<TakeDamageInfo_Dots>(PlayerMgr.Inst.PlayerEtt);\n    UnitProperty_Dots playerPpt =\n        GetComponent<UnitProperty_Dots>(PlayerMgr.Inst.PlayerEtt);\n\n    for (int k = 0; k < playerDamageBuffer.Length; k++)\n    {\n        TakeDamageInfo_Dots info = playerDamageBuffer[k];\n\n        if (!info.immuneDamage &&\n            (info.realDamage > 0f || info.hitMagicShieldDamage > 0f) &&\n            !playerPpt.isDead)\n        {\n            // 调用玩家控制器的受伤后处理\n            PlayerMgr.Inst.PlayerCtrller.AfterTakeDamage(\n                ref playerDamageBuffer.ElementAt(k)\n            );\n        }\n    }\n}\n```\n\n### UnitBase.AfterTakeDamage_Dots 虚方法\n\n**文件位置**: [UnitBase.cs:461-463](UnitBase.cs:461-463)\n\n```csharp\npublic virtual void AfterTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n{\n    // 默认为空,由子类重写\n    // 例如:\n    // - 播放受击动画\n    // - 创建受击特效\n    // - 触发反弹\n    // - 生成血液粒子\n}\n```\n\n---\n\n## 死亡判定系统\n\n**文件位置**: [UnitTakeDamageDeadSystem.cs](UnitTakeDamageDeadSystem.cs:1)\n\n### OnUpdate 方法\n\n**位置**: [UnitTakeDamageDeadSystem.cs:210-410](UnitTakeDamageDeadSystem.cs:210-410)\n\n```csharp\nprotected unsafe override void OnUpdate()\n{\n    EntityCommandBuffer ecb = GetSingleton<EndSimulationECBSystem.Singleton>()\n        .CreateCommandBuffer(World.Unmanaged);\n\n    Entity uiTextFloatEntity = GetSingletonEntity<UITextFloatByJobSingleton>();\n\n    // 清理缓存\n    _deadPpts.Clear();\n    _deadInfos.Clear();\n    _deadInfoIndex.Clear();\n    deadEntities.Clear();\n\n    // 遍历所有已死亡的单位\n    foreach (var (unitDead, unitPpt, transform, entity) in Query(...))\n    {\n        if (!unitPpt.ValueRO.isDead)\n            continue;\n\n        ref UnitDead deadData = ref unitDead.ValueRW;\n        LocalTransform pos = transform.ValueRO;\n\n        // 玩家最终死亡检查\n        if (deadData.playerFinallyDead)\n            break;\n\n        // ========== 1. 队友死亡处理 ==========\n\n        if (unitPpt.ValueRO.unitCfg.unitType == UnitType.Teammate ||\n            unitPpt.ValueRO.unitCfg.unitType == UnitType.TeammateNotAttack)\n        {\n            // 添加队友死亡标签\n            SetComponentEnabled<TeammateDeadTag>(entity, true);\n            continue;\n        }\n\n        // ========== 2. 掉落物品 ==========\n\n        if (unitPpt.ValueRO.deadDropItemInfos.IsCreated &&\n            unitPpt.ValueRO.deadDropItemInfos.Value.Length > 0)\n        {\n            QuickCreateSystem.Inst.CreateItemDrop(\n                LevelMgr.Inst.CurrentRoomMapPos,\n                unitPpt.ValueRO.deadDropItemInfos,\n                Tool2D.IgnoreZPoint(pos.Position),\n                0.2f\n            );\n        }\n\n        // ========== 3. 虚空爆炸检查 ==========\n\n        if ((unitPpt.ValueRO.unitCfg.triggerDeadEvent ||\n             IsSpecialVoidExplosionUnit(unitPpt.ValueRO.unitCfg.id)) &&\n            unitPpt.ValueRO.voidExplosionData.InstantKillRatio > 0f)\n        {\n            // 创建虚空爆炸\n            GameObject voidExplosion = ObjPoolMgr.Inst.GetGO(\n                \"Prefabs/Spell/\" + 31291,\n                pos.Position,\n                2.5f\n            );\n            voidExplosion.transform.localScale = Vector3.one;\n            voidExplosion.GetComponent<Spell3129VoidExplosion>()\n                .DataInitialize_Dots(\n                    unitPpt.ValueRO.unitCfg.maxHP,\n                    unitPpt.ValueRO.voidExplosionData\n                );\n\n            // 创建爆炸粒子\n            ecb.AppendToBuffer(uiTextFloatEntity,\n                new GlobalParticleEmitParams(\n                    GlobalParticleType.Spell,\n                    \"3129_Explosion\",\n                    pos.Position\n                )\n                { Size = 0.417f }\n            );\n        }\n\n        // ========== 4. 死亡特效 ==========\n\n        if (!deadData.deadlyInfo.dontCreateDeadEF)\n        {\n            if (unitPpt.ValueRO.unitCfg.deadEF != \"\")\n            {\n                bool isSummonTransparent =\n                    (unitPpt.ValueRO.unitCfg.unitType == UnitType.Teammate ||\n                     unitPpt.ValueRO.unitCfg.unitType == UnitType.TeammateNotAttack) &&\n                    DataMgr.settingData.FinalSummonTransparent <= 0.01f;\n\n                if (!isSummonTransparent)\n                {\n                    string effectPath = \"Prefabs/EF/\" +\n                        unitPpt.ValueRO.unitCfg.deadEF.ToString();\n\n                    // 特殊处理: 血液/幽灵死亡特效有多个变体\n                    if (unitPpt.ValueRO.unitCfg.deadEF == \"EF_Dead_Blood\" ||\n                        unitPpt.ValueRO.unitCfg.deadEF == \"EF_Dead_Ghost\")\n                    {\n                        effectPath += \"_\" + UnityEngine.Random.Range(0, 2);\n\n                        // 使用精灵特效系统\n                        SpriteEffectAnima anima =\n                            ABResources.LoadAsset<SpriteEffectAnima>(effectPath);\n\n                        float3 offset = new float3(\n                            UnityEngine.Random.Range(-0.1f, 0.1f),\n                            0.3f + UnityEngine.Random.Range(-0.1f, 0.1f),\n                            0f\n                        );\n\n                        float radius = GetEntityRadius(entity);\n\n                        SpellSpriteEffectController.Inst.PlayEffect(anima,\n                            new EffectPlayParam\n                            {\n                                Position = pos.Position + offset,\n                                Scale = Vector3.one * Mathf.Max(1f, radius * 2f + 0.3f),\n                                FilpX = (UnityEngine.Random.Range(0, 2) == 0),\n                                Unlit = false\n                            }\n                        );\n                    }\n                    else\n                    {\n                        ObjPoolMgr.Inst.GetGO(effectPath, pos.Position, 5f);\n                    }\n                }\n            }\n        }\n\n        // ========== 5. 永久死亡特效 ==========\n\n        if (unitPpt.ValueRO.unitCfg.deadPermanentEF.ToString() != \"\")\n        {\n            ObjPoolMgr.Inst.GetGO(\n                \"Prefabs/EF/\" + unitPpt.ValueRO.unitCfg.deadPermanentEF.ToString(),\n                pos.Position\n            );\n        }\n\n        // ========== 6. 血迹 ==========\n\n        if (!deadData.deadlyInfo.dontCreatebloodSplat &&\n            unitPpt.ValueRO.unitCfg.bloodSplatSize > 0f)\n        {\n            if (deadData.deadlyInfo.knockbackForce == Vector3.zero)\n            {\n                // 无方向血迹\n                ObjPoolMgr.Inst.GetGO(\"Prefabs/EF/EF_BloodSplat\",\n                    Tool2D.IgnoreZPoint(pos.Position))\n                    .GetComponent<BloodSplat>()\n                    .Initialize(unitPpt.ValueRO.unitCfg.bloodSplatSize);\n            }\n            else\n            {\n                // 有方向血迹\n                ObjPoolMgr.Inst.GetGO(\"Prefabs/EF/EF_BloodSplatDirect\",\n                    Tool2D.IgnoreZPoint(pos.Position))\n                    .GetComponent<BloodSplat>()\n                    .Initialize(\n                        unitPpt.ValueRO.unitCfg.bloodSplatSize,\n                        deadData.deadlyInfo.knockbackForce\n                    );\n            }\n        }\n\n        // ========== 7. 尸体 ==========\n\n        int corpseCount = unitPpt.ValueRO.unitCfg.corpseCount;\n        if (GameMgr.IsMobile_Static)\n        {\n            corpseCount = (int)(corpseCount * 0.5);  // 移动端减半\n        }\n\n        if (unitPpt.ValueRO.unitCfg.corpseType != CorpseType.None)\n        {\n            for (int i = 0; i < corpseCount; i++)\n            {\n                CorpseSystem.Inst.CreateCorpse(\n                    unitPpt.ValueRO.unitCfg.corpseType,\n                    pos.Position,\n                    deadData.deadlyInfo.knockbackForce\n                );\n            }\n        }\n\n        // ========== 8. 死亡音效 ==========\n\n        if (!deadData.deadlyInfo.dontPlayDeadSE)\n        {\n            if (unitPpt.ValueRO.unitCfg.isDeadSE3D)\n            {\n                unitPpt.ValueRO.unitCfg.deadSEs.Value.PlaySE(pos.Position);\n            }\n            else\n            {\n                unitPpt.ValueRO.unitCfg.deadSEs.Value.PlaySE();\n            }\n        }\n\n        // ========== 9. 根据单位类型处理死亡 ==========\n\n        switch (unitPpt.ValueRO.unitCfg.unitType)\n        {\n            case UnitType.Player:\n                HandlePlayerDeath(ref deadData, entity);\n                break;\n\n            case UnitType.Teammate:\n            case UnitType.TeammateNotAttack:\n                LevelMgr.Inst.CurrentRoomCtrller.UnitUnregister(entity);\n                break;\n\n            case UnitType.Monster:\n            case UnitType.Elite:\n            case UnitType.Boss:\n            case UnitType.WillAttack:\n            case UnitType.NotAttack:\n            case UnitType.Brittleness:\n                if (!unitPpt.ValueRO.unitCfg.isHybirdUnit)\n                {\n                    LevelMgr.Inst.CurrentRoomCtrller.UnitUnregister(entity);\n                }\n                break;\n        }\n    }\n}\n```\n\n### 玩家死亡处理\n\n```csharp\nprivate void HandlePlayerDeath(ref UnitDead deadData, Entity entity)\n{\n    Debug.Log(\"Player Dead\");\n\n    // 记录死亡次数\n    DataMgr.selectedWorldData.deadCount++;\n\n    TakeDamageInfo_Dots deadlyInfo = deadData.deadlyInfo;\n\n    // 记录击杀者\n    if (deadlyInfo.attackerEntity != Entity.Null)\n    {\n        if (HasComponent<UnitProperty_Dots>(deadlyInfo.attackerEntity))\n        {\n            int killerID = GetComponent<UnitProperty_Dots>(\n                deadlyInfo.attackerEntity\n            ).unitCfg.id;\n            Debug.Log(\"击杀者id: \" + killerID);\n        }\n        else\n        {\n            Debug.Log(\"击杀者id已经不可考证\");\n        }\n    }\n\n    // 标记玩家最终死亡\n    deadData.playerFinallyDead = true;\n\n    // 记录死亡日志\n    PlayerDeathLogger logger = new PlayerDeathLogger();\n    logger.death_counter = DataMgr.selectedWorldData.deadCount;\n    logger.equips = PlayerEquips.CreateAuto();\n    logger.monsters = LevelMgr.Inst.CurrentRoomCtrller.MonsterPpts\n        .Select(e => e.unitCfg.id).ToList();\n    logger.resources = ResourcesStatus.CreateAuto();\n    logger.click_return_camp =\n        (deadlyInfo.attackerType == AttackerType.FromUI);\n    logger.Report();\n\n    // 移动端数据上报\n    if (GameMgr.IsMobile_Static)\n    {\n        MobileMgr.inst.PluginActivity.UploadItemSnapshot(1);\n    }\n\n    // 触发玩家死亡事件\n    EventMgr.PlayerDead?.Invoke();\n\n    // 显示死亡UI\n    GameUISingletonMono<UIPlayerDead>.ShowInit();\n}\n```\n\n---\n\n## 护盾系统\n\n护盾分为两种类型:\n1. **永久护盾 (shield)**: 不会随时间消失\n2. **临时护盾 (shieldTemp)**: 进门时清除\n\n### 护盾扣除顺序\n\n**位置**: [UnitPropertySystem.cs](UnitPropertySystem.cs:1) (DOTS Job)\n\n```\n伤害应用顺序:\n1. 永久护盾 (shield)\n2. 临时护盾 (shieldTemp)\n3. 生命值 (currentHP)\n```\n\n### 护盾计算伪代码\n\n```csharp\nfloat originalDamage = damageInfo.damage;\nfloat remainingDamage = originalDamage;\nfloat realDamage = 0f;  // 实际造成的伤害(用于统计)\n\n// 1. 扣除永久护盾\nif (shield > 0 && remainingDamage > 0)\n{\n    float damageToShield = Min(remainingDamage, shield);\n    shield -= damageToShield;\n    remainingDamage -= damageToShield;\n    // 注意: 护盾吸收的伤害不计入realDamage\n}\n\n// 2. 扣除临时护盾\nif (shieldTemp > 0 && remainingDamage > 0)\n{\n    float damageToTempShield = Min(remainingDamage, shieldTemp);\n    shieldTemp -= damageToTempShield;\n    remainingDamage -= damageToTempShield;\n    realDamage += damageToTempShield;  // 临时护盾计入实际伤害\n}\n\n// 3. 扣除生命值\nif (remainingDamage > 0)\n{\n    currentHP -= remainingDamage;\n    realDamage += remainingDamage;\n\n    if (currentHP < 0)\n    {\n        currentHP = 0;\n    }\n}\n\n// 4. 检查死亡\nif (currentHP <= 0 && !isDead)\n{\n    isDead = true;\n}\n```\n\n### 护盾来源\n\n#### 1. 遗物提供的护盾\n\n```csharp\n// 遗物: 进门获得护盾\nif (ItemCtrller.relicCfg_FloorShield != null)\n{\n    PlayerMgr.Inst.ChangeShield(relicCfg_FloorShield.int1.result);\n}\n\n// 遗物: 临时护盾\nif (ItemCtrller.relicCfg_TempShield != null)\n{\n    PlayerMgr.Inst.ChangeShieldTemp(relicCfg_TempShield.int1.result);\n}\n```\n\n#### 2. 遗物组提供的护盾\n\n```csharp\n// 遗物组1: 临时护盾转永久护盾\nif (ItemCtrller.relicGroupConfigs.TryGetValue(1, out var config))\n{\n    float shieldPercent = config.int1.result / 100f;\n    float permanentShield = playerPpt.unitCfg.shieldTemp * shieldPercent;\n    PlayerMgr.Inst.ChangeShield(permanentShield);\n}\n```\n\n### ChangeShield 方法\n\n**位置**: [PlayerMgr.cs](PlayerMgr.cs:1)\n\n```csharp\npublic void ChangeShield(float value)\n{\n    EntityManager ettMgr = World.DefaultGameObjectInjectionWorld.EntityManager;\n    UnitProperty_Dots ppt = ettMgr.GetComponentData<UnitProperty_Dots>(PlayerEtt);\n\n    ppt.unitCfg.shield += value;\n\n    // 限制护盾上限\n    float maxShield = ppt.unitCfg.maxHP * 0.5f;  // 最大护盾为最大HP的50%\n    if (ppt.unitCfg.shield > maxShield)\n    {\n        ppt.unitCfg.shield = maxShield;\n    }\n\n    ettMgr.SetComponentData(PlayerEtt, ppt);\n\n    // 更新UI\n    UIPlayerDataMgr.Inst.UpdateHP();\n}\n```\n\n---\n\n## 暴击系统\n\n### 暴击判定流程\n\n```\n1. 获取暴击率\n   ├─ 技能配置的暴击率 (SpellConfig.criticalChance)\n   ├─ 额外暴击率 (TakeDamageInfo.extraCriticalChance)\n   └─ 玩家属性加成 (PlayerMgr.ExtraCriticalRatio)\n\n2. 随机判定\n   if (Random.value <= totalCriticalChance)\n       触发暴击\n\n3. 暴击伤害倍率\n   ├─ 默认: x2.0\n   └─ 遗物加成: x (2.0 + relic_AddCriticleDamageRatio)\n```\n\n### 暴击率计算\n\n**位置**: [PlayerMgr.cs:198-213](PlayerMgr.cs:198-213)\n\n```csharp\npublic float ExtraCriticalRatio\n{\n    get\n    {\n        float ratio = BaData.extraCriticalChance;  // 基础额外暴击率\n\n        // 遗物: 增加暴击率\n        if (ItemCtrller.relicCfg_AddCriticalChance != null)\n        {\n            ratio += (float)relicCfg_AddCriticalChance.int1.result / 100f;\n        }\n\n        // 诅咒: 减少暴击率\n        if (ItemCtrller.curseCfg_ReduceCriticalRatio != null)\n        {\n            ratio += (float)curseCfg_ReduceCriticalRatio.int1.result / 100f;\n        }\n\n        return ratio;\n    }\n}\n```\n\n### 暴击判定代码\n\n**位置**: [TakeDamageInfoPreProcessSystem.cs:315-334](TakeDamageInfoPreProcessSystem.cs:315-334)\n\n```csharp\nif (!info.isDamageCritical)\n{\n    // 获取暴击率\n    float critChance = info.extraCriticalChance;\n    if (info.spell.Entity != Entity.Null)\n    {\n        critChance = info.spell.Config.CriticalChance;\n    }\n\n    // 暴击判定\n    if (critChance > 0f &&\n        DTool.RandomValue(ref gRandom.ValueRW.random) <= critChance)\n    {\n        info.isDamageCritical = true;\n\n        // 计算暴击伤害\n        if (IsPlayerAttack(info) && relic_AddCriticleDamageRatio > 0f)\n        {\n            // 玩家有暴击伤害遗物\n            info.damage *= relic_AddCriticleDamageRatio;\n        }\n        else\n        {\n            // 默认暴击伤害 x2\n            info.damage *= 2f;\n        }\n    }\n}\n```\n\n### 暴击显示\n\n```csharp\n// 创建伤害数字时检查暴击标志\nif (info.isDamageCritical)\n{\n    // 显示黄色大号字体\n    CreateFloatText(\n        damage,\n        position,\n        Color.yellow,\n        scale: 1.5f\n    );\n}\nelse\n{\n    // 显示白色普通字体\n    CreateFloatText(\n        damage,\n        position,\n        Color.white,\n        scale: 1.0f\n    );\n}\n```\n\n---\n\n## 特殊伤害类型\n\n### 1. 真实伤害 (isUndifferDamage)\n\n真实伤害无视大部分防御机制,但有特殊限制。\n\n**特点**:\n- 无视固体物体免疫\n- 对玩家伤害限制在33.33%\n- 不受诅咒减伤影响\n\n**应用代码**: [TakeDamageInfoPreProcessSystem.cs:279-289](TakeDamageInfoPreProcessSystem.cs:279-289)\n\n```csharp\nif (info.isUndifferDamage)\n{\n    if (info.spell.Entity != Entity.Null)\n    {\n        // 限制真实伤害最多为配置值或33.33%,取较小值\n        info.damage *= math.min(\n            info.spell.Config.UndifferDamageRatio,\n            0.3333f\n        );\n    }\n    else\n    {\n        // 默认33.33%\n        info.damage *= 0.3333f;\n    }\n}\n```\n\n### 2. 百分比伤害 (isPercentageDamage)\n\n按目标最大生命值百分比造成伤害。\n\n**特点**:\n- 不受伤害加成/减免影响\n- 不受易伤效果影响\n- 适合对高血量敌人\n\n**计算代码**:\n\n```csharp\nif (info.isPercentageDamage)\n{\n    float maxHP = unitPpt.unitCfg.maxHP;\n    info.damage = maxHP * damagePercent;\n\n    // 注意: 百分比伤害不受以下影响\n    // - relic_ReduceDamageRatio\n    // - curse_VulnerabilityExtraDamageRatio\n    // - DamageReciveIncresePercent\n}\n```\n\n### 3. 陷阱伤害 (isTrapDamage)\n\n来自环境陷阱的伤害。\n\n**特点**:\n- 受诅咒\"陷阱目标\"影响\n- 可以同时伤害玩家和队友\n\n**修正代码**: [TakeDamageInfoPreProcessSystem.cs:244-247](TakeDamageInfoPreProcessSystem.cs:244-247)\n\n```csharp\n// 诅咒: 陷阱目标\nif (info.isTrapDamage && curse_TargetedTrapExtraDamageRatio > 0f)\n{\n    info.damage *= 1f + curse_TargetedTrapExtraDamageRatio;\n}\n```\n\n### 4. 穿透队友伤害 (isTeammateThrough)\n\n特殊技能可以穿透队友而不造成伤害。\n\n**应用场景**:\n- 某些特殊技能\n- 召唤物死亡爆炸\n\n**检查代码**:\n\n```csharp\nif (info.isTeammateThrough &&\n    targetPpt.unitCfg.unitType == UnitType.Teammate)\n{\n    info.immuneDamage = true;\n}\n```\n\n---\n\n## 伤害修正系统\n\n伤害修正分为多个层次:\n\n### 1. 基础伤害修正\n\n```\n基础伤害 = 技能配置伤害 * (1 + ExtraDamageRatio)\n\nExtraDamageRatio 来源:\n- BattleData.extraDamageRatio          基础额外伤害\n- 遗物: 诅咒战士                       +5% per 诅咒\n- 遗物: 金钱即力量                     +X% per Y金币\n- 遗物: 增伤                           +固定%\n- 遗物: 强者                           +固定%\n- 遗物: 疯眼                           动态增长\n- 遗物: 狂战士                         低血增伤\n- 诅咒: 降低伤害和速度                 -固定%\n- 诅咒: 满血增伤                       动态变化\n```\n\n**计算位置**: [PlayerMgr.cs:157-196](PlayerMgr.cs:157-196)\n\n### 2. 受伤减免修正\n\n```\n最终伤害 = 基础伤害 * DamageReductionRatio\n\nDamageReductionRatio 来源:\n- 遗物: 减伤                           * (1 - X%)\n- 遗物: 强者增伤 (敌人)                * (1 + X%)\n- 诅咒: 脆弱                           * (1 + X%)\n- 诅咒: 金币增伤                       * (1 + X%)\n- 诅咒: 敌人减伤                       * (1 - X%)\n```\n\n### 3. 特殊比例修正\n\n```\nplayerTakeDamageRatio:\n- 默认: 1.0\n- 特定技能可以修改\n\nteammateTakeDamageRatio:\n- 默认: 1.0\n- Boss技能对队友: 2.0 或 3.0\n```\n\n### 修正优先级\n\n```\nPriority 1: 特殊技能修正 (Boss技能对队友)\n    ↓\nPriority 2: 玩家基础修正 (无敌帧、闪避)\n    ↓\nPriority 3: 遗物/诅咒伤害比例\n    ↓\nPriority 4: 受伤比例 (playerTakeDamageRatio)\n    ↓\nPriority 5: 真实伤害特殊处理\n    ↓\nPriority 6: 易伤效果\n    ↓\nPriority 7: 暴击判定\n    ↓\nPriority 8: 伤害取整\n```\n\n---\n\n## 伤害公式总结\n\n### 完整伤害计算公式\n\n```\n最终伤害 = ⌈基础伤害 * 修正1 * 修正2 * ... * 修正N * 暴击倍率⌉\n\n其中:\n基础伤害 = 技能伤害 * (1 + ExtraDamageRatio)\n\n修正因子包括(按顺序):\n1. 特殊技能修正 (BossSpellModifier)\n2. 无敌帧检查 (→ immuneDamage)\n3. 闪避检查 (→ immuneDamage)\n4. 减伤遗物 (* (1 - relic_ReduceDamageRatio))\n5. 增伤遗物 (* (1 + relic_PowerfulManIncreaseDamage))\n6. 增伤诅咒 (* (1 + curse_VulnerabilityExtraDamageRatio))\n7. 金币增伤诅咒 (* (1 + curse_MoreMoneyMoreInjured))\n8. 受伤比例 (* playerTakeDamageRatio or teammateTakeDamageRatio)\n9. 真实伤害限制 (* min(undifferRatio, 0.3333))\n10. 易伤效果 (* DamageReciveIncresePercent)\n11. 暴击判定 (* criticalDamageRatio)\n\n⌈x⌉ = ceil(x)  // 向上取整\n```\n\n### 示例计算\n\n#### 场景: 玩家被敌人技能击中\n\n```\n技能原始伤害: 100\n玩家ExtraDamageRatio: 0  (敌人攻击不受玩家加成影响)\n遗物减伤20%\n诅咒脆弱+30%\n临时易伤+50%\n暴击率: 0.3 (30%)\n暴击判定: 成功\n\n计算过程:\n1. 基础伤害 = 100\n2. 应用减伤遗物: 100 * (1 - 0.2) = 80\n3. 应用脆弱诅咒: 80 * (1 + 0.3) = 104\n4. 应用易伤效果: 104 * 1.5 = 156\n5. 暴击判定成功: 156 * 2.0 = 312\n6. 向上取整: ⌈312⌉ = 312\n\n最终伤害: 312\n```\n\n#### 场景: 玩家攻击Boss\n\n```\n技能原始伤害: 50\n玩家ExtraDamageRatio: +50% (各种遗物)\n玩家ExtraCriticalRatio: +20%\n技能暴击率: 10%\n诅咒敌人减伤: -20%\n暴击判定: 失败\n\n计算过程:\n1. 基础伤害 = 50 * (1 + 0.5) = 75\n2. 敌人减伤诅咒: 75 * (1 - 0.2) = 60\n3. 暴击率 = 10% + 20% = 30%\n4. 暴击判定失败: 伤害不变\n5. 向上取整: ⌈60⌉ = 60\n\n最终伤害: 60\n```\n\n---\n\n## 总结\n\n### 关键特性\n\n1. **多阶段流水线**: 伤害经过7个系统依次处理\n2. **可中断性**: 任何阶段都可以将伤害设为免疫\n3. **护盾双重机制**: 永久护盾 + 临时护盾\n4. **暴击系统**: 默认x2,可通过遗物提升\n5. **特殊伤害类型**: 真实伤害、百分比伤害、陷阱伤害\n6. **伤害修正**: 遗物/诅咒/易伤多层修正\n\n### 性能优化\n\n1. **DOTS架构**: 使用Burst编译的Job进行并行处理\n2. **Buffer机制**: 每个Entity维护伤害信息缓冲区\n3. **每帧清理**: 避免内存泄漏\n\n### 扩展点\n\n1. **BeforeTakeDamage**: 受伤前自定义逻辑\n2. **AfterTakeDamage**: 受伤后自定义逻辑\n3. **遗物效果**: 在预处理阶段注入修正\n4. **诅咒效果**: 在预处理阶段注入修正\n\n---\n\n**文档版本**: 1.0\n**最后更新**: 2025-12-17\n**作者**: AI 代码分析助手\n","numLines":1774,"startLine":1,"totalLines":1774}}}
{"parentUuid":"f9ea4e09-0190-4dbf-9604-2e1a11502695","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UNx9EdxLrySFNATx6hvkYY","type":"tool_result","content":"     1→# AI战斗逻辑详细文档\n     2→\n     3→## 目录\n     4→- [1. 系统总览](#1-系统总览)\n     5→- [2. AI模式系统 (AIPattern)](#2-ai模式系统-aipattern)\n     6→- [3. 状态机架构](#3-状态机架构)\n     7→- [4. 普通怪物AI (Monster)](#4-普通怪物ai-monster)\n     8→- [5. 精英怪物AI (Elite)](#5-精英怪物ai-elite)\n     9→- [6. Boss AI系统](#6-boss-ai系统)\n    10→- [7. 目标选择策略](#7-目标选择策略)\n    11→- [8. 攻击决策系统](#8-攻击决策系统)\n    12→- [9. 移动行为模式](#9-移动行为模式)\n    13→- [10. 实战案例分析](#10-实战案例分析)\n    14→\n    15→---\n    16→\n    17→## 1. 系统总览\n    18→\n    19→### 1.1 AI层级结构\n    20→\n    21→```\n    22→              AI战斗逻辑系统\n    23→                    ↓\n    24→        ┌───────────┼───────────┐\n    25→        ↓           ↓           ↓\n    26→   普通怪物      精英怪物      Boss\n    27→  (Monster)    (Elite)      (Boss)\n    28→   175+种       17种         13种\n    29→        │           │           │\n    30→        └───────────┼───────────┘\n    31→                    ↓\n    32→              共同AI组件\n    33→         ┌──────────┴──────────┐\n    34→         ↓                     ↓\n    35→    状态机系统            AI模式系统\n    36→  (State Machine)      (AIPattern)\n    37→         │                     │\n    38→         ↓                     ↓\n    39→   目标选择系统          攻击决策系统\n    40→ (Target Selection)  (Attack Decision)\n    41→         │                     │\n    42→         └──────────┬──────────┘\n    43→                    ↓\n    44→              移动行为系统\n    45→           (Movement Behavior)\n    46→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5dc85f09-dd67-49ff-8e22-bde13624db0e","timestamp":"2025-12-18T11:34:53.267Z","toolUseResult":{"type":"text","file":{"filePath":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\05-AI战斗逻辑详细文档.md","content":"# AI战斗逻辑详细文档\n\n## 目录\n- [1. 系统总览](#1-系统总览)\n- [2. AI模式系统 (AIPattern)](#2-ai模式系统-aipattern)\n- [3. 状态机架构](#3-状态机架构)\n- [4. 普通怪物AI (Monster)](#4-普通怪物ai-monster)\n- [5. 精英怪物AI (Elite)](#5-精英怪物ai-elite)\n- [6. Boss AI系统](#6-boss-ai系统)\n- [7. 目标选择策略](#7-目标选择策略)\n- [8. 攻击决策系统](#8-攻击决策系统)\n- [9. 移动行为模式](#9-移动行为模式)\n- [10. 实战案例分析](#10-实战案例分析)\n\n---\n\n## 1. 系统总览\n\n### 1.1 AI层级结构\n\n```\n              AI战斗逻辑系统\n                    ↓\n        ┌───────────┼───────────┐\n        ↓           ↓           ↓\n   普通怪物      精英怪物      Boss\n  (Monster)    (Elite)      (Boss)\n   175+种       17种         13种\n        │           │           │\n        └───────────┼───────────┘\n                    ↓\n              共同AI组件\n         ┌──────────┴──────────┐\n         ↓                     ↓\n    状态机系统            AI模式系统\n  (State Machine)      (AIPattern)\n         │                     │\n         ↓                     ↓\n   目标选择系统          攻击决策系统\n (Target Selection)  (Attack Decision)\n         │                     │\n         └──────────┬──────────┘\n                    ↓\n              移动行为系统\n           (Movement Behavior)\n","numLines":46,"startLine":1,"totalLines":46}}}
{"parentUuid":"5dc85f09-dd67-49ff-8e22-bde13624db0e","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (29940 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01BGkbzakR4792kXyFFSMWtn"}]},"uuid":"2aa2d941-1835-4f66-8dbb-b7ec18e177d8","timestamp":"2025-12-18T11:34:54.564Z","toolUseResult":"Error: File content (29940 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"parentUuid":"2aa2d941-1835-4f66-8dbb-b7ec18e177d8","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016WzTQhjEiwBz1U6ULFWQet","type":"message","role":"assistant","content":[{"type":"text","text":"由于文件较大，让我用分段读取的方式获取剩余的文档内容。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":774,"cache_creation_input_tokens":27100,"cache_read_input_tokens":34878,"cache_creation":{"ephemeral_5m_input_tokens":27100,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"c9835112-a031-450d-9eca-d55d4fbce72e","timestamp":"2025-12-18T11:35:05.206Z"}
{"parentUuid":"c9835112-a031-450d-9eca-d55d4fbce72e","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016WzTQhjEiwBz1U6ULFWQet","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LN553izqgWhfFXRBrg3XfF","name":"Read","input":{"file_path":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\01-战斗系统核心架构.md","offset":1,"limit":2000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":774,"cache_creation_input_tokens":27100,"cache_read_input_tokens":34878,"cache_creation":{"ephemeral_5m_input_tokens":27100,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"80c168d0-eab1-4276-be9f-b095c046c16a","timestamp":"2025-12-18T11:35:06.516Z"}
{"parentUuid":"80c168d0-eab1-4276-be9f-b095c046c16a","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016WzTQhjEiwBz1U6ULFWQet","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GFiB8bbTzsZ82Qg5xp3TiB","name":"Read","input":{"file_path":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\03-技能系统详细文档.md","offset":1,"limit":2000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":774,"cache_creation_input_tokens":27100,"cache_read_input_tokens":34878,"cache_creation":{"ephemeral_5m_input_tokens":27100,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"282d26bc-967f-4adb-b14a-9d5026d71a0c","timestamp":"2025-12-18T11:35:07.148Z"}
{"parentUuid":"282d26bc-967f-4adb-b14a-9d5026d71a0c","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016WzTQhjEiwBz1U6ULFWQet","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Sjyfz4XG6c9dEm1D2nDsNH","name":"Read","input":{"file_path":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\04-单位系统详细文档.md","offset":1,"limit":2000}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":774,"cache_creation_input_tokens":27100,"cache_read_input_tokens":34878,"cache_creation":{"ephemeral_5m_input_tokens":27100,"ephemeral_1h_input_tokens":0},"output_tokens":386,"service_tier":"standard"}},"type":"assistant","uuid":"d3e79bff-bb8b-4381-9478-9ece5237c6c5","timestamp":"2025-12-18T11:35:07.502Z"}
{"parentUuid":"aecb8daa-fffa-41ab-a63a-2d74f7885444","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GFiB8bbTzsZ82Qg5xp3TiB","type":"tool_result","content":"     1→# 技能系统详细文档\n     2→\n     3→## 目录\n     4→1. [技能系统总览](#技能系统总览)\n     5→2. [技能配置系统 SpellConfig](#技能配置系统-spellconfig)\n     6→3. [技能基类 SpellBase](#技能基类-spellbase)\n     7→4. [法杖系统 Wand](#法杖系统-wand)\n     8→5. [技能发射系统](#技能发射系统)\n     9→6. [技能类型详解](#技能类型详解)\n    10→7. [技能能力类型 SpellAbilityType](#技能能力类型-spellabilitytype)\n    11→8. [技能初始化流程](#技能初始化流程)\n    12→9. [技能生命周期管理](#技能生命周期管理)\n    13→10. [技能增强系统](#技能增强系统)\n    14→\n    15→---\n    16→\n    17→## 技能系统总览\n    18→\n    19→### 系统架构\n    20→技能系统是游戏战斗的核心,负责处理所有法术的发射、飞行、命中、效果应用等逻辑。系统采用**配置驱动+类继承**的设计模式:\n    21→\n    22→```\n    23→技能系统核心组成\n    24→├── SpellConfig (配置数据)\n    25→├── SpellBase (基类逻辑)\n    26→├── Spell1001~4024 (具体实现类,100+种技能)\n    27→├── Wand (法杖-发射器)\n    28→├── SpellShootGroup (发射组)\n    29→├── SpellShootData (发射数据)\n    30→└── SpellInitialParameter (初始化参数)\n    31→```\n    32→\n    33→### 技能分类\n    34→\n    35→#### 1. 按类型分类 (SpellType)\n    36→```csharp\n    37→public enum SpellType\n    38→{\n    39→    Missile,    // 投射物类技能\n    40→    Summon,     // 召唤物类技能\n    41→    Enhance,    // 增强类技能(修改其他技能属性)\n    42→    Passive     // 被动类技能\n    43→}\n    44→```\n    45→\n    46→#### 2. 按能力分类 (SpellAbilityType)\n    47→共150+种不同的能力类型,分为以下几大类:\n    48→- **1000系列**: 基础投射物技能 (Bullet, Rollball, Butterfly等)\n    49→- **2000系列**: 召唤物技能 (Summon1~9)\n    50→- **3000系列**: 增强/修改类技能 (Volley, Multishot, Penetrate等)\n    51→- **4000系列**: 特殊被动技能 (ChargeMode, WandSpirit, Umbrella等)\n    52→- **9000系列**: 怪物专用技能\n    53→\n    54→---\n    55→\n    56→## 技能配置系统 SpellConfig\n    57→\n    58→### 核心数据结构\n    59→\n    60→```csharp\n    61→public class SpellConfig\n    62→{\n    63→    // === 基础信息 ===\n    64→    public int id;                      // 技能ID\n    65→    public string icon;                 // 图标路径\n    66→    public int level = 1;               // 技能等级 (1~3)\n    67→    public ItemDropType dropType;       // 稀有度 (Common/Rare/Epic/Special)\n    68→    public SpellType useType;           // 技能类型\n    69→    public SpellAbilityType abilityType;// 能力类型\n    70→\n    71→    // === 价格系统 ===\n    72→    public int priceCoin;               // 金币价格\n    73→    public int priceHP;                 // 生命值价格\n    74→\n    75→    // === 插槽系统 ===\n    76→    public int slotCost = 1;            // 占用插槽数量\n    77→    public int slotNumModifyValue;      // 修改插槽数量(增加/减少)\n    78→\n    79→    // === 法力消耗 ===\n    80→    public int mpCost;                  // 基础法力消耗\n    81→    public float mpCostAddSubCorrection;// 法力消耗加减修正\n    82→    public float mpCostMulDivCorrection;// 法力消耗乘除修正\n    83→\n    84→    // === 伤害系统 ===\n    85→    public float damage;                // 基础伤害\n    86→    public bool isDPS;                  // 是否为持续伤害\n    87→    public float DPSDamageInterval = 0.25f; // 持续伤害间隔\n    88→    public float criticalChance;        // 暴击率\n    89→\n    90→    // === 发射属性 ===\n    91→    public int shootCount = 1;          // 发射数量\n    92→    public float angle;                 // 散射角度\n    93→    public float shootIntervalAddSubRevise; // 射击间隔修正\n    94→\n    95→    // === 物理属性 ===\n    96→    public float speed;                 // 飞行速度\n    97→    public float duration;              // 持续时间\n    98→    public float knockback;             // 击退力度\n    99→    public float recoil;                // 后坐力\n   100→    public float upSpeed;               // 上升速度\n   101→    public float gravity;               // 重力\n   102→    public float radius;                // 影响半径\n   103→\n   104→    // === 冷却系统 ===\n   105→    public float coolDownAddSubRevise;  // 冷却时间加减修正\n   106→    public float coolDownRatio = 1f;    // 冷却时间比例修正\n   107→\n   108→    // === 特殊属性 ===\n   109→    public bool needActivate;           // 是否需要激活\n   110→    public bool canCompound = true;     // 是否可以合成\n   111→    public bool isKeepCasting;          // 是否持续施法\n   112→    public bool canCancelCasting;       // 是否可以取消施法\n   113→    public bool isParentTypeSpell;      // 是否为父类型技能\n   114→    public bool isSplitSpell;           // 是否会分裂\n   115→    public bool playShootSE = true;     // 是否播放发射音效\n   116→\n   117→    // === 召唤物相关 ===\n   118→    public int summonID;                // 召唤物ID\n   119→    public int summonLimit;             // 召唤物数量上限\n   120→\n   121→    // === 效果相关 ===\n   122→    public bool haveEffecforMissileSpell;  // 对投射物技能有效\n   123→    public bool haveEffecforSummonSpell;   // 对召唤物技能有效\n   124→\n   125→    // === 预制体 ===\n   126→    public string prefab;               // 预制体路径\n   127→\n   128→    // === 扩展字段 (用于各种特殊能力) ===\n   129→    public float float1;                // 浮点参数1\n   130→    public float float2;                // 浮点参数2\n   131→    public float float3;                // 浮点参数3\n   132→    public int int1;                    // 整数参数1\n   133→    public int int2;                    // 整数参数2\n   134→    public int int3;                    // 整数参数3\n   135→}\n   136→```\n   137→\n   138→### 配置加载与管理\n   139→\n   140→```csharp\n   141→// 静态字典存储所有配置\n   142→public static Dictionary<int, SpellConfig> dic;\n   143→public static List<SpellConfig> list;\n   144→\n   145→// 获取配置副本 (防止修改原始数据)\n   146→public static SpellConfig GetConfigCopy(int id)\n   147→{\n   148→    if (!dic.ContainsKey(id))\n   149→    {\n   150→        Debug.LogError(\"No ID:\" + id);\n   151→    }\n   152→    return dic[id].Copy();\n   153→}\n   154→\n   155→// 深拷贝配置\n   156→public SpellConfig Copy()\n   157→{\n   158→    return new SpellConfig\n   159→    {\n   160→        id = id,\n   161→        damage = damage,\n   162→        speed = speed,\n   163→        // ... 拷贝所有字段\n   164→    };\n   165→}\n   166→```\n   167→\n   168→### 配置信息格式化\n   169→\n   170→#### 1. 获取技能名称\n   171→```csharp\n   172→public string GetName(bool includeLevel = true)\n   173→{\n   174→    string text = (id + 7000000).GetText();  // 从本地化系统获取\n   175→    if (includeLevel)\n   176→    {\n   177→        if (level == 2)      text += \"+\";\n   178→        else if (level == 3) text += \"++\";\n   179→    }\n   180→    return text;\n   181→}\n   182→```\n   183→\n   184→#### 2. 获取详细信息\n   185→```csharp\n   186→public string GetInfo(float damageRatio = 1f, string newLineAdd = \"\")\n   187→{\n   188→    StringBuilder stringBuilder = new StringBuilder();\n   189→\n   190→    // 召唤物数量限制\n   191→    if (summonLimit > 0)\n   192→        stringBuilder.AppendIntField(14000304, summonLimit, ...);\n   193→\n   194→    // 召唤物生命值\n   195→    if (useType == SpellType.Summon)\n   196→    {\n   197→        float maxHP = UnitConfig.map[summonID].maxHP;\n   198→        stringBuilder.AppendFloatField(14000314, maxHP, ...);\n   199→    }\n   200→\n   201→    // 伤害信息\n   202→    if (damage != 0f)\n   203→    {\n   204→        stringBuilder.AppendStringField(14000301,\n   205→            (damage * damageRatio).ToStringDamage(), ...);\n   206→        if (isDPS)\n   207→            stringBuilder.AppendLink(\" (\", 14000302.GetText(), \")\");\n   208→    }\n   209→\n   210→    // 发射数量\n   211→    if (shootCount > 1)\n   212→        stringBuilder.AppendIntField(14000312, shootCount, ...);\n   213→\n   214→    // 射击间隔修正\n   215→    if (shootIntervalAddSubRevise != 0f)\n   216→        stringBuilder.AppendFloatField(14000204, shootIntervalAddSubRevise, ...);\n   217→\n   218→    // 冷却时间修正\n   219→    if (coolDownAddSubRevise != 0f)\n   220→        stringBuilder.AppendFloatField(14000205, coolDownAddSubRevise, ...);\n   221→\n   222→    // 暴击率\n   223→    if (criticalChance != 0f)\n   224→        stringBuilder.AppendFloatField(14000307, criticalChance, ...);\n   225→\n   226→    // 散射角度\n   227→    if (angle != 0f)\n   228→        stringBuilder.AppendFloatField(14000206, angle, ...);\n   229→\n   230→    // 法力消耗修正\n   231→    if (mpCostAddSubCorrection != 0f)\n   232→        stringBuilder.AppendFloatField(14000305, mpCostAddSubCorrection, ...);\n   233→\n   234→    // 影响半径\n   235→    if (radius != 0f)\n   236→        stringBuilder.AppendFloatField(14000303, radius, ...);\n   237→\n   238→    // 插槽消耗\n   239→    if (slotCost > 1)\n   240→        stringBuilder.AppendIntField(14000310, slotCost, ...);\n   241→\n   242→    // 插槽数量修改\n   243→    if (slotNumModifyValue != 0)\n   244→        stringBuilder.AppendFloatField(14000311, slotNumModifyValue, ...);\n   245→\n   246→    return stringBuilder.ToString().Trim();\n   247→}\n   248→```\n   249→\n   250→#### 3. 获取技能描述\n   251→```csharp\n   252→public string GetDes(float damageRatio = 1f, string nextLineAdd = \"\",\n   253→                     string color = \"\", string header = \"\")\n   254→{\n   255→    StringBuilder stringBuilder = new StringBuilder(\n   256→        (id + 7100000).GetText());  // 从本地化获取描述\n   257→\n   258→    // 替换描述中的变量占位符\n   259→    stringBuilder.Replace(\"int1\", int1.ToString());\n   260→    stringBuilder.Replace(\"int2\", int2.ToString());\n   261→    stringBuilder.Replace(\"int3\", int3.ToString());\n   262→    stringBuilder.Replace(\"float1\", GeneralTool.FloatToRetainDecimals(float1, 1));\n   263→    stringBuilder.Replace(\"float2\", GeneralTool.FloatToRetainDecimals(float2, 1));\n   264→    stringBuilder.Replace(\"float3\", GeneralTool.FloatToRetainDecimals(float3, 1));\n   265→    stringBuilder.Replace(\"shootCount\", shootCount.ToString());\n   266→    stringBuilder.Replace(\"spellDuration\",\n   267→        GeneralTool.FloatToRetainDecimals(duration, 1));\n   268→\n   269→    // 特殊能力的额外处理\n   270→    if (abilityType == SpellAbilityType.LightningChain)\n   271→    {\n   272→        string newValue = TextProcesser.GetColorText(\n   273→            Mathf.Ceil(int1 * damageRatio).ToString(\"F0\"), type);\n   274→        stringBuilder.Replace(\"int1\", newValue);\n   275→    }\n   276→\n   277→    stringBuilder.Replace(\"\\\\\", \"\\n\" + nextLineAdd);\n   278→\n   279→    return stringBuilder.ToString().Trim();\n   280→}\n   281→```\n   282→\n   283→### 稀有度系统\n   284→\n   285→```csharp\n   286→public string GetStrRarity()\n   287→{\n   288→    switch (dropType)\n   289→    {\n   290→        case ItemDropType.None:\n   291→        case ItemDropType.Common:\n   292→            return 1001601.GetText();  // \"普通\"\n   293→        case ItemDropType.Rare:\n   294→            return 1001602.GetText();  // \"稀有\"\n   295→        case ItemDropType.Epic:\n   296→            return 1001603.GetText();  // \"史诗\"\n   297→        case ItemDropType.Special:\n   298→            return 1001604.GetText();  // \"特殊\"\n   299→    }\n   300→}\n   301→```\n   302→\n   303→---\n   304→\n   305→## 技能基类 SpellBase\n   306→\n   307→### 类继承结构\n   308→\n   309→```\n   310→MonoBehaviour\n   311→  └── LayerCorrect\n   312→       └── SpellBase (抽象基类)\n   313→            ├── Spell1001Bullet (基础子弹)\n   314→            ├── Spell1002RollBall (滚球)\n   315→            ├── Spell1003Butterfly (蝴蝶)\n   316→            ├── Spell1007BlackHole (黑洞)\n   317→            ├── Spell1008ArcaneExplosion (奥术爆炸)\n   318→            ├── Spell1010SnakeWalk (蛇形走位)\n   319→            ├── Spell1015ArcaneNova (奥术新星)\n   320→            ├── Spell1019HighPressureWasher (高压水枪)\n   321→            ├── Spell1021MagicBreaker (破法者)\n   322→            ├── Spell1027SuperNova (超新星)\n   323→            ├── Spell1029DimensionTraveller (维度旅行者)\n   324→            ├── Spell1030Harpoons (鱼叉)\n   325→            ├── Spell2001Summon1 (召唤物1)\n   326→            ├── ... (100+种技能实现)\n   327→            └── Spell4024DaveHarpoons (戴夫的鱼叉)\n   328→```\n   329→\n   330→### 核心属性\n   331→\n   332→```csharp\n   333→public class SpellBase : LayerCorrect\n   334→{\n   335→    // === 物理组件 ===\n   336→    public Rigidbody rigid;             // 刚体\n   337→    public TriggerIn triggerIn;         // 触发器检测\n   338→    public SphereCollider sc_Rebound;   // 球形碰撞器(反弹)\n   339→    public BoxCollider bc_Rebound;      // 盒形碰撞器(反弹)\n   340→    public Shadow shadow;               // 阴影\n   341→\n   342→    // === 拥有者信息 ===\n   343→    public UnitProperty ownerPpt;       // 拥有者属性\n   344→    public Transform OwnerTsf;          // 拥有者Transform\n   345→    public Vector3 OwnerPoint;          // 拥有者位置点\n   346→    public SpellBase OwnerSpell;        // 父技能(如果是子技能)\n   347→\n   348→    // === 发射信息 ===\n   349→    public Wand shooterWand;            // 发射的法杖\n   350→    public Vector3 Direction;           // 飞行方向\n   351→    public Vector3 originalShootDirection; // 原始发射方向\n   352→    public float wandShootAngle;        // 法杖发射角度\n   353→\n   354→    // === 配置与参数 ===\n   355→    public SpellConfig spellCfg;        // 技能配置\n   356→    public SpellConfig level1Cfg;       // 1级配置\n   357→    public SpellConfig currentLevelPureCfg; // 当前等级纯配置\n   358→    public SpellInitialParameter InitialParameter; // 初始化参数\n   359→    public SpellShootData ShootData;    // 发射数据\n   360→\n   361→    // === 属性修正 ===\n   362→    // 伤害\n   363→    public float damageRatio = 1f;      // 伤害比例(加法)\n   364→    public float finalDamageRatio = 1f; // 最终伤害比例(乘法)\n   365→\n   366→    // 速度\n   367→    public float bonusSpeed;            // 额外速度(加法)\n   368→    public float speedRatio = 1f;       // 速度比例(加法)\n   369→    public float finalSpeedRatio = 1f;  // 最终速度比例(乘法)\n   370→    public float CurrentSpeed;          // 当前速度\n   371→    public float CurrentUpSpeed;        // 当前上升速度\n   372→\n   373→    // 半径\n   374→    public float radiusRatio = 1f;      // 半径比例(加法)\n   375→    public float finalRadiusRatio = 1f; // 最终半径比例(乘法)\n   376→    public float ColliderRadius;        // 碰撞器半径\n   377→\n   378→    // 击退\n   379→    public float knockbackRatio = 1f;       // 击退比例(加法)\n   380→    public float finalKnockbackRatio = 1f;  // 最终击退比例(乘法)\n   381→\n   382→    // 持续时间\n   383→    public float bonusDuration;             // 额外持续时间(加法)\n   384→    public float finalDurationRatio = 1f;   // 最终持续时间比例(乘法)\n   385→    public float DurationTimer;             // 持续时间计时器\n   386→\n   387→    // 其他\n   388→    public float overalCriticalChance;  // 总暴击率\n   389→    public float _angle;                // 散射角度\n   390→    public float spellVolumeRatio = 1f; // 技能体积比例\n   391→\n   392→    // === 状态元素效果 ===\n   393→    // 粘液\n   394→    public float spellMucusTime;            // 粘液持续时间\n   395→    public float spellMucusMoveSpeedRatio = 1f;  // 粘液移速比例\n   396→    public float spellMucusSpellSpeedRatio = 1f; // 粘液技能速度比例\n   397→\n   398→    // 毒素\n   399→    public float spellVenomTime;        // 毒素持续时间\n   400→    public float spellVenomOnceCount;   // 毒素触发次数\n   401→\n   402→    // 冰冻\n   403→    public float spellFrozenTime;       // 冰冻持续时间\n   404→\n   405→    // 燃烧\n   406→    public float spellBurnTime;         // 燃烧持续时间\n   407→    public float burnHpRatioPerSeconds; // 每秒燃烧血量百分比\n   408→\n   409→    // === 特殊移动模式 ===\n   410→    public SpellSpecialMovementType currentSpellMovement;\n   411→\n   412→    // 环绕\n   413→    public bool enableAroundPlayer = true;\n   414→    public float spellAroundOwnerRadius;    // 环绕半径\n   415→    public float spellAroundOwnerCurrentAngle; // 当前环绕角度\n   416→\n   417→    // 追踪\n   418→    public bool enableFollowTarget = true;\n   419→    public float spellFollowTargetRotateSpeed; // 追踪旋转速度\n   420→    public UnitProperty spellFollowTargetPpt;  // 追踪目标\n   421→\n   422→    // 跟随鼠标\n   423→    public bool enableFollowMouse = true;\n   424→    public float spellFollowMouseLerp;      // 跟随鼠标插值\n   425→\n   426→    // 悬停\n   427→    public float SpellHoverTime;        // 悬停总时间\n   428→    public float SpellHoverTimer;       // 悬停计时器\n   429→\n   430→    // === 穿透系统 ===\n   431→    public int penetrateTime;           // 穿透次数\n   432→\n   433→    // === 反弹系统 ===\n   434→    public int rebounceTime;            // 反弹次数\n   435→    public float extraReboundTime;      // 额外反弹次数\n   436→    public float reboundAddTime;        // 添加反弹次数\n   437→    public bool InFallRebounding;       // 是否在下落反弹中\n   438→    public bool createReboundEffect = true; // 是否创建反弹特效\n   439→\n   440→    // === 折射系统 ===\n   441→    public int remainRefractCount;      // 剩余折射次数\n   442→    public readonly List<GameObject> refractedTargets = new List<GameObject>();\n   443→\n   444→    // === 分裂系统 ===\n   445→    public int spellSplitCount;         // 分裂次数\n   446→\n   447→    // === 闪电链系统 ===\n   448→    public float lightningChainDamage;  // 闪电链伤害\n   449→    public float endThunderHitRadiu;    // 终结雷击半径\n   450→    public float endThunderHitPercent;  // 终结雷击百分比\n   451→    public float endTHunderHitChance;   // 终结雷击几率\n   452→\n   453→    // === 生命线系统 ===\n   454→    public float lifelineDamage;        // 生命线伤害\n   455→    public float lifelineDamageInterval = float.PositiveInfinity; // 生命线伤害间隔\n   456→\n   457→    // === 暴击拖拽系统 ===\n   458→    public float criticalDragDamagePercent;  // 暴击拖拽伤害百分比\n   459→    public float criticalDragEffectRadiu;    // 暴击拖拽效果半径\n   460→    public int criticalDragApllyToCount;     // 暴击拖拽应用数量\n   461→    public float criticalDragPullForce;      // 暴击拖拽拉力\n   462→\n   463→    // === 召唤物相关 ===\n   464→    public float SpellSummonHPRatio = 1f;           // 召唤物生命比例\n   465→    public float SpellSummonGainOwnerHpRatio;       // 召唤物获得拥有者生命比例\n   466→    public float SpellSUmmonFinalHpRatio = 1f;      // 召唤物最终生命比例\n   467→    public float SpellSummonMoveRatio = 1f;         // 召唤物移动比例\n   468→    public float SpellSummonHPRecover;              // 召唤物生命恢复\n   469→    public float SpellSummonHPFixDropAmount;        // 召唤物固定掉血量\n   470→    public float SpellSummonAttackSpeedRatio = 1f;  // 召唤物攻速比例\n   471→    public int SpellSummonAfterDeadSpawnWormCount;  // 召唤物死亡后生成蠕虫数量\n   472→    public float SpellSummonInstantDeathHpRatio;    // 召唤物瞬间死亡血量比例\n   473→    public float SpellSummonDeathExplodeRange;      // 召唤物死亡爆炸范围\n   474→    public float SpellSummonDeathExplodeHpDamageRatio; // 召唤物死亡爆炸生命伤害比例\n   475→\n   476→    // === 状态标记 ===\n   477→    public SpellColorType ColorType;    // 技能颜色类型\n   478→    public bool finishedInitialize;     // 是否完成初始化\n   479→    public bool isFlyFinish;            // 是否飞行结束\n   480→    public bool isOwnerSpellEnd;        // 拥有者技能是否结束\n   481→    public bool CreateFromMiniPool;     // 是否从小对象池创建\n   482→    public bool controlByRemoteWand;    // 是否由远程法杖控制\n   483→    public bool spellKeepCastBuffApplied; // 持续施法buff是否应用\n   484→    public bool indirectShootByPlayer;  // 是否由玩家间接发射\n   485→    public bool isThroughWall;          // 是否穿墙\n   486→    public bool CanChangeTeam = true;   // 是否可以改变阵营\n   487→    public bool CanBeCapture = true;    // 是否可以被捕获\n   488→    public bool shouldCameraShock = true; // 是否应该相机震动\n   489→\n   490→    // === 其他 ===\n   491→    public float TeammateTakDamageRatio = 1f; // 队友承受伤害比例\n   492→    public float undifferDamageRatio = 1f;    // 无差别伤害比例\n   493→    public Vector3 virtualRealPosition;       // 虚拟真实位置\n   494→    public WandPostSlotChargeData wandChargeData; // 法杖后置插槽充能数据\n   495→    public List<int> preSpellIDs;             // 前置技能ID列表\n   496→    public bool FromEcho;                     // 是否来自回响\n   497→}\n   498→```\n   499→\n   500→### 技能生命周期\n   501→\n   502→```csharp\n   503→// 1. OnEnable - 对象池启用时\n   504→public override void OnEnable()\n   505→{\n   506→    base.OnEnable();\n   507→    finishedInitialize = false;\n   508→    CreateFromMiniPool = false;\n   509→}\n   510→\n   511→// 2. Initialize - 初始化技能\n   512→public void Initialize(UnitProperty ownerPp, Vector3 dir, SpellConfig cfg,\n   513→                       Wand casterWand = null, params int[] preSpellIds)\n   514→{\n   515→    FinalInitialize(new SpellInitialParameter(ownerPp, dir, 0, cfg,\n   516→                    casterWand, preSpellIds.ToList()));\n   517→}\n   518→\n   519→// 3. FinalInitialize - 最终初始化\n   520→protected virtual void FinalInitialize(SpellInitialParameter initialParameter,\n   521→                                       SpellShootData shootData = null)\n   522→{\n   523→    // 单次初始化组件\n   524→    SingleInitial();\n   525→\n   526→    // 重置所有属性到默认值\n   527→    emitFlyFinishEvent = false;\n   528→    CurrentSpeed = 0f;\n   529→    CurrentUpSpeed = 0f;\n   530→    ColorType = SpellColorType.Player;\n   531→    DurationTimer = 0f;\n   532→    shouldCameraShock = true;\n   533→    isFlyFinish = false;\n   534→    wandShootAngle = 0f;\n   535→    // ... 重置100+个属性\n   536→\n   537→    // 应用初始化参数\n   538→    InitialParameter = initialParameter;\n   539→    preSpellIDs = initialParameter.shootSpellPreSpells.Copy();\n   540→    spellCfg = initialParameter.spelldataConfig.Copy();\n   541→    Direction = initialParameter.shootDirection;\n   542→    originalShootDirection = initialParameter.originShootDirection;\n   543→\n   544→    // 应用属性修正\n   545→    damageRatio += initialParameter.extraDamageRatio;\n   546→    finalDamageRatio *= initialParameter.finalDamageRatio;\n   547→    radiusRatio += initialParameter.extraSizeRatio;\n   548→    finalRadiusRatio *= initialParameter.finalSizeRatio;\n   549→    knockbackRatio += initialParameter.extraKnockBackRatio;\n   550→    finalKnockbackRatio *= initialParameter.finalKnockBackRatio;\n   551→    bonusDuration += initialParameter.extraDuration;\n   552→    finalDurationRatio *= initialParameter.finalDurationRatio;\n   553→    speedRatio += initialParameter.extraSpeedRatio;\n   554→    finalSpeedRatio *= initialParameter.finalSpeedRatio;\n   555→    bonusSpeed += initialParameter.bounsSpeed;\n   556→    // ... 更多修正\n   557→\n   558→    // 应用特殊效果数据\n   559→    lightningChainDamage = initialParameter.lightningChainDamage;\n   560→    lifelineDamage = initialParameter.lifeLineData.damage;\n   561→    lifelineDamageInterval = initialParameter.lifeLineData.Interval;\n   562→    // ... 更多特殊效果\n   563→\n   564→    // 设置拥有者信息\n   565→    ownerPpt = initialParameter.ownerPpt;\n   566→    OwnerTsf = initialParameter.OwnerTsf;\n   567→    OwnerSpell = initialParameter.OwnerSpell;\n   568→    OwnerPoint = initialParameter.OnwerPoint;\n   569→\n   570→    // 重置刚体速度\n   571→    if (rigid) rigid.linearVelocity = Vector3.zero;\n   572→\n   573→    // 处理折射\n   574→    refractedTargets.Clear();\n   575→    if (initialParameter.RefractionInfo.HasValue)\n   576→    {\n   577→        remainRefractCount = initialParameter.RefractionInfo.Value.count;\n   578→    }\n   579→\n   580→    // 调用子类初始化回调\n   581→    InitializeCallback();\n   582→\n   583→    // 标记初始化完成\n   584→    finishedInitialize = true;\n   585→}\n   586→\n   587→// 4. Update - 每帧更新\n   588→public virtual void Update()\n   589→{\n   590→    if (!finishedInitialize) return;\n   591→\n   592→    // 飞行中更新\n   593→    if (!isFlyFinish)\n   594→    {\n   595→        FlyUpdate();\n   596→    }\n   597→\n   598→    // 生命周期检测\n   599→    if (DurationTimer > GetFinalDuration())\n   600→    {\n   601→        isFlyFinish = true;\n   602→        OnFlyFinish();\n   603→    }\n   604→}\n   605→\n   606→// 5. OnRecycle - 回收到对象池\n   607→protected virtual void OnRecycle()\n   608→{\n   609→    // 清理引用\n   610→    ownerPpt = null;\n   611→    OwnerTsf = null;\n   612→    OwnerSpell = null;\n   613→    shooterWand = null;\n   614→    // ... 清理其他引用\n   615→\n   616→    // 触发回收事件\n   617→    OnWillRecycleIgnoreRecycle.Invoke(this);\n   618→}\n   619→```\n   620→\n   621→### 碰撞与触发检测\n   622→\n   623→```csharp\n   624→// TriggerIn回调 - 进入触发器\n   625→protected virtual void TriggerIn(Collider col)\n   626→{\n   627→    if (!finishedInitialize) return;\n   628→    if (isFlyFinish && SpellHoverTimer >= SpellHoverTime) return;\n   629→\n   630→    GameObject go = col.gameObject;\n   631→    string tag = go.tag;\n   632→\n   633→    // 处理不同标签的碰撞\n   634→    switch (tag)\n   635→    {\n   636→        case \"Monster\":      // 怪物\n   637→        case \"Destructible\": // 可破坏物\n   638→        case \"RollBall\":     // 滚球\n   639→        case \"Brittleness\":  // 易碎物\n   640→            OnHitTarget(go);\n   641→            break;\n   642→\n   643→        case \"Wall\":         // 墙壁\n   644→            if (!isThroughWall)\n   645→                OnHitWall(col);\n   646→            break;\n   647→\n   648→        case \"Spell\":        // 其他技能\n   649→            OnHitSpell(col);\n   650→            break;\n   651→    }\n   652→}\n   653→\n   654→// 命中目标\n   655→protected virtual void OnHitTarget(GameObject target)\n   656→{\n   657→    UnitProperty targetPpt = target.GetComponent<UnitProperty>();\n   658→    if (targetPpt == null) return;\n   659→\n   660→    // 队友检测\n   661→    if (IsTeammate(targetPpt) && !CanHitTeammate())\n   662→        return;\n   663→\n   664→    // 造成伤害\n   665→    TakeDamageInfo damageInfo = MakeDamageToUnit(targetPpt);\n   666→\n   667→    // 触发器检测\n   668→    TriggerCtrl.OnHitTriggerCheck(this, targetPpt, damageInfo);\n   669→\n   670→    // 穿透检测\n   671→    penetrateTime--;\n   672→    if (penetrateTime < 0)\n   673→    {\n   674→        PoolRecycle();\n   675→    }\n   676→}\n   677→\n   678→// 制作伤害信息\n   679→protected virtual TakeDamageInfo MakeDamageToUnit(UnitProperty unit)\n   680→{\n   681→    // 计算最终伤害\n   682→    float finalDamage = spellCfg.damage * (1f + damageRatio) * finalDamageRatio;\n   683→\n   684→    // 创建伤害信息\n   685→    TakeDamageInfo damageInfo = new TakeDamageInfo\n   686→    {\n   687→        attackerType = AttackerType.Spell,\n   688→        attackerPpt = ownerPpt,\n   689→        beHitPpt = unit,\n   690→        damage = finalDamage,\n   691→        criticalChance = overalCriticalChance,\n   692→        spellBase = this,\n   693→        knockbackForce = CalculateKnockbackForce(),\n   694→        wandChargeData = wandChargeData,\n   695→        playerTakeDamageRatio = 1f,\n   696→        teammateTakeDamageRatio = TeammateTakDamageRatio,\n   697→        isUndifferDamage = (undifferDamageRatio < 1f),\n   698→    };\n   699→\n   700→    // 应用状态效果\n   701→    ApplyStatusEffects(unit, damageInfo);\n   702→\n   703→    // 单位受击处理\n   704→    unit.TakeDamage(damageInfo);\n   705→\n   706→    return damageInfo;\n   707→}\n   708→\n   709→// 应用状态效果\n   710→protected virtual void ApplyStatusEffects(UnitProperty unit, TakeDamageInfo damageInfo)\n   711→{\n   712→    // 粘液效果\n   713→    if (spellMucusTime > 0)\n   714→    {\n   715→        unit.MucusSlowDown(spellMucusTime, spellMucusMoveSpeedRatio,\n   716→                          spellMucusSpellSpeedRatio);\n   717→    }\n   718→\n   719→    // 毒素效果\n   720→    if (spellVenomTime > 0)\n   721→    {\n   722→        unit.AddVenomEffect(spellVenomTime, spellVenomOnceCount);\n   723→    }\n   724→\n   725→    // 冰冻效果\n   726→    if (spellFrozenTime > 0)\n   727→    {\n   728→        unit.AddFrozenEffect(spellFrozenTime);\n   729→    }\n   730→\n   731→    // 燃烧效果\n   732→    if (spellBurnTime > 0)\n   733→    {\n   734→        unit.AddBurnEffect(spellBurnTime, burnHpRatioPerSeconds);\n   735→    }\n   736→}\n   737→\n   738→// 命中墙壁\n   739→protected virtual void OnHitWall(Collider col)\n   740→{\n   741→    // 反弹检测\n   742→    if (rebounceTime > 0)\n   743→    {\n   744→        rebounceTime--;\n   745→        Rebound(col);\n   746→    }\n   747→    else\n   748→    {\n   749→        CreateHitEffect();\n   750→        PoolRecycle();\n   751→    }\n   752→}\n   753→```\n   754→\n   755→### 特殊移动模式\n   756→\n   757→```csharp\n   758→// 特殊移动更新\n   759→protected virtual void SpecialMovementUpdate()\n   760→{\n   761→    switch (currentSpellMovement)\n   762→    {\n   763→        case SpellSpecialMovementType.AroundOwner:\n   764→            UpdateAroundOwner();\n   765→            break;\n   766→\n   767→        case SpellSpecialMovementType.AroundMouse:\n   768→            UpdateAroundMouse();\n   769→            break;\n   770→\n   771→        case SpellSpecialMovementType.FollowTarget:\n   772→            UpdateFollowTarget();\n   773→            break;\n   774→\n   775→        case SpellSpecialMovementType.FollowMouse:\n   776→            UpdateFollowMouse();\n   777→            break;\n   778→    }\n   779→}\n   780→\n   781→// 环绕拥有者更新\n   782→protected virtual void UpdateAroundOwner()\n   783→{\n   784→    if (!enableAroundPlayer) return;\n   785→    if (OwnerTsf == null) return;\n   786→\n   787→    // 更新角度\n   788→    spellAroundOwnerCurrentAngle += CurrentSpeed * Time.deltaTime\n   789→                                    * aroundOwnerRadiuToSpeedRatio;\n   790→\n   791→    // 计算位置\n   792→    float radians = spellAroundOwnerCurrentAngle * Mathf.Deg2Rad;\n   793→    Vector3 offset = new Vector3(\n   794→        Mathf.Cos(radians) * spellAroundOwnerRadius,\n   795→        Mathf.Sin(radians) * spellAroundOwnerRadius,\n   796→        0\n   797→    );\n   798→\n   799→    transform.position = OwnerTsf.position + offset;\n   800→}\n   801→\n   802→// 追踪目标更新\n   803→protected virtual void UpdateFollowTarget()\n   804→{\n   805→    if (!enableFollowTarget) return;\n   806→    if (!SpellFollowHaveTarget) return;\n   807→\n   808→    // 计算目标方向\n   809→    Vector3 targetDir = (spellFollowTargetPpt.transform.position\n   810→                        - transform.position).normalized;\n   811→\n   812→    // 平滑旋转\n   813→    Direction = Vector3.RotateTowards(Direction, targetDir,\n   814→                spellFollowTargetRotateSpeed * Time.deltaTime, 0f);\n   815→\n   816→    // 应用速度\n   817→    rigid.linearVelocity = Direction * CurrentSpeed;\n   818→}\n   819→\n   820→// 跟随鼠标更新\n   821→protected virtual void UpdateFollowMouse()\n   822→{\n   823→    if (!enableFollowMouse) return;\n   824→\n   825→    Vector3 mousePos = PlayerMgr.Inst.GetMousePoint();\n   826→    Vector3 targetDir = (mousePos - transform.position).normalized;\n   827→\n   828→    Direction = Vector3.Lerp(Direction, targetDir,\n   829→                spellFollowMouseLerp * Time.deltaTime);\n   830→\n   831→    rigid.linearVelocity = Direction * CurrentSpeed;\n   832→}\n   833→```\n   834→\n   835→---\n   836→\n   837→## 法杖系统 Wand\n   838→\n   839→### 核心概念\n   840→\n   841→法杖是技能的**发射器**和**容器**,负责:\n   842→1. 存储和管理技能插槽\n   843→2. 控制技能发射逻辑\n   844→3. 管理法力值系统\n   845→4. 应用法杖特殊能力\n   846→\n   847→### 核心数据结构\n   848→\n   849→```csharp\n   850→public class Wand : LayerCorrect\n   851→{\n   852→    // === 基础组件 ===\n   853→    public Transform tsf_ShootPoint;    // 发射点Transform\n   854→    public Animator animator;           // 动画控制器\n   855→    public Transform tsf_WandRoot;      // 法杖根节点\n   856→    public SpriteRenderer sr_Wand;      // 法杖精灵渲染器\n   857→\n   858→    // === 法杖配置 ===\n   859→    public int WandIndex { get; private set; } // 法杖索引\n   860→    public WandConfig WandCfg { get; }          // 法杖配置\n   861→\n   862→    // === 法力系统 ===\n   863→    private float _currentMp;           // 当前法力值\n   864→    public float CurrentMP { get; set; }// 当前法力(带范围限制)\n   865→    public float MaxMP { get; }         // 最大法力值\n   866→\n   867→    // === 射击控制 ===\n   868→    public float ShootIntervalTimer { get; set; } // 射击间隔计时器\n   869→    public float CoolingTimer { get; set; }       // 冷却计时器\n   870→    public float WandShootInterval { get; }       // 射击间隔\n   871→    public float WandCoolDown { get; }            // 冷却时间\n   872→\n   873→    // === 技能组系统 ===\n   874→    public List<SpellShootGroup> shootGroups = new List<SpellShootGroup>();\n   875→    public List<SpellShootGroup> postSlotShootGroups = new List<SpellShootGroup>();\n   876→    private int currentSpellGroupsIndex;\n   877→    public SpellShootGroup currentShootGroup { get; } // 当前发射组\n   878→\n   879→    // === 被动效果 ===\n   880→    // 法力相关\n   881→    private float passiveBonusMaxMp;            // 额外最大法力\n   882→    public float passiveWandMaxMpRatio = 1f;    // 最大法力比例\n   883→    private float passiveBonusMpGen;            // 额外法力恢复\n   884→    private float passiveMpGenRatio = 1f;       // 法力恢复比例\n   885→    public float passiveMpCostCorrection = 1f;  // 法力消耗修正\n   886→\n   887→    // 伤害相关\n   888→    public float passiveDamageRatio = 1f;       // 伤害比例\n   889→\n   890→    // 冷却相关\n   891→    public float passiveWandCoolDownAddSubAmount;   // 冷却时间加减\n   892→    public float passiveWandCoolDownTimeRatio = 1f; // 冷却时间比例\n   893→    public float passiveWandShootIntervalAddSubAmount; // 射击间隔加减\n   894→\n   895→    // 回响系统\n   896→    public float passiveEchoShootChance;        // 回响发射几率\n   897→    public float passiveEchoFreeShootChance;    // 免费回响发射几率\n   898→\n   899→    // 均等散射\n   900→    public bool passiveEqualAngleDistribution; // 均等角度分布\n   901→\n   902→    // 环绕半径\n   903→    public float passiveRandomMinRotateRadiuRatio = 1f;\n   904→    public float passiveRandomMaxRotateRadiuRatio = 1f;\n   905→\n   906→    // 特殊能力\n   907→    public bool passiveChargeEnable;            // 充能模式启用\n   908→    public int passiveChargeCountLimit;         // 充能次数上限\n   909→    private float passiveChargeInterval;        // 充能间隔\n   910→\n   911→    public bool passiveAutoWand;                // 自动法杖模式\n   912→    public AutoWandData passiveAutoWandShooterData; // 自动法杖数据\n   913→\n   914→    public bool passiveUmbrellaEnable;          // 保护伞启用\n   915→    public bool passiveUmbrellaMpFull;          // 保护伞满法力\n   916→\n   917→    public bool passiveRuneHammerEnable;        // 符文锤启用\n   918→    public bool passiveLaserCrystalEnable;      // 激光水晶启用\n   919→    public bool passiveBiAnBladeEnable;         // 碧安之刃启用\n   920→    public bool passiveDaveHarpoonsEnable;      // 戴夫鱼叉启用\n   921→\n   922→    public int ExtraNormalSlot;                 // 额外普通插槽\n   923→    public int ExtraPostSlot;                   // 额外后置插槽\n   924→\n   925→    public bool PassiveTransStoneEnable;        // 转换石启用\n   926→    public bool passiveRandomPosShoot;          // 随机位置发射\n   927→\n   928→    // === 后置插槽充能系统 ===\n   929→    private float PostSlotCurrentCharge;        // 当前充能\n   930→    private float PostSlotMaxCharge;            // 最大充能\n   931→\n   932→    // === 特殊道具 ===\n   933→    public List<Spell4004ChargeStars> ChargeStars; // 充能星星列表\n   934→    public List<GameObject> passiveLaserCrystal;   // 激光水晶列表\n   935→    public List<Spell4019BiAnLethalBlade> passiveBiAnBlade; // 碧安之刃列表\n   936→\n   937→    // === 其他 ===\n   938→    public int FinalShootCount;                 // 最终发射数量\n   939→    public float passiveOwnerSpeedUpRatio;      // 拥有者加速比例\n   940→}\n   941→```\n   942→\n   943→### WandConfig 法杖配置\n   944→\n   945→```csharp\n   946→public class WandConfig\n   947→{\n   948→    // === 基础信息 ===\n   949→    public int id;                      // 法杖ID\n   950→    public string icon;                 // 图标路径\n   951→    public int priceCoin;               // 金币价格\n   952→    public int priceHP;                 // 生命值价格\n   953→    public int dropStage;               // 掉落阶段\n   954→\n   955→    // === 射击属性 ===\n   956→    public float shootInterval;         // 射击间隔\n   957→    public float coolDown;              // 冷却时间\n   958→    public float angle;                 // 散射角度\n   959→    public int shootCount;              // 发射数量\n   960→\n   961→    // === 法力系统 ===\n   962→    public int maxMP;                   // 最大法力值\n   963→    public int mpRecovery;              // 法力恢复速度\n   964→    public int costCorrection;          // 消耗修正\n   965→\n   966→    // === 伤害系统 ===\n   967→    public float criticalChance;        // 暴击率\n   968→    public float damageCorrection;      // 伤害修正\n   969→\n   970→    // === 插槽系统 ===\n   971→    public SlotData[] normalSlots;      // 普通插槽数组\n   972→    public SlotData[] postSlots;        // 后置插槽数组\n   973→    public bool[] normalSlotIsLock;     // 普通插槽锁定状态\n   974→    public bool[] postSlotIsLock;       // 后置插槽锁定状态\n   975→\n   976→    // === 特殊能力 ===\n   977→    public WandAbility specialAbility;  // 特殊能力类型\n   978→\n   979→    // === 后置插槽触发系统 ===\n   980→    public WandPostSlotTriggerType postSlotTriggerType;\n   981→    public float PostSlotTriggerChargeRatio;\n   982→    public float PostslotMoveChargeRatio;      // 移动充能比例\n   983→    public float PostslotKillEnemyChargeRatio; // 击杀敌人充能比例\n   984→    public float PostslotSpellHitChargeRatio;  // 技能命中充能比例\n   985→    public float PostslotStandChargeRatio;     // 站立充能比例\n   986→    public float PostslotCastSpellChargeRatio; // 施法充能比例\n   987→    public float PostslotHighDamageChargeRatio;// 高伤害充能比例\n   988→    public float PostslotCriticalHitChargeRatio; // 暴击充能比例\n   989→    public float PostslotTakeDamageChargeRatio;  // 受伤充能比例\n   990→    public float PostslotTimeChargeRatio;      // 时间充能比例\n   991→\n   992→    // === 扩展字段 ===\n   993→    public int int1, int2, int3;\n   994→    public float float1, float2, float3;\n   995→}\n   996→```\n   997→\n   998→### 法杖更新流程\n   999→\n  1000→```csharp\n  1001→private void Update()\n  1002→{\n  1003→    // 1. 更新计时器\n  1004→    ShootIntervalTimer -= PlayerMgr.Inst.PlayerDeltaTime;\n  1005→    CoolingTimer -= PlayerMgr.Inst.PlayerDeltaTime;\n  1006→\n  1007→    // 2. 法力恢复\n  1008→    if (CurrentMP < MaxMP && passiveEnablaManaRegen)\n  1009→    {\n  1010→        CurrentMP += GetWandMpRecoverSpeed() * PlayerMgr.Inst.PlayerDeltaTime;\n  1011→        if (CurrentMP > MaxMP)\n  1012→            CurrentMP = MaxMP;\n  1013→    }\n  1014→\n  1015→    if (WandCfg == null) return;\n  1016→\n  1017→    // 3. 充能控制更新\n  1018→    ChargeControlUpdate();\n  1019→\n  1020→    // 4. 后置插槽触发状态更新\n  1021→    PostSlotTriggerStateUpdate();\n  1022→\n  1023→    // 5. 检查插槽变化\n  1024→    if (PlayerMgr.Inst.WandCheckSlotCount(WandIndex))\n  1025→    {\n  1026→        ResetAndRecheck();\n  1027→    }\n  1028→\n  1029→    // 6. 检查最大法力变化\n  1030→    if (Math.Abs(maxManaInLastFrame - MaxMP) > 0.01f)\n  1031→    {\n  1032→        maxManaInLastFrame = MaxMP;\n  1033→        ResetAndRecheck();\n  1034→    }\n  1035→\n  1036→    // 7. UI更新\n  1037→    UI_WandManaPercentUpdate();        // 法力百分比\n  1038→    UI_PostSlotIconPercentUpdate();    // 后置插槽图标\n  1039→    UI_UpdateNoManaWarning();          // 缺少法力警告\n  1040→    UI_UpdateUnusedWarning();          // 未使用警告\n  1041→    UI_UpdateWandFlipState();          // 法杖翻转状态\n  1042→    UI_UpdatePreShootHint();           // 预射击提示\n  1043→}\n  1044→```\n  1045→\n  1046→### 法杖发射系统\n  1047→\n  1048→#### 1. 检查是否可以发射\n  1049→\n  1050→```csharp\n  1051→public bool CanShoot()\n  1052→{\n  1053→    // 检查冷却时间\n  1054→    if (CoolingTimer > 0) return false;\n  1055→\n  1056→    // 检查射击间隔\n  1057→    if (ShootIntervalTimer > 0) return false;\n  1058→\n  1059→    // 检查是否有技能\n  1060→    if (currentShootGroup == null) return false;\n  1061→    if (currentShootGroup.Shoots.Length == 0) return false;\n  1062→\n  1063→    // 检查法力值\n  1064→    float manaCost = currentShootGroup.GetGroupManaCost(1f);\n  1065→    if (CurrentMP < manaCost) return false;\n  1066→\n  1067→    // 检查充能模式\n  1068→    if (IsCharging) return false;\n  1069→\n  1070→    return true;\n  1071→}\n  1072→```\n  1073→\n  1074→#### 2. 发射技能\n  1075→\n  1076→```csharp\n  1077→public void ShootSpell()\n  1078→{\n  1079→    if (!CanShoot()) return;\n  1080→\n  1081→    // 1. 消耗法力\n  1082→    float manaCost = currentShootGroup.GetGroupManaCost(1f);\n  1083→    CurrentMP -= manaCost;\n  1084→\n  1085→    // 2. 重置计时器\n  1086→    ShootIntervalTimer = WandShootInterval;\n  1087→    CoolingTimer = WandCoolDown;\n  1088→\n  1089→    // 3. 发射当前组\n  1090→    ShootSpellGroup(currentShootGroup);\n  1091→\n  1092→    // 4. 切换到下一组\n  1093→    currentSpellGroupsIndex = (currentSpellGroupsIndex + 1) % shootGroups.Count;\n  1094→\n  1095→    // 5. 回响检测\n  1096→    if (Random.value < passiveEchoShootChance)\n  1097→    {\n  1098→        EchoShoot();\n  1099→    }\n  1100→\n  1101→    // 6. 后置插槽触发检测\n  1102→    WandPostSlotTrigger.PostSlotCastSpellTriggerCheck(this);\n  1103→}\n  1104→\n  1105→// 发射技能组\n  1106→private void ShootSpellGroup(SpellShootGroup group)\n  1107→{\n  1108→    foreach (SpellShootData shootData in group.Shoots)\n  1109→    {\n  1110→        ShootSingleSpell(shootData);\n  1111→    }\n  1112→}\n  1113→\n  1114→// 发射单个技能\n  1115→private void ShootSingleSpell(SpellShootData shootData)\n  1116→{\n  1117→    // 1. 创建初始化参数\n  1118→    SpellInitialParameter.Builder builder = new SpellInitialParameter.Builder();\n  1119→    builder.ApplyUnitEffect(PlayerMgr.Inst.PlayerEtt);\n  1120→    builder.ApplyWandEffect(this, null);\n  1121→    builder.ApplySpellShootDataEffect(shootData);\n  1122→\n  1123→    // 2. 计算发射方向和位置\n  1124→    ShootSpellSpatialInfo spatialInfo = new ShootSpellSpatialInfo\n  1125→    {\n  1126→        Position = ShootPosition,\n  1127→        Direction = ShootDirection,\n  1128→    };\n  1129→\n  1130→    // 3. 构建参数\n  1131→    SpellInitialParameter parameter = builder.Build(spatialInfo);\n  1132→\n  1133→    // 4. 从对象池获取技能对象\n  1134→    GameObject spellGO = SpellPoolMgr.GetSpell(parameter.shootSpellID);\n  1135→    SpellBase spell = spellGO.GetComponent<SpellBase>();\n  1136→\n  1137→    // 5. 初始化技能\n  1138→    spell.InitializeV2(parameter, shootData);\n  1139→\n  1140→    // 6. 设置位置和旋转\n  1141→    spell.transform.position = spatialInfo.Position;\n  1142→    spell.transform.rotation = Quaternion.LookRotation(\n  1143→        Vector3.forward, spatialInfo.Direction);\n  1144→\n  1145→    // 7. 播放音效\n  1146→    if (parameter.spelldataConfig.playShootSE)\n  1147→    {\n  1148→        SEMgr.Inst.PlaySE(\"SE_Shoot\", SEPlayMode.Replay, 3, 0.05f);\n  1149→    }\n  1150→}\n  1151→```\n  1152→\n  1153→### 法杖特殊能力 WandAbility\n  1154→\n  1155→```csharp\n  1156→public enum WandAbility\n  1157→{\n  1158→    None = 0,\n  1159→    RandomAllColor = 1,         // 随机所有颜色\n  1160→    RandomBaseColor = 2,        // 随机基础颜色\n  1161→    RandomHighLevelColor = 3,   // 随机高级颜色\n  1162→    HigherKnockBack = 4,        // 更高击退\n  1163→    LowerFriendlyFire = 5,      // 降低友伤\n  1164→    RandomRadiu = 6,            // 随机半径\n  1165→    SpellReverseDirection = 7,  // 技能反向\n  1166→    CheapSpellHigherDamage = 8, // 便宜技能高伤害\n  1167→    HoldingWandCharacterFly = 9,// 持有法杖角色飞行\n  1168→    // ... 更多能力\n  1169→}\n  1170→```\n  1171→\n  1172→应用特殊能力示例:\n  1173→\n  1174→```csharp\n  1175→private void ProcessWandEffect(SpellInitialParameter data)\n  1176→{\n  1177→    switch (shooterWandCfg.specialAbility)\n  1178→    {\n  1179→        case WandAbility.RandomAllColor:\n  1180→            data.ColorType = SpellTools.GetRandomColor();\n  1181→            data.IsRandomColor = true;\n  1182→            int? colorSpellId = data.ColorType.ToSpellId(1);\n  1183→            if (colorSpellId.HasValue)\n  1184→                data.extraEnhanceIds.Add(colorSpellId.Value);\n  1185→            break;\n  1186→\n  1187→        case WandAbility.HigherKnockBack:\n  1188→            data.finalKnockBackRatio *= shooterWandCfg.float2 / 100f;\n  1189→            break;\n  1190→\n  1191→        case WandAbility.LowerFriendlyFire:\n  1192→            data.undifferDamageRatio *= shooterWandCfg.float1 / 100f;\n  1193→            break;\n  1194→\n  1195→        case WandAbility.RandomRadiu:\n  1196→            data.aroundCasterRadiuRatio = Random.Range(\n  1197→                shooterWandCfg.float1, shooterWandCfg.float2);\n  1198→            break;\n  1199→\n  1200→        case WandAbility.SpellReverseDirection:\n  1201→            data.reverseDirection = !data.reverseDirection;\n  1202→            break;\n  1203→\n  1204→        case WandAbility.CheapSpellHigherDamage:\n  1205→            if (shootData.GetSpellManaCost_FinalPlayerValue(shooterWand).Result\n  1206→                <= shooterWand.WandCfg.int1)\n  1207→            {\n  1208→                data.extraDamageRatio += shooterWand.WandCfg.float1 / 100f;\n  1209→            }\n  1210→            break;\n  1211→    }\n  1212→}\n  1213→```\n  1214→\n  1215→### 插槽系统\n  1216→\n  1217→#### 1. 获取有效插槽\n  1218→\n  1219→```csharp\n  1220→public SlotData[] GetValidSlotsData(bool normal, bool post)\n  1221→{\n  1222→    List<SlotData> validSlots = new List<SlotData>();\n  1223→\n  1224→    if (normal)\n  1225→    {\n  1226→        for (int i = 0; i < normalSlots.Length; i++)\n  1227→        {\n  1228→            if (normalSlots[i] != null && !normalSlots[i].isSealSlot)\n  1229→            {\n  1230→                validSlots.Add(normalSlots[i]);\n  1231→            }\n  1232→        }\n  1233→    }\n  1234→\n  1235→    if (post)\n  1236→    {\n  1237→        for (int i = 0; i < postSlots.Length; i++)\n  1238→        {\n  1239→            if (postSlots[i] != null && !postSlots[i].isSealSlot)\n  1240→            {\n  1241→                validSlots.Add(postSlots[i]);\n  1242→            }\n  1243→        }\n  1244→    }\n  1245→\n  1246→    return validSlots.ToArray();\n  1247→}\n  1248→```\n  1249→\n  1250→#### 2. 检查插槽被动效果\n  1251→\n  1252→```csharp\n  1253→private void CheckWandSlotPassiveEffect()\n  1254→{\n  1255→    // 重置所有被动效果\n  1256→    passiveBonusMaxMp = 0f;\n  1257→    passiveWandMaxMpRatio = 1f;\n  1258→    passiveDamageRatio = 1f;\n  1259→    // ... 重置所有被动\n  1260→\n  1261→    // 处理插槽效果的委托\n  1262→    Action<SlotData, SpellConfig, bool> processSlot =\n  1263→        (slot, spell, isPostSlot) =>\n  1264→    {\n  1265→        // 处理插槽数量修改\n  1266→        if (isPostSlot)\n  1267→            ExtraPostSlot += spell.slotNumModifyValue;\n  1268→        else\n  1269→            ExtraNormalSlot += spell.slotNumModifyValue;\n  1270→\n  1271→        // 处理冷却和射击间隔\n  1272→        passiveWandCoolDownAddSubAmount += spell.coolDownAddSubRevise;\n  1273→        passiveWandShootIntervalAddSubAmount += spell.shootIntervalAddSubRevise;\n  1274→\n  1275→        // 根据能力类型应用效果\n  1276→        switch (spell.abilityType)\n  1277→        {\n  1278→            case SpellAbilityType.EmptyContainer:\n  1279→                passiveWandMaxMpRatio += spell.float1 / 100f;\n  1280→                break;\n  1281→\n  1282→            case SpellAbilityType.ManaEssence:\n  1283→                passiveBonusMpGen += spell.float1;\n  1284→                break;\n  1285→\n  1286→            case SpellAbilityType.ChargeMode:\n  1287→                passiveMpCostCorrection *= spell.mpCostMulDivCorrection / 100f;\n  1288→                passiveChargeEnable = true;\n  1289→                passiveChargeCountLimit = spell.int1;\n  1290→                passiveChargeInterval = spell.float1;\n  1291→                break;\n  1292→\n  1293→            case SpellAbilityType.WandSpirit:\n  1294→                passiveAutoWand = true;\n  1295→                break;\n  1296→\n  1297→            case SpellAbilityType.EchoRune:\n  1298→                passiveEchoShootChance += spell.float1 / 100f;\n  1299→                passiveEchoFreeShootChance += spell.float2 / 100f;\n  1300→                break;\n  1301→\n  1302→            case SpellAbilityType.EqualDistributionAngle:\n  1303→                passiveEqualAngleDistribution = true;\n  1304→                break;\n  1305→\n  1306→            case SpellAbilityType.Umbrella:\n  1307→                passiveUmbrellaEnable = true;\n  1308→                passiveBonusMaxMp += spell.int2;\n  1309→                break;\n  1310→\n  1311→            case SpellAbilityType.RuneHammer:\n  1312→                passiveRuneHammerEnable = true;\n  1313→                break;\n  1314→\n  1315→            case SpellAbilityType.LaserBeam:\n  1316→                passiveLaserCrystalEnable = true;\n  1317→                break;\n  1318→\n  1319→            case SpellAbilityType.BiAnLethalBlade:\n  1320→                passiveBiAnBladeEnable = true;\n  1321→                passiveBiAnBladeShootCount = spell.int1;\n  1322→                passiveBiAnBladeTotalCount = spell.int2;\n  1323→                break;\n  1324→\n  1325→            case SpellAbilityType.DaveHarpoons:\n  1326→                passiveDaveHarpoonsEnable = true;\n  1327→                DaveHarpoonsSpellCount = spell.int1;\n  1328→                break;\n  1329→        }\n  1330→    };\n  1331→\n  1332→    // 遍历所有插槽\n  1333→    SlotData[] validSlots = WandCfg.GetValidSlotsData(normal: true, post: false);\n  1334→    foreach (SlotData slot in validSlots)\n  1335→    {\n  1336→        processSlot(slot, slot.GetFinalConfig(), false);\n  1337→    }\n  1338→\n  1339→    validSlots = WandCfg.GetValidSlotsData(normal: false, post: true);\n  1340→    foreach (SlotData slot in validSlots)\n  1341→    {\n  1342→        processSlot(slot, slot.GetFinalConfig(), true);\n  1343→    }\n  1344→}\n  1345→```\n  1346→\n  1347→---\n  1348→\n  1349→## 技能发射系统\n  1350→\n  1351→### SpellShootGroup 发射组\n  1352→\n  1353→发射组是技能的**组织单位**,一个法杖可以有多个发射组,按顺序循环发射。\n  1354→\n  1355→```csharp\n  1356→public class SpellShootGroup\n  1357→{\n  1358→    // 该组包含的所有发射数据\n  1359→    public SpellShootData[] Shoots = Array.Empty<SpellShootData>();\n  1360→\n  1361→    // 拥有者发射数据(如果是子组)\n  1362→    public SpellShootData OwnerShootData;\n  1363→\n  1364→    // 获取组的最高后坐力\n  1365→    public float GetGroupHighestRecoil()\n  1366→    {\n  1367→        (float, float) recoilData = GetGroupRecoilData();\n  1368→        if (recoilData.Item1 * recoilData.Item2 >= 0f)\n  1369→        {\n  1370→            return Mathf.Abs(recoilData.Item1) >= Mathf.Abs(recoilData.Item2)\n  1371→                   ? recoilData.Item1 : recoilData.Item2;\n  1372→        }\n  1373→        return recoilData.Item1 + recoilData.Item2;\n  1374→    }\n  1375→\n  1376→    // 获取组的后坐力数据 (最高, 最低)\n  1377→    public (float, float) GetGroupRecoilData()\n  1378→    {\n  1379→        float[] recoils = Shoots\n  1380→            .Where(e => e.GetSpellFallExplosionRadius() <= 0f)\n  1381→            .Select(e => e.GetSpellRecoil())\n  1382→            .ToArray();\n  1383→\n  1384→        if (recoils.Length == 0)\n  1385→            return (0f, 0f);\n  1386→\n  1387→        return (recoils.Max(), recoils.Min());\n  1388→    }\n  1389→\n  1390→    // 获取组的总法力消耗\n  1391→    public float GetGroupManaCost(float summonTypeSpellManaCostRatio)\n  1392→    {\n  1393→        return Shoots.Sum(e => e.GetSpellManaCostAndSubGroupManaCost(\n  1394→            summonTypeSpellManaCostRatio));\n  1395→    }\n  1396→\n  1397→    // 获取组的法力消耗比例\n  1398→    public float GetGroupManaCostRatio(SpellShootData shootData)\n  1399→    {\n  1400→        return GetGroupManaCostRatioFromVolley(shootData)\n  1401→             * GetGroupManaCostRatioFromMultiShoot()\n  1402→             * GetGroupManaCostRatioFromParentSpell();\n  1403→    }\n  1404→}\n  1405→```\n  1406→\n  1407→### SpellShootData 发射数据\n  1408→\n  1409→发射数据是技能的**配置容器**,包含技能本体、增强列表、触发器等。\n  1410→\n  1411→```csharp\n  1412→public class SpellShootData\n  1413→{\n  1414→    // === 核心数据 ===\n  1415→    public readonly SlotData Spell;              // 技能本体\n  1416→    public readonly SpellShootGroup OwnerGroup;  // 所属组\n  1417→    public SlotData[] EnhanceList = Array.Empty<SlotData>(); // 增强列表\n  1418→    public SlotData[] Triggers = Array.Empty<SlotData>();    // 触发器列表\n  1419→    public SpellShootGroup SubGroup;             // 子组(用于触发生成子技能)\n  1420→\n  1421→    // === 属性获取方法 ===\n  1422→\n  1423→    // 获取技能飞行速度\n  1424→    public RatioValue GetSpellFlySpeed()\n  1425→    {\n  1426→        RatioValue speed = new RatioValue(Spell.GetFinalConfig().speed);\n  1427→\n  1428→        foreach (var enhance in EnhanceList)\n  1429→        {\n  1430→            SpellConfig cfg = enhance.GetFinalConfig();\n  1431→            switch (cfg.abilityType)\n  1432→            {\n  1433→                case SpellAbilityType.AroundMouse:\n  1434→                case SpellAbilityType.EnhanceSpeedValue:\n  1435→                    speed.AddBase(cfg.float1);\n  1436→                    break;\n  1437→\n  1438→                case SpellAbilityType.SpeedToDuration:\n  1439→                    speed.MulRatio(cfg.float1 / 100f);\n  1440→                    break;\n  1441→            }\n  1442→        }\n  1443→\n  1444→        return speed;\n  1445→    }\n  1446→\n  1447→    // 获取技能伤害\n  1448→    public RatioValue GetSpellDamage()\n  1449→    {\n  1450→        RatioValue damage = new RatioValue(Spell.GetFinalConfig().damage);\n  1451→\n  1452→        // 应用组伤害比例\n  1453→        damage.Merge(OwnerGroup.GetGroupDamageRatio());\n  1454→\n  1455→        // 应用增强效果\n  1456→        foreach (var enhance in EnhanceList)\n  1457→        {\n  1458→            SpellConfig cfg = enhance.GetFinalConfig();\n  1459→            switch (cfg.abilityType)\n  1460→            {\n  1461→                case SpellAbilityType.EnhanceAttackRatio:\n  1462→                    damage.AddRatio(cfg.float1 / 100f);\n  1463→                    break;\n  1464→\n  1465→                case SpellAbilityType.PowerSavingMode:\n  1466→                    damage.MulRatio(cfg.float1 / 100f);\n  1467→                    break;\n  1468→            }\n  1469→        }\n  1470→\n  1471→        return damage;\n  1472→    }\n  1473→\n  1474→    // 获取技能持续时间\n  1475→    public RatioValue GetSpellDuration()\n  1476→    {\n  1477→        RatioValue duration = new RatioValue(Spell.GetFinalConfig().duration);\n  1478→\n  1479→        foreach (var enhance in EnhanceList)\n  1480→        {\n  1481→            SpellConfig cfg = enhance.GetFinalConfig();\n  1482→            switch (cfg.abilityType)\n  1483→            {\n  1484→                case SpellAbilityType.EnhanceDurationValue:\n  1485→                    duration.AddBase(cfg.float1);\n  1486→                    break;\n  1487→\n  1488→                case SpellAbilityType.PowerSavingMode:\n  1489→                    duration.MulRatio(cfg.float2 / 100f);\n  1490→                    break;\n  1491→\n  1492→                case SpellAbilityType.RandomRotationRadiu:\n  1493→                    duration.AddBase(cfg.float3);\n  1494→                    break;\n  1495→\n  1496→                case SpellAbilityType.AroundMouse:\n  1497→                    duration.AddBase(cfg.float2);\n  1498→                    break;\n  1499→            }\n  1500→        }\n  1501→\n  1502→        return duration;\n  1503→    }\n  1504→\n  1505→    // 获取技能影响半径\n  1506→    public RatioValue GetSpellEffectRadius()\n  1507→    {\n  1508→        RatioValue radius = new RatioValue(Spell.GetFinalConfig().radius);\n  1509→\n  1510→        foreach (var enhance in EnhanceList)\n  1511→        {\n  1512→            SpellConfig cfg = enhance.GetFinalConfig();\n  1513→            switch (cfg.abilityType)\n  1514→            {\n  1515→                case SpellAbilityType.EnhanceRadiusRatio:\n  1516→                    radius.AddRatio(cfg.float1 / 100f);\n  1517→                    break;\n  1518→\n  1519→                case SpellAbilityType.RadiuRatioDown:\n  1520→                    radius.MulRatio(cfg.float1 / 100f);\n  1521→                    break;\n  1522→            }\n  1523→        }\n  1524→\n  1525→        return radius;\n  1526→    }\n  1527→\n  1528→    // 获取技能暴击率\n  1529→    public RatioValue GetSpellCriticalChance()\n  1530→    {\n  1531→        RatioValue crit = new RatioValue(Spell.GetFinalConfig().criticalChance / 100f);\n  1532→\n  1533→        foreach (var enhance in EnhanceList)\n  1534→        {\n  1535→            SpellConfig cfg = enhance.GetFinalConfig();\n  1536→            crit.AddBase(cfg.criticalChance / 100f);\n  1537→        }\n  1538→\n  1539→        return crit;\n  1540→    }\n  1541→\n  1542→    // 获取技能散射角度\n  1543→    public RatioValue GetSpellScatter()\n  1544→    {\n  1545→        RatioValue scatter = new RatioValue(Spell.GetFinalConfig().angle);\n  1546→\n  1547→        // 添加组散射(来自齐射)\n  1548→        scatter.AddBase(OwnerGroup.GetGroupShootScatterFromVolley(this));\n  1549→\n  1550→        // 添加增强散射\n  1551→        foreach (var enhance in EnhanceList)\n  1552→        {\n  1553→            scatter.AddBase(enhance.GetFinalConfig().angle);\n  1554→        }\n  1555→\n  1556→        return scatter;\n  1557→    }\n  1558→\n  1559→    // 获取多重射击数据 (数量, 间隔)\n  1560→    public (int count, float gap) GetSpellMultiShootData()\n  1561→    {\n  1562→        var multiShootEnhances = EnhanceList\n  1563→            .Select(e => e.GetFinalConfig())\n  1564→            .Where(e => e.abilityType == SpellAbilityType.Multishot)\n  1565→            .ToArray();\n  1566→\n  1567→        if (multiShootEnhances.Length == 0)\n  1568→            return (1, 0f);\n  1569→\n  1570→        int count = 1 + multiShootEnhances.Sum(e => e.int1);\n  1571→        float gap = multiShootEnhances.Max(e => e.float1);\n  1572→\n  1573→        return (count, gap);\n  1574→    }\n  1575→\n  1576→    // 获取穿透次数\n  1577→    public int GetSpellPenetrateCount()\n  1578→    {\n  1579→        return EnhanceList\n  1580→            .Select(e => e.GetFinalConfig())\n  1581→            .Where(e => e.abilityType == SpellAbilityType.Penetrate)\n  1582→            .Sum(e => e.int1);\n  1583→    }\n  1584→\n  1585→    // 获取分裂次数\n  1586→    public int GetSplitCount()\n  1587→    {\n  1588→        return EnhanceList\n  1589→            .Select(e => e.GetFinalConfig())\n  1590→            .Where(e => e.abilityType == SpellAbilityType.SpellSplit)\n  1591→            .Sum(e => e.int1);\n  1592→    }\n  1593→\n  1594→    // 获取悬停时间\n  1595→    public float GetSpellHoverDuration()\n  1596→    {\n  1597→        return EnhanceList\n  1598→            .Select(e => e.GetFinalConfig())\n  1599→            .Where(e => e.abilityType == SpellAbilityType.SpellHover)\n  1600→            .Sum(e => e.float1);\n  1601→    }\n  1602→\n  1603→    // 获取元素效果数据\n  1604→\n  1605→    // 毒素元素\n  1606→    public (float duration, float count) GetVenomElementData()\n  1607→    {\n  1608→        var venomEnhances = EnhanceList\n  1609→            .Select(e => e.GetFinalConfig())\n  1610→            .Where(e => e.abilityType == SpellAbilityType.VenomCrystal)\n  1611→            .ToArray();\n  1612→\n  1613→        if (venomEnhances.Length == 0)\n  1614→            return (0f, 0f);\n  1615→\n  1616→        float duration = venomEnhances.Max(e => e.float1);\n  1617→        float count = venomEnhances.Sum(e => (float)e.int2);\n  1618→\n  1619→        return (duration, count);\n  1620→    }\n  1621→\n  1622→    // 粘液元素\n  1623→    public (float moveSpeedRatio, float spellSpeedRatio, float duration)\n  1624→        GetMucusElementData()\n  1625→    {\n  1626→        var mucusEnhances = EnhanceList\n  1627→            .Select(e => e.GetFinalConfig())\n  1628→            .Where(e => e.abilityType == SpellAbilityType.MucusCrystal)\n  1629→            .ToArray();\n  1630→\n  1631→        if (mucusEnhances.Length == 0)\n  1632→            return (1f, 1f, 0f);\n  1633→\n  1634→        float duration = mucusEnhances.Max(e => e.float1);\n  1635→        float moveSpeedRatio = mucusEnhances\n  1636→            .Aggregate(1f, (acc, e) => acc * (e.float2 / 100f));\n  1637→        float spellSpeedRatio = mucusEnhances\n  1638→            .Aggregate(1f, (acc, e) => acc * (e.float3 / 100f));\n  1639→\n  1640→        return (moveSpeedRatio, spellSpeedRatio, duration);\n  1641→    }\n  1642→\n  1643→    // 火焰元素\n  1644→    public (float burnPercent, float duration) GetFireElementData()\n  1645→    {\n  1646→        var fireEnhances = EnhanceList\n  1647→            .Select(e => e.GetFinalConfig())\n  1648→            .Where(e => e.abilityType == SpellAbilityType.FireCrystal)\n  1649→            .ToArray();\n  1650→\n  1651→        if (fireEnhances.Length == 0)\n  1652→            return (0f, 0f);\n  1653→\n  1654→        float duration = fireEnhances.Max(e => e.float2);\n  1655→        float burnPercent = fireEnhances.Sum(e => (float)e.int1 / 100f);\n  1656→\n  1657→        return (burnPercent, duration);\n  1658→    }\n  1659→\n  1660→    // 雷电元素\n  1661→    public (float ThunderHitChance, float ThunderHitRadius, float ThunderHitDamageRatio)\n  1662→        GetThunderElementData()\n  1663→    {\n  1664→        var thunderEnhances = EnhanceList\n  1665→            .Select(e => e.GetFinalConfig())\n  1666→            .Where(e => e.abilityType == SpellAbilityType.ThunderCrystal)\n  1667→            .ToArray();\n  1668→\n  1669→        if (thunderEnhances.Length == 0)\n  1670→            return (0f, 0f, 0f);\n  1671→\n  1672→        float chance = thunderEnhances.Max(e => e.float3 / 100f);\n  1673→        float radius = thunderEnhances.Max(e => e.float1);\n  1674→        float damageRatio = thunderEnhances.Sum(e => e.float2 / 100f);\n  1675→\n  1676→        return (chance, radius, damageRatio);\n  1677→    }\n  1678→\n  1679→    // 冰冻元素\n  1680→    public float GetFrozenElementData()\n  1681→    {\n  1682→        return EnhanceList\n  1683→            .Select(e => e.GetFinalConfig())\n  1684→            .Where(e => e.abilityType == SpellAbilityType.Frozen)\n  1685→            .Max(e => e.float1);\n  1686→    }\n  1687→\n  1688→    // 虚空元素\n  1689→    public (float VoidInstantKillThreshold, float VoidExplosionHpDamageRatio,\n  1690→            float VoidExplosionRange, float VoidDuration) GetVoidElementData()\n  1691→    {\n  1692→        var voidEnhances = EnhanceList\n  1693→            .Select(e => e.GetFinalConfig())\n  1694→            .Where(e => e.abilityType == SpellAbilityType.DeathInfect)\n  1695→            .ToArray();\n  1696→\n  1697→        if (voidEnhances.Length == 0)\n  1698→            return (0f, 0f, 0f, 0f);\n  1699→\n  1700→        float threshold = voidEnhances.Min(e => e.float1 / 100f);\n  1701→        float damageRatio = voidEnhances.Max(e => e.float2 / 100f);\n  1702→        float range = voidEnhances.Max(e => e.float3);\n  1703→        float duration = voidEnhances.Max(e => e.float4);\n  1704→\n  1705→        return (threshold, damageRatio, range, duration);\n  1706→    }\n  1707→}\n  1708→```\n  1709→\n  1710→---\n  1711→\n  1712→## 技能类型详解\n  1713→\n  1714→### 1. Missile (投射物类)\n  1715→\n  1716→最常见的技能类型,发射后按照设定轨迹飞行。\n  1717→\n  1718→#### Spell1001Bullet - 基础子弹\n  1719→\n  1720→最基础的投射物,直线飞行。\n  1721→\n  1722→```csharp\n  1723→public class Spell1001Bullet : SpellBase\n  1724→{\n  1725→    public override void InitializeCallback()\n  1726→    {\n  1727→        // 应用速度到刚体速度\n  1728→        ApplySpeedToVelocity();\n  1729→    }\n  1730→\n  1731→    public override void Update()\n  1732→    {\n  1733→        base.Update();\n  1734→\n  1735→        // 更新持续时间\n  1736→        if (!SIP.spellIsFall)\n  1737→        {\n  1738→            DurationTimer += Time.deltaTime;\n  1739→        }\n  1740→\n  1741→        // 检查是否超时\n  1742→        if (DurationTimer > spellCfg.duration)\n  1743→        {\n  1744→            if (!isFlyFinish)\n  1745→            {\n  1746→                isFlyFinish = true;\n  1747→                rigid.linearVelocity = Vector3.zero;\n  1748→                CurrentSpeed = 0f;\n  1749→            }\n  1750→\n  1751→            // 悬停检测\n  1752→            if (SpellHoverTime > 0f && SpellHoverTimer < SpellHoverTime)\n  1753→            {\n  1754→                SpellHoverTimer += Time.deltaTime;\n  1755→                return;\n  1756→            }\n  1757→\n  1758→            // 触发器检测\n  1759→            if ((!spellCfg.isSplitSpell && spellSplitCount != 0)\n  1760→                || TriggerCtrl.HasOnOverTrigger())\n  1761→            {\n  1762→                PoolRecycle();\n  1763→                return;\n  1764→            }\n  1765→\n  1766→            // 缩小动画\n  1767→            transform.localScale = Vector3.one *\n  1768→                (transform.localScale.x - 5f * Time.deltaTime);\n  1769→\n  1770→            if (transform.localScale.x <= 0f)\n  1771→            {\n  1772→                PoolRecycle();\n  1773→            }\n  1774→        }\n  1775→    }\n  1776→\n  1777→    protected override TakeDamageInfo MakeDamageToUnit(UnitProperty unit)\n  1778→    {\n  1779→        TakeDamageInfo result = base.MakeDamageToUnit(unit);\n  1780→\n  1781→        // 特殊效果: 增加目标受伤比例\n  1782→        if (spellCfg.float1 > 0f)\n  1783→        {\n  1784→            unit.BonusTakeDamageRatioRegister(\n  1785→                spellCfg.float1,  // 增伤比例\n  1786→                spellCfg.float2   // 持续时间\n  1787→            );\n  1788→        }\n  1789→\n  1790→        return result;\n  1791→    }\n  1792→}\n  1793→```\n  1794→\n  1795→#### Spell1002RollBall - 滚球\n  1796→\n  1797→会在地面滚动的球形投射物。\n  1798→\n  1799→特点:\n  1800→- 受重力影响\n  1801→- 在地面反弹\n  1802→- 可以被推动\n  1803→- 与环境物理交互\n  1804→\n  1805→#### Spell1003Butterfly - 蝴蝶\n  1806→\n  1807→追踪目标的投射物。\n  1808→\n  1809→特点:\n  1810→- 自动寻找最近敌人\n  1811→- 平滑转向\n  1812→- 有最大转向速度限制\n  1813→\n  1814→### 2. Summon (召唤物类)\n  1815→\n  1816→召唤友方单位协助战斗。\n  1817→\n  1818→#### Spell2001Summon1 - 基础召唤物\n  1819→\n  1820→```csharp\n  1821→// 召唤物有自己的UnitProperty和AI\n  1822→// 继承拥有者的部分属性\n  1823→// 受召唤物增强效果影响:\n  1824→// - SpellSummonHPRatio: 生命值比例\n  1825→// - SpellSummonMoveRatio: 移动速度比例\n  1826→// - SpellSummonAttackSpeedRatio: 攻击速度比例\n  1827→// - SpellSummonHPRecover: 生命恢复\n  1828→```\n  1829→\n  1830→召唤物特殊机制:\n  1831→1. **数量限制**: summonLimit\n  1832→2. **生命周期**: 持续时间或被击杀\n  1833→3. **属性继承**: 从拥有者继承部分属性\n  1834→4. **死亡效果**: 可能爆炸、生成蠕虫等\n  1835→\n  1836→### 3. Enhance (增强类)\n  1837→\n  1838→修改其他技能的属性,不直接造成伤害。\n  1839→\n  1840→#### 常见增强类型\n  1841→\n  1842→```csharp\n  1843→// 齐射 (Volley)\n  1844→// - 增加发射数量\n  1845→// - 添加散射角度\n  1846→// - 降低单个技能法力消耗\n  1847→\n  1848→// 多重射击 (Multishot)\n  1849→// - 同一技能发射多次\n  1850→// - 有时间间隔\n  1851→// - 降低总法力消耗\n  1852→\n  1853→// 穿透 (Penetrate)\n  1854→// - 技能可以穿透敌人\n  1855→// - 穿透次数可累加\n  1856→\n  1857→// 反弹 (Rebound)\n  1858→// - 技能碰到墙壁后反弹\n  1859→// - 反弹次数可累加\n  1860→\n  1861→// 分裂 (SpellSplit)\n  1862→// - 技能结束时分裂成多个\n  1863→// - 分裂的技能继承部分属性\n  1864→\n  1865→// 悬停 (SpellHover)\n  1866→// - 技能到达目标后悬停\n  1867→// - 悬停时间内持续造成伤害\n  1868→```\n  1869→\n  1870→### 4. Passive (被动类)\n  1871→\n  1872→全局效果,不需要发射。\n  1873→\n  1874→#### 常见被动类型\n  1875→\n  1876→```csharp\n  1877→// 增强攻击 (EnhanceAttackRatio)\n  1878→// - 增加所有技能伤害百分比\n  1879→\n  1880→// 增强暴击 (EnhanceCriticalChance)\n  1881→// - 增加所有技能暴击率\n  1882→\n  1883→// 增强速度 (EnhanceSpeedValue)\n  1884→// - 增加所有技能飞行速度\n  1885→\n  1886→// 增强半径 (EnhanceRadiusRatio)\n  1887→// - 增加所有技能影响半径\n  1888→\n  1889→// 充能模式 (ChargeMode)\n  1890→// - 改变法杖为充能发射模式\n  1891→// - 蓄力越久伤害越高\n  1892→\n  1893→// 法杖精灵 (WandSpirit)\n  1894→// - 生成自动发射的法杖\n  1895→```\n  1896→\n  1897→---\n  1898→\n  1899→## 技能能力类型 SpellAbilityType\n  1900→\n  1901→### 1000系列 - 基础投射物\n  1902→\n  1903→```csharp\n  1904→Bullet = 1001              // 基础子弹\n  1905→Rollball = 1002            // 滚球\n  1906→Butterfly = 1003           // 蝴蝶\n  1907→Laser = 1004               // 激光\n  1908→PreFirework = 1005         // 前置烟花\n  1909→HoverTorch = 1006          // 悬停火把\n  1910→BlackHole = 1007           // 黑洞\n  1911→ArcaneExplosion = 1008     // 奥术爆炸\n  1912→BackMP = 1009              // 回蓝\n  1913→SnakeWalk = 1010           // 蛇形走位\n  1914→DisintegrationRay = 1011   // 瓦解射线\n  1915→FireBall = 1012            // 火球\n  1916→Meteor = 1013              // 流星\n  1917→Rainbow = 1014             // 彩虹\n  1918→ArcaneNova = 1015          // 奥术新星\n  1919→Dash = 1016                // 冲刺\n  1920→DeathAdder = 1017          // 死亡毒蛇\n  1921→ThunderAura = 1018         // 雷电光环\n  1922→HighPressureWasher = 1019  // 高压水枪\n  1923→ManaCoin = 1020            // 法力硬币\n  1924→MagicBreaker = 1021        // 破法者\n  1925→Boomerang = 1022           // 回旋镖\n  1926→JudgementBlade = 1023      // 审判之刃\n  1927→GiantBubble = 1024         // 巨型泡泡\n  1928→DragonBreath = 1025        // 龙息\n  1929→ShiningStar = 1026         // 闪耀之星\n  1930→SuperNova = 1027           // 超新星\n  1931→MrBingArrow = 1028         // 冰先生之箭\n  1932→DimensionTraveller = 1029  // 维度旅行者\n  1933→Harpoons = 1030            // 鱼叉\n  1934→ShotGun = 1031             // 散弹枪\n  1935→```\n  1936→\n  1937→### 2000系列 - 召唤物\n  1938→\n  1939→```csharp\n  1940→Summon1 = 2001             // 召唤物1\n  1941→Summon2 = 2002             // 召唤物2\n  1942→Summon3 = 2003             // 召唤物3\n  1943→Summon4 = 2004             // 召唤物4\n  1944→Summon5 = 2005             // 召唤物5\n  1945→Summon6 = 2006             // 召唤物6\n  1946→Summon7 = 2007             // 召唤物7\n  1947→Summon8 = 2008             // 召唤物8\n  1948→Summon9 = 2009             // 召唤物9\n  1949→```\n  1950→\n  1951→### 3000系列 - 增强/修改类\n  1952→\n  1953→#### 3000-3099: 发射模式修改\n  1954→\n  1955→```csharp\n  1956→Volley = 3001              // 齐射\n  1957→Multishot = 3002           // 多重射击\n  1958→TotalScattering = 3003     // 全方位散射\n  1959→MucusCrystal = 3004        // 粘液水晶\n  1960→VenomCrystal = 3005        // 毒素水晶\n  1961→Penetrate = 3006           // 穿透\n  1962→LightningChain = 3007      // 闪电链\n  1963→SpellHover = 3008          // 技能悬停\n  1964→AroundOwner = 3009         // 环绕拥有者\n  1965→AroundMouse = 3010         // 环绕鼠标\n  1966→FollowTarget = 3011        // 追踪目标\n  1967→Rebound = 3012             // 反弹\n  1968→SpellSplit = 3013          // 技能分裂\n  1969→Frozen = 3014              // 冰冻\n  1970→ParasiticWorm = 3015       // 寄生蠕虫\n  1971→```\n  1972→\n  1973→#### 3100-3199: 属性增强类\n  1974→\n  1975→```csharp\n  1976→ThunderCrystal = 3101      // 雷电水晶\n  1977→EnhanceAttackRatio = 3102  // 增强攻击比例\n  1978→EnhanceDurationValue = 3103 // 增强持续时间\n  1979→PowerSavingMode = 3104     // 节能模式\n  1980→EnhanceCriticalChance = 3105 // 增强暴击率\n  1981→EnhanceSpeedValue = 3106   // 增强速度值\n  1982→EnhanceRadiusRatio = 3107  // 增强半径比例\n  1983→EnhanceSummonHPRecover = 3108 // 增强召唤物生命恢复\n  1984→Mimic = 3109               // 模仿\n  1985→LifeLine = 3110            // 生命线\n  1986→FireCrystal = 3111         // 火焰水晶\n  1987→PullForceCrystal = 3112    // 拉力水晶\n  1988→RadiuRatioDown = 3113      // 半径比例下降\n  1989→FollowOwner = 3114         // 跟随拥有者\n  1990→FusionSummon = 3115        // 融合召唤\n  1991→SpellEndTeleport = 3116    // 技能结束传送\n  1992→RandomRotationRadiu = 3117 // 随机旋转半径\n  1993→TeammateSacrifice = 3118   // 队友牺牲\n  1994→Fall = 3119                // 下落\n  1995→TeammateSprite = 3120      // 队友精灵\n  1996→Refraction = 3121          // 折射\n  1997→Unyielding = 3122          // 不屈\n  1998→OverDrive = 3123           // 超载\n  1999→FatSpell = 3124            // 胖技能\n  2000→ReverseCast = 3125         // 反向施法\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"bbf28fa3-5608-428d-942e-53f54c1eea07","timestamp":"2025-12-18T11:35:14.607Z","toolUseResult":{"type":"text","file":{"filePath":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\03-技能系统详细文档.md","content":"# 技能系统详细文档\n\n## 目录\n1. [技能系统总览](#技能系统总览)\n2. [技能配置系统 SpellConfig](#技能配置系统-spellconfig)\n3. [技能基类 SpellBase](#技能基类-spellbase)\n4. [法杖系统 Wand](#法杖系统-wand)\n5. [技能发射系统](#技能发射系统)\n6. [技能类型详解](#技能类型详解)\n7. [技能能力类型 SpellAbilityType](#技能能力类型-spellabilitytype)\n8. [技能初始化流程](#技能初始化流程)\n9. [技能生命周期管理](#技能生命周期管理)\n10. [技能增强系统](#技能增强系统)\n\n---\n\n## 技能系统总览\n\n### 系统架构\n技能系统是游戏战斗的核心,负责处理所有法术的发射、飞行、命中、效果应用等逻辑。系统采用**配置驱动+类继承**的设计模式:\n\n```\n技能系统核心组成\n├── SpellConfig (配置数据)\n├── SpellBase (基类逻辑)\n├── Spell1001~4024 (具体实现类,100+种技能)\n├── Wand (法杖-发射器)\n├── SpellShootGroup (发射组)\n├── SpellShootData (发射数据)\n└── SpellInitialParameter (初始化参数)\n```\n\n### 技能分类\n\n#### 1. 按类型分类 (SpellType)\n```csharp\npublic enum SpellType\n{\n    Missile,    // 投射物类技能\n    Summon,     // 召唤物类技能\n    Enhance,    // 增强类技能(修改其他技能属性)\n    Passive     // 被动类技能\n}\n```\n\n#### 2. 按能力分类 (SpellAbilityType)\n共150+种不同的能力类型,分为以下几大类:\n- **1000系列**: 基础投射物技能 (Bullet, Rollball, Butterfly等)\n- **2000系列**: 召唤物技能 (Summon1~9)\n- **3000系列**: 增强/修改类技能 (Volley, Multishot, Penetrate等)\n- **4000系列**: 特殊被动技能 (ChargeMode, WandSpirit, Umbrella等)\n- **9000系列**: 怪物专用技能\n\n---\n\n## 技能配置系统 SpellConfig\n\n### 核心数据结构\n\n```csharp\npublic class SpellConfig\n{\n    // === 基础信息 ===\n    public int id;                      // 技能ID\n    public string icon;                 // 图标路径\n    public int level = 1;               // 技能等级 (1~3)\n    public ItemDropType dropType;       // 稀有度 (Common/Rare/Epic/Special)\n    public SpellType useType;           // 技能类型\n    public SpellAbilityType abilityType;// 能力类型\n\n    // === 价格系统 ===\n    public int priceCoin;               // 金币价格\n    public int priceHP;                 // 生命值价格\n\n    // === 插槽系统 ===\n    public int slotCost = 1;            // 占用插槽数量\n    public int slotNumModifyValue;      // 修改插槽数量(增加/减少)\n\n    // === 法力消耗 ===\n    public int mpCost;                  // 基础法力消耗\n    public float mpCostAddSubCorrection;// 法力消耗加减修正\n    public float mpCostMulDivCorrection;// 法力消耗乘除修正\n\n    // === 伤害系统 ===\n    public float damage;                // 基础伤害\n    public bool isDPS;                  // 是否为持续伤害\n    public float DPSDamageInterval = 0.25f; // 持续伤害间隔\n    public float criticalChance;        // 暴击率\n\n    // === 发射属性 ===\n    public int shootCount = 1;          // 发射数量\n    public float angle;                 // 散射角度\n    public float shootIntervalAddSubRevise; // 射击间隔修正\n\n    // === 物理属性 ===\n    public float speed;                 // 飞行速度\n    public float duration;              // 持续时间\n    public float knockback;             // 击退力度\n    public float recoil;                // 后坐力\n    public float upSpeed;               // 上升速度\n    public float gravity;               // 重力\n    public float radius;                // 影响半径\n\n    // === 冷却系统 ===\n    public float coolDownAddSubRevise;  // 冷却时间加减修正\n    public float coolDownRatio = 1f;    // 冷却时间比例修正\n\n    // === 特殊属性 ===\n    public bool needActivate;           // 是否需要激活\n    public bool canCompound = true;     // 是否可以合成\n    public bool isKeepCasting;          // 是否持续施法\n    public bool canCancelCasting;       // 是否可以取消施法\n    public bool isParentTypeSpell;      // 是否为父类型技能\n    public bool isSplitSpell;           // 是否会分裂\n    public bool playShootSE = true;     // 是否播放发射音效\n\n    // === 召唤物相关 ===\n    public int summonID;                // 召唤物ID\n    public int summonLimit;             // 召唤物数量上限\n\n    // === 效果相关 ===\n    public bool haveEffecforMissileSpell;  // 对投射物技能有效\n    public bool haveEffecforSummonSpell;   // 对召唤物技能有效\n\n    // === 预制体 ===\n    public string prefab;               // 预制体路径\n\n    // === 扩展字段 (用于各种特殊能力) ===\n    public float float1;                // 浮点参数1\n    public float float2;                // 浮点参数2\n    public float float3;                // 浮点参数3\n    public int int1;                    // 整数参数1\n    public int int2;                    // 整数参数2\n    public int int3;                    // 整数参数3\n}\n```\n\n### 配置加载与管理\n\n```csharp\n// 静态字典存储所有配置\npublic static Dictionary<int, SpellConfig> dic;\npublic static List<SpellConfig> list;\n\n// 获取配置副本 (防止修改原始数据)\npublic static SpellConfig GetConfigCopy(int id)\n{\n    if (!dic.ContainsKey(id))\n    {\n        Debug.LogError(\"No ID:\" + id);\n    }\n    return dic[id].Copy();\n}\n\n// 深拷贝配置\npublic SpellConfig Copy()\n{\n    return new SpellConfig\n    {\n        id = id,\n        damage = damage,\n        speed = speed,\n        // ... 拷贝所有字段\n    };\n}\n```\n\n### 配置信息格式化\n\n#### 1. 获取技能名称\n```csharp\npublic string GetName(bool includeLevel = true)\n{\n    string text = (id + 7000000).GetText();  // 从本地化系统获取\n    if (includeLevel)\n    {\n        if (level == 2)      text += \"+\";\n        else if (level == 3) text += \"++\";\n    }\n    return text;\n}\n```\n\n#### 2. 获取详细信息\n```csharp\npublic string GetInfo(float damageRatio = 1f, string newLineAdd = \"\")\n{\n    StringBuilder stringBuilder = new StringBuilder();\n\n    // 召唤物数量限制\n    if (summonLimit > 0)\n        stringBuilder.AppendIntField(14000304, summonLimit, ...);\n\n    // 召唤物生命值\n    if (useType == SpellType.Summon)\n    {\n        float maxHP = UnitConfig.map[summonID].maxHP;\n        stringBuilder.AppendFloatField(14000314, maxHP, ...);\n    }\n\n    // 伤害信息\n    if (damage != 0f)\n    {\n        stringBuilder.AppendStringField(14000301,\n            (damage * damageRatio).ToStringDamage(), ...);\n        if (isDPS)\n            stringBuilder.AppendLink(\" (\", 14000302.GetText(), \")\");\n    }\n\n    // 发射数量\n    if (shootCount > 1)\n        stringBuilder.AppendIntField(14000312, shootCount, ...);\n\n    // 射击间隔修正\n    if (shootIntervalAddSubRevise != 0f)\n        stringBuilder.AppendFloatField(14000204, shootIntervalAddSubRevise, ...);\n\n    // 冷却时间修正\n    if (coolDownAddSubRevise != 0f)\n        stringBuilder.AppendFloatField(14000205, coolDownAddSubRevise, ...);\n\n    // 暴击率\n    if (criticalChance != 0f)\n        stringBuilder.AppendFloatField(14000307, criticalChance, ...);\n\n    // 散射角度\n    if (angle != 0f)\n        stringBuilder.AppendFloatField(14000206, angle, ...);\n\n    // 法力消耗修正\n    if (mpCostAddSubCorrection != 0f)\n        stringBuilder.AppendFloatField(14000305, mpCostAddSubCorrection, ...);\n\n    // 影响半径\n    if (radius != 0f)\n        stringBuilder.AppendFloatField(14000303, radius, ...);\n\n    // 插槽消耗\n    if (slotCost > 1)\n        stringBuilder.AppendIntField(14000310, slotCost, ...);\n\n    // 插槽数量修改\n    if (slotNumModifyValue != 0)\n        stringBuilder.AppendFloatField(14000311, slotNumModifyValue, ...);\n\n    return stringBuilder.ToString().Trim();\n}\n```\n\n#### 3. 获取技能描述\n```csharp\npublic string GetDes(float damageRatio = 1f, string nextLineAdd = \"\",\n                     string color = \"\", string header = \"\")\n{\n    StringBuilder stringBuilder = new StringBuilder(\n        (id + 7100000).GetText());  // 从本地化获取描述\n\n    // 替换描述中的变量占位符\n    stringBuilder.Replace(\"int1\", int1.ToString());\n    stringBuilder.Replace(\"int2\", int2.ToString());\n    stringBuilder.Replace(\"int3\", int3.ToString());\n    stringBuilder.Replace(\"float1\", GeneralTool.FloatToRetainDecimals(float1, 1));\n    stringBuilder.Replace(\"float2\", GeneralTool.FloatToRetainDecimals(float2, 1));\n    stringBuilder.Replace(\"float3\", GeneralTool.FloatToRetainDecimals(float3, 1));\n    stringBuilder.Replace(\"shootCount\", shootCount.ToString());\n    stringBuilder.Replace(\"spellDuration\",\n        GeneralTool.FloatToRetainDecimals(duration, 1));\n\n    // 特殊能力的额外处理\n    if (abilityType == SpellAbilityType.LightningChain)\n    {\n        string newValue = TextProcesser.GetColorText(\n            Mathf.Ceil(int1 * damageRatio).ToString(\"F0\"), type);\n        stringBuilder.Replace(\"int1\", newValue);\n    }\n\n    stringBuilder.Replace(\"\\\\\", \"\\n\" + nextLineAdd);\n\n    return stringBuilder.ToString().Trim();\n}\n```\n\n### 稀有度系统\n\n```csharp\npublic string GetStrRarity()\n{\n    switch (dropType)\n    {\n        case ItemDropType.None:\n        case ItemDropType.Common:\n            return 1001601.GetText();  // \"普通\"\n        case ItemDropType.Rare:\n            return 1001602.GetText();  // \"稀有\"\n        case ItemDropType.Epic:\n            return 1001603.GetText();  // \"史诗\"\n        case ItemDropType.Special:\n            return 1001604.GetText();  // \"特殊\"\n    }\n}\n```\n\n---\n\n## 技能基类 SpellBase\n\n### 类继承结构\n\n```\nMonoBehaviour\n  └── LayerCorrect\n       └── SpellBase (抽象基类)\n            ├── Spell1001Bullet (基础子弹)\n            ├── Spell1002RollBall (滚球)\n            ├── Spell1003Butterfly (蝴蝶)\n            ├── Spell1007BlackHole (黑洞)\n            ├── Spell1008ArcaneExplosion (奥术爆炸)\n            ├── Spell1010SnakeWalk (蛇形走位)\n            ├── Spell1015ArcaneNova (奥术新星)\n            ├── Spell1019HighPressureWasher (高压水枪)\n            ├── Spell1021MagicBreaker (破法者)\n            ├── Spell1027SuperNova (超新星)\n            ├── Spell1029DimensionTraveller (维度旅行者)\n            ├── Spell1030Harpoons (鱼叉)\n            ├── Spell2001Summon1 (召唤物1)\n            ├── ... (100+种技能实现)\n            └── Spell4024DaveHarpoons (戴夫的鱼叉)\n```\n\n### 核心属性\n\n```csharp\npublic class SpellBase : LayerCorrect\n{\n    // === 物理组件 ===\n    public Rigidbody rigid;             // 刚体\n    public TriggerIn triggerIn;         // 触发器检测\n    public SphereCollider sc_Rebound;   // 球形碰撞器(反弹)\n    public BoxCollider bc_Rebound;      // 盒形碰撞器(反弹)\n    public Shadow shadow;               // 阴影\n\n    // === 拥有者信息 ===\n    public UnitProperty ownerPpt;       // 拥有者属性\n    public Transform OwnerTsf;          // 拥有者Transform\n    public Vector3 OwnerPoint;          // 拥有者位置点\n    public SpellBase OwnerSpell;        // 父技能(如果是子技能)\n\n    // === 发射信息 ===\n    public Wand shooterWand;            // 发射的法杖\n    public Vector3 Direction;           // 飞行方向\n    public Vector3 originalShootDirection; // 原始发射方向\n    public float wandShootAngle;        // 法杖发射角度\n\n    // === 配置与参数 ===\n    public SpellConfig spellCfg;        // 技能配置\n    public SpellConfig level1Cfg;       // 1级配置\n    public SpellConfig currentLevelPureCfg; // 当前等级纯配置\n    public SpellInitialParameter InitialParameter; // 初始化参数\n    public SpellShootData ShootData;    // 发射数据\n\n    // === 属性修正 ===\n    // 伤害\n    public float damageRatio = 1f;      // 伤害比例(加法)\n    public float finalDamageRatio = 1f; // 最终伤害比例(乘法)\n\n    // 速度\n    public float bonusSpeed;            // 额外速度(加法)\n    public float speedRatio = 1f;       // 速度比例(加法)\n    public float finalSpeedRatio = 1f;  // 最终速度比例(乘法)\n    public float CurrentSpeed;          // 当前速度\n    public float CurrentUpSpeed;        // 当前上升速度\n\n    // 半径\n    public float radiusRatio = 1f;      // 半径比例(加法)\n    public float finalRadiusRatio = 1f; // 最终半径比例(乘法)\n    public float ColliderRadius;        // 碰撞器半径\n\n    // 击退\n    public float knockbackRatio = 1f;       // 击退比例(加法)\n    public float finalKnockbackRatio = 1f;  // 最终击退比例(乘法)\n\n    // 持续时间\n    public float bonusDuration;             // 额外持续时间(加法)\n    public float finalDurationRatio = 1f;   // 最终持续时间比例(乘法)\n    public float DurationTimer;             // 持续时间计时器\n\n    // 其他\n    public float overalCriticalChance;  // 总暴击率\n    public float _angle;                // 散射角度\n    public float spellVolumeRatio = 1f; // 技能体积比例\n\n    // === 状态元素效果 ===\n    // 粘液\n    public float spellMucusTime;            // 粘液持续时间\n    public float spellMucusMoveSpeedRatio = 1f;  // 粘液移速比例\n    public float spellMucusSpellSpeedRatio = 1f; // 粘液技能速度比例\n\n    // 毒素\n    public float spellVenomTime;        // 毒素持续时间\n    public float spellVenomOnceCount;   // 毒素触发次数\n\n    // 冰冻\n    public float spellFrozenTime;       // 冰冻持续时间\n\n    // 燃烧\n    public float spellBurnTime;         // 燃烧持续时间\n    public float burnHpRatioPerSeconds; // 每秒燃烧血量百分比\n\n    // === 特殊移动模式 ===\n    public SpellSpecialMovementType currentSpellMovement;\n\n    // 环绕\n    public bool enableAroundPlayer = true;\n    public float spellAroundOwnerRadius;    // 环绕半径\n    public float spellAroundOwnerCurrentAngle; // 当前环绕角度\n\n    // 追踪\n    public bool enableFollowTarget = true;\n    public float spellFollowTargetRotateSpeed; // 追踪旋转速度\n    public UnitProperty spellFollowTargetPpt;  // 追踪目标\n\n    // 跟随鼠标\n    public bool enableFollowMouse = true;\n    public float spellFollowMouseLerp;      // 跟随鼠标插值\n\n    // 悬停\n    public float SpellHoverTime;        // 悬停总时间\n    public float SpellHoverTimer;       // 悬停计时器\n\n    // === 穿透系统 ===\n    public int penetrateTime;           // 穿透次数\n\n    // === 反弹系统 ===\n    public int rebounceTime;            // 反弹次数\n    public float extraReboundTime;      // 额外反弹次数\n    public float reboundAddTime;        // 添加反弹次数\n    public bool InFallRebounding;       // 是否在下落反弹中\n    public bool createReboundEffect = true; // 是否创建反弹特效\n\n    // === 折射系统 ===\n    public int remainRefractCount;      // 剩余折射次数\n    public readonly List<GameObject> refractedTargets = new List<GameObject>();\n\n    // === 分裂系统 ===\n    public int spellSplitCount;         // 分裂次数\n\n    // === 闪电链系统 ===\n    public float lightningChainDamage;  // 闪电链伤害\n    public float endThunderHitRadiu;    // 终结雷击半径\n    public float endThunderHitPercent;  // 终结雷击百分比\n    public float endTHunderHitChance;   // 终结雷击几率\n\n    // === 生命线系统 ===\n    public float lifelineDamage;        // 生命线伤害\n    public float lifelineDamageInterval = float.PositiveInfinity; // 生命线伤害间隔\n\n    // === 暴击拖拽系统 ===\n    public float criticalDragDamagePercent;  // 暴击拖拽伤害百分比\n    public float criticalDragEffectRadiu;    // 暴击拖拽效果半径\n    public int criticalDragApllyToCount;     // 暴击拖拽应用数量\n    public float criticalDragPullForce;      // 暴击拖拽拉力\n\n    // === 召唤物相关 ===\n    public float SpellSummonHPRatio = 1f;           // 召唤物生命比例\n    public float SpellSummonGainOwnerHpRatio;       // 召唤物获得拥有者生命比例\n    public float SpellSUmmonFinalHpRatio = 1f;      // 召唤物最终生命比例\n    public float SpellSummonMoveRatio = 1f;         // 召唤物移动比例\n    public float SpellSummonHPRecover;              // 召唤物生命恢复\n    public float SpellSummonHPFixDropAmount;        // 召唤物固定掉血量\n    public float SpellSummonAttackSpeedRatio = 1f;  // 召唤物攻速比例\n    public int SpellSummonAfterDeadSpawnWormCount;  // 召唤物死亡后生成蠕虫数量\n    public float SpellSummonInstantDeathHpRatio;    // 召唤物瞬间死亡血量比例\n    public float SpellSummonDeathExplodeRange;      // 召唤物死亡爆炸范围\n    public float SpellSummonDeathExplodeHpDamageRatio; // 召唤物死亡爆炸生命伤害比例\n\n    // === 状态标记 ===\n    public SpellColorType ColorType;    // 技能颜色类型\n    public bool finishedInitialize;     // 是否完成初始化\n    public bool isFlyFinish;            // 是否飞行结束\n    public bool isOwnerSpellEnd;        // 拥有者技能是否结束\n    public bool CreateFromMiniPool;     // 是否从小对象池创建\n    public bool controlByRemoteWand;    // 是否由远程法杖控制\n    public bool spellKeepCastBuffApplied; // 持续施法buff是否应用\n    public bool indirectShootByPlayer;  // 是否由玩家间接发射\n    public bool isThroughWall;          // 是否穿墙\n    public bool CanChangeTeam = true;   // 是否可以改变阵营\n    public bool CanBeCapture = true;    // 是否可以被捕获\n    public bool shouldCameraShock = true; // 是否应该相机震动\n\n    // === 其他 ===\n    public float TeammateTakDamageRatio = 1f; // 队友承受伤害比例\n    public float undifferDamageRatio = 1f;    // 无差别伤害比例\n    public Vector3 virtualRealPosition;       // 虚拟真实位置\n    public WandPostSlotChargeData wandChargeData; // 法杖后置插槽充能数据\n    public List<int> preSpellIDs;             // 前置技能ID列表\n    public bool FromEcho;                     // 是否来自回响\n}\n```\n\n### 技能生命周期\n\n```csharp\n// 1. OnEnable - 对象池启用时\npublic override void OnEnable()\n{\n    base.OnEnable();\n    finishedInitialize = false;\n    CreateFromMiniPool = false;\n}\n\n// 2. Initialize - 初始化技能\npublic void Initialize(UnitProperty ownerPp, Vector3 dir, SpellConfig cfg,\n                       Wand casterWand = null, params int[] preSpellIds)\n{\n    FinalInitialize(new SpellInitialParameter(ownerPp, dir, 0, cfg,\n                    casterWand, preSpellIds.ToList()));\n}\n\n// 3. FinalInitialize - 最终初始化\nprotected virtual void FinalInitialize(SpellInitialParameter initialParameter,\n                                       SpellShootData shootData = null)\n{\n    // 单次初始化组件\n    SingleInitial();\n\n    // 重置所有属性到默认值\n    emitFlyFinishEvent = false;\n    CurrentSpeed = 0f;\n    CurrentUpSpeed = 0f;\n    ColorType = SpellColorType.Player;\n    DurationTimer = 0f;\n    shouldCameraShock = true;\n    isFlyFinish = false;\n    wandShootAngle = 0f;\n    // ... 重置100+个属性\n\n    // 应用初始化参数\n    InitialParameter = initialParameter;\n    preSpellIDs = initialParameter.shootSpellPreSpells.Copy();\n    spellCfg = initialParameter.spelldataConfig.Copy();\n    Direction = initialParameter.shootDirection;\n    originalShootDirection = initialParameter.originShootDirection;\n\n    // 应用属性修正\n    damageRatio += initialParameter.extraDamageRatio;\n    finalDamageRatio *= initialParameter.finalDamageRatio;\n    radiusRatio += initialParameter.extraSizeRatio;\n    finalRadiusRatio *= initialParameter.finalSizeRatio;\n    knockbackRatio += initialParameter.extraKnockBackRatio;\n    finalKnockbackRatio *= initialParameter.finalKnockBackRatio;\n    bonusDuration += initialParameter.extraDuration;\n    finalDurationRatio *= initialParameter.finalDurationRatio;\n    speedRatio += initialParameter.extraSpeedRatio;\n    finalSpeedRatio *= initialParameter.finalSpeedRatio;\n    bonusSpeed += initialParameter.bounsSpeed;\n    // ... 更多修正\n\n    // 应用特殊效果数据\n    lightningChainDamage = initialParameter.lightningChainDamage;\n    lifelineDamage = initialParameter.lifeLineData.damage;\n    lifelineDamageInterval = initialParameter.lifeLineData.Interval;\n    // ... 更多特殊效果\n\n    // 设置拥有者信息\n    ownerPpt = initialParameter.ownerPpt;\n    OwnerTsf = initialParameter.OwnerTsf;\n    OwnerSpell = initialParameter.OwnerSpell;\n    OwnerPoint = initialParameter.OnwerPoint;\n\n    // 重置刚体速度\n    if (rigid) rigid.linearVelocity = Vector3.zero;\n\n    // 处理折射\n    refractedTargets.Clear();\n    if (initialParameter.RefractionInfo.HasValue)\n    {\n        remainRefractCount = initialParameter.RefractionInfo.Value.count;\n    }\n\n    // 调用子类初始化回调\n    InitializeCallback();\n\n    // 标记初始化完成\n    finishedInitialize = true;\n}\n\n// 4. Update - 每帧更新\npublic virtual void Update()\n{\n    if (!finishedInitialize) return;\n\n    // 飞行中更新\n    if (!isFlyFinish)\n    {\n        FlyUpdate();\n    }\n\n    // 生命周期检测\n    if (DurationTimer > GetFinalDuration())\n    {\n        isFlyFinish = true;\n        OnFlyFinish();\n    }\n}\n\n// 5. OnRecycle - 回收到对象池\nprotected virtual void OnRecycle()\n{\n    // 清理引用\n    ownerPpt = null;\n    OwnerTsf = null;\n    OwnerSpell = null;\n    shooterWand = null;\n    // ... 清理其他引用\n\n    // 触发回收事件\n    OnWillRecycleIgnoreRecycle.Invoke(this);\n}\n```\n\n### 碰撞与触发检测\n\n```csharp\n// TriggerIn回调 - 进入触发器\nprotected virtual void TriggerIn(Collider col)\n{\n    if (!finishedInitialize) return;\n    if (isFlyFinish && SpellHoverTimer >= SpellHoverTime) return;\n\n    GameObject go = col.gameObject;\n    string tag = go.tag;\n\n    // 处理不同标签的碰撞\n    switch (tag)\n    {\n        case \"Monster\":      // 怪物\n        case \"Destructible\": // 可破坏物\n        case \"RollBall\":     // 滚球\n        case \"Brittleness\":  // 易碎物\n            OnHitTarget(go);\n            break;\n\n        case \"Wall\":         // 墙壁\n            if (!isThroughWall)\n                OnHitWall(col);\n            break;\n\n        case \"Spell\":        // 其他技能\n            OnHitSpell(col);\n            break;\n    }\n}\n\n// 命中目标\nprotected virtual void OnHitTarget(GameObject target)\n{\n    UnitProperty targetPpt = target.GetComponent<UnitProperty>();\n    if (targetPpt == null) return;\n\n    // 队友检测\n    if (IsTeammate(targetPpt) && !CanHitTeammate())\n        return;\n\n    // 造成伤害\n    TakeDamageInfo damageInfo = MakeDamageToUnit(targetPpt);\n\n    // 触发器检测\n    TriggerCtrl.OnHitTriggerCheck(this, targetPpt, damageInfo);\n\n    // 穿透检测\n    penetrateTime--;\n    if (penetrateTime < 0)\n    {\n        PoolRecycle();\n    }\n}\n\n// 制作伤害信息\nprotected virtual TakeDamageInfo MakeDamageToUnit(UnitProperty unit)\n{\n    // 计算最终伤害\n    float finalDamage = spellCfg.damage * (1f + damageRatio) * finalDamageRatio;\n\n    // 创建伤害信息\n    TakeDamageInfo damageInfo = new TakeDamageInfo\n    {\n        attackerType = AttackerType.Spell,\n        attackerPpt = ownerPpt,\n        beHitPpt = unit,\n        damage = finalDamage,\n        criticalChance = overalCriticalChance,\n        spellBase = this,\n        knockbackForce = CalculateKnockbackForce(),\n        wandChargeData = wandChargeData,\n        playerTakeDamageRatio = 1f,\n        teammateTakeDamageRatio = TeammateTakDamageRatio,\n        isUndifferDamage = (undifferDamageRatio < 1f),\n    };\n\n    // 应用状态效果\n    ApplyStatusEffects(unit, damageInfo);\n\n    // 单位受击处理\n    unit.TakeDamage(damageInfo);\n\n    return damageInfo;\n}\n\n// 应用状态效果\nprotected virtual void ApplyStatusEffects(UnitProperty unit, TakeDamageInfo damageInfo)\n{\n    // 粘液效果\n    if (spellMucusTime > 0)\n    {\n        unit.MucusSlowDown(spellMucusTime, spellMucusMoveSpeedRatio,\n                          spellMucusSpellSpeedRatio);\n    }\n\n    // 毒素效果\n    if (spellVenomTime > 0)\n    {\n        unit.AddVenomEffect(spellVenomTime, spellVenomOnceCount);\n    }\n\n    // 冰冻效果\n    if (spellFrozenTime > 0)\n    {\n        unit.AddFrozenEffect(spellFrozenTime);\n    }\n\n    // 燃烧效果\n    if (spellBurnTime > 0)\n    {\n        unit.AddBurnEffect(spellBurnTime, burnHpRatioPerSeconds);\n    }\n}\n\n// 命中墙壁\nprotected virtual void OnHitWall(Collider col)\n{\n    // 反弹检测\n    if (rebounceTime > 0)\n    {\n        rebounceTime--;\n        Rebound(col);\n    }\n    else\n    {\n        CreateHitEffect();\n        PoolRecycle();\n    }\n}\n```\n\n### 特殊移动模式\n\n```csharp\n// 特殊移动更新\nprotected virtual void SpecialMovementUpdate()\n{\n    switch (currentSpellMovement)\n    {\n        case SpellSpecialMovementType.AroundOwner:\n            UpdateAroundOwner();\n            break;\n\n        case SpellSpecialMovementType.AroundMouse:\n            UpdateAroundMouse();\n            break;\n\n        case SpellSpecialMovementType.FollowTarget:\n            UpdateFollowTarget();\n            break;\n\n        case SpellSpecialMovementType.FollowMouse:\n            UpdateFollowMouse();\n            break;\n    }\n}\n\n// 环绕拥有者更新\nprotected virtual void UpdateAroundOwner()\n{\n    if (!enableAroundPlayer) return;\n    if (OwnerTsf == null) return;\n\n    // 更新角度\n    spellAroundOwnerCurrentAngle += CurrentSpeed * Time.deltaTime\n                                    * aroundOwnerRadiuToSpeedRatio;\n\n    // 计算位置\n    float radians = spellAroundOwnerCurrentAngle * Mathf.Deg2Rad;\n    Vector3 offset = new Vector3(\n        Mathf.Cos(radians) * spellAroundOwnerRadius,\n        Mathf.Sin(radians) * spellAroundOwnerRadius,\n        0\n    );\n\n    transform.position = OwnerTsf.position + offset;\n}\n\n// 追踪目标更新\nprotected virtual void UpdateFollowTarget()\n{\n    if (!enableFollowTarget) return;\n    if (!SpellFollowHaveTarget) return;\n\n    // 计算目标方向\n    Vector3 targetDir = (spellFollowTargetPpt.transform.position\n                        - transform.position).normalized;\n\n    // 平滑旋转\n    Direction = Vector3.RotateTowards(Direction, targetDir,\n                spellFollowTargetRotateSpeed * Time.deltaTime, 0f);\n\n    // 应用速度\n    rigid.linearVelocity = Direction * CurrentSpeed;\n}\n\n// 跟随鼠标更新\nprotected virtual void UpdateFollowMouse()\n{\n    if (!enableFollowMouse) return;\n\n    Vector3 mousePos = PlayerMgr.Inst.GetMousePoint();\n    Vector3 targetDir = (mousePos - transform.position).normalized;\n\n    Direction = Vector3.Lerp(Direction, targetDir,\n                spellFollowMouseLerp * Time.deltaTime);\n\n    rigid.linearVelocity = Direction * CurrentSpeed;\n}\n```\n\n---\n\n## 法杖系统 Wand\n\n### 核心概念\n\n法杖是技能的**发射器**和**容器**,负责:\n1. 存储和管理技能插槽\n2. 控制技能发射逻辑\n3. 管理法力值系统\n4. 应用法杖特殊能力\n\n### 核心数据结构\n\n```csharp\npublic class Wand : LayerCorrect\n{\n    // === 基础组件 ===\n    public Transform tsf_ShootPoint;    // 发射点Transform\n    public Animator animator;           // 动画控制器\n    public Transform tsf_WandRoot;      // 法杖根节点\n    public SpriteRenderer sr_Wand;      // 法杖精灵渲染器\n\n    // === 法杖配置 ===\n    public int WandIndex { get; private set; } // 法杖索引\n    public WandConfig WandCfg { get; }          // 法杖配置\n\n    // === 法力系统 ===\n    private float _currentMp;           // 当前法力值\n    public float CurrentMP { get; set; }// 当前法力(带范围限制)\n    public float MaxMP { get; }         // 最大法力值\n\n    // === 射击控制 ===\n    public float ShootIntervalTimer { get; set; } // 射击间隔计时器\n    public float CoolingTimer { get; set; }       // 冷却计时器\n    public float WandShootInterval { get; }       // 射击间隔\n    public float WandCoolDown { get; }            // 冷却时间\n\n    // === 技能组系统 ===\n    public List<SpellShootGroup> shootGroups = new List<SpellShootGroup>();\n    public List<SpellShootGroup> postSlotShootGroups = new List<SpellShootGroup>();\n    private int currentSpellGroupsIndex;\n    public SpellShootGroup currentShootGroup { get; } // 当前发射组\n\n    // === 被动效果 ===\n    // 法力相关\n    private float passiveBonusMaxMp;            // 额外最大法力\n    public float passiveWandMaxMpRatio = 1f;    // 最大法力比例\n    private float passiveBonusMpGen;            // 额外法力恢复\n    private float passiveMpGenRatio = 1f;       // 法力恢复比例\n    public float passiveMpCostCorrection = 1f;  // 法力消耗修正\n\n    // 伤害相关\n    public float passiveDamageRatio = 1f;       // 伤害比例\n\n    // 冷却相关\n    public float passiveWandCoolDownAddSubAmount;   // 冷却时间加减\n    public float passiveWandCoolDownTimeRatio = 1f; // 冷却时间比例\n    public float passiveWandShootIntervalAddSubAmount; // 射击间隔加减\n\n    // 回响系统\n    public float passiveEchoShootChance;        // 回响发射几率\n    public float passiveEchoFreeShootChance;    // 免费回响发射几率\n\n    // 均等散射\n    public bool passiveEqualAngleDistribution; // 均等角度分布\n\n    // 环绕半径\n    public float passiveRandomMinRotateRadiuRatio = 1f;\n    public float passiveRandomMaxRotateRadiuRatio = 1f;\n\n    // 特殊能力\n    public bool passiveChargeEnable;            // 充能模式启用\n    public int passiveChargeCountLimit;         // 充能次数上限\n    private float passiveChargeInterval;        // 充能间隔\n\n    public bool passiveAutoWand;                // 自动法杖模式\n    public AutoWandData passiveAutoWandShooterData; // 自动法杖数据\n\n    public bool passiveUmbrellaEnable;          // 保护伞启用\n    public bool passiveUmbrellaMpFull;          // 保护伞满法力\n\n    public bool passiveRuneHammerEnable;        // 符文锤启用\n    public bool passiveLaserCrystalEnable;      // 激光水晶启用\n    public bool passiveBiAnBladeEnable;         // 碧安之刃启用\n    public bool passiveDaveHarpoonsEnable;      // 戴夫鱼叉启用\n\n    public int ExtraNormalSlot;                 // 额外普通插槽\n    public int ExtraPostSlot;                   // 额外后置插槽\n\n    public bool PassiveTransStoneEnable;        // 转换石启用\n    public bool passiveRandomPosShoot;          // 随机位置发射\n\n    // === 后置插槽充能系统 ===\n    private float PostSlotCurrentCharge;        // 当前充能\n    private float PostSlotMaxCharge;            // 最大充能\n\n    // === 特殊道具 ===\n    public List<Spell4004ChargeStars> ChargeStars; // 充能星星列表\n    public List<GameObject> passiveLaserCrystal;   // 激光水晶列表\n    public List<Spell4019BiAnLethalBlade> passiveBiAnBlade; // 碧安之刃列表\n\n    // === 其他 ===\n    public int FinalShootCount;                 // 最终发射数量\n    public float passiveOwnerSpeedUpRatio;      // 拥有者加速比例\n}\n```\n\n### WandConfig 法杖配置\n\n```csharp\npublic class WandConfig\n{\n    // === 基础信息 ===\n    public int id;                      // 法杖ID\n    public string icon;                 // 图标路径\n    public int priceCoin;               // 金币价格\n    public int priceHP;                 // 生命值价格\n    public int dropStage;               // 掉落阶段\n\n    // === 射击属性 ===\n    public float shootInterval;         // 射击间隔\n    public float coolDown;              // 冷却时间\n    public float angle;                 // 散射角度\n    public int shootCount;              // 发射数量\n\n    // === 法力系统 ===\n    public int maxMP;                   // 最大法力值\n    public int mpRecovery;              // 法力恢复速度\n    public int costCorrection;          // 消耗修正\n\n    // === 伤害系统 ===\n    public float criticalChance;        // 暴击率\n    public float damageCorrection;      // 伤害修正\n\n    // === 插槽系统 ===\n    public SlotData[] normalSlots;      // 普通插槽数组\n    public SlotData[] postSlots;        // 后置插槽数组\n    public bool[] normalSlotIsLock;     // 普通插槽锁定状态\n    public bool[] postSlotIsLock;       // 后置插槽锁定状态\n\n    // === 特殊能力 ===\n    public WandAbility specialAbility;  // 特殊能力类型\n\n    // === 后置插槽触发系统 ===\n    public WandPostSlotTriggerType postSlotTriggerType;\n    public float PostSlotTriggerChargeRatio;\n    public float PostslotMoveChargeRatio;      // 移动充能比例\n    public float PostslotKillEnemyChargeRatio; // 击杀敌人充能比例\n    public float PostslotSpellHitChargeRatio;  // 技能命中充能比例\n    public float PostslotStandChargeRatio;     // 站立充能比例\n    public float PostslotCastSpellChargeRatio; // 施法充能比例\n    public float PostslotHighDamageChargeRatio;// 高伤害充能比例\n    public float PostslotCriticalHitChargeRatio; // 暴击充能比例\n    public float PostslotTakeDamageChargeRatio;  // 受伤充能比例\n    public float PostslotTimeChargeRatio;      // 时间充能比例\n\n    // === 扩展字段 ===\n    public int int1, int2, int3;\n    public float float1, float2, float3;\n}\n```\n\n### 法杖更新流程\n\n```csharp\nprivate void Update()\n{\n    // 1. 更新计时器\n    ShootIntervalTimer -= PlayerMgr.Inst.PlayerDeltaTime;\n    CoolingTimer -= PlayerMgr.Inst.PlayerDeltaTime;\n\n    // 2. 法力恢复\n    if (CurrentMP < MaxMP && passiveEnablaManaRegen)\n    {\n        CurrentMP += GetWandMpRecoverSpeed() * PlayerMgr.Inst.PlayerDeltaTime;\n        if (CurrentMP > MaxMP)\n            CurrentMP = MaxMP;\n    }\n\n    if (WandCfg == null) return;\n\n    // 3. 充能控制更新\n    ChargeControlUpdate();\n\n    // 4. 后置插槽触发状态更新\n    PostSlotTriggerStateUpdate();\n\n    // 5. 检查插槽变化\n    if (PlayerMgr.Inst.WandCheckSlotCount(WandIndex))\n    {\n        ResetAndRecheck();\n    }\n\n    // 6. 检查最大法力变化\n    if (Math.Abs(maxManaInLastFrame - MaxMP) > 0.01f)\n    {\n        maxManaInLastFrame = MaxMP;\n        ResetAndRecheck();\n    }\n\n    // 7. UI更新\n    UI_WandManaPercentUpdate();        // 法力百分比\n    UI_PostSlotIconPercentUpdate();    // 后置插槽图标\n    UI_UpdateNoManaWarning();          // 缺少法力警告\n    UI_UpdateUnusedWarning();          // 未使用警告\n    UI_UpdateWandFlipState();          // 法杖翻转状态\n    UI_UpdatePreShootHint();           // 预射击提示\n}\n```\n\n### 法杖发射系统\n\n#### 1. 检查是否可以发射\n\n```csharp\npublic bool CanShoot()\n{\n    // 检查冷却时间\n    if (CoolingTimer > 0) return false;\n\n    // 检查射击间隔\n    if (ShootIntervalTimer > 0) return false;\n\n    // 检查是否有技能\n    if (currentShootGroup == null) return false;\n    if (currentShootGroup.Shoots.Length == 0) return false;\n\n    // 检查法力值\n    float manaCost = currentShootGroup.GetGroupManaCost(1f);\n    if (CurrentMP < manaCost) return false;\n\n    // 检查充能模式\n    if (IsCharging) return false;\n\n    return true;\n}\n```\n\n#### 2. 发射技能\n\n```csharp\npublic void ShootSpell()\n{\n    if (!CanShoot()) return;\n\n    // 1. 消耗法力\n    float manaCost = currentShootGroup.GetGroupManaCost(1f);\n    CurrentMP -= manaCost;\n\n    // 2. 重置计时器\n    ShootIntervalTimer = WandShootInterval;\n    CoolingTimer = WandCoolDown;\n\n    // 3. 发射当前组\n    ShootSpellGroup(currentShootGroup);\n\n    // 4. 切换到下一组\n    currentSpellGroupsIndex = (currentSpellGroupsIndex + 1) % shootGroups.Count;\n\n    // 5. 回响检测\n    if (Random.value < passiveEchoShootChance)\n    {\n        EchoShoot();\n    }\n\n    // 6. 后置插槽触发检测\n    WandPostSlotTrigger.PostSlotCastSpellTriggerCheck(this);\n}\n\n// 发射技能组\nprivate void ShootSpellGroup(SpellShootGroup group)\n{\n    foreach (SpellShootData shootData in group.Shoots)\n    {\n        ShootSingleSpell(shootData);\n    }\n}\n\n// 发射单个技能\nprivate void ShootSingleSpell(SpellShootData shootData)\n{\n    // 1. 创建初始化参数\n    SpellInitialParameter.Builder builder = new SpellInitialParameter.Builder();\n    builder.ApplyUnitEffect(PlayerMgr.Inst.PlayerEtt);\n    builder.ApplyWandEffect(this, null);\n    builder.ApplySpellShootDataEffect(shootData);\n\n    // 2. 计算发射方向和位置\n    ShootSpellSpatialInfo spatialInfo = new ShootSpellSpatialInfo\n    {\n        Position = ShootPosition,\n        Direction = ShootDirection,\n    };\n\n    // 3. 构建参数\n    SpellInitialParameter parameter = builder.Build(spatialInfo);\n\n    // 4. 从对象池获取技能对象\n    GameObject spellGO = SpellPoolMgr.GetSpell(parameter.shootSpellID);\n    SpellBase spell = spellGO.GetComponent<SpellBase>();\n\n    // 5. 初始化技能\n    spell.InitializeV2(parameter, shootData);\n\n    // 6. 设置位置和旋转\n    spell.transform.position = spatialInfo.Position;\n    spell.transform.rotation = Quaternion.LookRotation(\n        Vector3.forward, spatialInfo.Direction);\n\n    // 7. 播放音效\n    if (parameter.spelldataConfig.playShootSE)\n    {\n        SEMgr.Inst.PlaySE(\"SE_Shoot\", SEPlayMode.Replay, 3, 0.05f);\n    }\n}\n```\n\n### 法杖特殊能力 WandAbility\n\n```csharp\npublic enum WandAbility\n{\n    None = 0,\n    RandomAllColor = 1,         // 随机所有颜色\n    RandomBaseColor = 2,        // 随机基础颜色\n    RandomHighLevelColor = 3,   // 随机高级颜色\n    HigherKnockBack = 4,        // 更高击退\n    LowerFriendlyFire = 5,      // 降低友伤\n    RandomRadiu = 6,            // 随机半径\n    SpellReverseDirection = 7,  // 技能反向\n    CheapSpellHigherDamage = 8, // 便宜技能高伤害\n    HoldingWandCharacterFly = 9,// 持有法杖角色飞行\n    // ... 更多能力\n}\n```\n\n应用特殊能力示例:\n\n```csharp\nprivate void ProcessWandEffect(SpellInitialParameter data)\n{\n    switch (shooterWandCfg.specialAbility)\n    {\n        case WandAbility.RandomAllColor:\n            data.ColorType = SpellTools.GetRandomColor();\n            data.IsRandomColor = true;\n            int? colorSpellId = data.ColorType.ToSpellId(1);\n            if (colorSpellId.HasValue)\n                data.extraEnhanceIds.Add(colorSpellId.Value);\n            break;\n\n        case WandAbility.HigherKnockBack:\n            data.finalKnockBackRatio *= shooterWandCfg.float2 / 100f;\n            break;\n\n        case WandAbility.LowerFriendlyFire:\n            data.undifferDamageRatio *= shooterWandCfg.float1 / 100f;\n            break;\n\n        case WandAbility.RandomRadiu:\n            data.aroundCasterRadiuRatio = Random.Range(\n                shooterWandCfg.float1, shooterWandCfg.float2);\n            break;\n\n        case WandAbility.SpellReverseDirection:\n            data.reverseDirection = !data.reverseDirection;\n            break;\n\n        case WandAbility.CheapSpellHigherDamage:\n            if (shootData.GetSpellManaCost_FinalPlayerValue(shooterWand).Result\n                <= shooterWand.WandCfg.int1)\n            {\n                data.extraDamageRatio += shooterWand.WandCfg.float1 / 100f;\n            }\n            break;\n    }\n}\n```\n\n### 插槽系统\n\n#### 1. 获取有效插槽\n\n```csharp\npublic SlotData[] GetValidSlotsData(bool normal, bool post)\n{\n    List<SlotData> validSlots = new List<SlotData>();\n\n    if (normal)\n    {\n        for (int i = 0; i < normalSlots.Length; i++)\n        {\n            if (normalSlots[i] != null && !normalSlots[i].isSealSlot)\n            {\n                validSlots.Add(normalSlots[i]);\n            }\n        }\n    }\n\n    if (post)\n    {\n        for (int i = 0; i < postSlots.Length; i++)\n        {\n            if (postSlots[i] != null && !postSlots[i].isSealSlot)\n            {\n                validSlots.Add(postSlots[i]);\n            }\n        }\n    }\n\n    return validSlots.ToArray();\n}\n```\n\n#### 2. 检查插槽被动效果\n\n```csharp\nprivate void CheckWandSlotPassiveEffect()\n{\n    // 重置所有被动效果\n    passiveBonusMaxMp = 0f;\n    passiveWandMaxMpRatio = 1f;\n    passiveDamageRatio = 1f;\n    // ... 重置所有被动\n\n    // 处理插槽效果的委托\n    Action<SlotData, SpellConfig, bool> processSlot =\n        (slot, spell, isPostSlot) =>\n    {\n        // 处理插槽数量修改\n        if (isPostSlot)\n            ExtraPostSlot += spell.slotNumModifyValue;\n        else\n            ExtraNormalSlot += spell.slotNumModifyValue;\n\n        // 处理冷却和射击间隔\n        passiveWandCoolDownAddSubAmount += spell.coolDownAddSubRevise;\n        passiveWandShootIntervalAddSubAmount += spell.shootIntervalAddSubRevise;\n\n        // 根据能力类型应用效果\n        switch (spell.abilityType)\n        {\n            case SpellAbilityType.EmptyContainer:\n                passiveWandMaxMpRatio += spell.float1 / 100f;\n                break;\n\n            case SpellAbilityType.ManaEssence:\n                passiveBonusMpGen += spell.float1;\n                break;\n\n            case SpellAbilityType.ChargeMode:\n                passiveMpCostCorrection *= spell.mpCostMulDivCorrection / 100f;\n                passiveChargeEnable = true;\n                passiveChargeCountLimit = spell.int1;\n                passiveChargeInterval = spell.float1;\n                break;\n\n            case SpellAbilityType.WandSpirit:\n                passiveAutoWand = true;\n                break;\n\n            case SpellAbilityType.EchoRune:\n                passiveEchoShootChance += spell.float1 / 100f;\n                passiveEchoFreeShootChance += spell.float2 / 100f;\n                break;\n\n            case SpellAbilityType.EqualDistributionAngle:\n                passiveEqualAngleDistribution = true;\n                break;\n\n            case SpellAbilityType.Umbrella:\n                passiveUmbrellaEnable = true;\n                passiveBonusMaxMp += spell.int2;\n                break;\n\n            case SpellAbilityType.RuneHammer:\n                passiveRuneHammerEnable = true;\n                break;\n\n            case SpellAbilityType.LaserBeam:\n                passiveLaserCrystalEnable = true;\n                break;\n\n            case SpellAbilityType.BiAnLethalBlade:\n                passiveBiAnBladeEnable = true;\n                passiveBiAnBladeShootCount = spell.int1;\n                passiveBiAnBladeTotalCount = spell.int2;\n                break;\n\n            case SpellAbilityType.DaveHarpoons:\n                passiveDaveHarpoonsEnable = true;\n                DaveHarpoonsSpellCount = spell.int1;\n                break;\n        }\n    };\n\n    // 遍历所有插槽\n    SlotData[] validSlots = WandCfg.GetValidSlotsData(normal: true, post: false);\n    foreach (SlotData slot in validSlots)\n    {\n        processSlot(slot, slot.GetFinalConfig(), false);\n    }\n\n    validSlots = WandCfg.GetValidSlotsData(normal: false, post: true);\n    foreach (SlotData slot in validSlots)\n    {\n        processSlot(slot, slot.GetFinalConfig(), true);\n    }\n}\n```\n\n---\n\n## 技能发射系统\n\n### SpellShootGroup 发射组\n\n发射组是技能的**组织单位**,一个法杖可以有多个发射组,按顺序循环发射。\n\n```csharp\npublic class SpellShootGroup\n{\n    // 该组包含的所有发射数据\n    public SpellShootData[] Shoots = Array.Empty<SpellShootData>();\n\n    // 拥有者发射数据(如果是子组)\n    public SpellShootData OwnerShootData;\n\n    // 获取组的最高后坐力\n    public float GetGroupHighestRecoil()\n    {\n        (float, float) recoilData = GetGroupRecoilData();\n        if (recoilData.Item1 * recoilData.Item2 >= 0f)\n        {\n            return Mathf.Abs(recoilData.Item1) >= Mathf.Abs(recoilData.Item2)\n                   ? recoilData.Item1 : recoilData.Item2;\n        }\n        return recoilData.Item1 + recoilData.Item2;\n    }\n\n    // 获取组的后坐力数据 (最高, 最低)\n    public (float, float) GetGroupRecoilData()\n    {\n        float[] recoils = Shoots\n            .Where(e => e.GetSpellFallExplosionRadius() <= 0f)\n            .Select(e => e.GetSpellRecoil())\n            .ToArray();\n\n        if (recoils.Length == 0)\n            return (0f, 0f);\n\n        return (recoils.Max(), recoils.Min());\n    }\n\n    // 获取组的总法力消耗\n    public float GetGroupManaCost(float summonTypeSpellManaCostRatio)\n    {\n        return Shoots.Sum(e => e.GetSpellManaCostAndSubGroupManaCost(\n            summonTypeSpellManaCostRatio));\n    }\n\n    // 获取组的法力消耗比例\n    public float GetGroupManaCostRatio(SpellShootData shootData)\n    {\n        return GetGroupManaCostRatioFromVolley(shootData)\n             * GetGroupManaCostRatioFromMultiShoot()\n             * GetGroupManaCostRatioFromParentSpell();\n    }\n}\n```\n\n### SpellShootData 发射数据\n\n发射数据是技能的**配置容器**,包含技能本体、增强列表、触发器等。\n\n```csharp\npublic class SpellShootData\n{\n    // === 核心数据 ===\n    public readonly SlotData Spell;              // 技能本体\n    public readonly SpellShootGroup OwnerGroup;  // 所属组\n    public SlotData[] EnhanceList = Array.Empty<SlotData>(); // 增强列表\n    public SlotData[] Triggers = Array.Empty<SlotData>();    // 触发器列表\n    public SpellShootGroup SubGroup;             // 子组(用于触发生成子技能)\n\n    // === 属性获取方法 ===\n\n    // 获取技能飞行速度\n    public RatioValue GetSpellFlySpeed()\n    {\n        RatioValue speed = new RatioValue(Spell.GetFinalConfig().speed);\n\n        foreach (var enhance in EnhanceList)\n        {\n            SpellConfig cfg = enhance.GetFinalConfig();\n            switch (cfg.abilityType)\n            {\n                case SpellAbilityType.AroundMouse:\n                case SpellAbilityType.EnhanceSpeedValue:\n                    speed.AddBase(cfg.float1);\n                    break;\n\n                case SpellAbilityType.SpeedToDuration:\n                    speed.MulRatio(cfg.float1 / 100f);\n                    break;\n            }\n        }\n\n        return speed;\n    }\n\n    // 获取技能伤害\n    public RatioValue GetSpellDamage()\n    {\n        RatioValue damage = new RatioValue(Spell.GetFinalConfig().damage);\n\n        // 应用组伤害比例\n        damage.Merge(OwnerGroup.GetGroupDamageRatio());\n\n        // 应用增强效果\n        foreach (var enhance in EnhanceList)\n        {\n            SpellConfig cfg = enhance.GetFinalConfig();\n            switch (cfg.abilityType)\n            {\n                case SpellAbilityType.EnhanceAttackRatio:\n                    damage.AddRatio(cfg.float1 / 100f);\n                    break;\n\n                case SpellAbilityType.PowerSavingMode:\n                    damage.MulRatio(cfg.float1 / 100f);\n                    break;\n            }\n        }\n\n        return damage;\n    }\n\n    // 获取技能持续时间\n    public RatioValue GetSpellDuration()\n    {\n        RatioValue duration = new RatioValue(Spell.GetFinalConfig().duration);\n\n        foreach (var enhance in EnhanceList)\n        {\n            SpellConfig cfg = enhance.GetFinalConfig();\n            switch (cfg.abilityType)\n            {\n                case SpellAbilityType.EnhanceDurationValue:\n                    duration.AddBase(cfg.float1);\n                    break;\n\n                case SpellAbilityType.PowerSavingMode:\n                    duration.MulRatio(cfg.float2 / 100f);\n                    break;\n\n                case SpellAbilityType.RandomRotationRadiu:\n                    duration.AddBase(cfg.float3);\n                    break;\n\n                case SpellAbilityType.AroundMouse:\n                    duration.AddBase(cfg.float2);\n                    break;\n            }\n        }\n\n        return duration;\n    }\n\n    // 获取技能影响半径\n    public RatioValue GetSpellEffectRadius()\n    {\n        RatioValue radius = new RatioValue(Spell.GetFinalConfig().radius);\n\n        foreach (var enhance in EnhanceList)\n        {\n            SpellConfig cfg = enhance.GetFinalConfig();\n            switch (cfg.abilityType)\n            {\n                case SpellAbilityType.EnhanceRadiusRatio:\n                    radius.AddRatio(cfg.float1 / 100f);\n                    break;\n\n                case SpellAbilityType.RadiuRatioDown:\n                    radius.MulRatio(cfg.float1 / 100f);\n                    break;\n            }\n        }\n\n        return radius;\n    }\n\n    // 获取技能暴击率\n    public RatioValue GetSpellCriticalChance()\n    {\n        RatioValue crit = new RatioValue(Spell.GetFinalConfig().criticalChance / 100f);\n\n        foreach (var enhance in EnhanceList)\n        {\n            SpellConfig cfg = enhance.GetFinalConfig();\n            crit.AddBase(cfg.criticalChance / 100f);\n        }\n\n        return crit;\n    }\n\n    // 获取技能散射角度\n    public RatioValue GetSpellScatter()\n    {\n        RatioValue scatter = new RatioValue(Spell.GetFinalConfig().angle);\n\n        // 添加组散射(来自齐射)\n        scatter.AddBase(OwnerGroup.GetGroupShootScatterFromVolley(this));\n\n        // 添加增强散射\n        foreach (var enhance in EnhanceList)\n        {\n            scatter.AddBase(enhance.GetFinalConfig().angle);\n        }\n\n        return scatter;\n    }\n\n    // 获取多重射击数据 (数量, 间隔)\n    public (int count, float gap) GetSpellMultiShootData()\n    {\n        var multiShootEnhances = EnhanceList\n            .Select(e => e.GetFinalConfig())\n            .Where(e => e.abilityType == SpellAbilityType.Multishot)\n            .ToArray();\n\n        if (multiShootEnhances.Length == 0)\n            return (1, 0f);\n\n        int count = 1 + multiShootEnhances.Sum(e => e.int1);\n        float gap = multiShootEnhances.Max(e => e.float1);\n\n        return (count, gap);\n    }\n\n    // 获取穿透次数\n    public int GetSpellPenetrateCount()\n    {\n        return EnhanceList\n            .Select(e => e.GetFinalConfig())\n            .Where(e => e.abilityType == SpellAbilityType.Penetrate)\n            .Sum(e => e.int1);\n    }\n\n    // 获取分裂次数\n    public int GetSplitCount()\n    {\n        return EnhanceList\n            .Select(e => e.GetFinalConfig())\n            .Where(e => e.abilityType == SpellAbilityType.SpellSplit)\n            .Sum(e => e.int1);\n    }\n\n    // 获取悬停时间\n    public float GetSpellHoverDuration()\n    {\n        return EnhanceList\n            .Select(e => e.GetFinalConfig())\n            .Where(e => e.abilityType == SpellAbilityType.SpellHover)\n            .Sum(e => e.float1);\n    }\n\n    // 获取元素效果数据\n\n    // 毒素元素\n    public (float duration, float count) GetVenomElementData()\n    {\n        var venomEnhances = EnhanceList\n            .Select(e => e.GetFinalConfig())\n            .Where(e => e.abilityType == SpellAbilityType.VenomCrystal)\n            .ToArray();\n\n        if (venomEnhances.Length == 0)\n            return (0f, 0f);\n\n        float duration = venomEnhances.Max(e => e.float1);\n        float count = venomEnhances.Sum(e => (float)e.int2);\n\n        return (duration, count);\n    }\n\n    // 粘液元素\n    public (float moveSpeedRatio, float spellSpeedRatio, float duration)\n        GetMucusElementData()\n    {\n        var mucusEnhances = EnhanceList\n            .Select(e => e.GetFinalConfig())\n            .Where(e => e.abilityType == SpellAbilityType.MucusCrystal)\n            .ToArray();\n\n        if (mucusEnhances.Length == 0)\n            return (1f, 1f, 0f);\n\n        float duration = mucusEnhances.Max(e => e.float1);\n        float moveSpeedRatio = mucusEnhances\n            .Aggregate(1f, (acc, e) => acc * (e.float2 / 100f));\n        float spellSpeedRatio = mucusEnhances\n            .Aggregate(1f, (acc, e) => acc * (e.float3 / 100f));\n\n        return (moveSpeedRatio, spellSpeedRatio, duration);\n    }\n\n    // 火焰元素\n    public (float burnPercent, float duration) GetFireElementData()\n    {\n        var fireEnhances = EnhanceList\n            .Select(e => e.GetFinalConfig())\n            .Where(e => e.abilityType == SpellAbilityType.FireCrystal)\n            .ToArray();\n\n        if (fireEnhances.Length == 0)\n            return (0f, 0f);\n\n        float duration = fireEnhances.Max(e => e.float2);\n        float burnPercent = fireEnhances.Sum(e => (float)e.int1 / 100f);\n\n        return (burnPercent, duration);\n    }\n\n    // 雷电元素\n    public (float ThunderHitChance, float ThunderHitRadius, float ThunderHitDamageRatio)\n        GetThunderElementData()\n    {\n        var thunderEnhances = EnhanceList\n            .Select(e => e.GetFinalConfig())\n            .Where(e => e.abilityType == SpellAbilityType.ThunderCrystal)\n            .ToArray();\n\n        if (thunderEnhances.Length == 0)\n            return (0f, 0f, 0f);\n\n        float chance = thunderEnhances.Max(e => e.float3 / 100f);\n        float radius = thunderEnhances.Max(e => e.float1);\n        float damageRatio = thunderEnhances.Sum(e => e.float2 / 100f);\n\n        return (chance, radius, damageRatio);\n    }\n\n    // 冰冻元素\n    public float GetFrozenElementData()\n    {\n        return EnhanceList\n            .Select(e => e.GetFinalConfig())\n            .Where(e => e.abilityType == SpellAbilityType.Frozen)\n            .Max(e => e.float1);\n    }\n\n    // 虚空元素\n    public (float VoidInstantKillThreshold, float VoidExplosionHpDamageRatio,\n            float VoidExplosionRange, float VoidDuration) GetVoidElementData()\n    {\n        var voidEnhances = EnhanceList\n            .Select(e => e.GetFinalConfig())\n            .Where(e => e.abilityType == SpellAbilityType.DeathInfect)\n            .ToArray();\n\n        if (voidEnhances.Length == 0)\n            return (0f, 0f, 0f, 0f);\n\n        float threshold = voidEnhances.Min(e => e.float1 / 100f);\n        float damageRatio = voidEnhances.Max(e => e.float2 / 100f);\n        float range = voidEnhances.Max(e => e.float3);\n        float duration = voidEnhances.Max(e => e.float4);\n\n        return (threshold, damageRatio, range, duration);\n    }\n}\n```\n\n---\n\n## 技能类型详解\n\n### 1. Missile (投射物类)\n\n最常见的技能类型,发射后按照设定轨迹飞行。\n\n#### Spell1001Bullet - 基础子弹\n\n最基础的投射物,直线飞行。\n\n```csharp\npublic class Spell1001Bullet : SpellBase\n{\n    public override void InitializeCallback()\n    {\n        // 应用速度到刚体速度\n        ApplySpeedToVelocity();\n    }\n\n    public override void Update()\n    {\n        base.Update();\n\n        // 更新持续时间\n        if (!SIP.spellIsFall)\n        {\n            DurationTimer += Time.deltaTime;\n        }\n\n        // 检查是否超时\n        if (DurationTimer > spellCfg.duration)\n        {\n            if (!isFlyFinish)\n            {\n                isFlyFinish = true;\n                rigid.linearVelocity = Vector3.zero;\n                CurrentSpeed = 0f;\n            }\n\n            // 悬停检测\n            if (SpellHoverTime > 0f && SpellHoverTimer < SpellHoverTime)\n            {\n                SpellHoverTimer += Time.deltaTime;\n                return;\n            }\n\n            // 触发器检测\n            if ((!spellCfg.isSplitSpell && spellSplitCount != 0)\n                || TriggerCtrl.HasOnOverTrigger())\n            {\n                PoolRecycle();\n                return;\n            }\n\n            // 缩小动画\n            transform.localScale = Vector3.one *\n                (transform.localScale.x - 5f * Time.deltaTime);\n\n            if (transform.localScale.x <= 0f)\n            {\n                PoolRecycle();\n            }\n        }\n    }\n\n    protected override TakeDamageInfo MakeDamageToUnit(UnitProperty unit)\n    {\n        TakeDamageInfo result = base.MakeDamageToUnit(unit);\n\n        // 特殊效果: 增加目标受伤比例\n        if (spellCfg.float1 > 0f)\n        {\n            unit.BonusTakeDamageRatioRegister(\n                spellCfg.float1,  // 增伤比例\n                spellCfg.float2   // 持续时间\n            );\n        }\n\n        return result;\n    }\n}\n```\n\n#### Spell1002RollBall - 滚球\n\n会在地面滚动的球形投射物。\n\n特点:\n- 受重力影响\n- 在地面反弹\n- 可以被推动\n- 与环境物理交互\n\n#### Spell1003Butterfly - 蝴蝶\n\n追踪目标的投射物。\n\n特点:\n- 自动寻找最近敌人\n- 平滑转向\n- 有最大转向速度限制\n\n### 2. Summon (召唤物类)\n\n召唤友方单位协助战斗。\n\n#### Spell2001Summon1 - 基础召唤物\n\n```csharp\n// 召唤物有自己的UnitProperty和AI\n// 继承拥有者的部分属性\n// 受召唤物增强效果影响:\n// - SpellSummonHPRatio: 生命值比例\n// - SpellSummonMoveRatio: 移动速度比例\n// - SpellSummonAttackSpeedRatio: 攻击速度比例\n// - SpellSummonHPRecover: 生命恢复\n```\n\n召唤物特殊机制:\n1. **数量限制**: summonLimit\n2. **生命周期**: 持续时间或被击杀\n3. **属性继承**: 从拥有者继承部分属性\n4. **死亡效果**: 可能爆炸、生成蠕虫等\n\n### 3. Enhance (增强类)\n\n修改其他技能的属性,不直接造成伤害。\n\n#### 常见增强类型\n\n```csharp\n// 齐射 (Volley)\n// - 增加发射数量\n// - 添加散射角度\n// - 降低单个技能法力消耗\n\n// 多重射击 (Multishot)\n// - 同一技能发射多次\n// - 有时间间隔\n// - 降低总法力消耗\n\n// 穿透 (Penetrate)\n// - 技能可以穿透敌人\n// - 穿透次数可累加\n\n// 反弹 (Rebound)\n// - 技能碰到墙壁后反弹\n// - 反弹次数可累加\n\n// 分裂 (SpellSplit)\n// - 技能结束时分裂成多个\n// - 分裂的技能继承部分属性\n\n// 悬停 (SpellHover)\n// - 技能到达目标后悬停\n// - 悬停时间内持续造成伤害\n```\n\n### 4. Passive (被动类)\n\n全局效果,不需要发射。\n\n#### 常见被动类型\n\n```csharp\n// 增强攻击 (EnhanceAttackRatio)\n// - 增加所有技能伤害百分比\n\n// 增强暴击 (EnhanceCriticalChance)\n// - 增加所有技能暴击率\n\n// 增强速度 (EnhanceSpeedValue)\n// - 增加所有技能飞行速度\n\n// 增强半径 (EnhanceRadiusRatio)\n// - 增加所有技能影响半径\n\n// 充能模式 (ChargeMode)\n// - 改变法杖为充能发射模式\n// - 蓄力越久伤害越高\n\n// 法杖精灵 (WandSpirit)\n// - 生成自动发射的法杖\n```\n\n---\n\n## 技能能力类型 SpellAbilityType\n\n### 1000系列 - 基础投射物\n\n```csharp\nBullet = 1001              // 基础子弹\nRollball = 1002            // 滚球\nButterfly = 1003           // 蝴蝶\nLaser = 1004               // 激光\nPreFirework = 1005         // 前置烟花\nHoverTorch = 1006          // 悬停火把\nBlackHole = 1007           // 黑洞\nArcaneExplosion = 1008     // 奥术爆炸\nBackMP = 1009              // 回蓝\nSnakeWalk = 1010           // 蛇形走位\nDisintegrationRay = 1011   // 瓦解射线\nFireBall = 1012            // 火球\nMeteor = 1013              // 流星\nRainbow = 1014             // 彩虹\nArcaneNova = 1015          // 奥术新星\nDash = 1016                // 冲刺\nDeathAdder = 1017          // 死亡毒蛇\nThunderAura = 1018         // 雷电光环\nHighPressureWasher = 1019  // 高压水枪\nManaCoin = 1020            // 法力硬币\nMagicBreaker = 1021        // 破法者\nBoomerang = 1022           // 回旋镖\nJudgementBlade = 1023      // 审判之刃\nGiantBubble = 1024         // 巨型泡泡\nDragonBreath = 1025        // 龙息\nShiningStar = 1026         // 闪耀之星\nSuperNova = 1027           // 超新星\nMrBingArrow = 1028         // 冰先生之箭\nDimensionTraveller = 1029  // 维度旅行者\nHarpoons = 1030            // 鱼叉\nShotGun = 1031             // 散弹枪\n```\n\n### 2000系列 - 召唤物\n\n```csharp\nSummon1 = 2001             // 召唤物1\nSummon2 = 2002             // 召唤物2\nSummon3 = 2003             // 召唤物3\nSummon4 = 2004             // 召唤物4\nSummon5 = 2005             // 召唤物5\nSummon6 = 2006             // 召唤物6\nSummon7 = 2007             // 召唤物7\nSummon8 = 2008             // 召唤物8\nSummon9 = 2009             // 召唤物9\n```\n\n### 3000系列 - 增强/修改类\n\n#### 3000-3099: 发射模式修改\n\n```csharp\nVolley = 3001              // 齐射\nMultishot = 3002           // 多重射击\nTotalScattering = 3003     // 全方位散射\nMucusCrystal = 3004        // 粘液水晶\nVenomCrystal = 3005        // 毒素水晶\nPenetrate = 3006           // 穿透\nLightningChain = 3007      // 闪电链\nSpellHover = 3008          // 技能悬停\nAroundOwner = 3009         // 环绕拥有者\nAroundMouse = 3010         // 环绕鼠标\nFollowTarget = 3011        // 追踪目标\nRebound = 3012             // 反弹\nSpellSplit = 3013          // 技能分裂\nFrozen = 3014              // 冰冻\nParasiticWorm = 3015       // 寄生蠕虫\n```\n\n#### 3100-3199: 属性增强类\n\n```csharp\nThunderCrystal = 3101      // 雷电水晶\nEnhanceAttackRatio = 3102  // 增强攻击比例\nEnhanceDurationValue = 3103 // 增强持续时间\nPowerSavingMode = 3104     // 节能模式\nEnhanceCriticalChance = 3105 // 增强暴击率\nEnhanceSpeedValue = 3106   // 增强速度值\nEnhanceRadiusRatio = 3107  // 增强半径比例\nEnhanceSummonHPRecover = 3108 // 增强召唤物生命恢复\nMimic = 3109               // 模仿\nLifeLine = 3110            // 生命线\nFireCrystal = 3111         // 火焰水晶\nPullForceCrystal = 3112    // 拉力水晶\nRadiuRatioDown = 3113      // 半径比例下降\nFollowOwner = 3114         // 跟随拥有者\nFusionSummon = 3115        // 融合召唤\nSpellEndTeleport = 3116    // 技能结束传送\nRandomRotationRadiu = 3117 // 随机旋转半径\nTeammateSacrifice = 3118   // 队友牺牲\nFall = 3119                // 下落\nTeammateSprite = 3120      // 队友精灵\nRefraction = 3121          // 折射\nUnyielding = 3122          // 不屈\nOverDrive = 3123           // 超载\nFatSpell = 3124            // 胖技能\nReverseCast = 3125         // 反向施法","numLines":2000,"startLine":1,"totalLines":2600}}}
{"parentUuid":"bbf28fa3-5608-428d-942e-53f54c1eea07","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LN553izqgWhfFXRBrg3XfF","type":"tool_result","content":"     1→# 战斗系统核心架构文档\n     2→\n     3→## 目录\n     4→1. [系统概述](#系统概述)\n     5→2. [战斗管理器 (BattleMgr)](#战斗管理器-battlemgr)\n     6→3. [战斗数据 (BattleData)](#战斗数据-battledata)\n     7→4. [玩家管理器 (PlayerMgr)](#玩家管理器-playermgr)\n     8→5. [战斗流程](#战斗流程)\n     9→6. [数据结构设计](#数据结构设计)\n    10→7. [关键系统交互](#关键系统交互)\n    11→\n    12→---\n    13→\n    14→## 系统概述\n    15→\n    16→这是一个基于 Unity DOTS (Data-Oriented Technology Stack) 架构的 Roguelike 战斗系统。游戏采用关卡制(Stage-Level)结构,玩家通过房间探索、战斗、获取奖励来推进游戏进程。\n    17→\n    18→### 核心特点\n    19→- **ECS 架构**: 使用 Unity DOTS 进行高性能战斗计算\n    20→- **Roguelike 元素**: 随机生成、永久死亡、资源池管理\n    21→- **魔杖+技能系统**: 玩家通过魔杖释放技能进行战斗\n    22→- **遗物/诅咒系统**: 提供战斗增益或减益效果\n    23→- **难度分级**: 支持简单/普通/困难/噩梦1-3 多种难度\n    24→\n    25→### 技术栈\n    26→- **Unity DOTS**: Entity Component System\n    27→- **物理引擎**: Unity Physics (ECS版本)\n    28→- **动画**: Spine 2D 动画系统\n    29→- **导航**: NavMesh AI 导航\n    30→\n    31→---\n    32→\n    33→## 战斗管理器 (BattleMgr)\n    34→\n    35→**文件位置**: [BattleMgr.cs](BattleMgr.cs:1)\n    36→\n    37→### 类职责\n    38→`BattleMgr` 是战斗系统的核心管理器,负责:\n    39→1. 战斗场景初始化\n    40→2. 关卡生成和切换\n    41→3. 房间配置和奖励类型管理\n    42→4. 玩家进入门后的场景切换逻辑\n    43→5. 测试模式功能\n    44→\n    45→### 关键属性\n    46→\n    47→```csharp\n    48→public class BattleMgr : MonoBehaviour\n    49→{\n    50→    // 单例\n    51→    public static BattleMgr Inst { get; private set; }\n    52→\n    53→    // 关卡配置\n    54→    public int[] stageLevelsCount;           // 每个章节(Stage)的关卡数\n    55→    public float[] rroChances;               // 随机遗物/资源/物品(RRO)出现概率\n    56→\n    57→    // 当前进度\n    58→    public int CurrentStage                   // 当前章节 (1-10)\n    59→    public int CurrentLevel                   // 当前关卡层数\n    60→    public LevelRewardType CurrentRewardType  // 当前房间的奖励类型\n    61→    public List<LevelRewardType> NextRewardTypes  // 下个房间可选的奖励类型\n    62→\n    63→    private EntityManager ettMgr;            // DOTS EntityManager\n    64→    private bool isInitialized;              // 是否初始化完成\n    65→    private bool battleStart;                // 战斗是否开始\n    66→}\n    67→```\n    68→\n    69→### 初始化流程\n    70→\n    71→#### 1. Awake() - 战斗场景加载\n    72→**位置**: [BattleMgr.cs:123-129](BattleMgr.cs:123-129)\n    73→\n    74→```csharp\n    75→private void Awake()\n    76→{\n    77→    Inst = this;\n    78→    Destroy(objToDestroy);                    // 销毁临时对象\n    79→    ettMgr = World.DefaultGameObjectInjectionWorld.EntityManager;  // 获取 ECS 管理器\n    80→    Debug.Log(\"Enter Battle\");\n    81→}\n    82→```\n    83→\n    84→**分析**:\n    85→- 设置单例实例\n    86→- 获取 DOTS 的 EntityManager,用于后续所有 Entity 操作\n    87→- 这是战斗场景的第一个入口点\n    88→\n    89→#### 2. Update() - 等待 DOTS 初始化\n    90→**位置**: [BattleMgr.cs:197-205](BattleMgr.cs:197-205)\n    91→\n    92→```csharp\n    93→private void Update()\n    94→{\n    95→    ettMgr.CheckInitialize(ref isInitialized);  // 检查 DOTS 是否初始化\n    96→    if (isInitialized && !battleStart)\n    97→    {\n    98→        battleStart = true;\n    99→        StartHandle();                          // 开始战斗初始化\n   100→    }\n   101→}\n   102→```\n   103→\n   104→**分析**:\n   105→- DOTS 系统需要异步初始化\n   106→- `CheckInitialize` 是自定义扩展方法,检查所有必要的 System 是否就绪\n   107→- 确保 Entity/System 完全加载后才开始游戏逻辑\n   108→\n   109→#### 3. StartHandle() - 战斗初始化分支\n   110→**位置**: [BattleMgr.cs:207-412](BattleMgr.cs:207-412)\n   111→\n   112→```csharp\n   113→private void StartHandle()\n   114→{\n   115→    InputChange();                            // 更新输入UI显示\n   116→    UIPlayerDataMgr.Inst.ClearDragData();    // 清除拖拽数据\n   117→\n   118→    // 根据测试配置选择启动模式\n   119→    if (ScriptableObjMgr.Inst.testCtrller.BattleChapter)\n   120→        Start_TestChapter();                  // 测试模式\n   121→    else\n   122→        Start_Normal();                       // 正常模式\n   123→\n   124→    // ... 剧情逻辑处理\n   125→    // ... 测试模式物品生成 (魔杖/技能/遗物/药水)\n   126→}\n   127→```\n   128→\n   129→**关键测试功能**:\n   130→- `BattleAllWand`: 生成所有魔杖到地面\n   131→- `BattleAllSpell`: 生成所有技能到地面\n   132→- `BattleAllRelic`: 生成所有遗物到地面\n   133→- `BattleCoin1000`: 给玩家1000金币\n   134→- `BattleKey100`: 给玩家100钥匙\n   135→\n   136→---\n   137→\n   138→### 正常模式启动 (Start_Normal)\n   139→\n   140→**位置**: [BattleMgr.cs:414-557](BattleMgr.cs:414-557)\n   141→\n   142→```csharp\n   143→private void Start_Normal()\n   144→{\n   145→    BattleData _archiveBattleData = DataMgr.selectedWorldData.battleData8;\n   146→\n   147→    // 1. 创建玩家\n   148→    PlayerMgr.Inst.CreatePlayer();\n   149→    CamController.Inst.SetFollow(PlayerMgr.Inst.PlayerT);\n   150→\n   151→    // 2. 随机技能魔杖检查\n   152→    DataMgr.selectedWorldData.battleData8.RandomSpellWandCheck();\n   153→\n   154→    // 3. 清除伤害记录\n   155→    DamageRecordeManager.ClearAllRecorde();\n   156→\n   157→    // 4. 获取房间配置\n   158→    Dictionary<Vector2Int, RoomConfig> dictionary = new Dictionary<Vector2Int, RoomConfig>();\n   159→\n   160→    if (DataMgr.selectedWorldData.inBattle8)  // 从存档恢复\n   161→    {\n   162→        // 恢复存档的房间配置\n   163→        RoomConfig config = RoomConfig.GetConfig(BaData.currentRoomID);\n   164→        config.isFinalRoom = true;\n   165→        dictionary.Add(Vector2Int.zero, config);\n   166→        // ... 恢复玩家装备、遗物、诅咒\n   167→    }\n   168→    else  // 新游戏\n   169→    {\n   170→        dictionary = GetRoomCfgs(CurrentRewardType);  // 生成新房间\n   171→        NextRewardTypes = OutputMgr.GetDoors();       // 生成下一关可选门\n   172→\n   173→        // 第一次进入战斗的初始化\n   174→        if (DataMgr.selectedWorldData.firstEnterBattle)\n   175→        {\n   176→            CurrentLevel = 1;\n   177→            CurrentRewardType = LevelRewardType.Relic;\n   178→            // 给予初始魔杖和技能\n   179→            PlayerMgr.Inst.BaData.wandCfgs = new List<WandConfig> { WandConfig.GetConfig(1) };\n   180→            PlayerMgr.Inst.ChangeWandSpell(0, WandSlotType.Normal, 0, new SlotData(30051, 0));\n   181→            PlayerMgr.Inst.ChangeWandSpell(0, WandSlotType.Normal, 1, new SlotData(31031, 0));\n   182→        }\n   183→    }\n   184→\n   185→    // 5. 创建关卡\n   186→    Time.timeScale = 0f;  // 暂停时间,等待关卡加载\n   187→    LevelMgr.Inst.CreateLevel(dictionary, CurrentRewardType, NextRewardTypes,\n   188→        NextExtraDoorRewardType, fadeDisappear: false,\n   189→        delegate {\n   190→            CreateLevelFinish(!DataMgr.selectedWorldData.inBattle8);\n   191→            // ... 更新UI、重建魔杖、回满蓝\n   192→        });\n   193→}\n   194→```\n   195→\n   196→**关键流程分析**:\n   197→\n   198→1. **玩家创建**: [PlayerMgr.cs:276-339](PlayerMgr.cs:276-339)\n   199→   - 创建 Entity (DOTS)\n   200→   - 实例化 GameObject (渲染/控制)\n   201→   - 初始化玩家配置\n   202→\n   203→2. **存档恢复机制**:\n   204→   ```csharp\n   205→   if (DataMgr.selectedWorldData.inBattle8)  // 从战斗中恢复\n   206→   ```\n   207→   - 恢复遗物等级和计时器\n   208→   - 恢复诅咒状态\n   209→   - 恢复玩家体型\n   210→   - 特殊处理某些遗物(如WandAddSlot需要先添加低级版本)\n   211→\n   212→3. **新手引导**:\n   213→   ```csharp\n   214→   if (DataMgr.selectedWorldData.firstEnterBattle)\n   215→   {\n   216→       // 固定给予1号魔杖 + 基础技能\n   217→       wandCfgs = new List<WandConfig> { WandConfig.GetConfig(1) };\n   218→   }\n   219→   ```\n   220→\n   221→---\n   222→\n   223→### 房间生成系统 (GetRoomCfgs)\n   224→\n   225→**位置**: [BattleMgr.cs:633-882](BattleMgr.cs:633-882)\n   226→\n   227→这是战斗系统最复杂的方法之一,负责根据奖励类型生成对应的房间配置。\n   228→\n   229→#### 房间类型 (RoomType)\n   230→- `Monster`: 普通怪物房间\n   231→- `Elite`: 精英怪房间\n   232→- `Boss`: Boss房间\n   233→- `Puzzle`: 谜题/支线房间\n   234→- `Shortcut`: 快捷通道(跳过4层)\n   235→\n   236→#### 奖励类型 (LevelRewardType)\n   237→```csharp\n   238→public enum LevelRewardType\n   239→{\n   240→    None,      // 无奖励\n   241→    Spell,     // 技能奖励\n   242→    Relic,     // 遗物奖励\n   243→    MaxHP,     // 最大生命值提升\n   244→    Coin,      // 金币奖励\n   245→    Elite,     // 精英战斗\n   246→    Boss,      // Boss战斗\n   247→    Store,     // 商店\n   248→    Process,   // 加工站(升级技能)\n   249→    Spring,    // 温泉(回血)\n   250→    Shortcut,  // 快捷通道\n   251→    Wand,      // 魔杖(未使用)\n   252→    Chapter    // 章节过渡\n   253→}\n   254→```\n   255→\n   256→#### 房间生成逻辑\n   257→\n   258→```csharp\n   259→private Dictionary<Vector2Int, RoomConfig> GetRoomCfgs(LevelRewardType rewardType)\n   260→{\n   261→    Dictionary<Vector2Int, RoomConfig> dictionary = new Dictionary<Vector2Int, RoomConfig>();\n   262→\n   263→    // 测试关卡模式 (Stage >= 50)\n   264→    if (CurrentStage >= 50)\n   265→    {\n   266→        RoomConfig testRoomFromPool = PlayerMgr.Inst.BaData.GetTestRoomFromPool();\n   267→        testRoomFromPool.isFinalRoom = true;\n   268→        if (UnityEngine.Random.Range(0, 2) == 0)\n   269→            testRoomFromPool.ReverseX();  // 随机镜像\n   270→        testRoomFromPool.generateRO = true;  // 生成随机物品\n   271→        dictionary.Add(Vector2Int.zero, testRoomFromPool);\n   272→        // ... 侧边房间生成\n   273→    }\n   274→\n   275→    // 第0关(新手引导关卡)\n   276→    else if (CurrentLevel == 0 && CurrentStage % 2 == 1)\n   277→    {\n   278→        RoomConfig testRoomFromPool = OutputMgr.GetChapterRoom0();\n   279→        testRoomFromPool.isFinalRoom = true;\n   280→        dictionary.Add(new Vector2Int(0, 0), testRoomFromPool);\n   281→    }\n   282→\n   283→    // 根据不同奖励类型生成房间\n   284→    else\n   285→    {\n   286→        switch (rewardType)\n   287→        {\n   288→            case LevelRewardType.Spell:\n   289→            case LevelRewardType.Relic:\n   290→            case LevelRewardType.MaxHP:\n   291→            case LevelRewardType.Coin:\n   292→                // 普通战斗房间逻辑\n   293→                bool needSideRoom = PlayerMgr.Inst.BaData.specialRoomLevels.Contains(CurrentLevel);\n   294→                float rroChance = rroChances[CurrentStage - 1];\n   295→                bool needRRO = (UnityEngine.Random.value <= rroChance);\n   296→\n   297→                RoomConfig room = PlayerMgr.Inst.BaData.GetRoomFromPool(\n   298→                    RoomType.Monster, needSideRoom, needRRO);\n   299→                dictionary.Add(new Vector2Int(0, 0), room);\n   300→\n   301→                // 侧边房间(谜题房)\n   302→                if (needSideRoom)\n   303→                {\n   304→                    RoomConfig sideRoom = GetPuzzleRoom();  // 特殊剧情或普通谜题房\n   305→                    int direction = DetermineSideRoomDirection(room);\n   306→                    if (direction == -1) sideRoom.ReverseX();\n   307→                    dictionary.Add(new Vector2Int(direction, 0), sideRoom);\n   308→                }\n   309→                break;\n   310→\n   311→            case LevelRewardType.Boss:\n   312→                // Boss房间特殊处理\n   313→                bool useDave = CheckDaveBoss();\n   314→                dictionary.Add(new Vector2Int(0, 0), OutputMgr.GetBossRoom0(useDave));\n   315→                RoomConfig bossRoom = PlayerMgr.Inst.BaData.GetRoomFromPool(\n   316→                    RoomType.Boss, false, false, useDave);\n   317→                dictionary.Add(new Vector2Int(0, 1), bossRoom);\n   318→\n   319→                // 隐藏Boss房间\n   320→                if (ShouldHaveHiddenBoss())\n   321→                {\n   322→                    RoomConfig hiddenBoss = OutputMgr.GetHideBossRoom(useDave);\n   323→                    dictionary.Add(new Vector2Int(direction, 1), hiddenBoss);\n   324→                }\n   325→                break;\n   326→\n   327→            case LevelRewardType.Store:\n   328→                // 商店\n   329→                dictionary.Add(Vector2Int.zero, OutputMgr.GetStoreRoomCfg(CurrentStage));\n   330→                // 特殊遗物可能触发侧边药水房\n   331→                if (PlayerMgr.Inst.ItemCtrller.relic_SpecialStore)\n   332→                {\n   333→                    dictionary.Add(sidePos, OutputMgr.GetPotionRoomCfg(CurrentStage));\n   334→                }\n   335→                break;\n   336→\n   337→            // ... 其他房间类型\n   338→        }\n   339→    }\n   340→\n   341→    return dictionary;\n   342→}\n   343→```\n   344→\n   345→**关键概念**:\n   346→\n   347→1. **RRO (Random Relic/Resource/Object)**\n   348→   - 房间内随机生成的物品\n   349→   - 概率随章节递增: `rroChances[CurrentStage - 1]`\n   350→   - 可能是遗物、金币、钥匙等\n   351→\n   352→2. **侧边房间 (Side Room)**\n   353→   - 特定关卡会生成额外的侧边房间\n   354→   - 通过 `specialRoomLevels` 列表控制\n   355→   - 方向通过主房间的 `accessLeft/accessRight` 决定\n   356→\n   357→3. **房间镜像**\n   358→   - `ReverseX()` 方法可镜像房间布局\n   359→   - 用于增加房间多样性\n   360→\n   361→---\n   362→\n   363→### 玩家进入门系统 (PlayerEnterDoor)\n   364→\n   365→**位置**: [BattleMgr.cs:893-1140](BattleMgr.cs:893-1140)\n   366→\n   367→这是战斗流程中最关键的方法,处理玩家进入下一个房间的所有逻辑。\n   368→\n   369→```csharp\n   370→public void PlayerEnterDoor(DoorBase_Dots doorBase)\n   371→{\n   372→    // 1. DLC检查 (BiliBili版本限制)\n   373→    if (GameMgr.IsMobile_Static && GameMgr.ISUseBiliOneSDK &&\n   374→        NeedPurchaseCheck() && !GameMgr.HaveGame)\n   375→    {\n   376→        GameUISingletonMono<UIFullGame>.ShowInit();\n   377→        return;\n   378→    }\n   379→\n   380→    // 2. 自动存档\n   381→    if (CurrentStage > 1 || CurrentLevel > 0)\n   382→    {\n   383→        DataMgr.SaveSelectedWorldData();\n   384→    }\n   385→\n   386→    // 3. 记录战斗日志\n   387→    if (CurrentStage == 1 && CurrentLevel == 0)\n   388→    {\n   389→        // 记录游戏开始日志\n   390→        BattleStartLogger logger = new BattleStartLogger();\n   391→        logger.suit = new Suit { id = DataMgr.selectedWorldData.selectedSetID };\n   392→        logger.ban_spells = GetBannedSpells();\n   393→        logger.Report();\n   394→    }\n   395→    else if (LevelMgr.Inst.RoomFinishLogger != null)\n   396→    {\n   397→        // 记录房间完成日志\n   398→        RoomFinishLogger logger = LevelMgr.Inst.RoomFinishLogger;\n   399→        logger.finish_equips = PlayerEquips.CreateAuto();\n   400→        logger.spend_seconds = GetSpendTime();\n   401→        logger.next_room_selected = doorBase.rewardType;\n   402→    }\n   403→\n   404→    // 4. 特殊剧情检查\n   405→    if (CheckSpecialStory())\n   406→    {\n   407→        // 跳转到特殊剧情场景\n   408→        SceneManager.LoadScene(\"NPC7Appearance\");\n   409→        return;\n   410→    }\n   411→\n   412→    // 5. 停止玩家移动\n   413→    PlayerMgr.Inst.PlayerCtrller.StopMotion();\n   414→\n   415→    // 6. 处理进门前效果\n   416→    ProcessPlayerEnterDoorEffects(doorBase);\n   417→\n   418→    // 7. 清理当前房间\n   419→    DamageRecordeManager.ClearCurrentRecorde();\n   420→    UIPlayerDataMgr.Inst.CancelDrag();\n   421→\n   422→    // 8. 淡出并加载新场景\n   423→    UIMgr.Inst.uiFade.Show(delegate {\n   424→        // 恢复魔杖能量\n   425→        float mpRatio = CalculateMPRatio();\n   426→        PlayerMgr.Inst.AllWandFullMP(mpRatio);\n   427→\n   428→        // 无敌和飞行状态\n   429→        PlayerMgr.Inst.InvincibleRegister();\n   430→        PlayerMgr.Inst.FlyRegisterWithAllMate();\n   431→\n   432→        // 回收对象池\n   433→        GameMgr.Inst.RecycleAllPool();\n   434→\n   435→        // 处理章节过渡\n   436→        if (doorBase.rewardType == LevelRewardType.Chapter)\n   437→        {\n   438→            CurrentStage++;\n   439→            CurrentLevel = 0;\n   440→            ShowChapterTransition();\n   441→        }\n   442→        else\n   443→        {\n   444→            // 更新进度\n   445→            UpdateProgress(doorBase);\n   446→\n   447→            // 生成新房间\n   448→            Dictionary<Vector2Int, RoomConfig> roomCfgs = GetRoomCfgs(doorBase.rewardType);\n   449→            LevelMgr.Inst.CreateLevel(roomCfgs, CurrentRewardType,\n   450→                NextRewardTypes, NextExtraDoorRewardType,\n   451→                fadeDisappear: true, PlayerEnterDoor2);\n   452→        }\n   453→    });\n   454→}\n   455→```\n   456→\n   457→#### 进门前效果 (ProcessPlayerEnterDoorEffects)\n   458→\n   459→**位置**: [BattleMgr.cs:1142-1220](BattleMgr.cs:1142-1220)\n   460→\n   461→```csharp\n   462→private void ProcessPlayerEnterDoorEffects(DoorBase_Dots door)\n   463→{\n   464→    // 1. 遗物组效果 - 临时护盾转永久\n   465→    if (ItemCtrller.relicGroupConfigs.TryGetValue(1, out var config))\n   466→    {\n   467→        float shieldPercent = config.int1.result / 100f;\n   468→        float shield = playerPpt.unitCfg.shieldTemp * shieldPercent;\n   469→        PlayerMgr.Inst.ChangeShield(shield);\n   470→    }\n   471→\n   472→    // 2. 清除临时护盾\n   473→    if (playerPpt.unitCfg.shieldTemp > 0f)\n   474→    {\n   475→        PlayerMgr.Inst.ChangeShieldTemp(-playerPpt.unitCfg.shieldTemp);\n   476→    }\n   477→\n   478→    // 3. 迷幻药水效果清除\n   479→    if (ItemCtrller.uiPotionPsychedelic != null)\n   480→    {\n   481→        ItemCtrller.uiPotionPsychedelic.DestroySelf();\n   482→    }\n   483→\n   484→    // 4. 计算跨越层数 (快捷通道为4层)\n   485→    int crossLevels = (door.rewardType != LevelRewardType.Shortcut) ? 1 : 4;\n   486→\n   487→    // 5. 每层触发的效果\n   488→    for (int i = 0; i < crossLevels; i++)\n   489→    {\n   490→        // 遗物: 每层获得护盾\n   491→        if (ItemCtrller.relicCfg_FloorShield != null)\n   492→        {\n   493→            PlayerMgr.Inst.ChangeShield(relicCfg_FloorShield.int1.result);\n   494→        }\n   495→\n   496→        // 遗物: 存款利息\n   497→        if (ItemCtrller.relic_FollowObj_FloorInterest != null)\n   498→        {\n   499→            int interest = CalculateInterest();\n   500→            PlayerMgr.Inst.ChangeCoin(interest);\n   501→        }\n   502→\n   503→        // 天赋: 每层回血\n   504→        float recovery = DataMgr.selectedWorldData.GetTalentEnterDoorRecoveryValue();\n   505→        if (ItemCtrller.relicCfg_FloorRecovery != null)\n   506→        {\n   507→            recovery += relicCfg_FloorRecovery.int1.result;\n   508→        }\n   509→        if (recovery > 0f)\n   510→        {\n   511→            UnitDotsSyncSystem.UnitRecoveryHP(PlayerEtt, recovery, ettMgr);\n   512→        }\n   513→\n   514→        // 遗物: 临时护盾\n   515→        if (ItemCtrller.relicCfg_TempShield != null)\n   516→        {\n   517→            PlayerMgr.Inst.ChangeShieldTemp(relicCfg_TempShield.int1.result);\n   518→        }\n   519→\n   520→        // 遗物: 移除诅咒\n   521→        if (ItemCtrller.relicCfg_EnterDoorRemoveCurse != null &&\n   522→            BaData.curseIDs.Count > 0)\n   523→        {\n   524→            if (Random.value <= removeChance)\n   525→            {\n   526→                int removeIndex = Random.Range(0, BaData.curseIDs.Count);\n   527→                PlayerMgr.Inst.ItemCtrller.CurseRemoveByIndex(removeIndex);\n   528→            }\n   529→        }\n   530→    }\n   531→\n   532→    // 6. 诅咒: 流血\n   533→    if (ItemCtrller.curseCfg_Bled != null)\n   534→    {\n   535→        TakeDamageInfo_Dots dmg = TakeDamageInfo_Dots.NewInfo(AttackerType.NothingSpecial);\n   536→        dmg.damage = curseCfg_Bled.int1.result;\n   537→        dmg.ignorePlayerInvincibleFrame = true;\n   538→        dmg.ignoreRelicDodge = true;\n   539→        ettMgr.GetBuffer<TakeDamageInfo_Dots>(PlayerEtt).Add(dmg);\n   540→    }\n   541→\n   542→    // 7. 诅咒: 进门失去金币\n   543→    if (ItemCtrller.curseCfg_EnterDoorLoseCoin != null && CoinCount > 0)\n   544→    {\n   545→        int loseAmount = Mathf.Min(curseCfg_EnterDoorLoseCoin.int1.result, CoinCount);\n   546→        PlayerMgr.Inst.ChangeCoin(-loseAmount);\n   547→        CreateTextFloatVFX(-loseAmount, UITextFloatType.DropCoin);\n   548→    }\n   549→}\n   550→```\n   551→\n   552→**关键机制**:\n   553→\n   554→1. **临时护盾机制**\n   555→   - 临时护盾在进门前清除\n   556→   - 但可通过遗物组转换一定比例为永久护盾\n   557→\n   558→2. **跨层效果叠加**\n   559→   - 快捷通道(Shortcut)会跨越4层\n   560→   - 所有\"每层触发\"的效果会触发4次\n   561→   - 包括护盾、回血、利息等\n   562→\n   563→3. **诅咒惩罚**\n   564→   - 流血诅咒: 直接造成伤害,忽略无敌帧\n   565→   - 金币流失诅咒: 扣除固定数量金币\n   566→\n   567→#### 进门后效果 (ProcessPlayerEnterDoorAfterEffects)\n   568→\n   569→**位置**: [BattleMgr.cs:1222-1316](BattleMgr.cs:1222-1316)\n   570→\n   571→```csharp\n   572→private void ProcessPlayerEnterDoorAfterEffects()\n   573→{\n   574→    // 1. 清除悬浮药水效果\n   575→    if (ItemCtrller.potion_HoverEFGO != null)\n   576→    {\n   577→        Destroy(ItemCtrller.potion_HoverEFGO);\n   578→        PlayerMgr.Inst.FlyUnregister();\n   579→    }\n   580→\n   581→    // 2. 清除胃痛药水\n   582→    if (ItemCtrller.potion_Stomachache)\n   583→    {\n   584→        ItemCtrller.potion_Stomachache.DestroySelf();\n   585→    }\n   586→\n   587→    // 3. 遗物: 潘多拉魔盒 - 随机替换背包技能\n   588→    if (ItemCtrller.relicCfg_PandorasBox != null)\n   589→    {\n   590→        int replaceCount = relicCfg_PandorasBox.int1.result;\n   591→        for (int i = replaceCount - 1; i >= 0; i--)\n   592→        {\n   593→            if (i < BaData.bagSpellDatas.Count)\n   594→            {\n   595→                SlotData oldSpell = BaData.bagSpellDatas[i];\n   596→                if (oldSpell != null && !oldSpell.isSealSlot)\n   597→                {\n   598→                    // 获取同等级新技能\n   599→                    int newSpellID = BaData.GetSpellFromPool(\n   600→                        SpellConfig.dic[oldSpell.id].level,\n   601→                        SpellConfig.dic[oldSpell.id].dropType,\n   602→                        oldSpell.id);\n   603→\n   604→                    SlotData newSpell = new SlotData(newSpellID);\n   605→                    PlayerMgr.Inst.BagSpellChange(i, newSpell);\n   606→                }\n   607→            }\n   608→        }\n   609→    }\n   610→\n   611→    // 4. 遗物组: 进门无敌\n   612→    if (ItemCtrller.relicGroupConfigs.TryGetValue(4, out var config))\n   613→    {\n   614→        if (ItemCtrller.potion_Invincible == null)\n   615→        {\n   616→            ItemCtrller.potion_Invincible = Instantiate(invinciblePrefab);\n   617→        }\n   618→        ItemCtrller.potion_Invincible.Initialize(config.int1.result);\n   619→    }\n   620→\n   621→    // 5. 充能UI刷新\n   622→    if (ItemCtrller.uiRelic_LightArmor != null)\n   623→    {\n   624→        ItemCtrller.uiRelic_LightArmor.FullFill();\n   625→    }\n   626→    if (ItemCtrller.uiRelic_WarmSnow != null)\n   627→    {\n   628→        ItemCtrller.uiRelic_WarmSnow.FullFill();\n   629→    }\n   630→\n   631→    // 6. 遗物: 死神之镰 - 合成技能\n   632→    if (ItemCtrller.relic_Reaper != null)\n   633→    {\n   634→        ItemCtrller.relic_Reaper.CompoundSpell();\n   635→    }\n   636→\n   637→    // 7. 遗物: 隐形之翼 - 重置状态\n   638→    if (ItemCtrller.relic_InvisibleWing != null)\n   639→    {\n   640→        ItemCtrller.relic_InvisibleWing.EnterDoor();\n   641→    }\n   642→\n   643→    // 8. 诅咒: 随机诅咒重新抽取\n   644→    if (ItemCtrller.curse_RandomCurseCommon != null)\n   645→    {\n   646→        ItemCtrller.curse_RandomCurseCommon.RerollCurse();\n   647→    }\n   648→    if (ItemCtrller.curse_RandomCurseRare != null)\n   649→    {\n   650→        ItemCtrller.curse_RandomCurseRare.RerollCurse();\n   651→    }\n   652→\n   653→    // 9. 诅咒: 进门禁止射击\n   654→    if (ItemCtrller.curse_CantShootEnterRoom != null)\n   655→    {\n   656→        ItemCtrller.curse_CantShootEnterRoom.EnterDoor();\n   657→    }\n   658→\n   659→    // 10. 诅咒: 蜗牛追踪\n   660→    if (ItemCtrller.curse_SnailHunt != null)\n   661→    {\n   662→        ItemCtrller.curse_SnailHunt.EnterDoor();\n   663→    }\n   664→}\n   665→```\n   666→\n   667→**关键机制**:\n   668→\n   669→1. **潘多拉魔盒**\n   670→   - 随机替换前N个背包技能\n   671→   - 替换为同等级、同稀有度的技能\n   672→   - 不替换封印槽位\n   673→\n   674→2. **进门无敌**\n   675→   - 遗物组效果\n   676→   - 持续时间由遗物组配置决定\n   677→\n   678→3. **充能类遗物重置**\n   679→   - 轻甲、暖雪等需要充能的遗物\n   680→   - 进门后充能值恢复满\n   681→\n   682→4. **诅咒状态刷新**\n   683→   - 某些诅咒在进门时重新触发\n   684→   - 如随机诅咒会抽取新的诅咒效果\n   685→\n   686→---\n   687→\n   688→## 战斗数据 (BattleData)\n   689→\n   690→**文件位置**: [BattleData.cs](BattleData.cs:1)\n   691→\n   692→### 类职责\n   693→`BattleData` 是战斗过程中所有数据的容器,负责:\n   694→1. 玩家当前状态数据\n   695→2. 物品池管理 (技能/魔杖/遗物/诅咒)\n   696→3. 关卡进度追踪\n   697→4. 奖励类型管理\n   698→\n   699→### 核心数据结构\n   700→\n   701→```csharp\n   702→public class BattleData\n   703→{\n   704→    // ========== 玩家属性 ==========\n   705→    public UnitConfig playerCfg;              // 玩家单位配置\n   706→    public float bodySize = 1f;               // 体型大小\n   707→    public int coinCount;                     // 金币数量\n   708→    public int keyCount;                      // 钥匙数量\n   709→\n   710→    // ========== 玩家能力 ==========\n   711→    public int wandMaxCount = 1;              // 魔杖最大数量\n   712→    public int bagCount = 10;                 // 背包格子数\n   713→    public int potionMaxCount = 1;            // 药水槽位数\n   714→    public int mpMax;                         // 魔法值上限\n   715→    public float mpRecovery;                  // 魔法值回复速度\n   716→\n   717→    // ========== 额外加成 ==========\n   718→    public float extraMoveSpeedRatio;         // 额外移动速度比例\n   719→    public float extraDamageRatio;            // 额外伤害比例\n   720→    public float extraCriticalChance;         // 额外暴击率\n   721→\n   722→    // ========== 关卡进度 ==========\n   723→    public int currentLevel;                  // 当前关卡\n   724→    public int currentStage = 1;              // 当前章节\n   725→    public int currentRoomID;                 // 当前房间ID\n   726→    public LevelRewardType currentRewardType; // 当前奖励类型\n   727→    public List<LevelRewardType> nextRewardTypes;  // 下一关可选奖励类型\n   728→    public LevelRewardType nextExtraDoorRewardType; // 额外门奖励类型\n   729→\n   730→    // ========== 连续计数 (用于动态调整概率) ==========\n   731→    public int continuousNonSpell = 1;        // 连续未获得技能\n   732→    public int continuousNonRelic;            // 连续未获得遗物\n   733→    public int continuousNonCoin;             // 连续未获得金币\n   734→    public int continuousNonProcess;          // 连续未遇到加工站\n   735→    public int continuousNonStore;            // 连续未遇到商店\n   736→    public int continuousNonSpring;           // 连续未遇到温泉\n   737→\n   738→    // ========== 特殊房间 ==========\n   739→    public List<int> specialRoomLevels;       // 有侧边房间的关卡\n   740→    public bool shortcutRoomAppearedStage1-6; // 各章节快捷通道是否出现\n   741→\n   742→    // ========== 玩家装备 ==========\n   743→    public List<WandConfig> wandCfgs;         // 魔杖配置列表\n   744→    public List<SlotData> bagSpellDatas;      // 背包技能列表\n   745→    public List<RelicConfig> relicCfgs;       // 遗物配置列表\n   746→    public List<int> potionIDs;               // 药水ID列表\n   747→    public List<int> curseIDs;                // 诅咒ID列表\n   748→    public List<int> curseLevels;             // 诅咒等级列表\n   749→\n   750→    // ========== 物品池 ==========\n   751→    public List<int> poolOfRoomID;            // 房间ID池\n   752→    public List<int> poolOfWandID;            // 魔杖ID池\n   753→    public List<int> poolOfSpellID;           // 技能ID池\n   754→    public List<int> poolOfPotionID;          // 药水ID池\n   755→    public Dictionary<int, int> poolOfRelic;  // 遗物ID池 (ID -> 可获得次数)\n   756→    public Dictionary<int, int> poolOfCurse;  // 诅咒ID池 (ID -> 可获得次数)\n   757→\n   758→    // ========== 池状态标记 ==========\n   759→    public bool isSpellPoolHaveCommon = true;  // 池中是否有普通技能\n   760→    public bool isSpellPoolHaveRare = true;    // 池中是否有稀有技能\n   761→    public bool isSpellPoolHaveEpic = true;    // 池中是否有史诗技能\n   762→    public bool isSpellPoolHaveSpecial = true; // 池中是否有特殊技能\n   763→\n   764→    // ========== 伤害记录 ==========\n   765→    public DamageRecorder damageRecorderV2;   // 伤害记录器V2\n   766→}\n   767→```\n   768→\n   769→---\n   770→\n   771→### 初始化流程 (Initialize)\n   772→\n   773→**位置**: [BattleData.cs:116-179](BattleData.cs:116-179)\n   774→\n   775→```csharp\n   776→public void Initialize()\n   777→{\n   778→    // 1. 加载玩家基础配置\n   779→    playerCfg = UnitConfig.map[800001];  // 玩家单位ID固定为800001\n   780→\n   781→    // 2. 应用天赋加成\n   782→    if (DataMgr.selectedWorldData.levelOfWandLimit > 0)\n   783→    {\n   784→        wandMaxCount += TalentUpgrade.wandLimit[level-1].value;\n   785→    }\n   786→    if (DataMgr.selectedWorldData.levelOfBagLimit > 0)\n   787→    {\n   788→        bagCount += TalentUpgrade.bagLimit[level-1].value;\n   789→    }\n   790→    if (DataMgr.selectedWorldData.levelOfMaxHP > 0)\n   791→    {\n   792→        playerCfg.maxHP += TalentUpgrade.maxHP[level-1].value;\n   793→    }\n   794→    playerCfg.currentHP = playerCfg.maxHP;  // 满血开始\n   795→\n   796→    if (DataMgr.selectedWorldData.levelOfInitialCoin > 0)\n   797→    {\n   798→        coinCount += TalentUpgrade.initialCoin[level-1].value;\n   799→    }\n   800→    if (DataMgr.selectedWorldData.levelOfMaxMP > 0)\n   801→    {\n   802→        mpMax += TalentUpgrade.maxMP[level-1].value;\n   803→    }\n   804→    if (DataMgr.selectedWorldData.levelOfMPRecover > 0)\n   805→    {\n   806→        mpRecovery += TalentUpgrade.mpRecover[level-1].value;\n   807→    }\n   808→\n   809→    // 3. 应用研究加成\n   810→    DataMgr.selectedWorldData.CalculateAddingPoints();\n   811→    potionMaxCount += GetResearchValue(ResearchAbilityType.PotionLimit);\n   812→    keyCount += GetResearchValue(ResearchAbilityType.KeyChain);\n   813→\n   814→    // 4. 初始化容器\n   815→    for (int i = 0; i < wandMaxCount; i++)\n   816→        wandCfgs.Add(null);\n   817→\n   818→    for (int j = 0; j < bagCount; j++)\n   819→        bagSpellDatas.Add(null);\n   820→\n   821→    for (int k = 0; k < potionMaxCount; k++)\n   822→        potionIDs.Add(0);\n   823→\n   824→    // 5. 初始化物品池\n   825→    InitialPools();\n   826→\n   827→    // 6. 应用套装魔杖\n   828→    if (GetSelectedSetCfg().WandIDs.Length != 0)\n   829→    {\n   830→        wandCfgs[0] = WandConfig.GetConfig(GetCurrentSetWandID());\n   831→    }\n   832→\n   833→    // 7. 应用套装遗物 (从池中预先移除)\n   834→    int setRelicID = GetCurrentSetRelicID();\n   835→    int setRelicLevel = GetCurrentSetRelicLevel();\n   836→    if (setRelicID != 0 && poolOfRelic.ContainsKey(setRelicID))\n   837→    {\n   838→        for (int l = 0; l < setRelicLevel; l++)\n   839→        {\n   840→            poolOfRelic[setRelicID]--;\n   841→            if (poolOfRelic[setRelicID] == 0)\n   842→            {\n   843→                poolOfRelic.Remove(setRelicID);\n   844→                break;\n   845→            }\n   846→        }\n   847→    }\n   848→}\n   849→```\n   850→\n   851→**关键机制**:\n   852→\n   853→1. **天赋系统**\n   854→   - 永久升级,影响初始属性\n   855→   - 包括魔杖槽位、背包大小、生命值、法力值等\n   856→\n   857→2. **研究系统**\n   858→   - 营地内可解锁的被动效果\n   859→   - 如药水槽位、钥匙链等\n   860→\n   861→3. **套装系统**\n   862→   - 每个套装有初始魔杖和初始遗物\n   863→   - 初始遗物需要从池中预先移除,避免重复获得\n   864→\n   865→---\n   866→\n   867→### 物品池系统 (InitialPools)\n   868→\n   869→**位置**: [BattleData.cs:181-295](BattleData.cs:181-295)\n   870→\n   871→```csharp\n   872→public void InitialPools()\n   873→{\n   874→    // 清空所有池\n   875→    poolOfRoomID.Clear();\n   876→    poolOfWandID.Clear();\n   877→    poolOfSpellID.Clear();\n   878→    poolOfRelic.Clear();\n   879→    poolOfPotionID.Clear();\n   880→    poolOfCurse.Clear();\n   881→\n   882→    // ========== 房间池 ==========\n   883→    for (int i = 0; i < RoomConfig.list.Count; i++)\n   884→    {\n   885→        poolOfRoomID.Add(RoomConfig.list[i].id);\n   886→    }\n   887→\n   888→    // ========== 药水池 ==========\n   889→    for (int j = 0; j < PotionConfig.list.Count; j++)\n   890→    {\n   891→        if (PotionConfig.list[j].id != 3)  // 排除ID=3的特殊药水\n   892→        {\n   893→            poolOfPotionID.Add(PotionConfig.list[j].id);\n   894→        }\n   895→    }\n   896→\n   897→    // ========== 诅咒池 ==========\n   898→    for (int k = 0; k < CurseConfig.list.Count; k++)\n   899→    {\n   900→        // 特殊诅咒\"失去技能选项\"需要激活4选2天赋\n   901→        if (CurseConfig.list[k].abilityType != CurseAbilityType.LostSpellOption ||\n   902→            DataMgr.selectedWorldData.ActivateGirlHave4Pick2())\n   903→        {\n   904→            poolOfCurse.Add(CurseConfig.list[k].id, CurseConfig.list[k].count);\n   905→        }\n   906→    }\n   907→\n   908→    // ========== 魔杖池 ==========\n   909→    for (int l = 0; l < WandConfig.list.Count; l++)\n   910→    {\n   911→        WandConfig wand = WandConfig.list[l];\n   912→\n   913→        // 排除条件:\n   914→        // 1. 第一次进战斗 && 魔杖有后置槽位 (太复杂)\n   915→        // 2. 没有魔杖槽位升级天赋 && 魔杖需要多槽位机制\n   916→        bool exclude = (DataMgr.selectedWorldData.enterBattleTime == 1 &&\n   917→                        wand.postSlots.Length > 0);\n   918→\n   919→        if (levelOfWandLimit == 0 && selectedSetID != 5)\n   920→        {\n   921→            // 排除需要多魔杖协同的特殊能力魔杖\n   922→            exclude |= (wand.specialAbility == WandAbility.HoldWandDifferentManaGenRatio);\n   923→            exclude |= (wand.specialAbility == WandAbility.AllWandMpCostRatio);\n   924→            exclude |= (wand.specialAbility == WandAbility.AllWandMaxMpRatio);\n   925→            // ... 等等\n   926→        }\n   927→\n   928→        if (!exclude)\n   929→        {\n   930→            poolOfWandID.Add(wand.id);\n   931→        }\n   932→    }\n   933→\n   934→    // ========== 技能池 ==========\n   935→    // 首先获取已激活的技能\n   936→    List<int> activatedSpells = new List<int>();\n   937→    List<int> activatedRelics = new List<int>();\n   938→\n   939→    for (int m = 0; m < DataMgr.selectedWorldData.activateGirlActivatedIDs2.Count; m++)\n   940→    {\n   941→        int activateID = activateGirlActivatedIDs2[m];\n   942→        if (ActivateGirlConfig.dic.ContainsKey(activateID))\n   943→        {\n   944→            ActivateGirlConfig cfg = ActivateGirlConfig.dic[activateID];\n   945→            if (cfg.specialType == ActivateGirlSpecialType.None)\n   946→            {\n   947→                // 普通技能激活\n   948→                activatedSpells.AddRange(cfg.spellIDs);\n   949→            }\n   950→            else if (cfg.specialType == ActivateGirlSpecialType.Relic)\n   951→            {\n   952→                // 遗物技能激活\n   953→                activatedRelics.AddRange(cfg.spellIDs);\n   954→            }\n   955→        }\n   956→    }\n   957→\n   958→    // 添加技能到池\n   959→    for (int num2 = 0; num2 < SpellConfig.list.Count; num2++)\n   960→    {\n   961→        SpellConfig spell = SpellConfig.list[num2];\n   962→\n   963→        if (spell.dropType == ItemDropType.None)\n   964→            continue;  // 不掉落的技能\n   965→\n   966→        if (spell.needActivate)\n   967→        {\n   968→            // 需要激活的技能\n   969→            int baseID = spell.id / 10 * 10 + 1;  // 获取基础ID\n   970→            if (activatedSpells.Contains(baseID))\n   971→            {\n   972→                poolOfSpellID.Add(spell.id);\n   973→            }\n   974→        }\n   975→        else\n   976→        {\n   977→            // 特殊排除: 回响符文需要多魔杖\n   978→            if (wandMaxCount == 1 && selectedSetID != 5 &&\n   979→                spell.abilityType == SpellAbilityType.EchoRune)\n   980→            {\n   981→                continue;\n   982→            }\n   983→\n   984→            poolOfSpellID.Add(spell.id);\n   985→        }\n   986→    }\n   987→\n   988→    // 特殊套装技能\n   989→    if (selectedSetID == 9)\n   990→    {\n   991→        poolOfSpellID.Add(10281);  // 套装9专属技能\n   992→        poolOfSpellID.Add(10282);\n   993→        poolOfSpellID.Add(10283);\n   994→    }\n   995→    else if (selectedSetID == 11)\n   996→    {\n   997→        poolOfSpellID.Add(10311);  // 套装11专属技能\n   998→        poolOfSpellID.Add(10312);\n   999→        poolOfSpellID.Add(10313);\n  1000→    }\n  1001→\n  1002→    // ========== 遗物池 ==========\n  1003→    for (int num3 = 0; num3 < RelicConfig.list.Count; num3++)\n  1004→    {\n  1005→        RelicConfig relic = RelicConfig.list[num3];\n  1006→\n  1007→        if (relic.needActivate)\n  1008→        {\n  1009→            // 需要激活的遗物\n  1010→            if (activatedRelics.Contains(relic.id))\n  1011→            {\n  1012→                poolOfRelic.Add(relic.id, relic.maxCount);\n  1013→            }\n  1014→        }\n  1015→        else\n  1016→        {\n  1017→            // 特殊排除: 后置槽位效率遗物需要第二次进战斗\n  1018→            if (relic.abilityType == RelicAbilityType.PostSlotMoreEfficiency &&\n  1019→                enterBattleTime <= 1)\n  1020→            {\n  1021→                continue;\n  1022→            }\n  1023→\n  1024→            poolOfRelic.Add(relic.id, relic.maxCount);\n  1025→        }\n  1026→    }\n  1027→\n  1028→    // 特殊套装遗物\n  1029→    if (selectedSetID == 6 || selectedSetID == 7 || selectedSetID == 9)\n  1030→    {\n  1031→        poolOfRelic.Add(76, RelicConfig.dic[76].maxCount);  // 套装专属遗物\n  1032→    }\n  1033→\n  1034→    // 特殊激活遗物\n  1035→    if (activateGirlActivatedIDs2.Contains(1))\n  1036→    {\n  1037→        poolOfRelic.Add(72, RelicConfig.dic[72].maxCount);  // 激活角色1的遗物\n  1038→    }\n  1039→\n  1040→    // 排除首次进战斗的特殊遗物\n  1041→    if (enterBattleTime <= 1 && poolOfRelic.ContainsKey(69))\n  1042→    {\n  1043→        poolOfRelic.Remove(69);\n  1044→    }\n  1045→}\n  1046→```\n  1047→\n  1048→**关键机制**:\n  1049→\n  1050→1. **激活系统**\n  1051→   - 营地中可解锁角色,解锁后激活对应技能/遗物\n  1052→   - 技能ID规则: 基础ID = (技能ID / 10) * 10 + 1\n  1053→   - 例如: 10015的基础ID是10011\n  1054→\n  1055→2. **新手保护**\n  1056→   - 第一次进战斗排除复杂魔杖(有后置槽位的)\n  1057→   - 第一次进战斗排除某些高级遗物\n  1058→\n  1059→3. **多魔杖机制限制**\n  1060→   - 如果没有魔杖槽位升级,排除需要多魔杖协同的物品\n  1061→   - 例如: \"持有不同魔杖生成速率不同\"的魔杖\n  1062→\n  1063→4. **套装专属内容**\n  1064→   - 某些套装有专属技能和遗物\n  1065→   - 这些内容只在选择对应套装时加入池中\n  1066→\n  1067→---\n  1068→\n  1069→### 资源池抽取方法\n  1070→\n  1071→#### GetSpellFromPool - 从池中获取技能\n  1072→\n  1073→**位置**: [BattleData.cs:392-449](BattleData.cs:392-449)\n  1074→\n  1075→```csharp\n  1076→public int GetSpellFromPool(int level, ItemDropType dropType, int exceptID = 0)\n  1077→{\n  1078→    List<int> candidates = new List<int>();\n  1079→\n  1080→    // 筛选符合条件的技能\n  1081→    for (int i = 0; i < poolOfSpellID.Count; i++)\n  1082→    {\n  1083→        SpellConfig spell = SpellConfig.dic[poolOfSpellID[i]];\n  1084→        if (spell.level == level &&\n  1085→            spell.dropType == dropType &&\n  1086→            spell.id != exceptID)\n  1087→        {\n  1088→            candidates.Add(spell.id);\n  1089→        }\n  1090→    }\n  1091→\n  1092→    // 如果池中没有对应稀有度的技能,尝试降级/升级获取\n  1093→    if (candidates.Count == 0)\n  1094→    {\n  1095→        switch (dropType)\n  1096→        {\n  1097→            case ItemDropType.Common:\n  1098→                if (isSpellPoolHaveRare)\n  1099→                    return GetSpellFromPool(level, ItemDropType.Rare);\n  1100→                if (isSpellPoolHaveEpic)\n  1101→                    return GetSpellFromPool(1, ItemDropType.Epic);\n  1102→                return 10011;  // 默认技能ID\n  1103→\n  1104→            case ItemDropType.Rare:\n  1105→                if (isSpellPoolHaveCommon)\n  1106→                    return GetSpellFromPool(level, ItemDropType.Common);\n  1107→                if (isSpellPoolHaveEpic)\n  1108→                    return GetSpellFromPool(1, ItemDropType.Epic);\n  1109→                return 10011;\n  1110→\n  1111→            case ItemDropType.Epic:\n  1112→                if (isSpellPoolHaveRare)\n  1113→                    return GetSpellFromPool(level, ItemDropType.Rare);\n  1114→                if (isSpellPoolHaveCommon)\n  1115→                    return GetSpellFromPool(1, ItemDropType.Common);\n  1116→                return 10011;\n  1117→\n  1118→            case ItemDropType.Special:\n  1119→                if (isSpellPoolHaveCommon)\n  1120→                    return GetSpellFromPool(1, ItemDropType.Common);\n  1121→                return 10011;\n  1122→        }\n  1123→    }\n  1124→\n  1125→    // 随机返回一个\n  1126→    return candidates[Random.Range(0, candidates.Count)];\n  1127→}\n  1128→```\n  1129→\n  1130→**注意**: 这个方法**不会**从池中移除技能!技能池不会被消耗。\n  1131→\n  1132→#### GetWandFromPool - 从池中获取魔杖\n  1133→\n  1134→**位置**: [BattleData.cs:505-523](BattleData.cs:505-523)\n  1135→\n  1136→```csharp\n  1137→public int GetWandFromPool(int dropStage, params int[] exceptID)\n  1138→{\n  1139→    List<int> candidates = new List<int>();\n  1140→\n  1141→    // 筛选指定章节掉落的魔杖\n  1142→    for (int i = 0; i < poolOfWandID.Count; i++)\n  1143→    {\n  1144→        WandConfig wand = WandConfig.dic[poolOfWandID[i]];\n  1145→        if (wand.dropStage == dropStage &&\n  1146→            !exceptID.Contains(wand.id))\n  1147→        {\n  1148→            candidates.Add(poolOfWandID[i]);\n  1149→        }\n  1150→    }\n  1151→\n  1152→    if (candidates.Count == 0)\n  1153→    {\n  1154→        Debug.LogError(\"not enough Wand, drop stage:\" + dropStage);\n  1155→        return 1;  // 返回默认魔杖ID\n  1156→    }\n  1157→\n  1158→    int selected = candidates[Random.Range(0, candidates.Count)];\n  1159→    poolOfWandID.Remove(selected);  // 从池中移除!\n  1160→    return selected;\n  1161→}\n  1162→```\n  1163→\n  1164→**魔杖池会被消耗!** 获得魔杖后会从池中移除。\n  1165→\n  1166→#### GetRelicFromPool - 从池中获取遗物\n  1167→\n  1168→**位置**: [BattleData.cs:599-628](BattleData.cs:599-628)\n  1169→\n  1170→```csharp\n  1171→public int GetRelicFromPool(ItemDropType dropType, int[] exceptIDs = null)\n  1172→{\n  1173→    List<int> candidates = new List<int>();\n  1174→\n  1175→    // 筛选符合稀有度的遗物\n  1176→    foreach (KeyValuePair<int, int> item in poolOfRelic)\n  1177→    {\n  1178→        RelicConfig relic = RelicConfig.dic[item.Key];\n  1179→        if (relic.dropType == dropType &&\n  1180→            (exceptIDs == null || !exceptIDs.Contains(item.Key)))\n  1181→        {\n  1182→            candidates.Add(item.Key);\n  1183→        }\n  1184→    }\n  1185→\n  1186→    if (candidates.Count == 0)\n  1187→    {\n  1188→        Debug.LogError(\"not enough Relic,DropType:\" + dropType);\n  1189→        return 999;  // 错误ID\n  1190→    }\n  1191→\n  1192→    int selected = candidates[Random.Range(0, candidates.Count)];\n  1193→\n  1194→    // 减少可获得次数\n  1195→    if (poolOfRelic[selected] > 1)\n  1196→    {\n  1197→        poolOfRelic[selected]--;\n  1198→    }\n  1199→    else if (poolOfRelic[selected] == 1)\n  1200→    {\n  1201→        poolOfRelic.Remove(selected);  // 完全移除\n  1202→    }\n  1203→\n  1204→    return selected;\n  1205→}\n  1206→```\n  1207→\n  1208→**遗物有数量限制!** 每个遗物可以获得多次,但有上限。\n  1209→\n  1210→#### GetCurseFromPool - 从池中获取诅咒\n  1211→\n  1212→**位置**: [BattleData.cs:682-711](BattleData.cs:682-711)\n  1213→\n  1214→```csharp\n  1215→public int GetCurseFromPool(ItemDropType dropType)\n  1216→{\n  1217→    List<int> candidates = new List<int>();\n  1218→\n  1219→    foreach (KeyValuePair<int, int> item in poolOfCurse)\n  1220→    {\n  1221→        if (CurseConfig.dic[item.Key].dropType == dropType)\n  1222→        {\n  1223→            candidates.Add(item.Key);\n  1224→        }\n  1225→    }\n  1226→\n  1227→    if (candidates.Count == 0)\n  1228→    {\n  1229→        Debug.LogError(\"Not enough curse, drop type:\" + dropType);\n  1230→        return 999;\n  1231→    }\n  1232→\n  1233→    int selected = candidates[Random.Range(0, candidates.Count)];\n  1234→\n  1235→    // 减少可获得次数\n  1236→    if (poolOfCurse[selected] > 1)\n  1237→    {\n  1238→        poolOfCurse[selected]--;\n  1239→    }\n  1240→    else if (poolOfCurse[selected] == 1)\n  1241→    {\n  1242→        poolOfCurse.Remove(selected);\n  1243→    }\n  1244→\n  1245→    return selected;\n  1246→}\n  1247→```\n  1248→\n  1249→---\n  1250→\n  1251→### 随机魔杖技能系统 (RandomSpellWandCheck)\n  1252→\n  1253→**位置**: [BattleData.cs:530-597](BattleData.cs:530-597)\n  1254→\n  1255→某些魔杖具有特殊能力: 装备时自动填充随机技能。\n  1256→\n  1257→```csharp\n  1258→public void RandomSpellWandCheck()\n  1259→{\n  1260→    for (int i = 0; i < WandConfig.list.Count; i++)\n  1261→    {\n  1262→        WandConfig wand = WandConfig.list[i];\n  1263→\n  1264→        // 能力: 随机普通技能\n  1265→        if (wand.specialAbility == WandAbility.RandomCommonSpells)\n  1266→        {\n  1267→            SlotData[] normalSlots = wand.normalSlots;\n  1268→            bool[] normalSlotIsLock = wand.normalSlotIsLock;\n  1269→\n  1270→            Array.Fill(normalSlots, null);\n  1271→            Array.Fill(normalSlotIsLock, false);\n  1272→\n  1273→            // 填充槽位\n  1274→            for (int j = 0; j < normalSlots.Length; j++)\n  1275→            {\n  1276→                // 跳过超出限制的槽位\n  1277→                if (j >= wand.int1)\n  1278→                    continue;\n  1279→\n  1280→                // 跳过封印槽位和锁定槽位\n  1281→                if ((normalSlots[j] != null && normalSlots[j].isSealSlot) ||\n  1282→                    normalSlotIsLock[j])\n  1283→                    continue;\n  1284→\n  1285→                // 死循环保护\n  1286→                int loopCount = 0;\n  1287→                while (true)\n  1288→                {\n  1289→                    if (loopCount++ > 200)\n  1290→                    {\n  1291→                        Debug.LogError(\"死循环?!!!!\");\n  1292→                        break;\n  1293→                    }\n  1294→\n  1295→                    // 获取随机1级普通技能\n  1296→                    SlotData data = new SlotData(GetSpellFromPool(1, ItemDropType.Common));\n  1297→\n  1298→                    // 检查是否可以放入该槽位\n  1299→                    if (normalSlots.Bag_CanSetSpell(normalSlotIsLock, data, j))\n  1300→                    {\n  1301→                        normalSlots.Bag_SetSlot(normalSlotIsLock, data, j);\n  1302→                        break;\n  1303→                    }\n  1304→                }\n  1305→            }\n  1306→        }\n  1307→\n  1308→        // 能力: 随机稀有技能\n  1309→        else if (wand.specialAbility == WandAbility.RandomRareSpells)\n  1310→        {\n  1311→            // 类似逻辑,但使用 ItemDropType.Rare\n  1312→            // ...\n  1313→        }\n  1314→    }\n  1315→}\n  1316→```\n  1317→\n  1318→**关键点**:\n  1319→1. 每次进入战斗都会重新随机\n  1320→2. 使用 `Bag_CanSetSpell` 检查兼容性(避免冲突技能)\n  1321→3. 有死循环保护机制\n  1322→\n  1323→---\n  1324→\n  1325→### 特殊房间系统 (RandomSpecialRoom)\n  1326→\n  1327→**位置**: [BattleData.cs:297-323](BattleData.cs:297-323)\n  1328→\n  1329→```csharp\n  1330→public void RandomSpecialRoom()\n  1331→{\n  1332→    specialRoomLevels.Clear();\n  1333→\n  1334→    if (currentStage <= 1)\n  1335→        return;  // 第一章没有特殊房间\n  1336→\n  1337→    // 第一个特殊房间: 保证出现\n  1338→    int firstSpecialLevel = Random.Range(1, BattleMgr.Inst.stageLevelsCount[currentStage - 1]);\n  1339→    specialRoomLevels.Add(firstSpecialLevel);\n  1340→\n  1341→    // 第二个特殊房间: 33.33%概率\n  1342→    if (Random.value <= 0.3333f)\n  1343→    {\n  1344→        int loopCount = 0;\n  1345→        int secondSpecialLevel;\n  1346→        do\n  1347→        {\n  1348→            loopCount++;\n  1349→            if (loopCount > 100)\n  1350→            {\n  1351→                Debug.LogError(\"!\");\n  1352→                return;\n  1353→            }\n  1354→            secondSpecialLevel = Random.Range(1, BattleMgr.Inst.stageLevelsCount[currentStage - 1]);\n  1355→        }\n  1356→        while (specialRoomLevels.Contains(secondSpecialLevel));  // 确保不重复\n  1357→\n  1358→        specialRoomLevels.Add(secondSpecialLevel);\n  1359→    }\n  1360→}\n  1361→```\n  1362→\n  1363→**特殊房间用途**:\n  1364→- 在主战斗房间旁边添加侧边房间\n  1365→- 侧边房间通常是谜题房或NPC房\n  1366→- 增加游戏多样性\n  1367→\n  1368→---\n  1369→\n  1370→## 玩家管理器 (PlayerMgr)\n  1371→\n  1372→**文件位置**: [PlayerMgr.cs](PlayerMgr.cs:1)\n  1373→\n  1374→### 类职责\n  1375→`PlayerMgr` 负责管理玩家相关的所有逻辑:\n  1376→1. 玩家Entity和GameObject的生命周期\n  1377→2. 魔杖管理和切换\n  1378→3. 召唤物管理\n  1379→4. 玩家属性计算\n  1380→5. 物品拾取和使用\n  1381→\n  1382→### 核心属性\n  1383→\n  1384→```csharp\n  1385→public class PlayerMgr : MonoBehaviour\n  1386→{\n  1387→    public static PlayerMgr Inst { get; private set; }\n  1388→\n  1389→    // ========== 玩家对象 ==========\n  1390→    public GameObject PlayerGO { get; private set; }\n  1391→    public Entity PlayerEtt { get; private set; }\n  1392→    public UnitProperty PlayerPpt { get; private set; }\n  1393→    public PlayerController PlayerCtrller { get; private set; }\n  1394→\n  1395→    // ========== 魔杖系统 ==========\n  1396→    public List<Wand> Wands = new List<Wand>();\n  1397→    public int SelectedWandIndex { get; private set; } = -1;\n  1398→    public Wand SelectedWand => Wands[SelectedWandIndex];\n  1399→    public WandConfig SelectedWandCfg => BaData.wandCfgs[SelectedWandIndex];\n  1400→\n  1401→    // ========== 物品管理 ==========\n  1402→    public PlayerItemController ItemCtrller;\n  1403→\n  1404→    // ========== 召唤物 ==========\n  1405→    public List<UnitProperty> summonsPpts;           // 攻击型召唤物\n  1406→    public List<UnitProperty> summonsNotAttackPpts;  // 非攻击型召唤物\n  1407→    public Dictionary<Wand, UnitProperty> autoWandList;  // 自动魔杖列表\n  1408→\n  1409→    // ========== 对象池 ==========\n  1410→    public MiniObjPool MiniPool { get; set; }\n  1411→    public List<Spell1020CoinOnGround> manaCoinList { get; set; }\n  1412→\n  1413→    // ========== 快捷访问 ==========\n  1414→    public BattleData BaData => DataMgr.selectedWorldData.battleData8;\n  1415→    public Vector3 PlayerPoint => PlayerT.position;\n  1416→    public Vector3 ShootPoint => SelectedWand?.ShootPosition ?? PlayerPoint;\n  1417→    public int CoinCount => BaData.coinCount;\n  1418→    public int KeyCount => BaData.keyCount;\n  1419→}\n  1420→```\n  1421→\n  1422→---\n  1423→\n  1424→### 玩家创建流程 (CreatePlayer)\n  1425→\n  1426→**位置**: [PlayerMgr.cs:276-339](PlayerMgr.cs:276-339)\n  1427→\n  1428→```csharp\n  1429→public void CreatePlayer()\n  1430→{\n  1431→    // 1. 清理旧数据\n  1432→    if (ItemCtrller != null)\n  1433→        Destroy(ItemCtrller);\n  1434→\n  1435→    ItemCtrller = transform.AddComponent<PlayerItemController>();\n  1436→\n  1437→    // 清理悬浮药水特效\n  1438→    if (ItemCtrller.potion_HoverEFGO != null)\n  1439→        Destroy(ItemCtrller.potion_HoverEFGO);\n  1440→\n  1441→    // 清空召唤物列表\n  1442→    summonsPpts.Clear();\n  1443→    summonsNotAttackPpts.Clear();\n  1444→\n  1445→    // 取消自动魔杖\n  1446→    foreach (var autoWand in autoWandList)\n  1447→        CancelAutoControlWand(autoWand.Key);\n  1448→    autoWandList.Clear();\n  1449→\n  1450→    // 销毁旧玩家\n  1451→    if (PlayerGO != null)\n  1452→        Destroy(PlayerGO);\n  1453→\n  1454→    SelectedWandIndex = -1;\n  1455→\n  1456→    // 重建对象池\n  1457→    if (MiniPool != null)\n  1458→        Destroy(MiniPool.gameObject);\n  1459→    MiniPool = Instantiate(ABResources.LoadAsset<GameObject>(\"Prefabs/Mixed/MiniObjPool\"))\n  1460→        .GetComponent<MiniObjPool>();\n  1461→\n  1462→    IsHide = false;\n  1463→\n  1464→    // 2. 初始化战斗数据\n  1465→    BaData = new BattleData();\n  1466→    BaData.Initialize();\n  1467→\n  1468→    // 3. 创建 Entity (DOTS)\n  1469→    if (PlayerEtt != Entity.Null)\n  1470→        ettMgr.DestroyEntity(PlayerEtt);\n  1471→\n  1472→    using EntityQuery entityQuery = ettMgr.CreateEntityQuery(typeof(AllUnitEtt));\n  1473→    AllUnitEtt singleton = entityQuery.GetSingleton<AllUnitEtt>();\n  1474→    PlayerEtt = ettMgr.Instantiate(singleton.map[800001]);  // 玩家单位ID\n  1475→\n  1476→    // 设置物理碰撞器 (独立副本)\n  1477→    PhysicsCollider collider = ettMgr.GetComponentData<PhysicsCollider>(PlayerEtt);\n  1478→    Entity entity = PlayerEtt;\n  1479→    collider.MakeUnique(in entity, ettMgr);\n  1480→    ettMgr.SetComponentData(PlayerEtt, collider);\n  1481→\n  1482→    // 设置初始位置\n  1483→    LocalTransform transform = ettMgr.GetComponentData<LocalTransform>(PlayerEtt);\n  1484→    transform.Position = PlayerPoint;\n  1485→    ettMgr.SetComponentData(PlayerEtt, transform);\n  1486→\n  1487→    ettMgr.SetName(PlayerEtt, \"Player\");\n  1488→\n  1489→    // 设置单位配置\n  1490→    UnitProperty_Dots ppt = ettMgr.GetComponentData<UnitProperty_Dots>(PlayerEtt);\n  1491→    ppt.unitCfg = BaData.playerCfg;\n  1492→    ettMgr.SetComponentData(PlayerEtt, ppt);\n  1493→\n  1494→    // 4. 创建 GameObject (渲染和控制)\n  1495→    PlayerGO = Instantiate(ABResources.LoadAsset<GameObject>(\"Prefabs/Units/\" + 800001));\n  1496→    PlayerGO.SetActive(true);\n  1497→\n  1498→    PlayerCtrller = PlayerGO.GetComponent<PlayerController>();\n  1499→    PlayerCtrller.myPpt.myEntity = PlayerEtt;\n  1500→    PlayerPpt = PlayerCtrller.myPpt;\n  1501→\n  1502→    // 注册到同步系统\n  1503→    UnitDotsSyncSystem.existingUnit.Add(PlayerPpt);\n  1504→\n  1505→    // 关联 Entity 和 MonoBehaviour\n  1506→    PlayerController_Dots ctrllerData = ettMgr.GetComponentData<PlayerController_Dots>(PlayerEtt);\n  1507→    ctrllerData.playerCtrllerMono = PlayerCtrller;\n  1508→    ettMgr.SetComponentData(PlayerEtt, ctrllerData);\n  1509→\n  1510→    // 5. 更新皮肤\n  1511→    UpdateSkin();\n  1512→}\n  1513→```\n  1514→\n  1515→**ECS 与 MonoBehaviour 双重架构**:\n  1516→\n  1517→```\n  1518→┌─────────────────────────────────────────────────┐\n  1519→│                   DOTS Entity                    │\n  1520→│  ┌───────────────────────────────────────────┐ │\n  1521→│  │ UnitProperty_Dots (组件)                  │ │\n  1522→│  │  - unitCfg: UnitConfig                    │ │\n  1523→│  │  - currentHP, maxHP, shield, etc.         │ │\n  1524→│  │                                             │ │\n  1525→│  │ PlayerController_Dots (组件)              │ │\n  1526→│  │  - playerCtrllerMono: MonoBehaviour引用   │ │\n  1527→│  │                                             │ │\n  1528→│  │ LocalTransform (组件)                      │ │\n  1529→│  │  - Position, Rotation, Scale              │ │\n  1530→│  │                                             │ │\n  1531→│  │ PhysicsCollider (组件)                     │ │\n  1532→│  │  - 碰撞器数据                              │ │\n  1533→│  └───────────────────────────────────────────┘ │\n  1534→└──────────────────┬──────────────────────────────┘\n  1535→                   │ 双向引用\n  1536→                   ↓\n  1537→┌─────────────────────────────────────────────────┐\n  1538→│              MonoBehaviour GameObject            │\n  1539→│  ┌───────────────────────────────────────────┐ │\n  1540→│  │ PlayerController (脚本)                   │ │\n  1541→│  │  - 输入处理                                │ │\n  1542→│  │  - 动画控制                                │ │\n  1543→│  │  - 移动逻辑                                │ │\n  1544→│  │                                             │ │\n  1545→│  │ UnitProperty (脚本)                        │ │\n  1546→│  │  - myEntity: Entity引用                    │ │\n  1547→│  │  - 渲染相关数据                            │ │\n  1548→│  │  - 特效管理                                │ │\n  1549→│  │                                             │ │\n  1550→│  │ Spine SkeletonAnimation                    │ │\n  1551→│  │  - 角色动画                                │ │\n  1552→│  └───────────────────────────────────────────┘ │\n  1553→└─────────────────────────────────────────────────┘\n  1554→```\n  1555→\n  1556→**为什么需要双重架构?**\n  1557→1. **DOTS (Entity)**: 高性能数据计算\n  1558→   - 伤害计算、物理模拟、碰撞检测\n  1559→   - 使用 Job System 并行处理\n  1560→\n  1561→2. **MonoBehaviour**: 渲染和交互\n  1562→   - 动画播放、特效显示\n  1563→   - 输入处理、UI交互\n  1564→   - 声音播放\n  1565→\n  1566→---\n  1567→\n  1568→### 属性计算系统\n  1569→\n  1570→玩家的很多属性是动态计算的,受到遗物、诅咒、天赋等多种因素影响。\n  1571→\n  1572→#### ExtraDamageRatio - 额外伤害比例\n  1573→\n  1574→**位置**: [PlayerMgr.cs:157-196](PlayerMgr.cs:157-196)\n  1575→\n  1576→```csharp\n  1577→public float ExtraDamageRatio\n  1578→{\n  1579→    get\n  1580→    {\n  1581→        float ratio = BaData.extraDamageRatio;  // 基础额外伤害\n  1582→\n  1583→        // 遗物: 诅咒战士 (+5% per 诅咒)\n  1584→        if (ItemCtrller.relicCfg_CurseWarrior != null)\n  1585→        {\n  1586→            ratio += (float)relicCfg_CurseWarrior.int1.result / 100f *\n  1587→                     (float)BaData.curseIDs.Count;\n  1588→        }\n  1589→\n  1590→        // 遗物: 金钱即力量 (+X% per Y金币)\n  1591→        if (ItemCtrller.relicCfg_MoneyIsPower != null)\n  1592→        {\n  1593→            int coinThreshold = relicCfg_MoneyIsPower.int1.result;\n  1594→            int percentPerThreshold = relicCfg_MoneyIsPower.int2.result;\n  1595→            ratio += (float)CoinCount / (float)coinThreshold *\n  1596→                     (float)percentPerThreshold / 100f;\n  1597→        }\n  1598→\n  1599→        // 遗物: 增伤\n  1600→        if (ItemCtrller.relicCfg_AddDamage != null)\n  1601→        {\n  1602→            ratio += (float)relicCfg_AddDamage.int1.result / 100f;\n  1603→        }\n  1604→\n  1605→        // 遗物: 强者\n  1606→        if (ItemCtrller.relicCfg_PowerfulMan != null)\n  1607→        {\n  1608→            ratio += (float)relicCfg_PowerfulMan.int1.result / 100f;\n  1609→        }\n  1610→\n  1611→        // 遗物: 疯眼 (动态增长)\n  1612→        if (ItemCtrller.relicCfg_MadEye != null)\n  1613→        {\n  1614→            ratio += relicCfg_MadEye.floatTimer;\n  1615→        }\n  1616→\n  1617→        // 遗物: 狂战士 (低血增伤)\n  1618→        if (ItemCtrller.relic_MadWarrior != null)\n  1619→        {\n  1620→            ratio += relic_MadWarrior.ExtraDamageRatio;\n  1621→        }\n  1622→\n  1623→        // 诅咒: 降低伤害和速度\n  1624→        if (ItemCtrller.curseCfg_ReduceSpeedDamage != null)\n  1625→        {\n  1626→            ratio -= (float)curseCfg_ReduceSpeedDamage.int1.result / 100f;\n  1627→        }\n  1628→\n  1629→        // 诅咒: 满血增伤 (动态)\n  1630→        if (ItemCtrller.curseCfg_FullHPAddDamage != null)\n  1631→        {\n  1632→            ratio += curseCfg_FullHPAddDamage.floatTimer;\n  1633→        }\n  1634→\n  1635→        return ratio;\n  1636→    }\n  1637→}\n  1638→```\n  1639→\n  1640→**伤害计算公式**:\n  1641→```\n  1642→最终伤害 = 基础伤害 * (1 + ExtraDamageRatio)\n  1643→```\n  1644→\n  1645→#### MoveSpeedRatio - 移动速度比例\n  1646→\n  1647→**位置**: [UnitProperty.cs:223-282](UnitProperty.cs:223-282)\n  1648→\n  1649→```csharp\n  1650→public float MoveSpeedRatio\n  1651→{\n  1652→    get\n  1653→    {\n  1654→        float ratio = 1f;\n  1655→\n  1656→        // 诅咒: 敌人加速\n  1657→        if (PlayerMgr.Inst.ItemCtrller.curseCfg_EnemyAddMove != null &&\n  1658→            unitCfg.IsSameCamp(UnitType.Monster))\n  1659→        {\n  1660→            ratio *= (float)(curseCfg_EnemyAddMove.int1.result + 100) / 100f;\n  1661→        }\n  1662→\n  1663→        // 玩家特殊逻辑\n  1664→        if (unitCfg.unitType == UnitType.Player)\n  1665→        {\n  1666→            // 战斗数据额外移速\n  1667→            if (PlayerMgr.Inst.BaData != null)\n  1668→            {\n  1669→                ratio += PlayerMgr.Inst.BaData.extraMoveSpeedRatio;\n  1670→            }\n  1671→\n  1672→            // 诅咒: 反向移动\n  1673→            if (PlayerMgr.Inst.ItemCtrller.curse_IsReverseMove)\n  1674→            {\n  1675→                ratio = -ratio;\n  1676→            }\n  1677→\n  1678→            // 诅咒: 减移速\n  1679→            if (PlayerMgr.Inst.ItemCtrller.curseCfg_ReduceMoveSpeed != null)\n  1680→            {\n  1681→                ratio -= (float)curseCfg_ReduceMoveSpeed.int1.result / 100f;\n  1682→            }\n  1683→\n  1684→            // 遗物: 免疫地面\n  1685→            if (PlayerMgr.Inst.ItemCtrller.relicCfg_ImmuneSurface != null)\n  1686→            {\n  1687→                ratio += (float)relicCfg_ImmuneSurface.int1.result / 100f;\n  1688→            }\n  1689→\n  1690→            // 遗物: 增加移速\n  1691→            if (PlayerMgr.Inst.ItemCtrller.relic_AddMoveSpeed != null)\n  1692→            {\n  1693→                ratio += (float)relic_AddMoveSpeed.RelicCfg.int1.result / 100f;\n  1694→            }\n  1695→\n  1696→            // 遗物: 隐形之翼\n  1697→            if (PlayerMgr.Inst.ItemCtrller.relic_InvisibleWing != null)\n  1698→            {\n  1699→                ratio += relic_InvisibleWing.ExtraMoveSpeed;\n  1700→            }\n  1701→\n  1702→            // 遗物: 受伤加速\n  1703→            if (PlayerMgr.Inst.ItemCtrller.relic_InjuredAddMoveSpeed != null)\n  1704→            {\n  1705→                ratio *= relic_InjuredAddMoveSpeed.MoveSpeedRatio;\n  1706→            }\n  1707→\n  1708→            // 遗物: 变异者\n  1709→            if (PlayerMgr.Inst.ItemCtrller.relic_Variator != null)\n  1710→            {\n  1711→                ratio *= relic_Variator.MoveRate;\n  1712→            }\n  1713→\n  1714→            // 诅咒: 镣铐\n  1715→            if (PlayerMgr.Inst.ItemCtrller.curse_Shackle != null)\n  1716→            {\n  1717→                ratio *= curse_Shackle.MoveRatio;\n  1718→            }\n  1719→\n  1720→            // 魔杖能力加成\n  1721→            ratio *= PlayerMgr.Inst.PlayerMoveSpeedRatioFromWandAbility();\n  1722→        }\n  1723→\n  1724→        // 状态: 反向移动\n  1725→        if (affect_IsReverseMove)\n  1726→        {\n  1727→            ratio = -ratio;\n  1728→        }\n  1729→\n  1730→        // 状态: 粘液减速\n  1731→        if (affect_IsMucusDecelerate)\n  1732→        {\n  1733→            ratio *= affect_MucusMoveSpeedRatio;\n  1734→        }\n  1735→\n  1736→        return ratio;\n  1737→    }\n  1738→}\n  1739→```\n  1740→\n  1741→**移动速度公式**:\n  1742→```\n  1743→最终移速 = 基础移速 * MoveSpeedRatio\n  1744→```\n  1745→\n  1746→---\n  1747→\n  1748→## 战斗流程\n  1749→\n  1750→### 完整流程图\n  1751→\n  1752→```\n  1753→[游戏启动] → [选择套装/天赋] → [进入战斗场景]\n  1754→                                      ↓\n  1755→                        ┌─────────────────────────┐\n  1756→                        │   BattleMgr.Awake()     │\n  1757→                        │   - 初始化单例          │\n  1758→                        │   - 获取EntityManager   │\n  1759→                        └─────────────┬───────────┘\n  1760→                                      ↓\n  1761→                        ┌─────────────────────────┐\n  1762→                        │   BattleMgr.Update()    │\n  1763→                        │   - 等待DOTS初始化      │\n  1764→                        └─────────────┬───────────┘\n  1765→                                      ↓\n  1766→                        ┌─────────────────────────┐\n  1767→                        │  BattleMgr.StartHandle()│\n  1768→                        │  - 区分测试/正常模式    │\n  1769→                        └─────────────┬───────────┘\n  1770→                                      ↓\n  1771→                        ┌─────────────────────────┐\n  1772→                        │  Start_Normal()         │\n  1773→                        │  1. 创建玩家            │\n  1774→                        │  2. 初始化BattleData    │\n  1775→                        │  3. 生成房间配置        │\n  1776→                        │  4. 创建关卡            │\n  1777→                        └─────────────┬───────────┘\n  1778→                                      ↓\n  1779→                        ┌─────────────────────────┐\n  1780→                        │  CreateLevelFinish()    │\n  1781→                        │  - 淡入效果             │\n  1782→                        │  - 显示UI               │\n  1783→                        │  - 显示章节名           │\n  1784→                        └─────────────┬───────────┘\n  1785→                                      ↓\n  1786→                    ╔═════════════════════════════════╗\n  1787→                    ║        战斗循环开始             ║\n  1788→                    ╚═════════════════════════════════╝\n  1789→                                      ↓\n  1790→                  ┌───────────────────────────────────┐\n  1791→                  │   玩家战斗                        │\n  1792→                  │   - 移动、闪避                    │\n  1793→                  │   - 释放技能                      │\n  1794→                  │   - 受到伤害                      │\n  1795→                  │   - 拾取物品                      │\n  1796→                  └───────────────┬───────────────────┘\n  1797→                                  ↓\n  1798→                  ┌───────────────────────────────────┐\n  1799→                  │   清空房间敌人                    │\n  1800→                  │   - 所有敌人死亡                  │\n  1801→                  │   - 生成奖励                      │\n  1802→                  │   - 显示出口门                    │\n  1803→                  └───────────────┬───────────────────┘\n  1804→                                  ↓\n  1805→                  ┌───────────────────────────────────┐\n  1806→                  │   PlayerEnterDoor()               │\n  1807→                  │   1. 保存游戏                     │\n  1808→                  │   2. 记录战斗日志                 │\n  1809→                  │   3. 处理进门效果                 │\n  1810→                  │   4. 清理对象池                   │\n  1811→                  │   5. 更新进度                     │\n  1812→                  │   6. 生成新房间                   │\n  1813→                  └───────────────┬───────────────────┘\n  1814→                                  ↓\n  1815→                            [章节过渡?]\n  1816→                      Yes ↙         ↘ No\n  1817→        ┌──────────────────┐    ┌──────────────────┐\n  1818→        │ ShowChapterThrough│    │ 进入下一房间     │\n  1819→        │ - 增加Stage       │    │ - 增加Level      │\n  1820→        │ - 重置Level=0     │    │ - 生成新房间     │\n  1821→        │ - 显示过渡动画    │    └────────┬─────────┘\n  1822→        └────────┬──────────┘              │\n  1823→                 │                         │\n  1824→                 └─────────┬───────────────┘\n  1825→                           ↓\n  1826→                      [继续战斗]\n  1827→                           ↓\n  1828→                    ╔═════════════════════════════════╗\n  1829→                    ║     回到战斗循环                ║\n  1830→                    ╚═════════════════════════════════╝\n  1831→\n  1832→                           ↓ (直到 Boss 被击败)\n  1833→\n  1834→                    ┌──────────────────┐\n  1835→                    │  Boss战斗结束    │\n  1836→                    │  - 显示奖励      │\n  1837→                    │  - 解锁下一章    │\n  1838→                    └──────────────────┘\n  1839→```\n  1840→\n  1841→---\n  1842→\n  1843→### 详细阶段说明\n  1844→\n  1845→#### 阶段 1: 初始化 (Initialization)\n  1846→\n  1847→**时间线**: 场景加载 → DOTS就绪 → StartHandle()\n  1848→\n  1849→```\n  1850→Time: 0.0s → 0.5s\n  1851→│\n  1852→├─ BattleMgr.Awake()\n  1853→│  └─ 创建EntityManager实例\n  1854→│\n  1855→├─ 各种System初始化 (DOTS异步)\n  1856→│  ├─ UnitPropertySystem\n  1857→│  ├─ TakeDamageSystem\n  1858→│  ├─ SpellSystem\n  1859→│  └─ ...\n  1860→│\n  1861→└─ BattleMgr.Update() 检测到DOTS就绪\n  1862→   └─ 调用 StartHandle()\n  1863→```\n  1864→\n  1865→#### 阶段 2: 玩家创建 (Player Creation)\n  1866→\n  1867→**时间线**: StartHandle() → CreateLevelFinish()\n  1868→\n  1869→```\n  1870→PlayerMgr.CreatePlayer()\n  1871→│\n  1872→├─ 1. 清理旧数据\n  1873→│  ├─ 销毁旧 PlayerGO\n  1874→│  ├─ 销毁旧 Entity\n  1875→│  └─ 清空召唤物列表\n  1876→│\n  1877→├─ 2. 创建 BattleData\n  1878→│  ├─ 初始化物品池\n  1879→│  ├─ 应用天赋加成\n  1880→│  └─ 设置初始装备\n  1881→│\n  1882→├─ 3. 创建 DOTS Entity\n  1883→│  ├─ Instantiate Entity Template\n  1884→│  ├─ 设置 UnitProperty_Dots\n  1885→│  ├─ 设置 LocalTransform\n  1886→│  └─ 设置 PhysicsCollider\n  1887→│\n  1888→└─ 4. 创建 MonoBehaviour GameObject\n  1889→   ├─ Instantiate Prefab\n  1890→   ├─ 关联 Entity ↔ GameObject\n  1891→   └─ 初始化 PlayerController\n  1892→```\n  1893→\n  1894→#### 阶段 3: 关卡生成 (Level Generation)\n  1895→\n  1896→**时间线**: StartHandle() → LevelMgr.CreateLevel()\n  1897→\n  1898→```\n  1899→GetRoomCfgs(rewardType)\n  1900→│\n  1901→├─ 1. 判断房间类型\n  1902→│  ├─ Boss房间? → 生成前置房+Boss房\n  1903→│  ├─ 商店? → 生成商店房\n  1904→│  ├─ 战斗? → 生成怪物房\n  1905→│  └─ ...\n  1906→│\n  1907→├─ 2. 从池中获取房间配置\n  1908→│  ├─ BaData.GetRoomFromPool()\n  1909→│  └─ 检查特殊条件 (RRO, 侧边房间)\n  1910→│\n  1911→├─ 3. 生成侧边房间 (如果需要)\n  1912→│  ├─ 检查 specialRoomLevels\n  1913→│  ├─ 判断侧边房间方向\n  1914→│  └─ 添加到房间字典\n  1915→│\n  1916→└─ 4. 返回房间配置字典\n  1917→   Key: Vector2Int (房间相对位置)\n  1918→   Value: RoomConfig (房间配置)\n  1919→```\n  1920→\n  1921→#### 阶段 4: 战斗循环 (Combat Loop)\n  1922→\n  1923→**每帧执行** (Update/FixedUpdate)\n  1924→\n  1925→```\n  1926→[Input] → [PlayerController] → [Wand] → [Spell] → [Damage] → [UI Update]\n  1927→   ↓             ↓                ↓         ↓          ↓           ↓\n  1928→ 键盘输入    移动/闪避         释放技能   碰撞检测   伤害计算   更新HP条\n  1929→                                                    击退处理\n  1930→                                                    特效播放\n  1931→```\n  1932→\n  1933→**DOTS Systems 执行顺序**:\n  1934→\n  1935→```\n  1936→[Update阶段]\n  1937→│\n  1938→├─ UnitBaseSystem\n  1939→│  └─ 更新单位基础状态\n  1940→│\n  1941→├─ UnitPropertySystem\n  1942→│  └─ 更新单位属性 (HP, 移速, 状态)\n  1943→│\n  1944→├─ SpellSystem\n  1945→│  ├─ 更新技能位置\n  1946→│  ├─ 检测碰撞\n  1947→│  └─ 生成伤害信息\n  1948→│\n  1949→├─ TakeDamageInfoPreProcessSystem\n  1950→│  └─ 预处理伤害 (计算暴击, 应用减伤)\n  1951→│\n  1952→├─ UnitBeforeTakeDamageSystem\n  1953→│  └─ 受伤前事件 (闪避, 反弹, 遗物触发)\n  1954→│\n  1955→├─ UnitAfterTakeDamageSystem\n  1956→│  ├─ 扣除HP\n  1957→│  ├─ 应用击退\n  1958→│  └─ 触发受伤特效\n  1959→│\n  1960→├─ UnitTakeDamageDeadSystem\n  1961→│  └─ 检查死亡\n  1962→│\n  1963→├─ UnitTakeDamageClearSystem\n  1964→│  └─ 清除本帧伤害信息\n  1965→│\n  1966→└─ DamageRecordSystem\n  1967→   └─ 记录伤害到日志\n  1968→```\n  1969→\n  1970→#### 阶段 5: 清空房间 (Room Clear)\n  1971→\n  1972→**触发条件**: 所有敌人死亡\n  1973→\n  1974→```\n  1975→LevelMgr.CheckRoomClear()\n  1976→│\n  1977→├─ 1. 统计存活敌人\n  1978→│  ├─ 查询所有 Monster/Elite/Boss Entity\n  1979→│  └─ 过滤掉已死亡的\n  1980→│\n  1981→├─ 2. 如果敌人数 == 0\n  1982→│  ├─ 生成奖励\n  1983→│  │  ├─ 金币\n  1984→│  │  ├─ 钥匙\n  1985→│  │  └─ 随机掉落物\n  1986→│  │\n  1987→│  ├─ 生成出口门\n  1988→│  │  ├─ 根据 NextRewardTypes 生成多个门\n  1989→│  │  └─ 显示门的奖励类型图标\n  1990→│  │\n  1991→│  └─ 播放胜利音效/特效\n  1992→│\n  1993→└─ 3. 记录战斗日志\n  1994→   ├─ 击杀数量\n  1995→   ├─ 受到伤害\n  1996→   ├─ 使用技能\n  1997→   └─ 获得物品\n  1998→```\n  1999→\n  2000→#### 阶段 6: 进入下一房间 (Enter Next Room)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ff0bde57-cba7-466a-b1dc-e3e2ffeb5425","timestamp":"2025-12-18T11:35:14.869Z","toolUseResult":{"type":"text","file":{"filePath":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\01-战斗系统核心架构.md","content":"# 战斗系统核心架构文档\n\n## 目录\n1. [系统概述](#系统概述)\n2. [战斗管理器 (BattleMgr)](#战斗管理器-battlemgr)\n3. [战斗数据 (BattleData)](#战斗数据-battledata)\n4. [玩家管理器 (PlayerMgr)](#玩家管理器-playermgr)\n5. [战斗流程](#战斗流程)\n6. [数据结构设计](#数据结构设计)\n7. [关键系统交互](#关键系统交互)\n\n---\n\n## 系统概述\n\n这是一个基于 Unity DOTS (Data-Oriented Technology Stack) 架构的 Roguelike 战斗系统。游戏采用关卡制(Stage-Level)结构,玩家通过房间探索、战斗、获取奖励来推进游戏进程。\n\n### 核心特点\n- **ECS 架构**: 使用 Unity DOTS 进行高性能战斗计算\n- **Roguelike 元素**: 随机生成、永久死亡、资源池管理\n- **魔杖+技能系统**: 玩家通过魔杖释放技能进行战斗\n- **遗物/诅咒系统**: 提供战斗增益或减益效果\n- **难度分级**: 支持简单/普通/困难/噩梦1-3 多种难度\n\n### 技术栈\n- **Unity DOTS**: Entity Component System\n- **物理引擎**: Unity Physics (ECS版本)\n- **动画**: Spine 2D 动画系统\n- **导航**: NavMesh AI 导航\n\n---\n\n## 战斗管理器 (BattleMgr)\n\n**文件位置**: [BattleMgr.cs](BattleMgr.cs:1)\n\n### 类职责\n`BattleMgr` 是战斗系统的核心管理器,负责:\n1. 战斗场景初始化\n2. 关卡生成和切换\n3. 房间配置和奖励类型管理\n4. 玩家进入门后的场景切换逻辑\n5. 测试模式功能\n\n### 关键属性\n\n```csharp\npublic class BattleMgr : MonoBehaviour\n{\n    // 单例\n    public static BattleMgr Inst { get; private set; }\n\n    // 关卡配置\n    public int[] stageLevelsCount;           // 每个章节(Stage)的关卡数\n    public float[] rroChances;               // 随机遗物/资源/物品(RRO)出现概率\n\n    // 当前进度\n    public int CurrentStage                   // 当前章节 (1-10)\n    public int CurrentLevel                   // 当前关卡层数\n    public LevelRewardType CurrentRewardType  // 当前房间的奖励类型\n    public List<LevelRewardType> NextRewardTypes  // 下个房间可选的奖励类型\n\n    private EntityManager ettMgr;            // DOTS EntityManager\n    private bool isInitialized;              // 是否初始化完成\n    private bool battleStart;                // 战斗是否开始\n}\n```\n\n### 初始化流程\n\n#### 1. Awake() - 战斗场景加载\n**位置**: [BattleMgr.cs:123-129](BattleMgr.cs:123-129)\n\n```csharp\nprivate void Awake()\n{\n    Inst = this;\n    Destroy(objToDestroy);                    // 销毁临时对象\n    ettMgr = World.DefaultGameObjectInjectionWorld.EntityManager;  // 获取 ECS 管理器\n    Debug.Log(\"Enter Battle\");\n}\n```\n\n**分析**:\n- 设置单例实例\n- 获取 DOTS 的 EntityManager,用于后续所有 Entity 操作\n- 这是战斗场景的第一个入口点\n\n#### 2. Update() - 等待 DOTS 初始化\n**位置**: [BattleMgr.cs:197-205](BattleMgr.cs:197-205)\n\n```csharp\nprivate void Update()\n{\n    ettMgr.CheckInitialize(ref isInitialized);  // 检查 DOTS 是否初始化\n    if (isInitialized && !battleStart)\n    {\n        battleStart = true;\n        StartHandle();                          // 开始战斗初始化\n    }\n}\n```\n\n**分析**:\n- DOTS 系统需要异步初始化\n- `CheckInitialize` 是自定义扩展方法,检查所有必要的 System 是否就绪\n- 确保 Entity/System 完全加载后才开始游戏逻辑\n\n#### 3. StartHandle() - 战斗初始化分支\n**位置**: [BattleMgr.cs:207-412](BattleMgr.cs:207-412)\n\n```csharp\nprivate void StartHandle()\n{\n    InputChange();                            // 更新输入UI显示\n    UIPlayerDataMgr.Inst.ClearDragData();    // 清除拖拽数据\n\n    // 根据测试配置选择启动模式\n    if (ScriptableObjMgr.Inst.testCtrller.BattleChapter)\n        Start_TestChapter();                  // 测试模式\n    else\n        Start_Normal();                       // 正常模式\n\n    // ... 剧情逻辑处理\n    // ... 测试模式物品生成 (魔杖/技能/遗物/药水)\n}\n```\n\n**关键测试功能**:\n- `BattleAllWand`: 生成所有魔杖到地面\n- `BattleAllSpell`: 生成所有技能到地面\n- `BattleAllRelic`: 生成所有遗物到地面\n- `BattleCoin1000`: 给玩家1000金币\n- `BattleKey100`: 给玩家100钥匙\n\n---\n\n### 正常模式启动 (Start_Normal)\n\n**位置**: [BattleMgr.cs:414-557](BattleMgr.cs:414-557)\n\n```csharp\nprivate void Start_Normal()\n{\n    BattleData _archiveBattleData = DataMgr.selectedWorldData.battleData8;\n\n    // 1. 创建玩家\n    PlayerMgr.Inst.CreatePlayer();\n    CamController.Inst.SetFollow(PlayerMgr.Inst.PlayerT);\n\n    // 2. 随机技能魔杖检查\n    DataMgr.selectedWorldData.battleData8.RandomSpellWandCheck();\n\n    // 3. 清除伤害记录\n    DamageRecordeManager.ClearAllRecorde();\n\n    // 4. 获取房间配置\n    Dictionary<Vector2Int, RoomConfig> dictionary = new Dictionary<Vector2Int, RoomConfig>();\n\n    if (DataMgr.selectedWorldData.inBattle8)  // 从存档恢复\n    {\n        // 恢复存档的房间配置\n        RoomConfig config = RoomConfig.GetConfig(BaData.currentRoomID);\n        config.isFinalRoom = true;\n        dictionary.Add(Vector2Int.zero, config);\n        // ... 恢复玩家装备、遗物、诅咒\n    }\n    else  // 新游戏\n    {\n        dictionary = GetRoomCfgs(CurrentRewardType);  // 生成新房间\n        NextRewardTypes = OutputMgr.GetDoors();       // 生成下一关可选门\n\n        // 第一次进入战斗的初始化\n        if (DataMgr.selectedWorldData.firstEnterBattle)\n        {\n            CurrentLevel = 1;\n            CurrentRewardType = LevelRewardType.Relic;\n            // 给予初始魔杖和技能\n            PlayerMgr.Inst.BaData.wandCfgs = new List<WandConfig> { WandConfig.GetConfig(1) };\n            PlayerMgr.Inst.ChangeWandSpell(0, WandSlotType.Normal, 0, new SlotData(30051, 0));\n            PlayerMgr.Inst.ChangeWandSpell(0, WandSlotType.Normal, 1, new SlotData(31031, 0));\n        }\n    }\n\n    // 5. 创建关卡\n    Time.timeScale = 0f;  // 暂停时间,等待关卡加载\n    LevelMgr.Inst.CreateLevel(dictionary, CurrentRewardType, NextRewardTypes,\n        NextExtraDoorRewardType, fadeDisappear: false,\n        delegate {\n            CreateLevelFinish(!DataMgr.selectedWorldData.inBattle8);\n            // ... 更新UI、重建魔杖、回满蓝\n        });\n}\n```\n\n**关键流程分析**:\n\n1. **玩家创建**: [PlayerMgr.cs:276-339](PlayerMgr.cs:276-339)\n   - 创建 Entity (DOTS)\n   - 实例化 GameObject (渲染/控制)\n   - 初始化玩家配置\n\n2. **存档恢复机制**:\n   ```csharp\n   if (DataMgr.selectedWorldData.inBattle8)  // 从战斗中恢复\n   ```\n   - 恢复遗物等级和计时器\n   - 恢复诅咒状态\n   - 恢复玩家体型\n   - 特殊处理某些遗物(如WandAddSlot需要先添加低级版本)\n\n3. **新手引导**:\n   ```csharp\n   if (DataMgr.selectedWorldData.firstEnterBattle)\n   {\n       // 固定给予1号魔杖 + 基础技能\n       wandCfgs = new List<WandConfig> { WandConfig.GetConfig(1) };\n   }\n   ```\n\n---\n\n### 房间生成系统 (GetRoomCfgs)\n\n**位置**: [BattleMgr.cs:633-882](BattleMgr.cs:633-882)\n\n这是战斗系统最复杂的方法之一,负责根据奖励类型生成对应的房间配置。\n\n#### 房间类型 (RoomType)\n- `Monster`: 普通怪物房间\n- `Elite`: 精英怪房间\n- `Boss`: Boss房间\n- `Puzzle`: 谜题/支线房间\n- `Shortcut`: 快捷通道(跳过4层)\n\n#### 奖励类型 (LevelRewardType)\n```csharp\npublic enum LevelRewardType\n{\n    None,      // 无奖励\n    Spell,     // 技能奖励\n    Relic,     // 遗物奖励\n    MaxHP,     // 最大生命值提升\n    Coin,      // 金币奖励\n    Elite,     // 精英战斗\n    Boss,      // Boss战斗\n    Store,     // 商店\n    Process,   // 加工站(升级技能)\n    Spring,    // 温泉(回血)\n    Shortcut,  // 快捷通道\n    Wand,      // 魔杖(未使用)\n    Chapter    // 章节过渡\n}\n```\n\n#### 房间生成逻辑\n\n```csharp\nprivate Dictionary<Vector2Int, RoomConfig> GetRoomCfgs(LevelRewardType rewardType)\n{\n    Dictionary<Vector2Int, RoomConfig> dictionary = new Dictionary<Vector2Int, RoomConfig>();\n\n    // 测试关卡模式 (Stage >= 50)\n    if (CurrentStage >= 50)\n    {\n        RoomConfig testRoomFromPool = PlayerMgr.Inst.BaData.GetTestRoomFromPool();\n        testRoomFromPool.isFinalRoom = true;\n        if (UnityEngine.Random.Range(0, 2) == 0)\n            testRoomFromPool.ReverseX();  // 随机镜像\n        testRoomFromPool.generateRO = true;  // 生成随机物品\n        dictionary.Add(Vector2Int.zero, testRoomFromPool);\n        // ... 侧边房间生成\n    }\n\n    // 第0关(新手引导关卡)\n    else if (CurrentLevel == 0 && CurrentStage % 2 == 1)\n    {\n        RoomConfig testRoomFromPool = OutputMgr.GetChapterRoom0();\n        testRoomFromPool.isFinalRoom = true;\n        dictionary.Add(new Vector2Int(0, 0), testRoomFromPool);\n    }\n\n    // 根据不同奖励类型生成房间\n    else\n    {\n        switch (rewardType)\n        {\n            case LevelRewardType.Spell:\n            case LevelRewardType.Relic:\n            case LevelRewardType.MaxHP:\n            case LevelRewardType.Coin:\n                // 普通战斗房间逻辑\n                bool needSideRoom = PlayerMgr.Inst.BaData.specialRoomLevels.Contains(CurrentLevel);\n                float rroChance = rroChances[CurrentStage - 1];\n                bool needRRO = (UnityEngine.Random.value <= rroChance);\n\n                RoomConfig room = PlayerMgr.Inst.BaData.GetRoomFromPool(\n                    RoomType.Monster, needSideRoom, needRRO);\n                dictionary.Add(new Vector2Int(0, 0), room);\n\n                // 侧边房间(谜题房)\n                if (needSideRoom)\n                {\n                    RoomConfig sideRoom = GetPuzzleRoom();  // 特殊剧情或普通谜题房\n                    int direction = DetermineSideRoomDirection(room);\n                    if (direction == -1) sideRoom.ReverseX();\n                    dictionary.Add(new Vector2Int(direction, 0), sideRoom);\n                }\n                break;\n\n            case LevelRewardType.Boss:\n                // Boss房间特殊处理\n                bool useDave = CheckDaveBoss();\n                dictionary.Add(new Vector2Int(0, 0), OutputMgr.GetBossRoom0(useDave));\n                RoomConfig bossRoom = PlayerMgr.Inst.BaData.GetRoomFromPool(\n                    RoomType.Boss, false, false, useDave);\n                dictionary.Add(new Vector2Int(0, 1), bossRoom);\n\n                // 隐藏Boss房间\n                if (ShouldHaveHiddenBoss())\n                {\n                    RoomConfig hiddenBoss = OutputMgr.GetHideBossRoom(useDave);\n                    dictionary.Add(new Vector2Int(direction, 1), hiddenBoss);\n                }\n                break;\n\n            case LevelRewardType.Store:\n                // 商店\n                dictionary.Add(Vector2Int.zero, OutputMgr.GetStoreRoomCfg(CurrentStage));\n                // 特殊遗物可能触发侧边药水房\n                if (PlayerMgr.Inst.ItemCtrller.relic_SpecialStore)\n                {\n                    dictionary.Add(sidePos, OutputMgr.GetPotionRoomCfg(CurrentStage));\n                }\n                break;\n\n            // ... 其他房间类型\n        }\n    }\n\n    return dictionary;\n}\n```\n\n**关键概念**:\n\n1. **RRO (Random Relic/Resource/Object)**\n   - 房间内随机生成的物品\n   - 概率随章节递增: `rroChances[CurrentStage - 1]`\n   - 可能是遗物、金币、钥匙等\n\n2. **侧边房间 (Side Room)**\n   - 特定关卡会生成额外的侧边房间\n   - 通过 `specialRoomLevels` 列表控制\n   - 方向通过主房间的 `accessLeft/accessRight` 决定\n\n3. **房间镜像**\n   - `ReverseX()` 方法可镜像房间布局\n   - 用于增加房间多样性\n\n---\n\n### 玩家进入门系统 (PlayerEnterDoor)\n\n**位置**: [BattleMgr.cs:893-1140](BattleMgr.cs:893-1140)\n\n这是战斗流程中最关键的方法,处理玩家进入下一个房间的所有逻辑。\n\n```csharp\npublic void PlayerEnterDoor(DoorBase_Dots doorBase)\n{\n    // 1. DLC检查 (BiliBili版本限制)\n    if (GameMgr.IsMobile_Static && GameMgr.ISUseBiliOneSDK &&\n        NeedPurchaseCheck() && !GameMgr.HaveGame)\n    {\n        GameUISingletonMono<UIFullGame>.ShowInit();\n        return;\n    }\n\n    // 2. 自动存档\n    if (CurrentStage > 1 || CurrentLevel > 0)\n    {\n        DataMgr.SaveSelectedWorldData();\n    }\n\n    // 3. 记录战斗日志\n    if (CurrentStage == 1 && CurrentLevel == 0)\n    {\n        // 记录游戏开始日志\n        BattleStartLogger logger = new BattleStartLogger();\n        logger.suit = new Suit { id = DataMgr.selectedWorldData.selectedSetID };\n        logger.ban_spells = GetBannedSpells();\n        logger.Report();\n    }\n    else if (LevelMgr.Inst.RoomFinishLogger != null)\n    {\n        // 记录房间完成日志\n        RoomFinishLogger logger = LevelMgr.Inst.RoomFinishLogger;\n        logger.finish_equips = PlayerEquips.CreateAuto();\n        logger.spend_seconds = GetSpendTime();\n        logger.next_room_selected = doorBase.rewardType;\n    }\n\n    // 4. 特殊剧情检查\n    if (CheckSpecialStory())\n    {\n        // 跳转到特殊剧情场景\n        SceneManager.LoadScene(\"NPC7Appearance\");\n        return;\n    }\n\n    // 5. 停止玩家移动\n    PlayerMgr.Inst.PlayerCtrller.StopMotion();\n\n    // 6. 处理进门前效果\n    ProcessPlayerEnterDoorEffects(doorBase);\n\n    // 7. 清理当前房间\n    DamageRecordeManager.ClearCurrentRecorde();\n    UIPlayerDataMgr.Inst.CancelDrag();\n\n    // 8. 淡出并加载新场景\n    UIMgr.Inst.uiFade.Show(delegate {\n        // 恢复魔杖能量\n        float mpRatio = CalculateMPRatio();\n        PlayerMgr.Inst.AllWandFullMP(mpRatio);\n\n        // 无敌和飞行状态\n        PlayerMgr.Inst.InvincibleRegister();\n        PlayerMgr.Inst.FlyRegisterWithAllMate();\n\n        // 回收对象池\n        GameMgr.Inst.RecycleAllPool();\n\n        // 处理章节过渡\n        if (doorBase.rewardType == LevelRewardType.Chapter)\n        {\n            CurrentStage++;\n            CurrentLevel = 0;\n            ShowChapterTransition();\n        }\n        else\n        {\n            // 更新进度\n            UpdateProgress(doorBase);\n\n            // 生成新房间\n            Dictionary<Vector2Int, RoomConfig> roomCfgs = GetRoomCfgs(doorBase.rewardType);\n            LevelMgr.Inst.CreateLevel(roomCfgs, CurrentRewardType,\n                NextRewardTypes, NextExtraDoorRewardType,\n                fadeDisappear: true, PlayerEnterDoor2);\n        }\n    });\n}\n```\n\n#### 进门前效果 (ProcessPlayerEnterDoorEffects)\n\n**位置**: [BattleMgr.cs:1142-1220](BattleMgr.cs:1142-1220)\n\n```csharp\nprivate void ProcessPlayerEnterDoorEffects(DoorBase_Dots door)\n{\n    // 1. 遗物组效果 - 临时护盾转永久\n    if (ItemCtrller.relicGroupConfigs.TryGetValue(1, out var config))\n    {\n        float shieldPercent = config.int1.result / 100f;\n        float shield = playerPpt.unitCfg.shieldTemp * shieldPercent;\n        PlayerMgr.Inst.ChangeShield(shield);\n    }\n\n    // 2. 清除临时护盾\n    if (playerPpt.unitCfg.shieldTemp > 0f)\n    {\n        PlayerMgr.Inst.ChangeShieldTemp(-playerPpt.unitCfg.shieldTemp);\n    }\n\n    // 3. 迷幻药水效果清除\n    if (ItemCtrller.uiPotionPsychedelic != null)\n    {\n        ItemCtrller.uiPotionPsychedelic.DestroySelf();\n    }\n\n    // 4. 计算跨越层数 (快捷通道为4层)\n    int crossLevels = (door.rewardType != LevelRewardType.Shortcut) ? 1 : 4;\n\n    // 5. 每层触发的效果\n    for (int i = 0; i < crossLevels; i++)\n    {\n        // 遗物: 每层获得护盾\n        if (ItemCtrller.relicCfg_FloorShield != null)\n        {\n            PlayerMgr.Inst.ChangeShield(relicCfg_FloorShield.int1.result);\n        }\n\n        // 遗物: 存款利息\n        if (ItemCtrller.relic_FollowObj_FloorInterest != null)\n        {\n            int interest = CalculateInterest();\n            PlayerMgr.Inst.ChangeCoin(interest);\n        }\n\n        // 天赋: 每层回血\n        float recovery = DataMgr.selectedWorldData.GetTalentEnterDoorRecoveryValue();\n        if (ItemCtrller.relicCfg_FloorRecovery != null)\n        {\n            recovery += relicCfg_FloorRecovery.int1.result;\n        }\n        if (recovery > 0f)\n        {\n            UnitDotsSyncSystem.UnitRecoveryHP(PlayerEtt, recovery, ettMgr);\n        }\n\n        // 遗物: 临时护盾\n        if (ItemCtrller.relicCfg_TempShield != null)\n        {\n            PlayerMgr.Inst.ChangeShieldTemp(relicCfg_TempShield.int1.result);\n        }\n\n        // 遗物: 移除诅咒\n        if (ItemCtrller.relicCfg_EnterDoorRemoveCurse != null &&\n            BaData.curseIDs.Count > 0)\n        {\n            if (Random.value <= removeChance)\n            {\n                int removeIndex = Random.Range(0, BaData.curseIDs.Count);\n                PlayerMgr.Inst.ItemCtrller.CurseRemoveByIndex(removeIndex);\n            }\n        }\n    }\n\n    // 6. 诅咒: 流血\n    if (ItemCtrller.curseCfg_Bled != null)\n    {\n        TakeDamageInfo_Dots dmg = TakeDamageInfo_Dots.NewInfo(AttackerType.NothingSpecial);\n        dmg.damage = curseCfg_Bled.int1.result;\n        dmg.ignorePlayerInvincibleFrame = true;\n        dmg.ignoreRelicDodge = true;\n        ettMgr.GetBuffer<TakeDamageInfo_Dots>(PlayerEtt).Add(dmg);\n    }\n\n    // 7. 诅咒: 进门失去金币\n    if (ItemCtrller.curseCfg_EnterDoorLoseCoin != null && CoinCount > 0)\n    {\n        int loseAmount = Mathf.Min(curseCfg_EnterDoorLoseCoin.int1.result, CoinCount);\n        PlayerMgr.Inst.ChangeCoin(-loseAmount);\n        CreateTextFloatVFX(-loseAmount, UITextFloatType.DropCoin);\n    }\n}\n```\n\n**关键机制**:\n\n1. **临时护盾机制**\n   - 临时护盾在进门前清除\n   - 但可通过遗物组转换一定比例为永久护盾\n\n2. **跨层效果叠加**\n   - 快捷通道(Shortcut)会跨越4层\n   - 所有\"每层触发\"的效果会触发4次\n   - 包括护盾、回血、利息等\n\n3. **诅咒惩罚**\n   - 流血诅咒: 直接造成伤害,忽略无敌帧\n   - 金币流失诅咒: 扣除固定数量金币\n\n#### 进门后效果 (ProcessPlayerEnterDoorAfterEffects)\n\n**位置**: [BattleMgr.cs:1222-1316](BattleMgr.cs:1222-1316)\n\n```csharp\nprivate void ProcessPlayerEnterDoorAfterEffects()\n{\n    // 1. 清除悬浮药水效果\n    if (ItemCtrller.potion_HoverEFGO != null)\n    {\n        Destroy(ItemCtrller.potion_HoverEFGO);\n        PlayerMgr.Inst.FlyUnregister();\n    }\n\n    // 2. 清除胃痛药水\n    if (ItemCtrller.potion_Stomachache)\n    {\n        ItemCtrller.potion_Stomachache.DestroySelf();\n    }\n\n    // 3. 遗物: 潘多拉魔盒 - 随机替换背包技能\n    if (ItemCtrller.relicCfg_PandorasBox != null)\n    {\n        int replaceCount = relicCfg_PandorasBox.int1.result;\n        for (int i = replaceCount - 1; i >= 0; i--)\n        {\n            if (i < BaData.bagSpellDatas.Count)\n            {\n                SlotData oldSpell = BaData.bagSpellDatas[i];\n                if (oldSpell != null && !oldSpell.isSealSlot)\n                {\n                    // 获取同等级新技能\n                    int newSpellID = BaData.GetSpellFromPool(\n                        SpellConfig.dic[oldSpell.id].level,\n                        SpellConfig.dic[oldSpell.id].dropType,\n                        oldSpell.id);\n\n                    SlotData newSpell = new SlotData(newSpellID);\n                    PlayerMgr.Inst.BagSpellChange(i, newSpell);\n                }\n            }\n        }\n    }\n\n    // 4. 遗物组: 进门无敌\n    if (ItemCtrller.relicGroupConfigs.TryGetValue(4, out var config))\n    {\n        if (ItemCtrller.potion_Invincible == null)\n        {\n            ItemCtrller.potion_Invincible = Instantiate(invinciblePrefab);\n        }\n        ItemCtrller.potion_Invincible.Initialize(config.int1.result);\n    }\n\n    // 5. 充能UI刷新\n    if (ItemCtrller.uiRelic_LightArmor != null)\n    {\n        ItemCtrller.uiRelic_LightArmor.FullFill();\n    }\n    if (ItemCtrller.uiRelic_WarmSnow != null)\n    {\n        ItemCtrller.uiRelic_WarmSnow.FullFill();\n    }\n\n    // 6. 遗物: 死神之镰 - 合成技能\n    if (ItemCtrller.relic_Reaper != null)\n    {\n        ItemCtrller.relic_Reaper.CompoundSpell();\n    }\n\n    // 7. 遗物: 隐形之翼 - 重置状态\n    if (ItemCtrller.relic_InvisibleWing != null)\n    {\n        ItemCtrller.relic_InvisibleWing.EnterDoor();\n    }\n\n    // 8. 诅咒: 随机诅咒重新抽取\n    if (ItemCtrller.curse_RandomCurseCommon != null)\n    {\n        ItemCtrller.curse_RandomCurseCommon.RerollCurse();\n    }\n    if (ItemCtrller.curse_RandomCurseRare != null)\n    {\n        ItemCtrller.curse_RandomCurseRare.RerollCurse();\n    }\n\n    // 9. 诅咒: 进门禁止射击\n    if (ItemCtrller.curse_CantShootEnterRoom != null)\n    {\n        ItemCtrller.curse_CantShootEnterRoom.EnterDoor();\n    }\n\n    // 10. 诅咒: 蜗牛追踪\n    if (ItemCtrller.curse_SnailHunt != null)\n    {\n        ItemCtrller.curse_SnailHunt.EnterDoor();\n    }\n}\n```\n\n**关键机制**:\n\n1. **潘多拉魔盒**\n   - 随机替换前N个背包技能\n   - 替换为同等级、同稀有度的技能\n   - 不替换封印槽位\n\n2. **进门无敌**\n   - 遗物组效果\n   - 持续时间由遗物组配置决定\n\n3. **充能类遗物重置**\n   - 轻甲、暖雪等需要充能的遗物\n   - 进门后充能值恢复满\n\n4. **诅咒状态刷新**\n   - 某些诅咒在进门时重新触发\n   - 如随机诅咒会抽取新的诅咒效果\n\n---\n\n## 战斗数据 (BattleData)\n\n**文件位置**: [BattleData.cs](BattleData.cs:1)\n\n### 类职责\n`BattleData` 是战斗过程中所有数据的容器,负责:\n1. 玩家当前状态数据\n2. 物品池管理 (技能/魔杖/遗物/诅咒)\n3. 关卡进度追踪\n4. 奖励类型管理\n\n### 核心数据结构\n\n```csharp\npublic class BattleData\n{\n    // ========== 玩家属性 ==========\n    public UnitConfig playerCfg;              // 玩家单位配置\n    public float bodySize = 1f;               // 体型大小\n    public int coinCount;                     // 金币数量\n    public int keyCount;                      // 钥匙数量\n\n    // ========== 玩家能力 ==========\n    public int wandMaxCount = 1;              // 魔杖最大数量\n    public int bagCount = 10;                 // 背包格子数\n    public int potionMaxCount = 1;            // 药水槽位数\n    public int mpMax;                         // 魔法值上限\n    public float mpRecovery;                  // 魔法值回复速度\n\n    // ========== 额外加成 ==========\n    public float extraMoveSpeedRatio;         // 额外移动速度比例\n    public float extraDamageRatio;            // 额外伤害比例\n    public float extraCriticalChance;         // 额外暴击率\n\n    // ========== 关卡进度 ==========\n    public int currentLevel;                  // 当前关卡\n    public int currentStage = 1;              // 当前章节\n    public int currentRoomID;                 // 当前房间ID\n    public LevelRewardType currentRewardType; // 当前奖励类型\n    public List<LevelRewardType> nextRewardTypes;  // 下一关可选奖励类型\n    public LevelRewardType nextExtraDoorRewardType; // 额外门奖励类型\n\n    // ========== 连续计数 (用于动态调整概率) ==========\n    public int continuousNonSpell = 1;        // 连续未获得技能\n    public int continuousNonRelic;            // 连续未获得遗物\n    public int continuousNonCoin;             // 连续未获得金币\n    public int continuousNonProcess;          // 连续未遇到加工站\n    public int continuousNonStore;            // 连续未遇到商店\n    public int continuousNonSpring;           // 连续未遇到温泉\n\n    // ========== 特殊房间 ==========\n    public List<int> specialRoomLevels;       // 有侧边房间的关卡\n    public bool shortcutRoomAppearedStage1-6; // 各章节快捷通道是否出现\n\n    // ========== 玩家装备 ==========\n    public List<WandConfig> wandCfgs;         // 魔杖配置列表\n    public List<SlotData> bagSpellDatas;      // 背包技能列表\n    public List<RelicConfig> relicCfgs;       // 遗物配置列表\n    public List<int> potionIDs;               // 药水ID列表\n    public List<int> curseIDs;                // 诅咒ID列表\n    public List<int> curseLevels;             // 诅咒等级列表\n\n    // ========== 物品池 ==========\n    public List<int> poolOfRoomID;            // 房间ID池\n    public List<int> poolOfWandID;            // 魔杖ID池\n    public List<int> poolOfSpellID;           // 技能ID池\n    public List<int> poolOfPotionID;          // 药水ID池\n    public Dictionary<int, int> poolOfRelic;  // 遗物ID池 (ID -> 可获得次数)\n    public Dictionary<int, int> poolOfCurse;  // 诅咒ID池 (ID -> 可获得次数)\n\n    // ========== 池状态标记 ==========\n    public bool isSpellPoolHaveCommon = true;  // 池中是否有普通技能\n    public bool isSpellPoolHaveRare = true;    // 池中是否有稀有技能\n    public bool isSpellPoolHaveEpic = true;    // 池中是否有史诗技能\n    public bool isSpellPoolHaveSpecial = true; // 池中是否有特殊技能\n\n    // ========== 伤害记录 ==========\n    public DamageRecorder damageRecorderV2;   // 伤害记录器V2\n}\n```\n\n---\n\n### 初始化流程 (Initialize)\n\n**位置**: [BattleData.cs:116-179](BattleData.cs:116-179)\n\n```csharp\npublic void Initialize()\n{\n    // 1. 加载玩家基础配置\n    playerCfg = UnitConfig.map[800001];  // 玩家单位ID固定为800001\n\n    // 2. 应用天赋加成\n    if (DataMgr.selectedWorldData.levelOfWandLimit > 0)\n    {\n        wandMaxCount += TalentUpgrade.wandLimit[level-1].value;\n    }\n    if (DataMgr.selectedWorldData.levelOfBagLimit > 0)\n    {\n        bagCount += TalentUpgrade.bagLimit[level-1].value;\n    }\n    if (DataMgr.selectedWorldData.levelOfMaxHP > 0)\n    {\n        playerCfg.maxHP += TalentUpgrade.maxHP[level-1].value;\n    }\n    playerCfg.currentHP = playerCfg.maxHP;  // 满血开始\n\n    if (DataMgr.selectedWorldData.levelOfInitialCoin > 0)\n    {\n        coinCount += TalentUpgrade.initialCoin[level-1].value;\n    }\n    if (DataMgr.selectedWorldData.levelOfMaxMP > 0)\n    {\n        mpMax += TalentUpgrade.maxMP[level-1].value;\n    }\n    if (DataMgr.selectedWorldData.levelOfMPRecover > 0)\n    {\n        mpRecovery += TalentUpgrade.mpRecover[level-1].value;\n    }\n\n    // 3. 应用研究加成\n    DataMgr.selectedWorldData.CalculateAddingPoints();\n    potionMaxCount += GetResearchValue(ResearchAbilityType.PotionLimit);\n    keyCount += GetResearchValue(ResearchAbilityType.KeyChain);\n\n    // 4. 初始化容器\n    for (int i = 0; i < wandMaxCount; i++)\n        wandCfgs.Add(null);\n\n    for (int j = 0; j < bagCount; j++)\n        bagSpellDatas.Add(null);\n\n    for (int k = 0; k < potionMaxCount; k++)\n        potionIDs.Add(0);\n\n    // 5. 初始化物品池\n    InitialPools();\n\n    // 6. 应用套装魔杖\n    if (GetSelectedSetCfg().WandIDs.Length != 0)\n    {\n        wandCfgs[0] = WandConfig.GetConfig(GetCurrentSetWandID());\n    }\n\n    // 7. 应用套装遗物 (从池中预先移除)\n    int setRelicID = GetCurrentSetRelicID();\n    int setRelicLevel = GetCurrentSetRelicLevel();\n    if (setRelicID != 0 && poolOfRelic.ContainsKey(setRelicID))\n    {\n        for (int l = 0; l < setRelicLevel; l++)\n        {\n            poolOfRelic[setRelicID]--;\n            if (poolOfRelic[setRelicID] == 0)\n            {\n                poolOfRelic.Remove(setRelicID);\n                break;\n            }\n        }\n    }\n}\n```\n\n**关键机制**:\n\n1. **天赋系统**\n   - 永久升级,影响初始属性\n   - 包括魔杖槽位、背包大小、生命值、法力值等\n\n2. **研究系统**\n   - 营地内可解锁的被动效果\n   - 如药水槽位、钥匙链等\n\n3. **套装系统**\n   - 每个套装有初始魔杖和初始遗物\n   - 初始遗物需要从池中预先移除,避免重复获得\n\n---\n\n### 物品池系统 (InitialPools)\n\n**位置**: [BattleData.cs:181-295](BattleData.cs:181-295)\n\n```csharp\npublic void InitialPools()\n{\n    // 清空所有池\n    poolOfRoomID.Clear();\n    poolOfWandID.Clear();\n    poolOfSpellID.Clear();\n    poolOfRelic.Clear();\n    poolOfPotionID.Clear();\n    poolOfCurse.Clear();\n\n    // ========== 房间池 ==========\n    for (int i = 0; i < RoomConfig.list.Count; i++)\n    {\n        poolOfRoomID.Add(RoomConfig.list[i].id);\n    }\n\n    // ========== 药水池 ==========\n    for (int j = 0; j < PotionConfig.list.Count; j++)\n    {\n        if (PotionConfig.list[j].id != 3)  // 排除ID=3的特殊药水\n        {\n            poolOfPotionID.Add(PotionConfig.list[j].id);\n        }\n    }\n\n    // ========== 诅咒池 ==========\n    for (int k = 0; k < CurseConfig.list.Count; k++)\n    {\n        // 特殊诅咒\"失去技能选项\"需要激活4选2天赋\n        if (CurseConfig.list[k].abilityType != CurseAbilityType.LostSpellOption ||\n            DataMgr.selectedWorldData.ActivateGirlHave4Pick2())\n        {\n            poolOfCurse.Add(CurseConfig.list[k].id, CurseConfig.list[k].count);\n        }\n    }\n\n    // ========== 魔杖池 ==========\n    for (int l = 0; l < WandConfig.list.Count; l++)\n    {\n        WandConfig wand = WandConfig.list[l];\n\n        // 排除条件:\n        // 1. 第一次进战斗 && 魔杖有后置槽位 (太复杂)\n        // 2. 没有魔杖槽位升级天赋 && 魔杖需要多槽位机制\n        bool exclude = (DataMgr.selectedWorldData.enterBattleTime == 1 &&\n                        wand.postSlots.Length > 0);\n\n        if (levelOfWandLimit == 0 && selectedSetID != 5)\n        {\n            // 排除需要多魔杖协同的特殊能力魔杖\n            exclude |= (wand.specialAbility == WandAbility.HoldWandDifferentManaGenRatio);\n            exclude |= (wand.specialAbility == WandAbility.AllWandMpCostRatio);\n            exclude |= (wand.specialAbility == WandAbility.AllWandMaxMpRatio);\n            // ... 等等\n        }\n\n        if (!exclude)\n        {\n            poolOfWandID.Add(wand.id);\n        }\n    }\n\n    // ========== 技能池 ==========\n    // 首先获取已激活的技能\n    List<int> activatedSpells = new List<int>();\n    List<int> activatedRelics = new List<int>();\n\n    for (int m = 0; m < DataMgr.selectedWorldData.activateGirlActivatedIDs2.Count; m++)\n    {\n        int activateID = activateGirlActivatedIDs2[m];\n        if (ActivateGirlConfig.dic.ContainsKey(activateID))\n        {\n            ActivateGirlConfig cfg = ActivateGirlConfig.dic[activateID];\n            if (cfg.specialType == ActivateGirlSpecialType.None)\n            {\n                // 普通技能激活\n                activatedSpells.AddRange(cfg.spellIDs);\n            }\n            else if (cfg.specialType == ActivateGirlSpecialType.Relic)\n            {\n                // 遗物技能激活\n                activatedRelics.AddRange(cfg.spellIDs);\n            }\n        }\n    }\n\n    // 添加技能到池\n    for (int num2 = 0; num2 < SpellConfig.list.Count; num2++)\n    {\n        SpellConfig spell = SpellConfig.list[num2];\n\n        if (spell.dropType == ItemDropType.None)\n            continue;  // 不掉落的技能\n\n        if (spell.needActivate)\n        {\n            // 需要激活的技能\n            int baseID = spell.id / 10 * 10 + 1;  // 获取基础ID\n            if (activatedSpells.Contains(baseID))\n            {\n                poolOfSpellID.Add(spell.id);\n            }\n        }\n        else\n        {\n            // 特殊排除: 回响符文需要多魔杖\n            if (wandMaxCount == 1 && selectedSetID != 5 &&\n                spell.abilityType == SpellAbilityType.EchoRune)\n            {\n                continue;\n            }\n\n            poolOfSpellID.Add(spell.id);\n        }\n    }\n\n    // 特殊套装技能\n    if (selectedSetID == 9)\n    {\n        poolOfSpellID.Add(10281);  // 套装9专属技能\n        poolOfSpellID.Add(10282);\n        poolOfSpellID.Add(10283);\n    }\n    else if (selectedSetID == 11)\n    {\n        poolOfSpellID.Add(10311);  // 套装11专属技能\n        poolOfSpellID.Add(10312);\n        poolOfSpellID.Add(10313);\n    }\n\n    // ========== 遗物池 ==========\n    for (int num3 = 0; num3 < RelicConfig.list.Count; num3++)\n    {\n        RelicConfig relic = RelicConfig.list[num3];\n\n        if (relic.needActivate)\n        {\n            // 需要激活的遗物\n            if (activatedRelics.Contains(relic.id))\n            {\n                poolOfRelic.Add(relic.id, relic.maxCount);\n            }\n        }\n        else\n        {\n            // 特殊排除: 后置槽位效率遗物需要第二次进战斗\n            if (relic.abilityType == RelicAbilityType.PostSlotMoreEfficiency &&\n                enterBattleTime <= 1)\n            {\n                continue;\n            }\n\n            poolOfRelic.Add(relic.id, relic.maxCount);\n        }\n    }\n\n    // 特殊套装遗物\n    if (selectedSetID == 6 || selectedSetID == 7 || selectedSetID == 9)\n    {\n        poolOfRelic.Add(76, RelicConfig.dic[76].maxCount);  // 套装专属遗物\n    }\n\n    // 特殊激活遗物\n    if (activateGirlActivatedIDs2.Contains(1))\n    {\n        poolOfRelic.Add(72, RelicConfig.dic[72].maxCount);  // 激活角色1的遗物\n    }\n\n    // 排除首次进战斗的特殊遗物\n    if (enterBattleTime <= 1 && poolOfRelic.ContainsKey(69))\n    {\n        poolOfRelic.Remove(69);\n    }\n}\n```\n\n**关键机制**:\n\n1. **激活系统**\n   - 营地中可解锁角色,解锁后激活对应技能/遗物\n   - 技能ID规则: 基础ID = (技能ID / 10) * 10 + 1\n   - 例如: 10015的基础ID是10011\n\n2. **新手保护**\n   - 第一次进战斗排除复杂魔杖(有后置槽位的)\n   - 第一次进战斗排除某些高级遗物\n\n3. **多魔杖机制限制**\n   - 如果没有魔杖槽位升级,排除需要多魔杖协同的物品\n   - 例如: \"持有不同魔杖生成速率不同\"的魔杖\n\n4. **套装专属内容**\n   - 某些套装有专属技能和遗物\n   - 这些内容只在选择对应套装时加入池中\n\n---\n\n### 资源池抽取方法\n\n#### GetSpellFromPool - 从池中获取技能\n\n**位置**: [BattleData.cs:392-449](BattleData.cs:392-449)\n\n```csharp\npublic int GetSpellFromPool(int level, ItemDropType dropType, int exceptID = 0)\n{\n    List<int> candidates = new List<int>();\n\n    // 筛选符合条件的技能\n    for (int i = 0; i < poolOfSpellID.Count; i++)\n    {\n        SpellConfig spell = SpellConfig.dic[poolOfSpellID[i]];\n        if (spell.level == level &&\n            spell.dropType == dropType &&\n            spell.id != exceptID)\n        {\n            candidates.Add(spell.id);\n        }\n    }\n\n    // 如果池中没有对应稀有度的技能,尝试降级/升级获取\n    if (candidates.Count == 0)\n    {\n        switch (dropType)\n        {\n            case ItemDropType.Common:\n                if (isSpellPoolHaveRare)\n                    return GetSpellFromPool(level, ItemDropType.Rare);\n                if (isSpellPoolHaveEpic)\n                    return GetSpellFromPool(1, ItemDropType.Epic);\n                return 10011;  // 默认技能ID\n\n            case ItemDropType.Rare:\n                if (isSpellPoolHaveCommon)\n                    return GetSpellFromPool(level, ItemDropType.Common);\n                if (isSpellPoolHaveEpic)\n                    return GetSpellFromPool(1, ItemDropType.Epic);\n                return 10011;\n\n            case ItemDropType.Epic:\n                if (isSpellPoolHaveRare)\n                    return GetSpellFromPool(level, ItemDropType.Rare);\n                if (isSpellPoolHaveCommon)\n                    return GetSpellFromPool(1, ItemDropType.Common);\n                return 10011;\n\n            case ItemDropType.Special:\n                if (isSpellPoolHaveCommon)\n                    return GetSpellFromPool(1, ItemDropType.Common);\n                return 10011;\n        }\n    }\n\n    // 随机返回一个\n    return candidates[Random.Range(0, candidates.Count)];\n}\n```\n\n**注意**: 这个方法**不会**从池中移除技能!技能池不会被消耗。\n\n#### GetWandFromPool - 从池中获取魔杖\n\n**位置**: [BattleData.cs:505-523](BattleData.cs:505-523)\n\n```csharp\npublic int GetWandFromPool(int dropStage, params int[] exceptID)\n{\n    List<int> candidates = new List<int>();\n\n    // 筛选指定章节掉落的魔杖\n    for (int i = 0; i < poolOfWandID.Count; i++)\n    {\n        WandConfig wand = WandConfig.dic[poolOfWandID[i]];\n        if (wand.dropStage == dropStage &&\n            !exceptID.Contains(wand.id))\n        {\n            candidates.Add(poolOfWandID[i]);\n        }\n    }\n\n    if (candidates.Count == 0)\n    {\n        Debug.LogError(\"not enough Wand, drop stage:\" + dropStage);\n        return 1;  // 返回默认魔杖ID\n    }\n\n    int selected = candidates[Random.Range(0, candidates.Count)];\n    poolOfWandID.Remove(selected);  // 从池中移除!\n    return selected;\n}\n```\n\n**魔杖池会被消耗!** 获得魔杖后会从池中移除。\n\n#### GetRelicFromPool - 从池中获取遗物\n\n**位置**: [BattleData.cs:599-628](BattleData.cs:599-628)\n\n```csharp\npublic int GetRelicFromPool(ItemDropType dropType, int[] exceptIDs = null)\n{\n    List<int> candidates = new List<int>();\n\n    // 筛选符合稀有度的遗物\n    foreach (KeyValuePair<int, int> item in poolOfRelic)\n    {\n        RelicConfig relic = RelicConfig.dic[item.Key];\n        if (relic.dropType == dropType &&\n            (exceptIDs == null || !exceptIDs.Contains(item.Key)))\n        {\n            candidates.Add(item.Key);\n        }\n    }\n\n    if (candidates.Count == 0)\n    {\n        Debug.LogError(\"not enough Relic,DropType:\" + dropType);\n        return 999;  // 错误ID\n    }\n\n    int selected = candidates[Random.Range(0, candidates.Count)];\n\n    // 减少可获得次数\n    if (poolOfRelic[selected] > 1)\n    {\n        poolOfRelic[selected]--;\n    }\n    else if (poolOfRelic[selected] == 1)\n    {\n        poolOfRelic.Remove(selected);  // 完全移除\n    }\n\n    return selected;\n}\n```\n\n**遗物有数量限制!** 每个遗物可以获得多次,但有上限。\n\n#### GetCurseFromPool - 从池中获取诅咒\n\n**位置**: [BattleData.cs:682-711](BattleData.cs:682-711)\n\n```csharp\npublic int GetCurseFromPool(ItemDropType dropType)\n{\n    List<int> candidates = new List<int>();\n\n    foreach (KeyValuePair<int, int> item in poolOfCurse)\n    {\n        if (CurseConfig.dic[item.Key].dropType == dropType)\n        {\n            candidates.Add(item.Key);\n        }\n    }\n\n    if (candidates.Count == 0)\n    {\n        Debug.LogError(\"Not enough curse, drop type:\" + dropType);\n        return 999;\n    }\n\n    int selected = candidates[Random.Range(0, candidates.Count)];\n\n    // 减少可获得次数\n    if (poolOfCurse[selected] > 1)\n    {\n        poolOfCurse[selected]--;\n    }\n    else if (poolOfCurse[selected] == 1)\n    {\n        poolOfCurse.Remove(selected);\n    }\n\n    return selected;\n}\n```\n\n---\n\n### 随机魔杖技能系统 (RandomSpellWandCheck)\n\n**位置**: [BattleData.cs:530-597](BattleData.cs:530-597)\n\n某些魔杖具有特殊能力: 装备时自动填充随机技能。\n\n```csharp\npublic void RandomSpellWandCheck()\n{\n    for (int i = 0; i < WandConfig.list.Count; i++)\n    {\n        WandConfig wand = WandConfig.list[i];\n\n        // 能力: 随机普通技能\n        if (wand.specialAbility == WandAbility.RandomCommonSpells)\n        {\n            SlotData[] normalSlots = wand.normalSlots;\n            bool[] normalSlotIsLock = wand.normalSlotIsLock;\n\n            Array.Fill(normalSlots, null);\n            Array.Fill(normalSlotIsLock, false);\n\n            // 填充槽位\n            for (int j = 0; j < normalSlots.Length; j++)\n            {\n                // 跳过超出限制的槽位\n                if (j >= wand.int1)\n                    continue;\n\n                // 跳过封印槽位和锁定槽位\n                if ((normalSlots[j] != null && normalSlots[j].isSealSlot) ||\n                    normalSlotIsLock[j])\n                    continue;\n\n                // 死循环保护\n                int loopCount = 0;\n                while (true)\n                {\n                    if (loopCount++ > 200)\n                    {\n                        Debug.LogError(\"死循环?!!!!\");\n                        break;\n                    }\n\n                    // 获取随机1级普通技能\n                    SlotData data = new SlotData(GetSpellFromPool(1, ItemDropType.Common));\n\n                    // 检查是否可以放入该槽位\n                    if (normalSlots.Bag_CanSetSpell(normalSlotIsLock, data, j))\n                    {\n                        normalSlots.Bag_SetSlot(normalSlotIsLock, data, j);\n                        break;\n                    }\n                }\n            }\n        }\n\n        // 能力: 随机稀有技能\n        else if (wand.specialAbility == WandAbility.RandomRareSpells)\n        {\n            // 类似逻辑,但使用 ItemDropType.Rare\n            // ...\n        }\n    }\n}\n```\n\n**关键点**:\n1. 每次进入战斗都会重新随机\n2. 使用 `Bag_CanSetSpell` 检查兼容性(避免冲突技能)\n3. 有死循环保护机制\n\n---\n\n### 特殊房间系统 (RandomSpecialRoom)\n\n**位置**: [BattleData.cs:297-323](BattleData.cs:297-323)\n\n```csharp\npublic void RandomSpecialRoom()\n{\n    specialRoomLevels.Clear();\n\n    if (currentStage <= 1)\n        return;  // 第一章没有特殊房间\n\n    // 第一个特殊房间: 保证出现\n    int firstSpecialLevel = Random.Range(1, BattleMgr.Inst.stageLevelsCount[currentStage - 1]);\n    specialRoomLevels.Add(firstSpecialLevel);\n\n    // 第二个特殊房间: 33.33%概率\n    if (Random.value <= 0.3333f)\n    {\n        int loopCount = 0;\n        int secondSpecialLevel;\n        do\n        {\n            loopCount++;\n            if (loopCount > 100)\n            {\n                Debug.LogError(\"!\");\n                return;\n            }\n            secondSpecialLevel = Random.Range(1, BattleMgr.Inst.stageLevelsCount[currentStage - 1]);\n        }\n        while (specialRoomLevels.Contains(secondSpecialLevel));  // 确保不重复\n\n        specialRoomLevels.Add(secondSpecialLevel);\n    }\n}\n```\n\n**特殊房间用途**:\n- 在主战斗房间旁边添加侧边房间\n- 侧边房间通常是谜题房或NPC房\n- 增加游戏多样性\n\n---\n\n## 玩家管理器 (PlayerMgr)\n\n**文件位置**: [PlayerMgr.cs](PlayerMgr.cs:1)\n\n### 类职责\n`PlayerMgr` 负责管理玩家相关的所有逻辑:\n1. 玩家Entity和GameObject的生命周期\n2. 魔杖管理和切换\n3. 召唤物管理\n4. 玩家属性计算\n5. 物品拾取和使用\n\n### 核心属性\n\n```csharp\npublic class PlayerMgr : MonoBehaviour\n{\n    public static PlayerMgr Inst { get; private set; }\n\n    // ========== 玩家对象 ==========\n    public GameObject PlayerGO { get; private set; }\n    public Entity PlayerEtt { get; private set; }\n    public UnitProperty PlayerPpt { get; private set; }\n    public PlayerController PlayerCtrller { get; private set; }\n\n    // ========== 魔杖系统 ==========\n    public List<Wand> Wands = new List<Wand>();\n    public int SelectedWandIndex { get; private set; } = -1;\n    public Wand SelectedWand => Wands[SelectedWandIndex];\n    public WandConfig SelectedWandCfg => BaData.wandCfgs[SelectedWandIndex];\n\n    // ========== 物品管理 ==========\n    public PlayerItemController ItemCtrller;\n\n    // ========== 召唤物 ==========\n    public List<UnitProperty> summonsPpts;           // 攻击型召唤物\n    public List<UnitProperty> summonsNotAttackPpts;  // 非攻击型召唤物\n    public Dictionary<Wand, UnitProperty> autoWandList;  // 自动魔杖列表\n\n    // ========== 对象池 ==========\n    public MiniObjPool MiniPool { get; set; }\n    public List<Spell1020CoinOnGround> manaCoinList { get; set; }\n\n    // ========== 快捷访问 ==========\n    public BattleData BaData => DataMgr.selectedWorldData.battleData8;\n    public Vector3 PlayerPoint => PlayerT.position;\n    public Vector3 ShootPoint => SelectedWand?.ShootPosition ?? PlayerPoint;\n    public int CoinCount => BaData.coinCount;\n    public int KeyCount => BaData.keyCount;\n}\n```\n\n---\n\n### 玩家创建流程 (CreatePlayer)\n\n**位置**: [PlayerMgr.cs:276-339](PlayerMgr.cs:276-339)\n\n```csharp\npublic void CreatePlayer()\n{\n    // 1. 清理旧数据\n    if (ItemCtrller != null)\n        Destroy(ItemCtrller);\n\n    ItemCtrller = transform.AddComponent<PlayerItemController>();\n\n    // 清理悬浮药水特效\n    if (ItemCtrller.potion_HoverEFGO != null)\n        Destroy(ItemCtrller.potion_HoverEFGO);\n\n    // 清空召唤物列表\n    summonsPpts.Clear();\n    summonsNotAttackPpts.Clear();\n\n    // 取消自动魔杖\n    foreach (var autoWand in autoWandList)\n        CancelAutoControlWand(autoWand.Key);\n    autoWandList.Clear();\n\n    // 销毁旧玩家\n    if (PlayerGO != null)\n        Destroy(PlayerGO);\n\n    SelectedWandIndex = -1;\n\n    // 重建对象池\n    if (MiniPool != null)\n        Destroy(MiniPool.gameObject);\n    MiniPool = Instantiate(ABResources.LoadAsset<GameObject>(\"Prefabs/Mixed/MiniObjPool\"))\n        .GetComponent<MiniObjPool>();\n\n    IsHide = false;\n\n    // 2. 初始化战斗数据\n    BaData = new BattleData();\n    BaData.Initialize();\n\n    // 3. 创建 Entity (DOTS)\n    if (PlayerEtt != Entity.Null)\n        ettMgr.DestroyEntity(PlayerEtt);\n\n    using EntityQuery entityQuery = ettMgr.CreateEntityQuery(typeof(AllUnitEtt));\n    AllUnitEtt singleton = entityQuery.GetSingleton<AllUnitEtt>();\n    PlayerEtt = ettMgr.Instantiate(singleton.map[800001]);  // 玩家单位ID\n\n    // 设置物理碰撞器 (独立副本)\n    PhysicsCollider collider = ettMgr.GetComponentData<PhysicsCollider>(PlayerEtt);\n    Entity entity = PlayerEtt;\n    collider.MakeUnique(in entity, ettMgr);\n    ettMgr.SetComponentData(PlayerEtt, collider);\n\n    // 设置初始位置\n    LocalTransform transform = ettMgr.GetComponentData<LocalTransform>(PlayerEtt);\n    transform.Position = PlayerPoint;\n    ettMgr.SetComponentData(PlayerEtt, transform);\n\n    ettMgr.SetName(PlayerEtt, \"Player\");\n\n    // 设置单位配置\n    UnitProperty_Dots ppt = ettMgr.GetComponentData<UnitProperty_Dots>(PlayerEtt);\n    ppt.unitCfg = BaData.playerCfg;\n    ettMgr.SetComponentData(PlayerEtt, ppt);\n\n    // 4. 创建 GameObject (渲染和控制)\n    PlayerGO = Instantiate(ABResources.LoadAsset<GameObject>(\"Prefabs/Units/\" + 800001));\n    PlayerGO.SetActive(true);\n\n    PlayerCtrller = PlayerGO.GetComponent<PlayerController>();\n    PlayerCtrller.myPpt.myEntity = PlayerEtt;\n    PlayerPpt = PlayerCtrller.myPpt;\n\n    // 注册到同步系统\n    UnitDotsSyncSystem.existingUnit.Add(PlayerPpt);\n\n    // 关联 Entity 和 MonoBehaviour\n    PlayerController_Dots ctrllerData = ettMgr.GetComponentData<PlayerController_Dots>(PlayerEtt);\n    ctrllerData.playerCtrllerMono = PlayerCtrller;\n    ettMgr.SetComponentData(PlayerEtt, ctrllerData);\n\n    // 5. 更新皮肤\n    UpdateSkin();\n}\n```\n\n**ECS 与 MonoBehaviour 双重架构**:\n\n```\n┌─────────────────────────────────────────────────┐\n│                   DOTS Entity                    │\n│  ┌───────────────────────────────────────────┐ │\n│  │ UnitProperty_Dots (组件)                  │ │\n│  │  - unitCfg: UnitConfig                    │ │\n│  │  - currentHP, maxHP, shield, etc.         │ │\n│  │                                             │ │\n│  │ PlayerController_Dots (组件)              │ │\n│  │  - playerCtrllerMono: MonoBehaviour引用   │ │\n│  │                                             │ │\n│  │ LocalTransform (组件)                      │ │\n│  │  - Position, Rotation, Scale              │ │\n│  │                                             │ │\n│  │ PhysicsCollider (组件)                     │ │\n│  │  - 碰撞器数据                              │ │\n│  └───────────────────────────────────────────┘ │\n└──────────────────┬──────────────────────────────┘\n                   │ 双向引用\n                   ↓\n┌─────────────────────────────────────────────────┐\n│              MonoBehaviour GameObject            │\n│  ┌───────────────────────────────────────────┐ │\n│  │ PlayerController (脚本)                   │ │\n│  │  - 输入处理                                │ │\n│  │  - 动画控制                                │ │\n│  │  - 移动逻辑                                │ │\n│  │                                             │ │\n│  │ UnitProperty (脚本)                        │ │\n│  │  - myEntity: Entity引用                    │ │\n│  │  - 渲染相关数据                            │ │\n│  │  - 特效管理                                │ │\n│  │                                             │ │\n│  │ Spine SkeletonAnimation                    │ │\n│  │  - 角色动画                                │ │\n│  └───────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────┘\n```\n\n**为什么需要双重架构?**\n1. **DOTS (Entity)**: 高性能数据计算\n   - 伤害计算、物理模拟、碰撞检测\n   - 使用 Job System 并行处理\n\n2. **MonoBehaviour**: 渲染和交互\n   - 动画播放、特效显示\n   - 输入处理、UI交互\n   - 声音播放\n\n---\n\n### 属性计算系统\n\n玩家的很多属性是动态计算的,受到遗物、诅咒、天赋等多种因素影响。\n\n#### ExtraDamageRatio - 额外伤害比例\n\n**位置**: [PlayerMgr.cs:157-196](PlayerMgr.cs:157-196)\n\n```csharp\npublic float ExtraDamageRatio\n{\n    get\n    {\n        float ratio = BaData.extraDamageRatio;  // 基础额外伤害\n\n        // 遗物: 诅咒战士 (+5% per 诅咒)\n        if (ItemCtrller.relicCfg_CurseWarrior != null)\n        {\n            ratio += (float)relicCfg_CurseWarrior.int1.result / 100f *\n                     (float)BaData.curseIDs.Count;\n        }\n\n        // 遗物: 金钱即力量 (+X% per Y金币)\n        if (ItemCtrller.relicCfg_MoneyIsPower != null)\n        {\n            int coinThreshold = relicCfg_MoneyIsPower.int1.result;\n            int percentPerThreshold = relicCfg_MoneyIsPower.int2.result;\n            ratio += (float)CoinCount / (float)coinThreshold *\n                     (float)percentPerThreshold / 100f;\n        }\n\n        // 遗物: 增伤\n        if (ItemCtrller.relicCfg_AddDamage != null)\n        {\n            ratio += (float)relicCfg_AddDamage.int1.result / 100f;\n        }\n\n        // 遗物: 强者\n        if (ItemCtrller.relicCfg_PowerfulMan != null)\n        {\n            ratio += (float)relicCfg_PowerfulMan.int1.result / 100f;\n        }\n\n        // 遗物: 疯眼 (动态增长)\n        if (ItemCtrller.relicCfg_MadEye != null)\n        {\n            ratio += relicCfg_MadEye.floatTimer;\n        }\n\n        // 遗物: 狂战士 (低血增伤)\n        if (ItemCtrller.relic_MadWarrior != null)\n        {\n            ratio += relic_MadWarrior.ExtraDamageRatio;\n        }\n\n        // 诅咒: 降低伤害和速度\n        if (ItemCtrller.curseCfg_ReduceSpeedDamage != null)\n        {\n            ratio -= (float)curseCfg_ReduceSpeedDamage.int1.result / 100f;\n        }\n\n        // 诅咒: 满血增伤 (动态)\n        if (ItemCtrller.curseCfg_FullHPAddDamage != null)\n        {\n            ratio += curseCfg_FullHPAddDamage.floatTimer;\n        }\n\n        return ratio;\n    }\n}\n```\n\n**伤害计算公式**:\n```\n最终伤害 = 基础伤害 * (1 + ExtraDamageRatio)\n```\n\n#### MoveSpeedRatio - 移动速度比例\n\n**位置**: [UnitProperty.cs:223-282](UnitProperty.cs:223-282)\n\n```csharp\npublic float MoveSpeedRatio\n{\n    get\n    {\n        float ratio = 1f;\n\n        // 诅咒: 敌人加速\n        if (PlayerMgr.Inst.ItemCtrller.curseCfg_EnemyAddMove != null &&\n            unitCfg.IsSameCamp(UnitType.Monster))\n        {\n            ratio *= (float)(curseCfg_EnemyAddMove.int1.result + 100) / 100f;\n        }\n\n        // 玩家特殊逻辑\n        if (unitCfg.unitType == UnitType.Player)\n        {\n            // 战斗数据额外移速\n            if (PlayerMgr.Inst.BaData != null)\n            {\n                ratio += PlayerMgr.Inst.BaData.extraMoveSpeedRatio;\n            }\n\n            // 诅咒: 反向移动\n            if (PlayerMgr.Inst.ItemCtrller.curse_IsReverseMove)\n            {\n                ratio = -ratio;\n            }\n\n            // 诅咒: 减移速\n            if (PlayerMgr.Inst.ItemCtrller.curseCfg_ReduceMoveSpeed != null)\n            {\n                ratio -= (float)curseCfg_ReduceMoveSpeed.int1.result / 100f;\n            }\n\n            // 遗物: 免疫地面\n            if (PlayerMgr.Inst.ItemCtrller.relicCfg_ImmuneSurface != null)\n            {\n                ratio += (float)relicCfg_ImmuneSurface.int1.result / 100f;\n            }\n\n            // 遗物: 增加移速\n            if (PlayerMgr.Inst.ItemCtrller.relic_AddMoveSpeed != null)\n            {\n                ratio += (float)relic_AddMoveSpeed.RelicCfg.int1.result / 100f;\n            }\n\n            // 遗物: 隐形之翼\n            if (PlayerMgr.Inst.ItemCtrller.relic_InvisibleWing != null)\n            {\n                ratio += relic_InvisibleWing.ExtraMoveSpeed;\n            }\n\n            // 遗物: 受伤加速\n            if (PlayerMgr.Inst.ItemCtrller.relic_InjuredAddMoveSpeed != null)\n            {\n                ratio *= relic_InjuredAddMoveSpeed.MoveSpeedRatio;\n            }\n\n            // 遗物: 变异者\n            if (PlayerMgr.Inst.ItemCtrller.relic_Variator != null)\n            {\n                ratio *= relic_Variator.MoveRate;\n            }\n\n            // 诅咒: 镣铐\n            if (PlayerMgr.Inst.ItemCtrller.curse_Shackle != null)\n            {\n                ratio *= curse_Shackle.MoveRatio;\n            }\n\n            // 魔杖能力加成\n            ratio *= PlayerMgr.Inst.PlayerMoveSpeedRatioFromWandAbility();\n        }\n\n        // 状态: 反向移动\n        if (affect_IsReverseMove)\n        {\n            ratio = -ratio;\n        }\n\n        // 状态: 粘液减速\n        if (affect_IsMucusDecelerate)\n        {\n            ratio *= affect_MucusMoveSpeedRatio;\n        }\n\n        return ratio;\n    }\n}\n```\n\n**移动速度公式**:\n```\n最终移速 = 基础移速 * MoveSpeedRatio\n```\n\n---\n\n## 战斗流程\n\n### 完整流程图\n\n```\n[游戏启动] → [选择套装/天赋] → [进入战斗场景]\n                                      ↓\n                        ┌─────────────────────────┐\n                        │   BattleMgr.Awake()     │\n                        │   - 初始化单例          │\n                        │   - 获取EntityManager   │\n                        └─────────────┬───────────┘\n                                      ↓\n                        ┌─────────────────────────┐\n                        │   BattleMgr.Update()    │\n                        │   - 等待DOTS初始化      │\n                        └─────────────┬───────────┘\n                                      ↓\n                        ┌─────────────────────────┐\n                        │  BattleMgr.StartHandle()│\n                        │  - 区分测试/正常模式    │\n                        └─────────────┬───────────┘\n                                      ↓\n                        ┌─────────────────────────┐\n                        │  Start_Normal()         │\n                        │  1. 创建玩家            │\n                        │  2. 初始化BattleData    │\n                        │  3. 生成房间配置        │\n                        │  4. 创建关卡            │\n                        └─────────────┬───────────┘\n                                      ↓\n                        ┌─────────────────────────┐\n                        │  CreateLevelFinish()    │\n                        │  - 淡入效果             │\n                        │  - 显示UI               │\n                        │  - 显示章节名           │\n                        └─────────────┬───────────┘\n                                      ↓\n                    ╔═════════════════════════════════╗\n                    ║        战斗循环开始             ║\n                    ╚═════════════════════════════════╝\n                                      ↓\n                  ┌───────────────────────────────────┐\n                  │   玩家战斗                        │\n                  │   - 移动、闪避                    │\n                  │   - 释放技能                      │\n                  │   - 受到伤害                      │\n                  │   - 拾取物品                      │\n                  └───────────────┬───────────────────┘\n                                  ↓\n                  ┌───────────────────────────────────┐\n                  │   清空房间敌人                    │\n                  │   - 所有敌人死亡                  │\n                  │   - 生成奖励                      │\n                  │   - 显示出口门                    │\n                  └───────────────┬───────────────────┘\n                                  ↓\n                  ┌───────────────────────────────────┐\n                  │   PlayerEnterDoor()               │\n                  │   1. 保存游戏                     │\n                  │   2. 记录战斗日志                 │\n                  │   3. 处理进门效果                 │\n                  │   4. 清理对象池                   │\n                  │   5. 更新进度                     │\n                  │   6. 生成新房间                   │\n                  └───────────────┬───────────────────┘\n                                  ↓\n                            [章节过渡?]\n                      Yes ↙         ↘ No\n        ┌──────────────────┐    ┌──────────────────┐\n        │ ShowChapterThrough│    │ 进入下一房间     │\n        │ - 增加Stage       │    │ - 增加Level      │\n        │ - 重置Level=0     │    │ - 生成新房间     │\n        │ - 显示过渡动画    │    └────────┬─────────┘\n        └────────┬──────────┘              │\n                 │                         │\n                 └─────────┬───────────────┘\n                           ↓\n                      [继续战斗]\n                           ↓\n                    ╔═════════════════════════════════╗\n                    ║     回到战斗循环                ║\n                    ╚═════════════════════════════════╝\n\n                           ↓ (直到 Boss 被击败)\n\n                    ┌──────────────────┐\n                    │  Boss战斗结束    │\n                    │  - 显示奖励      │\n                    │  - 解锁下一章    │\n                    └──────────────────┘\n```\n\n---\n\n### 详细阶段说明\n\n#### 阶段 1: 初始化 (Initialization)\n\n**时间线**: 场景加载 → DOTS就绪 → StartHandle()\n\n```\nTime: 0.0s → 0.5s\n│\n├─ BattleMgr.Awake()\n│  └─ 创建EntityManager实例\n│\n├─ 各种System初始化 (DOTS异步)\n│  ├─ UnitPropertySystem\n│  ├─ TakeDamageSystem\n│  ├─ SpellSystem\n│  └─ ...\n│\n└─ BattleMgr.Update() 检测到DOTS就绪\n   └─ 调用 StartHandle()\n```\n\n#### 阶段 2: 玩家创建 (Player Creation)\n\n**时间线**: StartHandle() → CreateLevelFinish()\n\n```\nPlayerMgr.CreatePlayer()\n│\n├─ 1. 清理旧数据\n│  ├─ 销毁旧 PlayerGO\n│  ├─ 销毁旧 Entity\n│  └─ 清空召唤物列表\n│\n├─ 2. 创建 BattleData\n│  ├─ 初始化物品池\n│  ├─ 应用天赋加成\n│  └─ 设置初始装备\n│\n├─ 3. 创建 DOTS Entity\n│  ├─ Instantiate Entity Template\n│  ├─ 设置 UnitProperty_Dots\n│  ├─ 设置 LocalTransform\n│  └─ 设置 PhysicsCollider\n│\n└─ 4. 创建 MonoBehaviour GameObject\n   ├─ Instantiate Prefab\n   ├─ 关联 Entity ↔ GameObject\n   └─ 初始化 PlayerController\n```\n\n#### 阶段 3: 关卡生成 (Level Generation)\n\n**时间线**: StartHandle() → LevelMgr.CreateLevel()\n\n```\nGetRoomCfgs(rewardType)\n│\n├─ 1. 判断房间类型\n│  ├─ Boss房间? → 生成前置房+Boss房\n│  ├─ 商店? → 生成商店房\n│  ├─ 战斗? → 生成怪物房\n│  └─ ...\n│\n├─ 2. 从池中获取房间配置\n│  ├─ BaData.GetRoomFromPool()\n│  └─ 检查特殊条件 (RRO, 侧边房间)\n│\n├─ 3. 生成侧边房间 (如果需要)\n│  ├─ 检查 specialRoomLevels\n│  ├─ 判断侧边房间方向\n│  └─ 添加到房间字典\n│\n└─ 4. 返回房间配置字典\n   Key: Vector2Int (房间相对位置)\n   Value: RoomConfig (房间配置)\n```\n\n#### 阶段 4: 战斗循环 (Combat Loop)\n\n**每帧执行** (Update/FixedUpdate)\n\n```\n[Input] → [PlayerController] → [Wand] → [Spell] → [Damage] → [UI Update]\n   ↓             ↓                ↓         ↓          ↓           ↓\n 键盘输入    移动/闪避         释放技能   碰撞检测   伤害计算   更新HP条\n                                                    击退处理\n                                                    特效播放\n```\n\n**DOTS Systems 执行顺序**:\n\n```\n[Update阶段]\n│\n├─ UnitBaseSystem\n│  └─ 更新单位基础状态\n│\n├─ UnitPropertySystem\n│  └─ 更新单位属性 (HP, 移速, 状态)\n│\n├─ SpellSystem\n│  ├─ 更新技能位置\n│  ├─ 检测碰撞\n│  └─ 生成伤害信息\n│\n├─ TakeDamageInfoPreProcessSystem\n│  └─ 预处理伤害 (计算暴击, 应用减伤)\n│\n├─ UnitBeforeTakeDamageSystem\n│  └─ 受伤前事件 (闪避, 反弹, 遗物触发)\n│\n├─ UnitAfterTakeDamageSystem\n│  ├─ 扣除HP\n│  ├─ 应用击退\n│  └─ 触发受伤特效\n│\n├─ UnitTakeDamageDeadSystem\n│  └─ 检查死亡\n│\n├─ UnitTakeDamageClearSystem\n│  └─ 清除本帧伤害信息\n│\n└─ DamageRecordSystem\n   └─ 记录伤害到日志\n```\n\n#### 阶段 5: 清空房间 (Room Clear)\n\n**触发条件**: 所有敌人死亡\n\n```\nLevelMgr.CheckRoomClear()\n│\n├─ 1. 统计存活敌人\n│  ├─ 查询所有 Monster/Elite/Boss Entity\n│  └─ 过滤掉已死亡的\n│\n├─ 2. 如果敌人数 == 0\n│  ├─ 生成奖励\n│  │  ├─ 金币\n│  │  ├─ 钥匙\n│  │  └─ 随机掉落物\n│  │\n│  ├─ 生成出口门\n│  │  ├─ 根据 NextRewardTypes 生成多个门\n│  │  └─ 显示门的奖励类型图标\n│  │\n│  └─ 播放胜利音效/特效\n│\n└─ 3. 记录战斗日志\n   ├─ 击杀数量\n   ├─ 受到伤害\n   ├─ 使用技能\n   └─ 获得物品\n```\n\n#### 阶段 6: 进入下一房间 (Enter Next Room)","numLines":2000,"startLine":1,"totalLines":2647}}}
{"parentUuid":"ff0bde57-cba7-466a-b1dc-e3e2ffeb5425","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Sjyfz4XG6c9dEm1D2nDsNH","type":"tool_result","content":"     1→# 单位系统详细文档\n     2→\n     3→## 目录\n     4→- [1. 系统总览](#1-系统总览)\n     5→- [2. 单位类型系统](#2-单位类型系统)\n     6→- [3. 单位配置 UnitConfig](#3-单位配置-unitconfig)\n     7→- [4. 单位基类 UnitBase](#4-单位基类-unitbase)\n     8→- [5. 单位属性 UnitProperty](#5-单位属性-unitproperty)\n     9→- [6. DOTS架构组件](#6-dots架构组件)\n    10→- [7. 状态效果系统](#7-状态效果系统)\n    11→- [8. AI状态机系统](#8-ai状态机系统)\n    12→- [9. 移动与寻路系统](#9-移动与寻路系统)\n    13→- [10. 召唤物系统](#10-召唤物系统)\n    14→- [11. 单位生命周期](#11-单位生命周期)\n    15→- [12. 实战案例：Monster1分析](#12-实战案例monster1分析)\n    16→\n    17→---\n    18→\n    19→## 1. 系统总览\n    20→\n    21→### 1.1 架构概述\n    22→\n    23→单位系统采用**双架构设计**：\n    24→- **MonoBehaviour层**：负责渲染、动画、逻辑控制\n    25→- **DOTS ECS层**：负责高性能计算（移动、物理、状态效果）\n    26→\n    27→```\n    28→┌─────────────────────────────────────────────────────────┐\n    29→│                    单位系统架构                           │\n    30→├─────────────────────────────────────────────────────────┤\n    31→│                                                         │\n    32→│  MonoBehaviour层（渲染+逻辑）                             │\n    33→│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │\n    34→│  │  UnitBase    │  │ UnitProperty │  │ Monster1/2/3 │  │\n    35→│  │  (基类)      │  │  (属性)      │  │  (具体实现)  │  │\n    36→│  │              │  │              │  │              │  │\n    37→│  │ - AI逻辑     │  │ - HP/Shield  │  │ - 状态机     │  │\n    38→│  │ - 动画控制   │  │ - 状态效果   │  │ - 攻击逻辑   │  │\n    39→│  │ - 目标搜索   │  │ - 伤害计算   │  │ - 特殊行为   │  │\n    40→│  └──────────────┘  └──────────────┘  └──────────────┘  │\n    41→│         │                  │                  │         │\n    42→│         └──────────────────┼──────────────────┘         │\n    43→│                            │                            │\n    44→│  ════════════════════════════════════════════════════   │\n    45→│                            │                            │\n    46→│  DOTS ECS层（高性能计算）                                 │\n    47→│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │\n    48→│  │UnitBase_Dots │  │UnitProperty  │  │  ISystem     │  │\n    49→│  │ (移动组件)   │  │    _Dots     │  │  (系统)      │  │\n    50→│  │              │  │ (属性组件)   │  │              │  │\n    51→│  │ - 移动向量   │  │ - 状态计时器 │  │ - 移动系统   │  │\n    52→│  │ - 翻转控制   │  │ - 免疫计数   │  │ - 状态系统   │  │\n    53→│  │ - 跳跃物理   │  │ - 击退向量   │  │ - 效果系统   │  │\n    54→│  └──────────────┘  └──────────────┘  └──────────────┘  │\n    55→│                                                         │\n    56→└─────────────────────────────────────────────────────────┘\n    57→```\n    58→\n    59→### 1.2 核心类关系\n    60→\n    61→```\n    62→UnitConfig (配置数据)\n    63→    ↓ 加载\n    64→UnitBase (MonoBehaviour基类)\n    65→    ├── UnitProperty (属性组件)\n    66→    ├── UnitBase_Dots (DOTS移动组件)\n    67→    ├── UnitProperty_Dots (DOTS属性组件)\n    68→    │\n    69→    ├── Player1 (玩家)\n    70→    ├── Teammate1/2/3... (友方召唤物)\n    71→    └── Monster1/2/3... (175+种敌人)\n    72→        └── Boss1/2/3... (Boss单位)\n    73→```\n    74→\n    75→---\n    76→\n    77→## 2. 单位类型系统\n    78→\n    79→### 2.1 UnitType枚举\n    80→\n    81→```csharp\n    82→public enum UnitType\n    83→{\n    84→    Player,              // 玩家\n    85→    Teammate,            // 队友（会攻击）\n    86→    TeammateNotAttack,   // 队友（不攻击）\n    87→    Monster,             // 普通怪物\n    88→    Elite,               // 精英怪物\n    89→    Boss,                // Boss\n    90→    WillAttack,          // 会攻击的单位\n    91→    NotAttack,           // 不攻击的单位\n    92→    Brittleness          // 易碎物（可破坏物体）\n    93→}\n    94→```\n    95→\n    96→### 2.2 阵营判定\n    97→\n    98→**同阵营逻辑**：\n    99→```csharp\n   100→public bool IsSameCamp(UnitType unitType)\n   101→{\n   102→    switch (this.unitType)\n   103→    {\n   104→        case UnitType.Player:\n   105→        case UnitType.Teammate:\n   106→        case UnitType.TeammateNotAttack:\n   107→            // 玩家阵营\n   108→            return unitType == UnitType.Player ||\n   109→                   unitType == UnitType.Teammate ||\n   110→                   unitType == UnitType.TeammateNotAttack;\n   111→\n   112→        case UnitType.Monster:\n   113→        case UnitType.Elite:\n   114→        case UnitType.Boss:\n   115→        case UnitType.WillAttack:\n   116→            // 敌对阵营\n   117→            return unitType == UnitType.Monster ||\n   118→                   unitType == UnitType.Elite ||\n   119→                   unitType == UnitType.Boss ||\n   120→                   unitType == UnitType.WillAttack;\n   121→\n   122→        case UnitType.NotAttack:\n   123→        case UnitType.Brittleness:\n   124→            // 中立阵营\n   125→            return unitType == UnitType.NotAttack ||\n   126→                   unitType == UnitType.Brittleness;\n   127→    }\n   128→}\n   129→```\n   130→\n   131→**阵营分类**：\n   132→- **玩家阵营**：Player, Teammate, TeammateNotAttack\n   133→- **敌对阵营**：Monster, Elite, Boss, WillAttack\n   134→- **中立阵营**：NotAttack, Brittleness\n   135→\n   136→---\n   137→\n   138→## 3. 单位配置 UnitConfig\n   139→\n   140→### 3.1 配置结构\n   141→\n   142→```csharp\n   143→public struct UnitConfig\n   144→{\n   145→    // ====== 基础属性 ======\n   146→    public int id;                      // 单位ID\n   147→    public UnitType unitType;           // 单位类型\n   148→    public float maxHP;                 // 最大生命值\n   149→    public float currentHP;             // 当前生命值\n   150→    public float shield;                // 护盾值\n   151→    public float shieldTemp;            // 临时护盾\n   152→    public float moveSpeed;             // 移动速度\n   153→\n   154→    // ====== 战斗属性 ======\n   155→    public float knockbackRatio;        // 击退比例\n   156→    public float beHitRatio;            // 受击比例\n   157→    public float frozenTimeRatio;       // 冰冻时间比例\n   158→\n   159→    // ====== 免疫属性 ======\n   160→    public bool immuneMucus;            // 免疫粘液\n   161→    public bool immuneVenom;            // 免疫毒素\n   162→    public bool immuneSpike;            // 免疫尖刺\n   163→    public bool immuneAbyss;            // 免疫深渊\n   164→\n   165→    // ====== 物理特性 ======\n   166→    public bool isFly;                  // 是否飞行\n   167→    public bool isCheckStuck;           // 是否检查卡住\n   168→    public bool theme6Reposition;       // 第6章重定位\n   169→    public bool isSolidObj;             // 是否固体物体\n   170→    public bool isHybirdUnit;           // 是否混合单位\n   171→\n   172→    // ====== 视觉表现 ======\n   173→    public bool isBehitColor;           // 受击变色\n   174→    public bool immediatelyBorn;        // 立即出生\n   175→    public float bloodSplatSize;        // 血液飞溅大小\n   176→    public CorpseType corpseType;       // 尸体类型\n   177→    public int corpseCount;             // 尸体数量\n   178→\n   179→    // ====== 音效特效 ======\n   180→    public FixedString128Bytes beHitSE;        // 受击音效\n   181→    public FixedString128Bytes deadEF;         // 死亡特效\n   182→    public FixedString128Bytes deadEFH;        // 和谐版死亡特效\n   183→    public FixedString128Bytes deadPermanentEF;// 永久死亡特效\n   184→    public BlobAssetReference<BlobArray<FixedString128Bytes>> deadSEs; // 死亡音效数组\n   185→    public bool isDeadSE3D;             // 是否3D死亡音效\n   186→\n   187→    // ====== 图鉴系统 ======\n   188→    public bool inGallery;              // 是否在图鉴中\n   189→    public bool haveGalleryH;           // 是否有和谐版图鉴\n   190→    public float relicShowHPUIHight;    // 遗物显示HP UI高度\n   191→\n   192→    // ====== 游戏进度 ======\n   193→    public DifficultyType appearDiffi;  // 出现难度\n   194→    public float appearChapter;         // 出现章节\n   195→    public bool triggerDeadEvent;       // 触发死亡事件\n   196→    public bool loadArchiveCreate;      // 加载存档创建\n   197→}\n   198→```\n   199→\n   200→### 3.2 配置加载\n   201→\n   202→```csharp\n   203→public class Initializer : DataMgr.ConfigInitializer<UnitConfig>\n   204→{\n   205→    public override void ApplyResult(List<UnitConfig> result)\n   206→    {\n   207→        list = result;\n   208→        // 使用NativeHashMap存储，支持DOTS系统高效访问\n   209→        map = new NativeHashMap<int, UnitConfig>(list.Count, Allocator.Persistent);\n   210→\n   211→        for (int i = 0; i < list.Count; i++)\n   212→        {\n   213→            // 和谐版特殊处理\n   214→            if (GameMgr.IsHarmony_Static)\n   215→            {\n   216→                UnitConfig value = list[i];\n   217→                value.bloodSplatSize = 0f;        // 移除血液效果\n   218→                value.corpseType = CorpseType.None; // 移除尸体\n   219→                value.deadPermanentEF = \"\";       // 移除永久特效\n   220→\n   221→                // 使用和谐版死亡特效\n   222→                if (value.deadEFH != \"\")\n   223→                {\n   224→                    value.deadEF = value.deadEFH;\n   225→                }\n   226→\n   227→                list[i] = value;\n   228→            }\n   229→\n   230→            map.Add(list[i].id, list[i]);\n   231→        }\n   232→    }\n   233→}\n   234→```\n   235→\n   236→### 3.3 配置访问\n   237→\n   238→```csharp\n   239→// 静态访问\n   240→public static NativeHashMap<int, UnitConfig> map;\n   241→public static List<UnitConfig> list;\n   242→\n   243→// 使用示例\n   244→UnitConfig config = UnitConfig.map[unitID];\n   245→Debug.Log($\"单位名称: {config.GetName()}\");\n   246→Debug.Log($\"单位描述: {config.GetDesc()}\");\n   247→```\n   248→\n   249→---\n   250→\n   251→## 4. 单位基类 UnitBase\n   252→\n   253→### 4.1 核心字段\n   254→\n   255→```csharp\n   256→public class UnitBase : MonoBehaviour\n   257→{\n   258→    // ====== 核心引用 ======\n   259→    public UnitProperty myPpt;           // 我的属性组件\n   260→    public UnitProperty targetPpt;       // 目标属性组件\n   261→    public Entity targetEntity;          // 目标实体(DOTS)\n   262→\n   263→    // ====== 物理组件 ======\n   264→    public Rigidbody Rigid;              // 刚体\n   265→    public CapsuleCollider CC_Self;      // 碰撞体\n   266→\n   267→    // ====== 动画组件 ======\n   268→    public Animator Anima;               // Animator动画\n   269→    public SkeletonAnimation SAnima;     // Spine动画\n   270→\n   271→    // ====== 移动相关 ======\n   272→    public Vector3 CurrentMotion;        // 当前运动向量\n   273→    public NavInfo navInfo;              // 寻路信息\n   274→    public int navAreaMask = -1;         // 寻路区域遮罩\n   275→    public float moveLerp = 8f;          // 移动插值速度\n   276→    public float moveThreshold = 0.1f;   // 移动阈值\n   277→    public bool isMoveFlip = true;       // 是否移动翻转\n   278→\n   279→    // ====== AI相关 ======\n   280→    public float checkTargetIntervalTimer; // 目标检查计时器\n   281→\n   282→    // ====== 召唤物管理 ======\n   283→    public SpellBase SummonerSpellBase;     // 召唤者法术\n   284→    public List<UnitProperty> mateSummonsPpts;         // 会攻击的召唤物\n   285→    public List<UnitProperty> mateSummonsNotAttackPpts;// 不攻击的召唤物\n   286→\n   287→    // ====== 跳跃系统 ======\n   288→    public bool baseIsJumping;           // 是否正在跳跃\n   289→    public float baseJumpUpForce;        // 跳跃上升力\n   290→    public float baseJumpGravity;        // 跳跃重力\n   291→\n   292→    // ====== 冰冻状态缓存 ======\n   293→    private Vector3 frozenBeforeRigid;   // 冰冻前刚体速度\n   294→    private bool frozenBeforeKinematic;  // 冰冻前运动学状态\n   295→    private Vector3 frozenBeforeMotion;  // 冰冻前运动向量\n   296→}\n   297→```\n   298→\n   299→### 4.2 生命周期方法\n   300→\n   301→```csharp\n   302→// 单次初始化（只调用一次）\n   303→public virtual void SingleInitial() { }\n   304→\n   305→// 每次生成时初始化（每次进入房间）\n   306→public virtual void EveryInitial() { }\n   307→\n   308→// 第1帧初始化\n   309→public virtual void Frame1Initial() { }\n   310→\n   311→// 第2帧初始化\n   312→public virtual void Frame2Initial() { }\n   313→\n   314→// 每帧更新\n   315→protected virtual void Update() { }\n   316→\n   317→// DOTS物理后更新\n   318→public virtual void AfterDotsPhysicsUpdate() { }\n   319→```\n   320→\n   321→### 4.3 伤害处理钩子\n   322→\n   323→```csharp\n   324→// ====== MonoBehaviour伤害钩子 ======\n   325→public virtual void BeforeTakeDamage(TakeDamageInfo info) { }\n   326→public virtual void AfterTakeDamage(TakeDamageInfo info) { }\n   327→\n   328→// ====== DOTS伤害钩子 ======\n   329→public virtual void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info) { }\n   330→public virtual void AfterTakeDamage_Dots(ref TakeDamageInfo_Dots info) { }\n   331→\n   332→// ====== 死亡钩子 ======\n   333→public virtual void BeforeAnnouncedDeath_Dots(ref TakeDamageInfo_Dots info) { }\n   334→public virtual void AfterDead(ref TakeDamageInfo_Dots info) { }\n   335→```\n   336→\n   337→### 4.4 目标搜索系统\n   338→\n   339→```csharp\n   340→// 获取最近的可攻击目标\n   341→public void GetNearestTarget(bool checkWall = false)\n   342→{\n   343→    switch (myPpt.unitCfg.unitType)\n   344→    {\n   345→        case UnitType.Player:\n   346→        case UnitType.Teammate:\n   347→        case UnitType.TeammateNotAttack:\n   348→            // 玩家阵营：搜索敌对单位\n   349→            targetEntity = LevelMgr.Inst.CurrentRoomCtrller\n   350→                .GetNearestTargetableEntity(transform.position, checkWall);\n   351→            break;\n   352→\n   353→        case UnitType.Monster:\n   354→        case UnitType.Elite:\n   355→        case UnitType.Boss:\n   356→        case UnitType.WillAttack:\n   357→            // 敌对阵营：搜索玩家/友军\n   358→            targetEntity = LevelMgr.Inst.CurrentRoomCtrller\n   359→                .GetNearestFriendlyEntity(transform.position, checkWall);\n   360→            break;\n   361→    }\n   362→}\n   363→\n   364→// 优先锁定玩家\n   365→protected void GetNearestTargetPlayerFirst()\n   366→{\n   367→    if (PlayerMgr.Inst.PlayerCtrller.IsVisible)\n   368→    {\n   369→        targetEntity = PlayerMgr.Inst.PlayerEtt;\n   370→    }\n   371→    else\n   372→    {\n   373→        GetNearestTarget();\n   374→    }\n   375→}\n   376→\n   377→// 随机目标\n   378→protected void GetRandomTarget()\n   379→{\n   380→    switch (myPpt.unitCfg.unitType)\n   381→    {\n   382→        case UnitType.Player:\n   383→        case UnitType.Teammate:\n   384→        case UnitType.TeammateNotAttack:\n   385→            targetPpt = LevelMgr.Inst.CurrentRoomCtrller.GetRandomTargetablePpt();\n   386→            break;\n   387→\n   388→        case UnitType.Monster:\n   389→        case UnitType.Elite:\n   390→        case UnitType.Boss:\n   391→        case UnitType.WillAttack:\n   392→            targetPpt = PlayerMgr.Inst.GetRandomPpt();\n   393→            break;\n   394→    }\n   395→}\n   396→\n   397→// 距离计算\n   398→protected float ToTargetDistance()\n   399→{\n   400→    if (!HaveTarget)\n   401→    {\n   402→        Debug.LogError(\"没有目标，却想获得到目标的距离？\");\n   403→        return 1000f;\n   404→    }\n   405→    return Tool2D.IgnoreZDistance(transform.position, TargetPoint);\n   406→}\n   407→\n   408→// 方向计算\n   409→protected Vector3 ToTargetDir()\n   410→{\n   411→    return Tool2D.IgnoreZV2ToV1Normal(TargetPoint, transform.position);\n   412→}\n   413→\n   414→// 角度计算\n   415→protected float ToTargetDegree()\n   416→{\n   417→    return Tool2D.GetDegree(ToPointDir(TargetPoint));\n   418→}\n   419→```\n   420→\n   421→**目标搜索属性**：\n   422→```csharp\n   423→public bool HaveTarget => targetEntity != Entity.Null;\n   424→public Vector3 TargetPoint\n   425→{\n   426→    get\n   427→    {\n   428→        if (targetEntity != Entity.Null)\n   429→        {\n   430→            LocalTransform localTransform = GetComponentData<LocalTransform>(targetEntity);\n   431→            return localTransform.Position;\n   432→        }\n   433→        if (targetPpt != null)\n   434→        {\n   435→            return targetPpt.transform.position;\n   436→        }\n   437→        return Vector3.zero;\n   438→    }\n   439→}\n   440→```\n   441→\n   442→### 4.5 移动与翻转\n   443→\n   444→```csharp\n   445→// 设置移动\n   446→public void SetMove(Vector3 motion, bool isFlip = true)\n   447→{\n   448→    CurrentMotion = Tool2D.IgnoreZPoint(CurrentMotion);\n   449→    CurrentMotion = Vector3.Lerp(CurrentMotion, motion, moveLerp * Time.deltaTime);\n   450→\n   451→    // 根据移动方向翻转\n   452→    if (isFlip && isMoveFlip && myPpt.SR_Models != null)\n   453→    {\n   454→        SetFlip(CurrentMotion.x);\n   455→    }\n   456→}\n   457→\n   458→// 设置翻转\n   459→protected virtual void SetFlip(float motionX)\n   460→{\n   461→    if (Mathf.Abs(motionX) > 0.01f)\n   462→    {\n   463→        myPpt.SetFlip(motionX < 0f);\n   464→    }\n   465→}\n   466→\n   467→// SpriteRenderer翻转\n   468→public void SetSingleFlip(SpriteRenderer sr, bool flipX)\n   469→{\n   470→    sr.flipX = flipX;\n   471→    // 同步shader参数\n   472→    sr.material.SetFloat(GameConstManaged.shaderFlipXIndex,\n   473→                         flipX ? -1 : 1);\n   474→}\n   475→\n   476→// MeshRenderer翻转\n   477→public void SetMRFlip(MeshRenderer mr, bool flipX)\n   478→{\n   479→    mr.material.SetFloat(GameConstManaged.shaderFlipXIndex,\n   480→                         flipX ? -1 : 1);\n   481→}\n   482→```\n   483→\n   484→### 4.6 跳跃系统\n   485→\n   486→```csharp\n   487→// 开始跳跃（DOTS版本）\n   488→protected void JumpStart_Dots(float upForce, float gravity)\n   489→{\n   490→    if (!baseIsJumping)\n   491→    {\n   492→        baseIsJumping = true;\n   493→        baseJumpUpForce = upForce;\n   494→        baseJumpGravity = gravity;\n   495→\n   496→        // 确保Z轴归零\n   497→        if (transform.position.z > 0f)\n   498→        {\n   499→            transform.position = Tool2D.IgnoreZPoint(transform.position);\n   500→            LocalTransform componentData = GetComponentData<LocalTransform>();\n   501→            componentData.Position = transform.position;\n   502→            SetComponentData(componentData);\n   503→        }\n   504→\n   505→        // 注册击退免疫\n   506→        UnitProperty_Dots componentData2 = GetComponentData<UnitProperty_Dots>();\n   507→        componentData2.ImmuneKnockbackRegister();\n   508→        componentData2.IsVelocityDeclice = false;\n   509→        SetComponentData(componentData2);\n   510→    }\n   511→}\n   512→\n   513→// 停止跳跃\n   514→protected void JumpStop_Dots()\n   515→{\n   516→    if (baseIsJumping)\n   517→    {\n   518→        baseIsJumping = false;\n   519→        baseJumpUpForce = 0f;\n   520→        baseJumpGravity = 0f;\n   521→\n   522→        // 清除Z轴速度\n   523→        PhysicsVelocity componentData = GetComponentData<PhysicsVelocity>();\n   524→        componentData.Linear.z = 0f;\n   525→        SetComponentData(componentData);\n   526→\n   527→        // 确保位置在地面\n   528→        transform.position = Tool2D.IgnoreZPoint(transform);\n   529→        LocalTransform componentData2 = GetComponentData<LocalTransform>();\n   530→        componentData2.Position = transform.position;\n   531→        SetComponentData(componentData2);\n   532→\n   533→        // 取消击退免疫\n   534→        UnitProperty_Dots componentData3 = GetComponentData<UnitProperty_Dots>();\n   535→        componentData3.ImmuneKnockbackUnregister();\n   536→        componentData3.IsVelocityDeclice = true;\n   537→        SetComponentData(componentData3);\n   538→    }\n   539→}\n   540→\n   541→// 跳跃反弹\n   542→protected void JumpRebounce(float bounceRatio)\n   543→{\n   544→    baseJumpUpForce = -bounceRatio * baseJumpUpForce;\n   545→}\n   546→```\n   547→\n   548→### 4.7 冰冻系统\n   549→\n   550→```csharp\n   551→// 进入冰冻状态\n   552→public virtual void SetFrozen()\n   553→{\n   554→    // 保存冰冻前状态\n   555→    frozenBeforeRigid = Rigid.linearVelocity;\n   556→    frozenBeforeKinematic = Rigid.isKinematic;\n   557→    frozenBeforeMotion = CurrentMotion;\n   558→\n   559→    // 停止运动\n   560→    CurrentMotion = Vector3.zero;\n   561→    Rigid.isKinematic = true;\n   562→    SyncDotsRigidKindmatic();\n   563→    SyncDotsVelocity();\n   564→\n   565→    // 暂停动画\n   566→    if (Anima != null)\n   567→    {\n   568→        Anima.speed = 0f;\n   569→    }\n   570→    if (SAnima != null)\n   571→    {\n   572→        SAnima.timeScale = 0f;\n   573→    }\n   574→}\n   575→\n   576→// 解除冰冻状态\n   577→public virtual void SetUnfrozen()\n   578→{\n   579→    // 恢复运动学状态\n   580→    Rigid.isKinematic = frozenBeforeKinematic;\n   581→    if (!Rigid.isKinematic)\n   582→    {\n   583→        Rigid.linearVelocity = frozenBeforeRigid;\n   584→    }\n   585→    SyncDotsRigidKindmatic();\n   586→    SyncDotsVelocity();\n   587→\n   588→    // 恢复动画\n   589→    if (Anima != null)\n   590→    {\n   591→        Anima.speed = 1f;\n   592→    }\n   593→    if (SAnima != null)\n   594→    {\n   595→        SAnima.timeScale = 1f;\n   596→    }\n   597→}\n   598→```\n   599→\n   600→---\n   601→\n   602→## 5. 单位属性 UnitProperty\n   603→\n   604→### 5.1 核心字段\n   605→\n   606→```csharp\n   607→public class UnitProperty : MonoBehaviour\n   608→{\n   609→    // ====== 配置与标识 ======\n   610→    public UnitConfig unitCfg;           // 单位配置\n   611→    public Entity entity;                // DOTS实体\n   612→\n   613→    // ====== 层级变换 ======\n   614→    public Transform tsf_Layer;          // 层级Transform\n   615→    public SpriteRenderer[] SR_Models;   // 模型渲染器数组\n   616→\n   617→    // ====== 碰撞体 ======\n   618→    public CapsuleCollider CC_Self;      // 自身碰撞体\n   619→\n   620→    // ====== 动画 ======\n   621→    public Animator Anima;               // Animator\n   622→    public SkeletonAnimation SAnima;     // Spine动画\n   623→\n   624→    // ====== 单位引用 ======\n   625→    public UnitBase UnitBas;             // 单位基类\n   626→\n   627→    // ====== 状态标记 ======\n   628→    public bool isUnitDead;              // 是否死亡\n   629→    public bool AlreadyDead;             // 已经死亡（用于防止重复触发）\n   630→    public bool CanTouch;                // 可以接触（用于碰撞检测）\n   631→}\n   632→```\n   633→\n   634→### 5.2 伤害接口\n   635→\n   636→```csharp\n   637→// 受到伤害（简化版）\n   638→public void TakeDamage(float damage, UnitProperty attackerPpt)\n   639→{\n   640→    TakeDamageInfo info = new TakeDamageInfo\n   641→    {\n   642→        attacker = attackerPpt,\n   643→        defender = this,\n   644→        baseDamage = damage\n   645→    };\n   646→    TakeDamage(info);\n   647→}\n   648→\n   649→// 受到伤害（完整版）\n   650→public void TakeDamage(TakeDamageInfo info)\n   651→{\n   652→    // 调用7阶段伤害计算流程\n   653→    DamageMgr.TakeDamage(info);\n   654→}\n   655→\n   656→// 受到伤害（DOTS版本）\n   657→public void TakeDamage_Dots(ref TakeDamageInfo_Dots info)\n   658→{\n   659→    DamageMgr.TakeDamage_Dots(ref info);\n   660→}\n   661→```\n   662→\n   663→### 5.3 翻转控制\n   664→\n   665→```csharp\n   666→public void SetFlip(bool flipX)\n   667→{\n   668→    // 翻转所有模型渲染器\n   669→    for (int i = 0; i < SR_Models.Length; i++)\n   670→    {\n   671→        SR_Models[i].flipX = flipX;\n   672→        SR_Models[i].material.SetFloat(\n   673→            GameConstManaged.shaderFlipXIndex,\n   674→            flipX ? -1 : 1\n   675→        );\n   676→    }\n   677→}\n   678→```\n   679→\n   680→---\n   681→\n   682→## 6. DOTS架构组件\n   683→\n   684→### 6.1 UnitBase_Dots（移动组件）\n   685→\n   686→```csharp\n   687→public struct UnitBase_Dots : IComponentData\n   688→{\n   689→    // ====== 移动相关 ======\n   690→    public float3 targetMotion;          // 目标运动向量\n   691→    public bool isAutoFlip;              // 是否自动翻转\n   692→    private bool isFlip;                 // 当前翻转状态\n   693→\n   694→    // ====== 跳跃相关 ======\n   695→    public bool isJumping;               // 是否正在跳跃\n   696→    public float jumpUpForce;            // 跳跃上升力\n   697→    public float jumpGravity;            // 跳跃重力\n   698→\n   699→    // 设置移动\n   700→    public void SetMove(float3 motion, bool thisTimeShouldFlip = true)\n   701→    {\n   702→        targetMotion = motion;\n   703→\n   704→        if (isAutoFlip && thisTimeShouldFlip)\n   705→        {\n   706→            SetFlip(motion.x < 0f);\n   707→        }\n   708→    }\n   709→\n   710→    // 设置翻转\n   711→    public void SetFlip(bool flip)\n   712→    {\n   713→        if (isFlip != flip)\n   714→        {\n   715→            isFlip = flip;\n   716→            // 通知MonoBehaviour层更新\n   717→        }\n   718→    }\n   719→\n   720→    // 开始跳跃\n   721→    public void JumpStart(float upForce, float gravity)\n   722→    {\n   723→        if (!isJumping)\n   724→        {\n   725→            isJumping = true;\n   726→            jumpUpForce = upForce;\n   727→            jumpGravity = gravity;\n   728→        }\n   729→    }\n   730→\n   731→    // 停止跳跃\n   732→    public void JumpStop()\n   733→    {\n   734→        if (isJumping)\n   735→        {\n   736→            isJumping = false;\n   737→            jumpUpForce = 0f;\n   738→            jumpGravity = 0f;\n   739→        }\n   740→    }\n   741→}\n   742→```\n   743→\n   744→### 6.2 UnitProperty_Dots（属性组件）\n   745→\n   746→```csharp\n   747→public struct UnitProperty_Dots : IComponentData\n   748→{\n   749→    // ====== 基础属性 ======\n   750→    public float maxHP;\n   751→    public float currentHP;\n   752→    public float shield;\n   753→    public float shieldTemp;\n   754→\n   755→    // ====== 移动属性 ======\n   756→    public float moveSpeed;\n   757→    public bool IsVelocityDeclice;       // 速度是否衰减\n   758→\n   759→    // ====== 粘液效果 (Mucus) ======\n   760→    public float affect_MucusHitTimer;         // 粘液受击计时器\n   761→    public float affect_MucusMoveSpeedRatio;   // 粘液移速比例\n   762→    public float affect_MucusSpellSpeedRatio;  // 粘液法术速度比例\n   763→\n   764→    // ====== 毒素效果 (Venom) ======\n   765→    public float affect_VenomDurationTimer;    // 毒素持续计时器\n   766→    public float affect_VenomCurrentStack;     // 当前毒素层数\n   767→\n   768→    // ====== 燃烧效果 (Burn) ======\n   769→    public float affect_burnDurationTimer;     // 燃烧持续计时器\n   770→    public float affect_burnHPRatio;           // 燃烧HP比例\n   771→\n   772→    // ====== 冰冻效果 (Frozen) ======\n   773→    public UnitProperty.Affect_FrozenState FronzenState; // 冰冻状态\n   774→    public float affect_FrozenTime;            // 冰冻时间\n   775→\n   776→    // ====== 虚空效果 (Void) ======\n   777→    public Spell3129VoidExplosion.VoidExplosionData_Dots voidExplosionData;\n   778→    public float voidEffectTimer;              // 虚空效果计时器\n   779→\n   780→    // ====== 深渊效果 (Abyss) ======\n   781→    public float abyssEffectTimer;             // 深渊效果计时器\n   782→\n   783→    // ====== 免疫计数器系统 ======\n   784→    private int flyCounter;                    // 飞行计数器\n   785→    private int invincibleCounter;             // 无敌计数器\n   786→    private int immuneKnockbackCounter;        // 击退免疫计数器\n   787→    private int immnueMucusCounter;            // 粘液免疫计数器\n   788→    private int immnueVenomCounter;            // 毒素免疫计数器\n   789→    private int immuneVoidCounter;             // 虚空免疫计数器\n   790→\n   791→    // ====== 击退系统 ======\n   792→    public float3 knockbackVelocity;           // 击退速度向量\n   793→    public float knockbackDurationTimer;       // 击退持续计时器\n   794→\n   795→    // ====== 受击效果 ======\n   796→    public float beHitShakeTimer;              // 受击震动计时器\n   797→    public float beHitColorTimer;              // 受击变色计时器\n   798→\n   799→    // ====== 特殊状态 ======\n   800→    public bool canTakeDamage;                 // 是否可以受伤\n   801→    public bool isInvincible;                  // 是否无敌\n   802→}\n   803→```\n   804→\n   805→### 6.3 免疫计数器机制\n   806→\n   807→**设计理念**：使用计数器而非布尔值，支持多个来源同时注册/注销免疫状态\n   808→\n   809→```csharp\n   810→// ====== 飞行免疫 ======\n   811→public void FlyRegister()\n   812→{\n   813→    flyCounter++;\n   814→}\n   815→\n   816→public void FlyUnregister()\n   817→{\n   818→    flyCounter--;\n   819→    if (flyCounter < 0)\n   820→    {\n   821→        Debug.LogError(\"飞行计数器小于0！\");\n   822→        flyCounter = 0;\n   823→    }\n   824→}\n   825→\n   826→public bool IsFly => flyCounter > 0;\n   827→\n   828→// ====== 无敌免疫 ======\n   829→public void InvincibleRegister()\n   830→{\n   831→    invincibleCounter++;\n   832→}\n   833→\n   834→public void InvincibleUnregister()\n   835→{\n   836→    invincibleCounter--;\n   837→    if (invincibleCounter < 0)\n   838→    {\n   839→        Debug.LogError(\"无敌计数器小于0！\");\n   840→        invincibleCounter = 0;\n   841→    }\n   842→}\n   843→\n   844→public bool IsInvincible => invincibleCounter > 0;\n   845→\n   846→// ====== 击退免疫 ======\n   847→public void ImmuneKnockbackRegister()\n   848→{\n   849→    immuneKnockbackCounter++;\n   850→}\n   851→\n   852→public void ImmuneKnockbackUnregister()\n   853→{\n   854→    immuneKnockbackCounter--;\n   855→    if (immuneKnockbackCounter < 0)\n   856→    {\n   857→        Debug.LogError(\"击退免疫计数器小于0！\");\n   858→        immuneKnockbackCounter = 0;\n   859→    }\n   860→}\n   861→\n   862→public bool IsImmuneKnockback => immuneKnockbackCounter > 0;\n   863→\n   864→// ====== 粘液免疫 ======\n   865→public void ImmuneMucusRegister()\n   866→{\n   867→    immnueMucusCounter++;\n   868→}\n   869→\n   870→public void ImmuneMucusUnregister()\n   871→{\n   872→    immnueMucusCounter--;\n   873→}\n   874→\n   875→public bool IsImmuneMucus => immnueMucusCounter > 0;\n   876→\n   877→// ====== 毒素免疫 ======\n   878→public void ImmuneVenomRegister()\n   879→{\n   880→    immnueVenomCounter++;\n   881→}\n   882→\n   883→public void ImmuneVenomUnregister()\n   884→{\n   885→    immnueVenomCounter--;\n   886→}\n   887→\n   888→public bool IsImmuneVenom => immnueVenomCounter > 0;\n   889→\n   890→// ====== 虚空免疫 ======\n   891→public void ImmuneVoidRegister()\n   892→{\n   893→    immuneVoidCounter++;\n   894→}\n   895→\n   896→public void ImmuneVoidUnregister()\n   897→{\n   898→    immuneVoidCounter--;\n   899→}\n   900→\n   901→public bool IsImmuneVoid => immuneVoidCounter > 0;\n   902→```\n   903→\n   904→**使用场景**：\n   905→```csharp\n   906→// 场景1：单位跳跃时注册飞行+击退免疫\n   907→void StartJump()\n   908→{\n   909→    ppt_Dots.FlyRegister();\n   910→    ppt_Dots.ImmuneKnockbackRegister();\n   911→}\n   912→\n   913→void EndJump()\n   914→{\n   915→    ppt_Dots.FlyUnregister();\n   916→    ppt_Dots.ImmuneKnockbackUnregister();\n   917→}\n   918→\n   919→// 场景2：遗物提供永久无敌\n   920→void OnRelicEquip()\n   921→{\n   922→    ppt_Dots.InvincibleRegister();  // 永不调用Unregister\n   923→}\n   924→\n   925→// 场景3：多个技能同时提供飞行\n   926→void Spell1Active()\n   927→{\n   928→    ppt_Dots.FlyRegister();  // 计数器 = 1\n   929→}\n   930→\n   931→void Spell2Active()\n   932→{\n   933→    ppt_Dots.FlyRegister();  // 计数器 = 2\n   934→}\n   935→\n   936→void Spell1Deactive()\n   937→{\n   938→    ppt_Dots.FlyUnregister(); // 计数器 = 1, 仍然飞行\n   939→}\n   940→\n   941→void Spell2Deactive()\n   942→{\n   943→    ppt_Dots.FlyUnregister(); // 计数器 = 0, 结束飞行\n   944→}\n   945→```\n   946→\n   947→---\n   948→\n   949→## 7. 状态效果系统\n   950→\n   951→### 7.1 状态效果类型\n   952→\n   953→| 状态效果 | 英文名 | 效果说明 | 数据结构 |\n   954→|---------|--------|---------|---------|\n   955→| **粘液** | Mucus | 减速移动和法术速度 | MucusHitTimer, MucusMoveSpeedRatio, MucusSpellSpeedRatio |\n   956→| **毒素** | Venom | 持续伤害，可叠加 | VenomDurationTimer, VenomCurrentStack |\n   957→| **燃烧** | Burn | 持续伤害（基于最大HP比例） | burnDurationTimer, burnHPRatio |\n   958→| **冰冻** | Frozen | 完全无法行动 | FronzenState, FrozenTime |\n   959→| **虚空** | Void | 虚空爆炸标记 | voidExplosionData, voidEffectTimer |\n   960→| **深渊** | Abyss | 深渊效果 | abyssEffectTimer |\n   961→\n   962→### 7.2 粘液效果 (Mucus)\n   963→\n   964→**效果机制**：\n   965→- 减少移动速度\n   966→- 减少法术发射速度\n   967→- 受击刷新持续时间\n   968→\n   969→```csharp\n   970→// 粘液数据\n   971→public float affect_MucusHitTimer;         // 粘液受击计时器（持续时间）\n   972→public float affect_MucusMoveSpeedRatio;   // 移速比例（如0.5表示减速50%）\n   973→public float affect_MucusSpellSpeedRatio;  // 法术速度比例\n   974→\n   975→// 应用粘液效果\n   976→public void ApplyMucusEffect(float duration, float moveSpeedRatio, float spellSpeedRatio)\n   977→{\n   978→    if (!IsImmuneMucus)\n   979→    {\n   980→        affect_MucusHitTimer = duration;\n   981→        affect_MucusMoveSpeedRatio = moveSpeedRatio;\n   982→        affect_MucusSpellSpeedRatio = spellSpeedRatio;\n   983→    }\n   984→}\n   985→\n   986→// 每帧更新\n   987→void UpdateMucusEffect(float deltaTime)\n   988→{\n   989→    if (affect_MucusHitTimer > 0)\n   990→    {\n   991→        affect_MucusHitTimer -= deltaTime;\n   992→\n   993→        // 应用移速减速\n   994→        float finalMoveSpeed = baseMoveSpeed * affect_MucusMoveSpeedRatio;\n   995→\n   996→        // 应用法术速度减速\n   997→        float finalSpellSpeed = baseSpellSpeed * affect_MucusSpellSpeedRatio;\n   998→    }\n   999→}\n  1000→```\n  1001→\n  1002→### 7.3 毒素效果 (Venom)\n  1003→\n  1004→**效果机制**：\n  1005→- 可叠加层数\n  1006→- 每层造成持续伤害\n  1007→- 持续时间独立计算\n  1008→\n  1009→```csharp\n  1010→// 毒素数据\n  1011→public float affect_VenomDurationTimer;    // 持续时间\n  1012→public float affect_VenomCurrentStack;     // 当前层数\n  1013→\n  1014→// 应用毒素效果\n  1015→public void ApplyVenomEffect(float duration, float stackToAdd)\n  1016→{\n  1017→    if (!IsImmuneVenom)\n  1018→    {\n  1019→        affect_VenomDurationTimer = duration;\n  1020→        affect_VenomCurrentStack += stackToAdd;\n  1021→\n  1022→        // 层数上限限制\n  1023→        if (affect_VenomCurrentStack > maxVenomStack)\n  1024→        {\n  1025→            affect_VenomCurrentStack = maxVenomStack;\n  1026→        }\n  1027→    }\n  1028→}\n  1029→\n  1030→// 每帧更新\n  1031→void UpdateVenomEffect(float deltaTime)\n  1032→{\n  1033→    if (affect_VenomDurationTimer > 0)\n  1034→    {\n  1035→        affect_VenomDurationTimer -= deltaTime;\n  1036→\n  1037→        // 造成持续伤害\n  1038→        venomDamageTimer += deltaTime;\n  1039→        if (venomDamageTimer >= venomDamageInterval)\n  1040→        {\n  1041→            venomDamageTimer = 0f;\n  1042→            float damage = venomDamagePerStack * affect_VenomCurrentStack;\n  1043→            TakeDamage_Venom(damage);\n  1044→        }\n  1045→\n  1046→        // 持续时间结束，清除毒素\n  1047→        if (affect_VenomDurationTimer <= 0)\n  1048→        {\n  1049→            affect_VenomCurrentStack = 0f;\n  1050→        }\n  1051→    }\n  1052→}\n  1053→```\n  1054→\n  1055→### 7.4 燃烧效果 (Burn)\n  1056→\n  1057→**效果机制**：\n  1058→- 基于最大HP比例造成伤害\n  1059→- 持续时间内持续燃烧\n  1060→- 有视觉火焰特效\n  1061→\n  1062→```csharp\n  1063→// 燃烧数据\n  1064→public float affect_burnDurationTimer;     // 持续时间\n  1065→public float affect_burnHPRatio;           // 每秒伤害比例（基于最大HP）\n  1066→\n  1067→// 应用燃烧效果\n  1068→public void ApplyBurnEffect(float duration, float hpRatioPerSecond)\n  1069→{\n  1070→    affect_burnDurationTimer = duration;\n  1071→    affect_burnHPRatio = hpRatioPerSecond;\n  1072→}\n  1073→\n  1074→// 每帧更新\n  1075→void UpdateBurnEffect(float deltaTime)\n  1076→{\n  1077→    if (affect_burnDurationTimer > 0)\n  1078→    {\n  1079→        affect_burnDurationTimer -= deltaTime;\n  1080→\n  1081→        // 计算燃烧伤害\n  1082→        float damagePerFrame = maxHP * affect_burnHPRatio * deltaTime;\n  1083→        TakeDamage_Burn(damagePerFrame);\n  1084→\n  1085→        // 生成火焰特效\n  1086→        if (burnEffectTimer <= 0)\n  1087→        {\n  1088→            burnEffectTimer = burnEffectInterval;\n  1089→            SpawnBurnEffect();\n  1090→        }\n  1091→        burnEffectTimer -= deltaTime;\n  1092→    }\n  1093→}\n  1094→```\n  1095→\n  1096→### 7.5 冰冻效果 (Frozen)\n  1097→\n  1098→**效果机制**：\n  1099→- 完全停止单位行动\n  1100→- 暂停动画播放\n  1101→- 视觉冰块特效\n  1102→\n  1103→```csharp\n  1104→// 冰冻状态枚举\n  1105→public enum Affect_FrozenState\n  1106→{\n  1107→    None,           // 无冰冻\n  1108→    Frozen,         // 冰冻中\n  1109→    Unfreezing      // 解冻中（播放解冻动画）\n  1110→}\n  1111→\n  1112→// 冰冻数据\n  1113→public Affect_FrozenState FronzenState;\n  1114→public float affect_FrozenTime;\n  1115→\n  1116→// 应用冰冻效果\n  1117→public void ApplyFrozenEffect(float duration)\n  1118→{\n  1119→    float finalDuration = duration * frozenTimeRatio;  // 应用冰冻时间比例\n  1120→\n  1121→    if (FronzenState == Affect_FrozenState.None)\n  1122→    {\n  1123→        FronzenState = Affect_FrozenState.Frozen;\n  1124→        affect_FrozenTime = finalDuration;\n  1125→\n  1126→        // 调用MonoBehaviour层的冰冻方法\n  1127→        unitBase.SetFrozen();\n  1128→\n  1129→        // 生成冰块特效\n  1130→        SpawnFrozenEffect();\n  1131→    }\n  1132→    else if (FronzenState == Affect_FrozenState.Frozen)\n  1133→    {\n  1134→        // 刷新冰冻时间\n  1135→        affect_FrozenTime = Mathf.Max(affect_FrozenTime, finalDuration);\n  1136→    }\n  1137→}\n  1138→\n  1139→// 每帧更新\n  1140→void UpdateFrozenEffect(float deltaTime)\n  1141→{\n  1142→    if (FronzenState == Affect_FrozenState.Frozen)\n  1143→    {\n  1144→        affect_FrozenTime -= deltaTime;\n  1145→\n  1146→        if (affect_FrozenTime <= 0)\n  1147→        {\n  1148→            // 解除冰冻\n  1149→            FronzenState = Affect_FrozenState.None;\n  1150→            unitBase.SetUnfrozen();\n  1151→            DestroyFrozenEffect();\n  1152→        }\n  1153→    }\n  1154→}\n  1155→```\n  1156→\n  1157→### 7.6 虚空效果 (Void)\n  1158→\n  1159→**效果机制**：\n  1160→- 标记单位为虚空爆炸目标\n  1161→- 死亡时触发虚空爆炸\n  1162→- 爆炸造成范围伤害\n  1163→\n  1164→```csharp\n  1165→// 虚空爆炸数据（来自法术3129）\n  1166→public struct VoidExplosionData_Dots\n  1167→{\n  1168→    public Entity casterEntity;          // 施法者实体\n  1169→    public float explosionRadius;        // 爆炸半径\n  1170→    public float explosionDamage;        // 爆炸伤害\n  1171→    public bool isMarked;                // 是否被标记\n  1172→}\n  1173→\n  1174→// 虚空数据\n  1175→public VoidExplosionData_Dots voidExplosionData;\n  1176→public float voidEffectTimer;\n  1177→\n  1178→// 应用虚空效果\n  1179→public void ApplyVoidEffect(Entity caster, float radius, float damage, float duration)\n  1180→{\n  1181→    if (!IsImmuneVoid)\n  1182→    {\n  1183→        voidExplosionData.casterEntity = caster;\n  1184→        voidExplosionData.explosionRadius = radius;\n  1185→        voidExplosionData.explosionDamage = damage;\n  1186→        voidExplosionData.isMarked = true;\n  1187→        voidEffectTimer = duration;\n  1188→\n  1189→        // 生成虚空标记特效\n  1190→        SpawnVoidMarkEffect();\n  1191→    }\n  1192→}\n  1193→\n  1194→// 单位死亡时触发\n  1195→public void OnDeath()\n  1196→{\n  1197→    if (voidExplosionData.isMarked)\n  1198→    {\n  1199→        // 触发虚空爆炸\n  1200→        TriggerVoidExplosion();\n  1201→    }\n  1202→}\n  1203→\n  1204→void TriggerVoidExplosion()\n  1205→{\n  1206→    // 查找范围内所有单位\n  1207→    List<UnitProperty> unitsInRange = FindUnitsInRadius(\n  1208→        transform.position,\n  1209→        voidExplosionData.explosionRadius\n  1210→    );\n  1211→\n  1212→    // 对每个单位造成伤害\n  1213→    foreach (var unit in unitsInRange)\n  1214→    {\n  1215→        TakeDamageInfo_Dots damageInfo = new TakeDamageInfo_Dots\n  1216→        {\n  1217→            attackerEntity = voidExplosionData.casterEntity,\n  1218→            defenderEntity = unit.entity,\n  1219→            baseDamage = voidExplosionData.explosionDamage,\n  1220→            damageType = DamageType.VoidExplosion\n  1221→        };\n  1222→\n  1223→        unit.TakeDamage_Dots(ref damageInfo);\n  1224→    }\n  1225→\n  1226→    // 生成爆炸特效\n  1227→    SpawnVoidExplosionEffect();\n  1228→}\n  1229→```\n  1230→\n  1231→### 7.7 深渊效果 (Abyss)\n  1232→\n  1233→**效果机制**：\n  1234→- 深渊伤害（特殊伤害类型）\n  1235→- 可能有特殊的视觉效果\n  1236→\n  1237→```csharp\n  1238→// 深渊数据\n  1239→public float abyssEffectTimer;\n  1240→\n  1241→// 应用深渊效果\n  1242→public void ApplyAbyssEffect(float duration)\n  1243→{\n  1244→    if (!unitCfg.immuneAbyss)\n  1245→    {\n  1246→        abyssEffectTimer = duration;\n  1247→        // 深渊效果逻辑\n  1248→    }\n  1249→}\n  1250→```\n  1251→\n  1252→### 7.8 状态效果优先级与叠加规则\n  1253→\n  1254→**优先级**（从高到低）：\n  1255→1. **冰冻** - 完全控制单位，阻止所有行动\n  1256→2. **击退** - 短暂失去控制\n  1257→3. **粘液** - 减速效果\n  1258→4. **毒素/燃烧** - 持续伤害，不影响行动\n  1259→5. **虚空/深渊** - 标记效果，不影响行动\n  1260→\n  1261→**叠加规则**：\n  1262→- **冰冻**：不可叠加，只刷新持续时间\n  1263→- **粘液**：不可叠加，每次受击刷新持续时间\n  1264→- **毒素**：可叠加层数，持续时间独立\n  1265→- **燃烧**：不可叠加，刷新持续时间\n  1266→- **虚空**：可多次标记，独立触发\n  1267→- **击退**：可叠加，向量累加\n  1268→\n  1269→---\n  1270→\n  1271→## 8. AI状态机系统\n  1272→\n  1273→### 8.1 状态机概述\n  1274→\n  1275→每个敌人单位都有一个状态机控制其行为，状态机由**状态枚举**和**状态更新方法**组成。\n  1276→\n  1277→### 8.2 Monster1状态机（示例）\n  1278→\n  1279→```csharp\n  1280→public enum UnitState\n  1281→{\n  1282→    BornIdle,           // 出生待机\n  1283→    Idle,               // 待机\n  1284→    IdleWalk,           // 闲逛\n  1285→    MoveToTarget,       // 移动到目标\n  1286→    Attack,             // 攻击\n  1287→    PermanentAttack,    // 持续攻击\n  1288→    LongAttackAfter,    // 长攻击后\n  1289→    Fly,                // 飞行\n  1290→    JumpPrepare,        // 跳跃准备\n  1291→    Jump                // 跳跃\n  1292→}\n  1293→```\n  1294→\n  1295→### 8.3 状态机流程图\n  1296→\n  1297→```\n  1298→          出生\n  1299→           ↓\n  1300→      [BornIdle]\n  1301→           ↓\n  1302→       首次初始化\n  1303→           ↓\n  1304→        [Idle] ←───────┐\n  1305→           ↓           │\n  1306→    是否有目标？         │\n  1307→      ↙     ↘         │\n  1308→    是       否        │\n  1309→     ↓       ↓        │\n  1310→[MoveToTarget] [IdleWalk]\n  1311→     ↓                │\n  1312→  到达攻击范围？        │\n  1313→     ↓                │\n  1314→  [Attack] ───────────┘\n  1315→     ↓\n  1316→  攻击完成\n  1317→     ↓\n  1318→   [Idle]\n  1319→\n  1320→\n  1321→  特殊状态转换：\n  1322→\n  1323→  任意状态 → [JumpPrepare] → [Jump] → [Idle]\n  1324→            (跳跃检查)      (落地)\n  1325→\n  1326→  [Attack] → [PermanentAttack] → [LongAttackAfter] → [Idle]\n  1327→           (长攻击动画)        (攻击后摇)\n  1328→```\n  1329→\n  1330→### 8.4 状态更新逻辑\n  1331→\n  1332→```csharp\n  1333→protected override void Update()\n  1334→{\n  1335→    base.Update();\n  1336→\n  1337→    // 死亡或冰冻时不更新AI\n  1338→    if (myPpt.isUnitDead || myPpt.IsFrozen)\n  1339→        return;\n  1340→\n  1341→    switch (state)\n  1342→    {\n  1343→        case UnitState.BornIdle:\n  1344→            UpdateBornIdle();\n  1345→            break;\n  1346→\n  1347→        case UnitState.Idle:\n  1348→            UpdateIdle();\n  1349→            break;\n  1350→\n  1351→        case UnitState.IdleWalk:\n  1352→            UpdateIdleWalk();\n  1353→            break;\n  1354→\n  1355→        case UnitState.MoveToTarget:\n  1356→            UpdateMoveToTarget();\n  1357→            break;\n  1358→\n  1359→        case UnitState.Attack:\n  1360→            UpdateAttack();\n  1361→            break;\n  1362→\n  1363→        case UnitState.PermanentAttack:\n  1364→            UpdatePermanentAttack();\n  1365→            break;\n  1366→\n  1367→        case UnitState.Jump:\n  1368→            UpdateJump();\n  1369→            break;\n  1370→    }\n  1371→\n  1372→    // 跳跃检查（可在任何状态触发）\n  1373→    JumpCheck();\n  1374→}\n  1375→```\n  1376→\n  1377→### 8.5 状态实现示例\n  1378→\n  1379→#### 8.5.1 出生待机 (BornIdle)\n  1380→\n  1381→```csharp\n  1382→void UpdateBornIdle()\n  1383→{\n  1384→    // 等待出生动画播放完毕\n  1385→    if (bornIdleTimer >= bornIdleDuration)\n  1386→    {\n  1387→        state = UnitState.Idle;\n  1388→        PlayAnimation(\"Idle\");\n  1389→    }\n  1390→\n  1391→    bornIdleTimer += Time.deltaTime;\n  1392→}\n  1393→```\n  1394→\n  1395→#### 8.5.2 待机 (Idle)\n  1396→\n  1397→```csharp\n  1398→void UpdateIdle()\n  1399→{\n  1400→    idleTimer += Time.deltaTime;\n  1401→\n  1402→    // 搜索目标\n  1403→    GetNearestTargetWithTimer();\n  1404→\n  1405→    // 有目标 → 移动到目标\n  1406→    if (HaveTarget)\n  1407→    {\n  1408→        state = UnitState.MoveToTarget;\n  1409→        PlayAnimation(\"Walk\");\n  1410→    }\n  1411→    // 无目标且等待足够时间 → 闲逛\n  1412→    else if (idleTimer >= idleDuration.result)\n  1413→    {\n  1414→        idleTimer = 0f;\n  1415→        idleDuration.RandomResult();\n  1416→        state = UnitState.IdleWalk;\n  1417→\n  1418→        // 随机选择闲逛目标点\n  1419→        idleWalkTargetPoint = GetRandomPointInRange(5f);\n  1420→        PlayAnimation(\"Walk\");\n  1421→    }\n  1422→}\n  1423→```\n  1424→\n  1425→#### 8.5.3 闲逛 (IdleWalk)\n  1426→\n  1427→```csharp\n  1428→void UpdateIdleWalk()\n  1429→{\n  1430→    // 获取导航路径\n  1431→    GetNavInfoWithTimer(idleWalkTargetPoint);\n  1432→\n  1433→    // 沿路径移动\n  1434→    if (!navInfo.allCornerArrived)\n  1435→    {\n  1436→        Vector3 moveDir = ToPointDir(navInfo.corners[navInfo.currentCornerIndex]);\n  1437→        SetMove(moveDir * myPpt.unitCfg.moveSpeed);\n  1438→        CheckNavInfo();\n  1439→    }\n  1440→    else\n  1441→    {\n  1442→        // 到达目标点 → 返回待机\n  1443→        state = UnitState.Idle;\n  1444→        PlayAnimation(\"Idle\");\n  1445→    }\n  1446→\n  1447→    // 发现目标 → 移动到目标\n  1448→    GetNearestTargetWithTimer();\n  1449→    if (HaveTarget)\n  1450→    {\n  1451→        state = UnitState.MoveToTarget;\n  1452→    }\n  1453→}\n  1454→```\n  1455→\n  1456→#### 8.5.4 移动到目标 (MoveToTarget)\n  1457→\n  1458→```csharp\n  1459→void UpdateMoveToTarget()\n  1460→{\n  1461→    // 目标丢失 → 返回待机\n  1462→    if (!HaveTarget)\n  1463→    {\n  1464→        state = UnitState.Idle;\n  1465→        PlayAnimation(\"Idle\");\n  1466→        return;\n  1467→    }\n  1468→\n  1469→    // 更新目标位置\n  1470→    targetLastPosition = TargetPoint;\n  1471→\n  1472→    // 计算距离\n  1473→    float distance = ToTargetDistance();\n  1474→\n  1475→    // 到达攻击范围 → 攻击\n  1476→    if (distance <= attackRange)\n  1477→    {\n  1478→        state = UnitState.Attack;\n  1479→\n  1480→        // 根据AI模式选择攻击动画\n  1481→        if (pattern == AIPattern.Pattern2 || pattern == AIPattern.Pattern3)\n  1482→        {\n  1483→            PlayAnimation(\"Attack\");\n  1484→        }\n  1485→        else if (pattern == AIPattern.Pattern5)\n  1486→        {\n  1487→            PlayAnimation(\"LongAttackBefore\");\n  1488→        }\n  1489→\n  1490→        SetMove(Vector3.zero);  // 停止移动\n  1491→        return;\n  1492→    }\n  1493→\n  1494→    // 获取导航路径\n  1495→    GetNavInfoWithTimer(targetLastPosition);\n  1496→\n  1497→    // 沿路径移动\n  1498→    if (!navInfo.allCornerArrived)\n  1499→    {\n  1500→        Vector3 moveDir = ToPointDir(navInfo.corners[navInfo.currentCornerIndex]);\n  1501→        SetMove(moveDir * myPpt.unitCfg.moveSpeed);\n  1502→        CheckNavInfo();\n  1503→    }\n  1504→}\n  1505→```\n  1506→\n  1507→#### 8.5.5 攻击 (Attack)\n  1508→\n  1509→```csharp\n  1510→void UpdateAttack()\n  1511→{\n  1512→    // 攻击状态由动画事件驱动，不在Update中处理\n  1513→    // 动画事件会调用OnAnimationEvent方法\n  1514→}\n  1515→\n  1516→// 动画事件回调\n  1517→public override void OnAnimationEvent(string animaName)\n  1518→{\n  1519→    switch (animaName)\n  1520→    {\n  1521→        case \"Attack\":\n  1522→            // 发射法术\n  1523→            if (HaveTarget)\n  1524→            {\n  1525→                ShootSpellAtTarget();\n  1526→            }\n  1527→            break;\n  1528→\n  1529→        case \"AttackFinish\":\n  1530→            // 攻击完成 → 返回待机\n  1531→            state = UnitState.Idle;\n  1532→            PlayAnimation(\"Idle\");\n  1533→            break;\n  1534→\n  1535→        case \"LongAttackBeforeFinish\":\n  1536→            // 长攻击前摇完成 → 进入持续攻击\n  1537→            state = UnitState.PermanentAttack;\n  1538→            PlayAnimation(\"LongAttack\");\n  1539→            break;\n  1540→\n  1541→        case \"LongAttackOverFinish\":\n  1542→            // 长攻击完成 → 返回待机\n  1543→            state = UnitState.Idle;\n  1544→            PlayAnimation(\"Idle\");\n  1545→            break;\n  1546→    }\n  1547→}\n  1548→```\n  1549→\n  1550→#### 8.5.6 跳跃 (Jump)\n  1551→\n  1552→```csharp\n  1553→void UpdateJump()\n  1554→{\n  1555→    // 跳跃由物理系统控制\n  1556→    // 落地时通过碰撞检测触发\n  1557→}\n  1558→\n  1559→void OnCollisionEnter(Collision collision)\n  1560→{\n  1561→    if (state == UnitState.Jump && collision.gameObject.layer == GameConst.Layer_Ground)\n  1562→    {\n  1563→        // 落地\n  1564→        JumpStop_Dots();\n  1565→\n  1566→        // 落地特效\n  1567→        SpawnLandingEffect();\n  1568→\n  1569→        // 返回待机\n  1570→        state = UnitState.Idle;\n  1571→        PlayAnimation(\"Idle\");\n  1572→\n  1573→        // 更新腿部动画\n  1574→        for (int i = 0; i < legs.Length; i++)\n  1575→        {\n  1576→            legs[i].SetIdle();\n  1577→        }\n  1578→    }\n  1579→}\n  1580→```\n  1581→\n  1582→### 8.6 跳跃检查机制\n  1583→\n  1584→```csharp\n  1585→public void JumpCheck()\n  1586→{\n  1587→    // 只有特定AI模式才会跳跃\n  1588→    if (pattern == AIPattern.Pattern4 ||\n  1589→        pattern == AIPattern.Pattern5 ||\n  1590→        pattern == AIPattern.Pattern7 ||\n  1591→        pattern == AIPattern.Pattern8)\n  1592→    {\n  1593→        jumpCheckTimer += Time.deltaTime;\n  1594→\n  1595→        if (jumpCheckTimer > jumpCheckTime.result)\n  1596→        {\n  1597→            jumpCheckTimer = 0f;\n  1598→            jumpCheckTime.RandomResult();\n  1599→\n  1600→            // 进入跳跃准备状态\n  1601→            state = UnitState.JumpPrepare;\n  1602→            PlayAnimation(\"JumpPrepare\");\n  1603→        }\n  1604→    }\n  1605→}\n  1606→```\n  1607→\n  1608→### 8.7 AI模式 (AIPattern)\n  1609→\n  1610→```csharp\n  1611→public enum AIPattern\n  1612→{\n  1613→    Pattern1,  // 近战普通攻击\n  1614→    Pattern2,  // 远程单发攻击\n  1615→    Pattern3,  // 远程快速攻击\n  1616→    Pattern4,  // 跳跃攻击\n  1617→    Pattern5,  // 跳跃+毒素攻击\n  1618→    Pattern6,  // 双向同时射击\n  1619→    Pattern7,  // 跳跃变体1\n  1620→    Pattern8,  // 双向分散射击\n  1621→    Pattern9   // 三向散射\n  1622→}\n  1623→```\n  1624→\n  1625→**不同AI模式的射击逻辑**：\n  1626→\n  1627→```csharp\n  1628→void ShootSpellAtTarget()\n  1629→{\n  1630→    UnitSpellModifier sSPModifier = UnitBase.GetSSPModifier(in ssp);\n  1631→\n  1632→    switch (pattern)\n  1633→    {\n  1634→        case AIPattern.Pattern2:\n  1635→        case AIPattern.Pattern3:\n  1636→            // 单发射击\n  1637→            sSPModifier.Direction = ToTargetDir();\n  1638→            sSPModifier.SpawnPosition = transform.position + new Vector3(0f, 0f, -spellHeight);\n  1639→            sSPModifier.ApplyToSSP(ref ssp);\n  1640→            ShootSpell(ssp);\n  1641→            break;\n  1642→\n  1643→        case AIPattern.Pattern6:\n  1644→            // 双向同时射击（左右各一发）\n  1645→            sSPModifier.Direction = ToTargetDir();\n  1646→            sSPModifier.SpawnPosition = transform.position +\n  1647→                                       new Vector3(0f, 0f, -spellHeight) +\n  1648→                                       ToTargetDir(-90f) * bulletOffset;\n  1649→            sSPModifier.ApplyToSSP(ref ssp);\n  1650→            ShootSpell(ssp);\n  1651→\n  1652→            sSPModifier.SpawnPosition = transform.position +\n  1653→                                       new Vector3(0f, 0f, -spellHeight) +\n  1654→                                       ToTargetDir(90f) * bulletOffset;\n  1655→            sSPModifier.ApplyToSSP(ref ssp);\n  1656→            ShootSpell(ssp);\n  1657→            break;\n  1658→\n  1659→        case AIPattern.Pattern8:\n  1660→            // 双向分散射击（±5度）\n  1661→            sSPModifier.Direction = ToTargetDir(-5f);\n  1662→            sSPModifier.SpawnPosition = transform.position + new Vector3(0f, 0f, -spellHeight);\n  1663→            sSPModifier.ApplyToSSP(ref ssp);\n  1664→            ShootSpell(ssp);\n  1665→\n  1666→            sSPModifier.Direction = ToTargetDir(5f);\n  1667→            sSPModifier.SpawnPosition = transform.position + new Vector3(0f, 0f, -spellHeight);\n  1668→            sSPModifier.ApplyToSSP(ref ssp);\n  1669→            ShootSpell(ssp);\n  1670→            break;\n  1671→\n  1672→        case AIPattern.Pattern9:\n  1673→            // 三向散射（0度, 120度, 240度）\n  1674→            for (int i = 0; i < 3; i++)\n  1675→            {\n  1676→                float angle = i * 120f;\n  1677→                sSPModifier.Direction = ToTargetDir(angle);\n  1678→                sSPModifier.SpawnPosition = transform.position +\n  1679→                                           new Vector3(0f, 0f, -spellHeight) +\n  1680→                                           ToTargetDir(angle) * bulletOffset;\n  1681→                sSPModifier.ApplyToSSP(ref ssp);\n  1682→                ShootSpell(ssp);\n  1683→            }\n  1684→            break;\n  1685→    }\n  1686→}\n  1687→```\n  1688→\n  1689→---\n  1690→\n  1691→## 9. 移动与寻路系统\n  1692→\n  1693→### 9.1 NavMesh寻路\n  1694→\n  1695→**NavInfo结构**：\n  1696→```csharp\n  1697→public struct NavInfo\n  1698→{\n  1699→    public Vector3[] corners;           // 路径拐点数组\n  1700→    public int currentCornerIndex;      // 当前拐点索引\n  1701→    public bool allCornerArrived;       // 是否到达所有拐点\n  1702→}\n  1703→```\n  1704→\n  1705→**获取导航路径**：\n  1706→```csharp\n  1707→public void GetNavInfo(Vector3 targetPoint)\n  1708→{\n  1709→    // 使用NavMesh计算路径\n  1710→    NavMeshPath navMeshPath = Tool2D.GetNavMeshPath(\n  1711→        transform.position,\n  1712→        targetPoint,\n  1713→        navAreaMask\n  1714→    );\n  1715→\n  1716→    navInfo.corners = navMeshPath.corners;\n  1717→    navInfo.currentCornerIndex = 0;\n  1718→    navInfo.allCornerArrived = false;\n  1719→\n  1720→    CheckNavInfo();\n  1721→}\n  1722→\n  1723→// 带定时器的版本（避免每帧计算）\n  1724→public void GetNavInfoWithTimer(Vector3 targetPoint)\n  1725→{\n  1726→    if (navInfo.corners == null)\n  1727→    {\n  1728→        GetNavInfo(targetPoint);\n  1729→    }\n  1730→\n  1731→    checkTargetIntervalTimer += Time.deltaTime;\n  1732→    if (checkTargetIntervalTimer > 0.1f)\n  1733→    {\n  1734→        checkTargetIntervalTimer = 0f;\n  1735→        GetNavInfo(targetPoint);\n  1736→    }\n  1737→}\n  1738→```\n  1739→\n  1740→**检查路径拐点**：\n  1741→```csharp\n  1742→public void CheckNavInfo()\n  1743→{\n  1744→    for (int i = navInfo.currentCornerIndex; i < navInfo.corners.Length; i++)\n  1745→    {\n  1746→        // 计算到当前拐点的距离\n  1747→        float distanceSqr = (Tool2D.IgnoreZPoint(transform.position) -\n  1748→                            Tool2D.IgnoreZPoint(navInfo.corners[i])).sqrMagnitude;\n  1749→\n  1750→        // 到达拐点\n  1751→        if (distanceSqr < moveThreshold * moveThreshold)\n  1752→        {\n  1753→            navInfo.currentCornerIndex++;\n  1754→\n  1755→            // 到达最后一个拐点\n  1756→            if (navInfo.currentCornerIndex == navInfo.corners.Length)\n  1757→            {\n  1758→                navInfo.allCornerArrived = true;\n  1759→                navInfo.currentCornerIndex = navInfo.corners.Length - 1;\n  1760→            }\n  1761→        }\n  1762→        else\n  1763→        {\n  1764→            break;  // 未到达当前拐点，停止检查\n  1765→        }\n  1766→    }\n  1767→}\n  1768→```\n  1769→\n  1770→**沿路径移动**：\n  1771→```csharp\n  1772→void MoveAlongPath()\n  1773→{\n  1774→    if (!navInfo.allCornerArrived)\n  1775→    {\n  1776→        // 获取当前目标拐点\n  1777→        Vector3 targetCorner = navInfo.corners[navInfo.currentCornerIndex];\n  1778→\n  1779→        // 计算移动方向\n  1780→        Vector3 moveDir = ToPointDir(targetCorner);\n  1781→\n  1782→        // 应用移动\n  1783→        SetMove(moveDir * myPpt.unitCfg.moveSpeed);\n  1784→\n  1785→        // 检查是否到达拐点\n  1786→        CheckNavInfo();\n  1787→    }\n  1788→    else\n  1789→    {\n  1790→        // 到达目的地，停止移动\n  1791→        SetMove(Vector3.zero);\n  1792→    }\n  1793→}\n  1794→```\n  1795→\n  1796→### 9.2 NavMesh区域遮罩\n  1797→\n  1798→```csharp\n  1799→// 设置导航区域遮罩\n  1800→public void SetNavMeshArea(int layer)\n  1801→{\n  1802→    navAreaMask = layer;\n  1803→}\n  1804→\n  1805→// 使用示例\n  1806→// -1 = 所有区域\n  1807→// GameConst.NavMesh_Ground = 只在地面区域\n  1808→// GameConst.NavMesh_Air = 只在空中区域\n  1809→SetNavMeshArea(-1);  // 使用所有区域\n  1810→```\n  1811→\n  1812→### 9.3 DOTS移动系统\n  1813→\n  1814→**UnitBase_Dots移动逻辑**：\n  1815→```csharp\n  1816→// 设置移动（DOTS版本）\n  1817→public void SetMove(float3 motion, bool thisTimeShouldFlip = true)\n  1818→{\n  1819→    targetMotion = motion;\n  1820→\n  1821→    if (isAutoFlip && thisTimeShouldFlip)\n  1822→    {\n  1823→        SetFlip(motion.x < 0f);\n  1824→    }\n  1825→}\n  1826→\n  1827→// ISystem更新移动\n  1828→[BurstCompile]\n  1829→public partial struct UnitMoveSystem : ISystem\n  1830→{\n  1831→    [BurstCompile]\n  1832→    public void OnUpdate(ref SystemState state)\n  1833→    {\n  1834→        float deltaTime = SystemAPI.Time.DeltaTime;\n  1835→\n  1836→        foreach (var (baseData, pptData, transform, velocity) in\n  1837→                 SystemAPI.Query<RefRW<UnitBase_Dots>,\n  1838→                                RefRO<UnitProperty_Dots>,\n  1839→                                RefRW<LocalTransform>,\n  1840→                                RefRW<PhysicsVelocity>>())\n  1841→        {\n  1842→            // 应用粘液减速\n  1843→            float moveSpeedRatio = pptData.ValueRO.affect_MucusMoveSpeedRatio;\n  1844→            if (moveSpeedRatio == 0f)\n  1845→                moveSpeedRatio = 1f;\n  1846→\n  1847→            // 计算最终速度\n  1848→            float3 finalMotion = baseData.ValueRO.targetMotion * moveSpeedRatio;\n  1849→\n  1850→            // 应用到物理速度\n  1851→            velocity.ValueRW.Linear.xy = finalMotion.xy;\n  1852→\n  1853→            // 速度衰减\n  1854→            if (pptData.ValueRO.IsVelocityDeclice)\n  1855→            {\n  1856→                velocity.ValueRW.Linear *= 0.9f;\n  1857→            }\n  1858→        }\n  1859→    }\n  1860→}\n  1861→```\n  1862→\n  1863→### 9.4 跳跃物理\n  1864→\n  1865→```csharp\n  1866→// 普通跳跃\n  1867→public void NormalJump(Vector3 forwardForce, float upForce, float gravity)\n  1868→{\n  1869→    // 注册飞行状态\n  1870→    UnitProperty_Dots componentData = GetComponentData<UnitProperty_Dots>();\n  1871→    componentData.FlyRegister();\n  1872→    SetComponentData(componentData);\n  1873→\n  1874→    // 获取目标点\n  1875→    GetNearestTarget();\n  1876→    Vector3 targetPos = HaveTarget ?\n  1877→        Tool2D.GetNavMeshPointIngoreZ(transform.position + forwardForce) :\n  1878→        Tool2D.GetNavMeshPointIngoreZ(transform.position + forwardForce.normalized);\n  1879→\n  1880→    // 计算水平速度（炮弹轨迹计算）\n  1881→    float horizontalSpeed = GeneralTool.CannonSpeed(\n  1882→        upForce,\n  1883→        0f,\n  1884→        gravity,\n  1885→        Vector3.Distance(transform.position, targetPos)\n  1886→    );\n  1887→\n  1888→    // 应用速度\n  1889→    Rigid.linearVelocity = ToPointDir(targetPos) * horizontalSpeed;\n  1890→\n  1891→    // 同步到DOTS\n  1892→    PhysicsVelocity componentData2 = GetComponentData<PhysicsVelocity>();\n  1893→    componentData2.Linear = Rigid.linearVelocity;\n  1894→    SetComponentData(componentData2);\n  1895→\n  1896→    // 开始跳跃\n  1897→    JumpStart_Dots(upForce, gravity);\n  1898→\n  1899→    state = UnitState.Jump;\n  1900→}\n  1901→\n  1902→// 出生跳跃（固定速度）\n  1903→public void BornJump(Vector3 forwardForce, float upForce, float gravity)\n  1904→{\n  1905→    Rigid.linearVelocity = forwardForce;\n  1906→\n  1907→    PhysicsVelocity componentData = GetComponentData<PhysicsVelocity>();\n  1908→    componentData.Linear = Rigid.linearVelocity;\n  1909→    SetComponentData(componentData);\n  1910→\n  1911→    JumpStart_Dots(upForce, gravity);\n  1912→\n  1913→    UnitProperty_Dots componentData2 = GetComponentData<UnitProperty_Dots>();\n  1914→    componentData2.FlyRegister();\n  1915→    SetComponentData(componentData2);\n  1916→\n  1917→    state = UnitState.Fly;\n  1918→}\n  1919→```\n  1920→\n  1921→**跳跃物理系统（DOTS）**：\n  1922→```csharp\n  1923→[BurstCompile]\n  1924→public partial struct UnitJumpSystem : ISystem\n  1925→{\n  1926→    [BurstCompile]\n  1927→    public void OnUpdate(ref SystemState state)\n  1928→    {\n  1929→        float deltaTime = SystemAPI.Time.DeltaTime;\n  1930→\n  1931→        foreach (var (baseData, transform, velocity) in\n  1932→                 SystemAPI.Query<RefRW<UnitBase_Dots>,\n  1933→                                RefRW<LocalTransform>,\n  1934→                                RefRW<PhysicsVelocity>>())\n  1935→        {\n  1936→            if (baseData.ValueRO.isJumping)\n  1937→            {\n  1938→                // 应用垂直速度\n  1939→                velocity.ValueRW.Linear.z = baseData.ValueRO.jumpUpForce;\n  1940→\n  1941→                // 应用重力\n  1942→                baseData.ValueRW.jumpUpForce += baseData.ValueRO.jumpGravity * deltaTime;\n  1943→\n  1944→                // 落地检测\n  1945→                if (transform.ValueRO.Position.z <= 0f && baseData.ValueRO.jumpUpForce < 0f)\n  1946→                {\n  1947→                    // 落地，停止跳跃\n  1948→                    transform.ValueRW.Position.z = 0f;\n  1949→                    velocity.ValueRW.Linear.z = 0f;\n  1950→                    baseData.ValueRW.isJumping = false;\n  1951→                }\n  1952→            }\n  1953→        }\n  1954→    }\n  1955→}\n  1956→```\n  1957→\n  1958→---\n  1959→\n  1960→## 10. 召唤物系统\n  1961→\n  1962→### 10.1 召唤物管理\n  1963→\n  1964→**召唤物列表**：\n  1965→```csharp\n  1966→public List<UnitProperty> mateSummonsPpts;          // 会攻击的召唤物\n  1967→public List<UnitProperty> mateSummonsNotAttackPpts; // 不攻击的召唤物\n  1968→```\n  1969→\n  1970→### 10.2 召唤物初始化\n  1971→\n  1972→```csharp\n  1973→public void SummonsInitial(SpellBase spellBase)\n  1974→{\n  1975→    SummonerSpellBase = spellBase;\n  1976→\n  1977→    // 获取基础配置\n  1978→    UnitConfig unitConfig = UnitConfig.map[myPpt.unitCfg.id];\n  1979→\n  1980→    // ====== 计算生命值 ======\n  1981→    int gainHP = 0;\n  1982→\n  1983→    // 从主人获得生命值\n  1984→    if (spellBase.SpellSummonGainOwnerHpRatio > 0f)\n  1985→    {\n  1986→        UnitBase unitBas = spellBase.ownerPpt.UnitBas;\n  1987→\n  1988→        // 特殊召唤物（Teammate5）使用自己的HP\n  1989→        if (unitBas is Teammate5 || unitBas is Teammate5FuseController)\n  1990→        {\n  1991→            gainHP = Mathf.CeilToInt(\n  1992→                spellBase.ownerPpt.unitCfg.maxHP *\n  1993→                spellBase.SpellSummonGainOwnerHpRatio\n  1994→            );\n  1995→        }\n  1996→        else\n  1997→        {\n  1998→            // 普通召唤物使用玩家的HP\n  1999→            gainHP = Mathf.CeilToInt(\n  2000→                PlayerMgr.Inst.PlayerPpt.unitCfg.maxHP *\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"067ed8d2-4080-420e-a181-e61aa0f90ffd","timestamp":"2025-12-18T11:35:14.886Z","toolUseResult":{"type":"text","file":{"filePath":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\04-单位系统详细文档.md","content":"# 单位系统详细文档\n\n## 目录\n- [1. 系统总览](#1-系统总览)\n- [2. 单位类型系统](#2-单位类型系统)\n- [3. 单位配置 UnitConfig](#3-单位配置-unitconfig)\n- [4. 单位基类 UnitBase](#4-单位基类-unitbase)\n- [5. 单位属性 UnitProperty](#5-单位属性-unitproperty)\n- [6. DOTS架构组件](#6-dots架构组件)\n- [7. 状态效果系统](#7-状态效果系统)\n- [8. AI状态机系统](#8-ai状态机系统)\n- [9. 移动与寻路系统](#9-移动与寻路系统)\n- [10. 召唤物系统](#10-召唤物系统)\n- [11. 单位生命周期](#11-单位生命周期)\n- [12. 实战案例：Monster1分析](#12-实战案例monster1分析)\n\n---\n\n## 1. 系统总览\n\n### 1.1 架构概述\n\n单位系统采用**双架构设计**：\n- **MonoBehaviour层**：负责渲染、动画、逻辑控制\n- **DOTS ECS层**：负责高性能计算（移动、物理、状态效果）\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    单位系统架构                           │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  MonoBehaviour层（渲染+逻辑）                             │\n│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │\n│  │  UnitBase    │  │ UnitProperty │  │ Monster1/2/3 │  │\n│  │  (基类)      │  │  (属性)      │  │  (具体实现)  │  │\n│  │              │  │              │  │              │  │\n│  │ - AI逻辑     │  │ - HP/Shield  │  │ - 状态机     │  │\n│  │ - 动画控制   │  │ - 状态效果   │  │ - 攻击逻辑   │  │\n│  │ - 目标搜索   │  │ - 伤害计算   │  │ - 特殊行为   │  │\n│  └──────────────┘  └──────────────┘  └──────────────┘  │\n│         │                  │                  │         │\n│         └──────────────────┼──────────────────┘         │\n│                            │                            │\n│  ════════════════════════════════════════════════════   │\n│                            │                            │\n│  DOTS ECS层（高性能计算）                                 │\n│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │\n│  │UnitBase_Dots │  │UnitProperty  │  │  ISystem     │  │\n│  │ (移动组件)   │  │    _Dots     │  │  (系统)      │  │\n│  │              │  │ (属性组件)   │  │              │  │\n│  │ - 移动向量   │  │ - 状态计时器 │  │ - 移动系统   │  │\n│  │ - 翻转控制   │  │ - 免疫计数   │  │ - 状态系统   │  │\n│  │ - 跳跃物理   │  │ - 击退向量   │  │ - 效果系统   │  │\n│  └──────────────┘  └──────────────┘  └──────────────┘  │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### 1.2 核心类关系\n\n```\nUnitConfig (配置数据)\n    ↓ 加载\nUnitBase (MonoBehaviour基类)\n    ├── UnitProperty (属性组件)\n    ├── UnitBase_Dots (DOTS移动组件)\n    ├── UnitProperty_Dots (DOTS属性组件)\n    │\n    ├── Player1 (玩家)\n    ├── Teammate1/2/3... (友方召唤物)\n    └── Monster1/2/3... (175+种敌人)\n        └── Boss1/2/3... (Boss单位)\n```\n\n---\n\n## 2. 单位类型系统\n\n### 2.1 UnitType枚举\n\n```csharp\npublic enum UnitType\n{\n    Player,              // 玩家\n    Teammate,            // 队友（会攻击）\n    TeammateNotAttack,   // 队友（不攻击）\n    Monster,             // 普通怪物\n    Elite,               // 精英怪物\n    Boss,                // Boss\n    WillAttack,          // 会攻击的单位\n    NotAttack,           // 不攻击的单位\n    Brittleness          // 易碎物（可破坏物体）\n}\n```\n\n### 2.2 阵营判定\n\n**同阵营逻辑**：\n```csharp\npublic bool IsSameCamp(UnitType unitType)\n{\n    switch (this.unitType)\n    {\n        case UnitType.Player:\n        case UnitType.Teammate:\n        case UnitType.TeammateNotAttack:\n            // 玩家阵营\n            return unitType == UnitType.Player ||\n                   unitType == UnitType.Teammate ||\n                   unitType == UnitType.TeammateNotAttack;\n\n        case UnitType.Monster:\n        case UnitType.Elite:\n        case UnitType.Boss:\n        case UnitType.WillAttack:\n            // 敌对阵营\n            return unitType == UnitType.Monster ||\n                   unitType == UnitType.Elite ||\n                   unitType == UnitType.Boss ||\n                   unitType == UnitType.WillAttack;\n\n        case UnitType.NotAttack:\n        case UnitType.Brittleness:\n            // 中立阵营\n            return unitType == UnitType.NotAttack ||\n                   unitType == UnitType.Brittleness;\n    }\n}\n```\n\n**阵营分类**：\n- **玩家阵营**：Player, Teammate, TeammateNotAttack\n- **敌对阵营**：Monster, Elite, Boss, WillAttack\n- **中立阵营**：NotAttack, Brittleness\n\n---\n\n## 3. 单位配置 UnitConfig\n\n### 3.1 配置结构\n\n```csharp\npublic struct UnitConfig\n{\n    // ====== 基础属性 ======\n    public int id;                      // 单位ID\n    public UnitType unitType;           // 单位类型\n    public float maxHP;                 // 最大生命值\n    public float currentHP;             // 当前生命值\n    public float shield;                // 护盾值\n    public float shieldTemp;            // 临时护盾\n    public float moveSpeed;             // 移动速度\n\n    // ====== 战斗属性 ======\n    public float knockbackRatio;        // 击退比例\n    public float beHitRatio;            // 受击比例\n    public float frozenTimeRatio;       // 冰冻时间比例\n\n    // ====== 免疫属性 ======\n    public bool immuneMucus;            // 免疫粘液\n    public bool immuneVenom;            // 免疫毒素\n    public bool immuneSpike;            // 免疫尖刺\n    public bool immuneAbyss;            // 免疫深渊\n\n    // ====== 物理特性 ======\n    public bool isFly;                  // 是否飞行\n    public bool isCheckStuck;           // 是否检查卡住\n    public bool theme6Reposition;       // 第6章重定位\n    public bool isSolidObj;             // 是否固体物体\n    public bool isHybirdUnit;           // 是否混合单位\n\n    // ====== 视觉表现 ======\n    public bool isBehitColor;           // 受击变色\n    public bool immediatelyBorn;        // 立即出生\n    public float bloodSplatSize;        // 血液飞溅大小\n    public CorpseType corpseType;       // 尸体类型\n    public int corpseCount;             // 尸体数量\n\n    // ====== 音效特效 ======\n    public FixedString128Bytes beHitSE;        // 受击音效\n    public FixedString128Bytes deadEF;         // 死亡特效\n    public FixedString128Bytes deadEFH;        // 和谐版死亡特效\n    public FixedString128Bytes deadPermanentEF;// 永久死亡特效\n    public BlobAssetReference<BlobArray<FixedString128Bytes>> deadSEs; // 死亡音效数组\n    public bool isDeadSE3D;             // 是否3D死亡音效\n\n    // ====== 图鉴系统 ======\n    public bool inGallery;              // 是否在图鉴中\n    public bool haveGalleryH;           // 是否有和谐版图鉴\n    public float relicShowHPUIHight;    // 遗物显示HP UI高度\n\n    // ====== 游戏进度 ======\n    public DifficultyType appearDiffi;  // 出现难度\n    public float appearChapter;         // 出现章节\n    public bool triggerDeadEvent;       // 触发死亡事件\n    public bool loadArchiveCreate;      // 加载存档创建\n}\n```\n\n### 3.2 配置加载\n\n```csharp\npublic class Initializer : DataMgr.ConfigInitializer<UnitConfig>\n{\n    public override void ApplyResult(List<UnitConfig> result)\n    {\n        list = result;\n        // 使用NativeHashMap存储，支持DOTS系统高效访问\n        map = new NativeHashMap<int, UnitConfig>(list.Count, Allocator.Persistent);\n\n        for (int i = 0; i < list.Count; i++)\n        {\n            // 和谐版特殊处理\n            if (GameMgr.IsHarmony_Static)\n            {\n                UnitConfig value = list[i];\n                value.bloodSplatSize = 0f;        // 移除血液效果\n                value.corpseType = CorpseType.None; // 移除尸体\n                value.deadPermanentEF = \"\";       // 移除永久特效\n\n                // 使用和谐版死亡特效\n                if (value.deadEFH != \"\")\n                {\n                    value.deadEF = value.deadEFH;\n                }\n\n                list[i] = value;\n            }\n\n            map.Add(list[i].id, list[i]);\n        }\n    }\n}\n```\n\n### 3.3 配置访问\n\n```csharp\n// 静态访问\npublic static NativeHashMap<int, UnitConfig> map;\npublic static List<UnitConfig> list;\n\n// 使用示例\nUnitConfig config = UnitConfig.map[unitID];\nDebug.Log($\"单位名称: {config.GetName()}\");\nDebug.Log($\"单位描述: {config.GetDesc()}\");\n```\n\n---\n\n## 4. 单位基类 UnitBase\n\n### 4.1 核心字段\n\n```csharp\npublic class UnitBase : MonoBehaviour\n{\n    // ====== 核心引用 ======\n    public UnitProperty myPpt;           // 我的属性组件\n    public UnitProperty targetPpt;       // 目标属性组件\n    public Entity targetEntity;          // 目标实体(DOTS)\n\n    // ====== 物理组件 ======\n    public Rigidbody Rigid;              // 刚体\n    public CapsuleCollider CC_Self;      // 碰撞体\n\n    // ====== 动画组件 ======\n    public Animator Anima;               // Animator动画\n    public SkeletonAnimation SAnima;     // Spine动画\n\n    // ====== 移动相关 ======\n    public Vector3 CurrentMotion;        // 当前运动向量\n    public NavInfo navInfo;              // 寻路信息\n    public int navAreaMask = -1;         // 寻路区域遮罩\n    public float moveLerp = 8f;          // 移动插值速度\n    public float moveThreshold = 0.1f;   // 移动阈值\n    public bool isMoveFlip = true;       // 是否移动翻转\n\n    // ====== AI相关 ======\n    public float checkTargetIntervalTimer; // 目标检查计时器\n\n    // ====== 召唤物管理 ======\n    public SpellBase SummonerSpellBase;     // 召唤者法术\n    public List<UnitProperty> mateSummonsPpts;         // 会攻击的召唤物\n    public List<UnitProperty> mateSummonsNotAttackPpts;// 不攻击的召唤物\n\n    // ====== 跳跃系统 ======\n    public bool baseIsJumping;           // 是否正在跳跃\n    public float baseJumpUpForce;        // 跳跃上升力\n    public float baseJumpGravity;        // 跳跃重力\n\n    // ====== 冰冻状态缓存 ======\n    private Vector3 frozenBeforeRigid;   // 冰冻前刚体速度\n    private bool frozenBeforeKinematic;  // 冰冻前运动学状态\n    private Vector3 frozenBeforeMotion;  // 冰冻前运动向量\n}\n```\n\n### 4.2 生命周期方法\n\n```csharp\n// 单次初始化（只调用一次）\npublic virtual void SingleInitial() { }\n\n// 每次生成时初始化（每次进入房间）\npublic virtual void EveryInitial() { }\n\n// 第1帧初始化\npublic virtual void Frame1Initial() { }\n\n// 第2帧初始化\npublic virtual void Frame2Initial() { }\n\n// 每帧更新\nprotected virtual void Update() { }\n\n// DOTS物理后更新\npublic virtual void AfterDotsPhysicsUpdate() { }\n```\n\n### 4.3 伤害处理钩子\n\n```csharp\n// ====== MonoBehaviour伤害钩子 ======\npublic virtual void BeforeTakeDamage(TakeDamageInfo info) { }\npublic virtual void AfterTakeDamage(TakeDamageInfo info) { }\n\n// ====== DOTS伤害钩子 ======\npublic virtual void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info) { }\npublic virtual void AfterTakeDamage_Dots(ref TakeDamageInfo_Dots info) { }\n\n// ====== 死亡钩子 ======\npublic virtual void BeforeAnnouncedDeath_Dots(ref TakeDamageInfo_Dots info) { }\npublic virtual void AfterDead(ref TakeDamageInfo_Dots info) { }\n```\n\n### 4.4 目标搜索系统\n\n```csharp\n// 获取最近的可攻击目标\npublic void GetNearestTarget(bool checkWall = false)\n{\n    switch (myPpt.unitCfg.unitType)\n    {\n        case UnitType.Player:\n        case UnitType.Teammate:\n        case UnitType.TeammateNotAttack:\n            // 玩家阵营：搜索敌对单位\n            targetEntity = LevelMgr.Inst.CurrentRoomCtrller\n                .GetNearestTargetableEntity(transform.position, checkWall);\n            break;\n\n        case UnitType.Monster:\n        case UnitType.Elite:\n        case UnitType.Boss:\n        case UnitType.WillAttack:\n            // 敌对阵营：搜索玩家/友军\n            targetEntity = LevelMgr.Inst.CurrentRoomCtrller\n                .GetNearestFriendlyEntity(transform.position, checkWall);\n            break;\n    }\n}\n\n// 优先锁定玩家\nprotected void GetNearestTargetPlayerFirst()\n{\n    if (PlayerMgr.Inst.PlayerCtrller.IsVisible)\n    {\n        targetEntity = PlayerMgr.Inst.PlayerEtt;\n    }\n    else\n    {\n        GetNearestTarget();\n    }\n}\n\n// 随机目标\nprotected void GetRandomTarget()\n{\n    switch (myPpt.unitCfg.unitType)\n    {\n        case UnitType.Player:\n        case UnitType.Teammate:\n        case UnitType.TeammateNotAttack:\n            targetPpt = LevelMgr.Inst.CurrentRoomCtrller.GetRandomTargetablePpt();\n            break;\n\n        case UnitType.Monster:\n        case UnitType.Elite:\n        case UnitType.Boss:\n        case UnitType.WillAttack:\n            targetPpt = PlayerMgr.Inst.GetRandomPpt();\n            break;\n    }\n}\n\n// 距离计算\nprotected float ToTargetDistance()\n{\n    if (!HaveTarget)\n    {\n        Debug.LogError(\"没有目标，却想获得到目标的距离？\");\n        return 1000f;\n    }\n    return Tool2D.IgnoreZDistance(transform.position, TargetPoint);\n}\n\n// 方向计算\nprotected Vector3 ToTargetDir()\n{\n    return Tool2D.IgnoreZV2ToV1Normal(TargetPoint, transform.position);\n}\n\n// 角度计算\nprotected float ToTargetDegree()\n{\n    return Tool2D.GetDegree(ToPointDir(TargetPoint));\n}\n```\n\n**目标搜索属性**：\n```csharp\npublic bool HaveTarget => targetEntity != Entity.Null;\npublic Vector3 TargetPoint\n{\n    get\n    {\n        if (targetEntity != Entity.Null)\n        {\n            LocalTransform localTransform = GetComponentData<LocalTransform>(targetEntity);\n            return localTransform.Position;\n        }\n        if (targetPpt != null)\n        {\n            return targetPpt.transform.position;\n        }\n        return Vector3.zero;\n    }\n}\n```\n\n### 4.5 移动与翻转\n\n```csharp\n// 设置移动\npublic void SetMove(Vector3 motion, bool isFlip = true)\n{\n    CurrentMotion = Tool2D.IgnoreZPoint(CurrentMotion);\n    CurrentMotion = Vector3.Lerp(CurrentMotion, motion, moveLerp * Time.deltaTime);\n\n    // 根据移动方向翻转\n    if (isFlip && isMoveFlip && myPpt.SR_Models != null)\n    {\n        SetFlip(CurrentMotion.x);\n    }\n}\n\n// 设置翻转\nprotected virtual void SetFlip(float motionX)\n{\n    if (Mathf.Abs(motionX) > 0.01f)\n    {\n        myPpt.SetFlip(motionX < 0f);\n    }\n}\n\n// SpriteRenderer翻转\npublic void SetSingleFlip(SpriteRenderer sr, bool flipX)\n{\n    sr.flipX = flipX;\n    // 同步shader参数\n    sr.material.SetFloat(GameConstManaged.shaderFlipXIndex,\n                         flipX ? -1 : 1);\n}\n\n// MeshRenderer翻转\npublic void SetMRFlip(MeshRenderer mr, bool flipX)\n{\n    mr.material.SetFloat(GameConstManaged.shaderFlipXIndex,\n                         flipX ? -1 : 1);\n}\n```\n\n### 4.6 跳跃系统\n\n```csharp\n// 开始跳跃（DOTS版本）\nprotected void JumpStart_Dots(float upForce, float gravity)\n{\n    if (!baseIsJumping)\n    {\n        baseIsJumping = true;\n        baseJumpUpForce = upForce;\n        baseJumpGravity = gravity;\n\n        // 确保Z轴归零\n        if (transform.position.z > 0f)\n        {\n            transform.position = Tool2D.IgnoreZPoint(transform.position);\n            LocalTransform componentData = GetComponentData<LocalTransform>();\n            componentData.Position = transform.position;\n            SetComponentData(componentData);\n        }\n\n        // 注册击退免疫\n        UnitProperty_Dots componentData2 = GetComponentData<UnitProperty_Dots>();\n        componentData2.ImmuneKnockbackRegister();\n        componentData2.IsVelocityDeclice = false;\n        SetComponentData(componentData2);\n    }\n}\n\n// 停止跳跃\nprotected void JumpStop_Dots()\n{\n    if (baseIsJumping)\n    {\n        baseIsJumping = false;\n        baseJumpUpForce = 0f;\n        baseJumpGravity = 0f;\n\n        // 清除Z轴速度\n        PhysicsVelocity componentData = GetComponentData<PhysicsVelocity>();\n        componentData.Linear.z = 0f;\n        SetComponentData(componentData);\n\n        // 确保位置在地面\n        transform.position = Tool2D.IgnoreZPoint(transform);\n        LocalTransform componentData2 = GetComponentData<LocalTransform>();\n        componentData2.Position = transform.position;\n        SetComponentData(componentData2);\n\n        // 取消击退免疫\n        UnitProperty_Dots componentData3 = GetComponentData<UnitProperty_Dots>();\n        componentData3.ImmuneKnockbackUnregister();\n        componentData3.IsVelocityDeclice = true;\n        SetComponentData(componentData3);\n    }\n}\n\n// 跳跃反弹\nprotected void JumpRebounce(float bounceRatio)\n{\n    baseJumpUpForce = -bounceRatio * baseJumpUpForce;\n}\n```\n\n### 4.7 冰冻系统\n\n```csharp\n// 进入冰冻状态\npublic virtual void SetFrozen()\n{\n    // 保存冰冻前状态\n    frozenBeforeRigid = Rigid.linearVelocity;\n    frozenBeforeKinematic = Rigid.isKinematic;\n    frozenBeforeMotion = CurrentMotion;\n\n    // 停止运动\n    CurrentMotion = Vector3.zero;\n    Rigid.isKinematic = true;\n    SyncDotsRigidKindmatic();\n    SyncDotsVelocity();\n\n    // 暂停动画\n    if (Anima != null)\n    {\n        Anima.speed = 0f;\n    }\n    if (SAnima != null)\n    {\n        SAnima.timeScale = 0f;\n    }\n}\n\n// 解除冰冻状态\npublic virtual void SetUnfrozen()\n{\n    // 恢复运动学状态\n    Rigid.isKinematic = frozenBeforeKinematic;\n    if (!Rigid.isKinematic)\n    {\n        Rigid.linearVelocity = frozenBeforeRigid;\n    }\n    SyncDotsRigidKindmatic();\n    SyncDotsVelocity();\n\n    // 恢复动画\n    if (Anima != null)\n    {\n        Anima.speed = 1f;\n    }\n    if (SAnima != null)\n    {\n        SAnima.timeScale = 1f;\n    }\n}\n```\n\n---\n\n## 5. 单位属性 UnitProperty\n\n### 5.1 核心字段\n\n```csharp\npublic class UnitProperty : MonoBehaviour\n{\n    // ====== 配置与标识 ======\n    public UnitConfig unitCfg;           // 单位配置\n    public Entity entity;                // DOTS实体\n\n    // ====== 层级变换 ======\n    public Transform tsf_Layer;          // 层级Transform\n    public SpriteRenderer[] SR_Models;   // 模型渲染器数组\n\n    // ====== 碰撞体 ======\n    public CapsuleCollider CC_Self;      // 自身碰撞体\n\n    // ====== 动画 ======\n    public Animator Anima;               // Animator\n    public SkeletonAnimation SAnima;     // Spine动画\n\n    // ====== 单位引用 ======\n    public UnitBase UnitBas;             // 单位基类\n\n    // ====== 状态标记 ======\n    public bool isUnitDead;              // 是否死亡\n    public bool AlreadyDead;             // 已经死亡（用于防止重复触发）\n    public bool CanTouch;                // 可以接触（用于碰撞检测）\n}\n```\n\n### 5.2 伤害接口\n\n```csharp\n// 受到伤害（简化版）\npublic void TakeDamage(float damage, UnitProperty attackerPpt)\n{\n    TakeDamageInfo info = new TakeDamageInfo\n    {\n        attacker = attackerPpt,\n        defender = this,\n        baseDamage = damage\n    };\n    TakeDamage(info);\n}\n\n// 受到伤害（完整版）\npublic void TakeDamage(TakeDamageInfo info)\n{\n    // 调用7阶段伤害计算流程\n    DamageMgr.TakeDamage(info);\n}\n\n// 受到伤害（DOTS版本）\npublic void TakeDamage_Dots(ref TakeDamageInfo_Dots info)\n{\n    DamageMgr.TakeDamage_Dots(ref info);\n}\n```\n\n### 5.3 翻转控制\n\n```csharp\npublic void SetFlip(bool flipX)\n{\n    // 翻转所有模型渲染器\n    for (int i = 0; i < SR_Models.Length; i++)\n    {\n        SR_Models[i].flipX = flipX;\n        SR_Models[i].material.SetFloat(\n            GameConstManaged.shaderFlipXIndex,\n            flipX ? -1 : 1\n        );\n    }\n}\n```\n\n---\n\n## 6. DOTS架构组件\n\n### 6.1 UnitBase_Dots（移动组件）\n\n```csharp\npublic struct UnitBase_Dots : IComponentData\n{\n    // ====== 移动相关 ======\n    public float3 targetMotion;          // 目标运动向量\n    public bool isAutoFlip;              // 是否自动翻转\n    private bool isFlip;                 // 当前翻转状态\n\n    // ====== 跳跃相关 ======\n    public bool isJumping;               // 是否正在跳跃\n    public float jumpUpForce;            // 跳跃上升力\n    public float jumpGravity;            // 跳跃重力\n\n    // 设置移动\n    public void SetMove(float3 motion, bool thisTimeShouldFlip = true)\n    {\n        targetMotion = motion;\n\n        if (isAutoFlip && thisTimeShouldFlip)\n        {\n            SetFlip(motion.x < 0f);\n        }\n    }\n\n    // 设置翻转\n    public void SetFlip(bool flip)\n    {\n        if (isFlip != flip)\n        {\n            isFlip = flip;\n            // 通知MonoBehaviour层更新\n        }\n    }\n\n    // 开始跳跃\n    public void JumpStart(float upForce, float gravity)\n    {\n        if (!isJumping)\n        {\n            isJumping = true;\n            jumpUpForce = upForce;\n            jumpGravity = gravity;\n        }\n    }\n\n    // 停止跳跃\n    public void JumpStop()\n    {\n        if (isJumping)\n        {\n            isJumping = false;\n            jumpUpForce = 0f;\n            jumpGravity = 0f;\n        }\n    }\n}\n```\n\n### 6.2 UnitProperty_Dots（属性组件）\n\n```csharp\npublic struct UnitProperty_Dots : IComponentData\n{\n    // ====== 基础属性 ======\n    public float maxHP;\n    public float currentHP;\n    public float shield;\n    public float shieldTemp;\n\n    // ====== 移动属性 ======\n    public float moveSpeed;\n    public bool IsVelocityDeclice;       // 速度是否衰减\n\n    // ====== 粘液效果 (Mucus) ======\n    public float affect_MucusHitTimer;         // 粘液受击计时器\n    public float affect_MucusMoveSpeedRatio;   // 粘液移速比例\n    public float affect_MucusSpellSpeedRatio;  // 粘液法术速度比例\n\n    // ====== 毒素效果 (Venom) ======\n    public float affect_VenomDurationTimer;    // 毒素持续计时器\n    public float affect_VenomCurrentStack;     // 当前毒素层数\n\n    // ====== 燃烧效果 (Burn) ======\n    public float affect_burnDurationTimer;     // 燃烧持续计时器\n    public float affect_burnHPRatio;           // 燃烧HP比例\n\n    // ====== 冰冻效果 (Frozen) ======\n    public UnitProperty.Affect_FrozenState FronzenState; // 冰冻状态\n    public float affect_FrozenTime;            // 冰冻时间\n\n    // ====== 虚空效果 (Void) ======\n    public Spell3129VoidExplosion.VoidExplosionData_Dots voidExplosionData;\n    public float voidEffectTimer;              // 虚空效果计时器\n\n    // ====== 深渊效果 (Abyss) ======\n    public float abyssEffectTimer;             // 深渊效果计时器\n\n    // ====== 免疫计数器系统 ======\n    private int flyCounter;                    // 飞行计数器\n    private int invincibleCounter;             // 无敌计数器\n    private int immuneKnockbackCounter;        // 击退免疫计数器\n    private int immnueMucusCounter;            // 粘液免疫计数器\n    private int immnueVenomCounter;            // 毒素免疫计数器\n    private int immuneVoidCounter;             // 虚空免疫计数器\n\n    // ====== 击退系统 ======\n    public float3 knockbackVelocity;           // 击退速度向量\n    public float knockbackDurationTimer;       // 击退持续计时器\n\n    // ====== 受击效果 ======\n    public float beHitShakeTimer;              // 受击震动计时器\n    public float beHitColorTimer;              // 受击变色计时器\n\n    // ====== 特殊状态 ======\n    public bool canTakeDamage;                 // 是否可以受伤\n    public bool isInvincible;                  // 是否无敌\n}\n```\n\n### 6.3 免疫计数器机制\n\n**设计理念**：使用计数器而非布尔值，支持多个来源同时注册/注销免疫状态\n\n```csharp\n// ====== 飞行免疫 ======\npublic void FlyRegister()\n{\n    flyCounter++;\n}\n\npublic void FlyUnregister()\n{\n    flyCounter--;\n    if (flyCounter < 0)\n    {\n        Debug.LogError(\"飞行计数器小于0！\");\n        flyCounter = 0;\n    }\n}\n\npublic bool IsFly => flyCounter > 0;\n\n// ====== 无敌免疫 ======\npublic void InvincibleRegister()\n{\n    invincibleCounter++;\n}\n\npublic void InvincibleUnregister()\n{\n    invincibleCounter--;\n    if (invincibleCounter < 0)\n    {\n        Debug.LogError(\"无敌计数器小于0！\");\n        invincibleCounter = 0;\n    }\n}\n\npublic bool IsInvincible => invincibleCounter > 0;\n\n// ====== 击退免疫 ======\npublic void ImmuneKnockbackRegister()\n{\n    immuneKnockbackCounter++;\n}\n\npublic void ImmuneKnockbackUnregister()\n{\n    immuneKnockbackCounter--;\n    if (immuneKnockbackCounter < 0)\n    {\n        Debug.LogError(\"击退免疫计数器小于0！\");\n        immuneKnockbackCounter = 0;\n    }\n}\n\npublic bool IsImmuneKnockback => immuneKnockbackCounter > 0;\n\n// ====== 粘液免疫 ======\npublic void ImmuneMucusRegister()\n{\n    immnueMucusCounter++;\n}\n\npublic void ImmuneMucusUnregister()\n{\n    immnueMucusCounter--;\n}\n\npublic bool IsImmuneMucus => immnueMucusCounter > 0;\n\n// ====== 毒素免疫 ======\npublic void ImmuneVenomRegister()\n{\n    immnueVenomCounter++;\n}\n\npublic void ImmuneVenomUnregister()\n{\n    immnueVenomCounter--;\n}\n\npublic bool IsImmuneVenom => immnueVenomCounter > 0;\n\n// ====== 虚空免疫 ======\npublic void ImmuneVoidRegister()\n{\n    immuneVoidCounter++;\n}\n\npublic void ImmuneVoidUnregister()\n{\n    immuneVoidCounter--;\n}\n\npublic bool IsImmuneVoid => immuneVoidCounter > 0;\n```\n\n**使用场景**：\n```csharp\n// 场景1：单位跳跃时注册飞行+击退免疫\nvoid StartJump()\n{\n    ppt_Dots.FlyRegister();\n    ppt_Dots.ImmuneKnockbackRegister();\n}\n\nvoid EndJump()\n{\n    ppt_Dots.FlyUnregister();\n    ppt_Dots.ImmuneKnockbackUnregister();\n}\n\n// 场景2：遗物提供永久无敌\nvoid OnRelicEquip()\n{\n    ppt_Dots.InvincibleRegister();  // 永不调用Unregister\n}\n\n// 场景3：多个技能同时提供飞行\nvoid Spell1Active()\n{\n    ppt_Dots.FlyRegister();  // 计数器 = 1\n}\n\nvoid Spell2Active()\n{\n    ppt_Dots.FlyRegister();  // 计数器 = 2\n}\n\nvoid Spell1Deactive()\n{\n    ppt_Dots.FlyUnregister(); // 计数器 = 1, 仍然飞行\n}\n\nvoid Spell2Deactive()\n{\n    ppt_Dots.FlyUnregister(); // 计数器 = 0, 结束飞行\n}\n```\n\n---\n\n## 7. 状态效果系统\n\n### 7.1 状态效果类型\n\n| 状态效果 | 英文名 | 效果说明 | 数据结构 |\n|---------|--------|---------|---------|\n| **粘液** | Mucus | 减速移动和法术速度 | MucusHitTimer, MucusMoveSpeedRatio, MucusSpellSpeedRatio |\n| **毒素** | Venom | 持续伤害，可叠加 | VenomDurationTimer, VenomCurrentStack |\n| **燃烧** | Burn | 持续伤害（基于最大HP比例） | burnDurationTimer, burnHPRatio |\n| **冰冻** | Frozen | 完全无法行动 | FronzenState, FrozenTime |\n| **虚空** | Void | 虚空爆炸标记 | voidExplosionData, voidEffectTimer |\n| **深渊** | Abyss | 深渊效果 | abyssEffectTimer |\n\n### 7.2 粘液效果 (Mucus)\n\n**效果机制**：\n- 减少移动速度\n- 减少法术发射速度\n- 受击刷新持续时间\n\n```csharp\n// 粘液数据\npublic float affect_MucusHitTimer;         // 粘液受击计时器（持续时间）\npublic float affect_MucusMoveSpeedRatio;   // 移速比例（如0.5表示减速50%）\npublic float affect_MucusSpellSpeedRatio;  // 法术速度比例\n\n// 应用粘液效果\npublic void ApplyMucusEffect(float duration, float moveSpeedRatio, float spellSpeedRatio)\n{\n    if (!IsImmuneMucus)\n    {\n        affect_MucusHitTimer = duration;\n        affect_MucusMoveSpeedRatio = moveSpeedRatio;\n        affect_MucusSpellSpeedRatio = spellSpeedRatio;\n    }\n}\n\n// 每帧更新\nvoid UpdateMucusEffect(float deltaTime)\n{\n    if (affect_MucusHitTimer > 0)\n    {\n        affect_MucusHitTimer -= deltaTime;\n\n        // 应用移速减速\n        float finalMoveSpeed = baseMoveSpeed * affect_MucusMoveSpeedRatio;\n\n        // 应用法术速度减速\n        float finalSpellSpeed = baseSpellSpeed * affect_MucusSpellSpeedRatio;\n    }\n}\n```\n\n### 7.3 毒素效果 (Venom)\n\n**效果机制**：\n- 可叠加层数\n- 每层造成持续伤害\n- 持续时间独立计算\n\n```csharp\n// 毒素数据\npublic float affect_VenomDurationTimer;    // 持续时间\npublic float affect_VenomCurrentStack;     // 当前层数\n\n// 应用毒素效果\npublic void ApplyVenomEffect(float duration, float stackToAdd)\n{\n    if (!IsImmuneVenom)\n    {\n        affect_VenomDurationTimer = duration;\n        affect_VenomCurrentStack += stackToAdd;\n\n        // 层数上限限制\n        if (affect_VenomCurrentStack > maxVenomStack)\n        {\n            affect_VenomCurrentStack = maxVenomStack;\n        }\n    }\n}\n\n// 每帧更新\nvoid UpdateVenomEffect(float deltaTime)\n{\n    if (affect_VenomDurationTimer > 0)\n    {\n        affect_VenomDurationTimer -= deltaTime;\n\n        // 造成持续伤害\n        venomDamageTimer += deltaTime;\n        if (venomDamageTimer >= venomDamageInterval)\n        {\n            venomDamageTimer = 0f;\n            float damage = venomDamagePerStack * affect_VenomCurrentStack;\n            TakeDamage_Venom(damage);\n        }\n\n        // 持续时间结束，清除毒素\n        if (affect_VenomDurationTimer <= 0)\n        {\n            affect_VenomCurrentStack = 0f;\n        }\n    }\n}\n```\n\n### 7.4 燃烧效果 (Burn)\n\n**效果机制**：\n- 基于最大HP比例造成伤害\n- 持续时间内持续燃烧\n- 有视觉火焰特效\n\n```csharp\n// 燃烧数据\npublic float affect_burnDurationTimer;     // 持续时间\npublic float affect_burnHPRatio;           // 每秒伤害比例（基于最大HP）\n\n// 应用燃烧效果\npublic void ApplyBurnEffect(float duration, float hpRatioPerSecond)\n{\n    affect_burnDurationTimer = duration;\n    affect_burnHPRatio = hpRatioPerSecond;\n}\n\n// 每帧更新\nvoid UpdateBurnEffect(float deltaTime)\n{\n    if (affect_burnDurationTimer > 0)\n    {\n        affect_burnDurationTimer -= deltaTime;\n\n        // 计算燃烧伤害\n        float damagePerFrame = maxHP * affect_burnHPRatio * deltaTime;\n        TakeDamage_Burn(damagePerFrame);\n\n        // 生成火焰特效\n        if (burnEffectTimer <= 0)\n        {\n            burnEffectTimer = burnEffectInterval;\n            SpawnBurnEffect();\n        }\n        burnEffectTimer -= deltaTime;\n    }\n}\n```\n\n### 7.5 冰冻效果 (Frozen)\n\n**效果机制**：\n- 完全停止单位行动\n- 暂停动画播放\n- 视觉冰块特效\n\n```csharp\n// 冰冻状态枚举\npublic enum Affect_FrozenState\n{\n    None,           // 无冰冻\n    Frozen,         // 冰冻中\n    Unfreezing      // 解冻中（播放解冻动画）\n}\n\n// 冰冻数据\npublic Affect_FrozenState FronzenState;\npublic float affect_FrozenTime;\n\n// 应用冰冻效果\npublic void ApplyFrozenEffect(float duration)\n{\n    float finalDuration = duration * frozenTimeRatio;  // 应用冰冻时间比例\n\n    if (FronzenState == Affect_FrozenState.None)\n    {\n        FronzenState = Affect_FrozenState.Frozen;\n        affect_FrozenTime = finalDuration;\n\n        // 调用MonoBehaviour层的冰冻方法\n        unitBase.SetFrozen();\n\n        // 生成冰块特效\n        SpawnFrozenEffect();\n    }\n    else if (FronzenState == Affect_FrozenState.Frozen)\n    {\n        // 刷新冰冻时间\n        affect_FrozenTime = Mathf.Max(affect_FrozenTime, finalDuration);\n    }\n}\n\n// 每帧更新\nvoid UpdateFrozenEffect(float deltaTime)\n{\n    if (FronzenState == Affect_FrozenState.Frozen)\n    {\n        affect_FrozenTime -= deltaTime;\n\n        if (affect_FrozenTime <= 0)\n        {\n            // 解除冰冻\n            FronzenState = Affect_FrozenState.None;\n            unitBase.SetUnfrozen();\n            DestroyFrozenEffect();\n        }\n    }\n}\n```\n\n### 7.6 虚空效果 (Void)\n\n**效果机制**：\n- 标记单位为虚空爆炸目标\n- 死亡时触发虚空爆炸\n- 爆炸造成范围伤害\n\n```csharp\n// 虚空爆炸数据（来自法术3129）\npublic struct VoidExplosionData_Dots\n{\n    public Entity casterEntity;          // 施法者实体\n    public float explosionRadius;        // 爆炸半径\n    public float explosionDamage;        // 爆炸伤害\n    public bool isMarked;                // 是否被标记\n}\n\n// 虚空数据\npublic VoidExplosionData_Dots voidExplosionData;\npublic float voidEffectTimer;\n\n// 应用虚空效果\npublic void ApplyVoidEffect(Entity caster, float radius, float damage, float duration)\n{\n    if (!IsImmuneVoid)\n    {\n        voidExplosionData.casterEntity = caster;\n        voidExplosionData.explosionRadius = radius;\n        voidExplosionData.explosionDamage = damage;\n        voidExplosionData.isMarked = true;\n        voidEffectTimer = duration;\n\n        // 生成虚空标记特效\n        SpawnVoidMarkEffect();\n    }\n}\n\n// 单位死亡时触发\npublic void OnDeath()\n{\n    if (voidExplosionData.isMarked)\n    {\n        // 触发虚空爆炸\n        TriggerVoidExplosion();\n    }\n}\n\nvoid TriggerVoidExplosion()\n{\n    // 查找范围内所有单位\n    List<UnitProperty> unitsInRange = FindUnitsInRadius(\n        transform.position,\n        voidExplosionData.explosionRadius\n    );\n\n    // 对每个单位造成伤害\n    foreach (var unit in unitsInRange)\n    {\n        TakeDamageInfo_Dots damageInfo = new TakeDamageInfo_Dots\n        {\n            attackerEntity = voidExplosionData.casterEntity,\n            defenderEntity = unit.entity,\n            baseDamage = voidExplosionData.explosionDamage,\n            damageType = DamageType.VoidExplosion\n        };\n\n        unit.TakeDamage_Dots(ref damageInfo);\n    }\n\n    // 生成爆炸特效\n    SpawnVoidExplosionEffect();\n}\n```\n\n### 7.7 深渊效果 (Abyss)\n\n**效果机制**：\n- 深渊伤害（特殊伤害类型）\n- 可能有特殊的视觉效果\n\n```csharp\n// 深渊数据\npublic float abyssEffectTimer;\n\n// 应用深渊效果\npublic void ApplyAbyssEffect(float duration)\n{\n    if (!unitCfg.immuneAbyss)\n    {\n        abyssEffectTimer = duration;\n        // 深渊效果逻辑\n    }\n}\n```\n\n### 7.8 状态效果优先级与叠加规则\n\n**优先级**（从高到低）：\n1. **冰冻** - 完全控制单位，阻止所有行动\n2. **击退** - 短暂失去控制\n3. **粘液** - 减速效果\n4. **毒素/燃烧** - 持续伤害，不影响行动\n5. **虚空/深渊** - 标记效果，不影响行动\n\n**叠加规则**：\n- **冰冻**：不可叠加，只刷新持续时间\n- **粘液**：不可叠加，每次受击刷新持续时间\n- **毒素**：可叠加层数，持续时间独立\n- **燃烧**：不可叠加，刷新持续时间\n- **虚空**：可多次标记，独立触发\n- **击退**：可叠加，向量累加\n\n---\n\n## 8. AI状态机系统\n\n### 8.1 状态机概述\n\n每个敌人单位都有一个状态机控制其行为，状态机由**状态枚举**和**状态更新方法**组成。\n\n### 8.2 Monster1状态机（示例）\n\n```csharp\npublic enum UnitState\n{\n    BornIdle,           // 出生待机\n    Idle,               // 待机\n    IdleWalk,           // 闲逛\n    MoveToTarget,       // 移动到目标\n    Attack,             // 攻击\n    PermanentAttack,    // 持续攻击\n    LongAttackAfter,    // 长攻击后\n    Fly,                // 飞行\n    JumpPrepare,        // 跳跃准备\n    Jump                // 跳跃\n}\n```\n\n### 8.3 状态机流程图\n\n```\n          出生\n           ↓\n      [BornIdle]\n           ↓\n       首次初始化\n           ↓\n        [Idle] ←───────┐\n           ↓           │\n    是否有目标？         │\n      ↙     ↘         │\n    是       否        │\n     ↓       ↓        │\n[MoveToTarget] [IdleWalk]\n     ↓                │\n  到达攻击范围？        │\n     ↓                │\n  [Attack] ───────────┘\n     ↓\n  攻击完成\n     ↓\n   [Idle]\n\n\n  特殊状态转换：\n\n  任意状态 → [JumpPrepare] → [Jump] → [Idle]\n            (跳跃检查)      (落地)\n\n  [Attack] → [PermanentAttack] → [LongAttackAfter] → [Idle]\n           (长攻击动画)        (攻击后摇)\n```\n\n### 8.4 状态更新逻辑\n\n```csharp\nprotected override void Update()\n{\n    base.Update();\n\n    // 死亡或冰冻时不更新AI\n    if (myPpt.isUnitDead || myPpt.IsFrozen)\n        return;\n\n    switch (state)\n    {\n        case UnitState.BornIdle:\n            UpdateBornIdle();\n            break;\n\n        case UnitState.Idle:\n            UpdateIdle();\n            break;\n\n        case UnitState.IdleWalk:\n            UpdateIdleWalk();\n            break;\n\n        case UnitState.MoveToTarget:\n            UpdateMoveToTarget();\n            break;\n\n        case UnitState.Attack:\n            UpdateAttack();\n            break;\n\n        case UnitState.PermanentAttack:\n            UpdatePermanentAttack();\n            break;\n\n        case UnitState.Jump:\n            UpdateJump();\n            break;\n    }\n\n    // 跳跃检查（可在任何状态触发）\n    JumpCheck();\n}\n```\n\n### 8.5 状态实现示例\n\n#### 8.5.1 出生待机 (BornIdle)\n\n```csharp\nvoid UpdateBornIdle()\n{\n    // 等待出生动画播放完毕\n    if (bornIdleTimer >= bornIdleDuration)\n    {\n        state = UnitState.Idle;\n        PlayAnimation(\"Idle\");\n    }\n\n    bornIdleTimer += Time.deltaTime;\n}\n```\n\n#### 8.5.2 待机 (Idle)\n\n```csharp\nvoid UpdateIdle()\n{\n    idleTimer += Time.deltaTime;\n\n    // 搜索目标\n    GetNearestTargetWithTimer();\n\n    // 有目标 → 移动到目标\n    if (HaveTarget)\n    {\n        state = UnitState.MoveToTarget;\n        PlayAnimation(\"Walk\");\n    }\n    // 无目标且等待足够时间 → 闲逛\n    else if (idleTimer >= idleDuration.result)\n    {\n        idleTimer = 0f;\n        idleDuration.RandomResult();\n        state = UnitState.IdleWalk;\n\n        // 随机选择闲逛目标点\n        idleWalkTargetPoint = GetRandomPointInRange(5f);\n        PlayAnimation(\"Walk\");\n    }\n}\n```\n\n#### 8.5.3 闲逛 (IdleWalk)\n\n```csharp\nvoid UpdateIdleWalk()\n{\n    // 获取导航路径\n    GetNavInfoWithTimer(idleWalkTargetPoint);\n\n    // 沿路径移动\n    if (!navInfo.allCornerArrived)\n    {\n        Vector3 moveDir = ToPointDir(navInfo.corners[navInfo.currentCornerIndex]);\n        SetMove(moveDir * myPpt.unitCfg.moveSpeed);\n        CheckNavInfo();\n    }\n    else\n    {\n        // 到达目标点 → 返回待机\n        state = UnitState.Idle;\n        PlayAnimation(\"Idle\");\n    }\n\n    // 发现目标 → 移动到目标\n    GetNearestTargetWithTimer();\n    if (HaveTarget)\n    {\n        state = UnitState.MoveToTarget;\n    }\n}\n```\n\n#### 8.5.4 移动到目标 (MoveToTarget)\n\n```csharp\nvoid UpdateMoveToTarget()\n{\n    // 目标丢失 → 返回待机\n    if (!HaveTarget)\n    {\n        state = UnitState.Idle;\n        PlayAnimation(\"Idle\");\n        return;\n    }\n\n    // 更新目标位置\n    targetLastPosition = TargetPoint;\n\n    // 计算距离\n    float distance = ToTargetDistance();\n\n    // 到达攻击范围 → 攻击\n    if (distance <= attackRange)\n    {\n        state = UnitState.Attack;\n\n        // 根据AI模式选择攻击动画\n        if (pattern == AIPattern.Pattern2 || pattern == AIPattern.Pattern3)\n        {\n            PlayAnimation(\"Attack\");\n        }\n        else if (pattern == AIPattern.Pattern5)\n        {\n            PlayAnimation(\"LongAttackBefore\");\n        }\n\n        SetMove(Vector3.zero);  // 停止移动\n        return;\n    }\n\n    // 获取导航路径\n    GetNavInfoWithTimer(targetLastPosition);\n\n    // 沿路径移动\n    if (!navInfo.allCornerArrived)\n    {\n        Vector3 moveDir = ToPointDir(navInfo.corners[navInfo.currentCornerIndex]);\n        SetMove(moveDir * myPpt.unitCfg.moveSpeed);\n        CheckNavInfo();\n    }\n}\n```\n\n#### 8.5.5 攻击 (Attack)\n\n```csharp\nvoid UpdateAttack()\n{\n    // 攻击状态由动画事件驱动，不在Update中处理\n    // 动画事件会调用OnAnimationEvent方法\n}\n\n// 动画事件回调\npublic override void OnAnimationEvent(string animaName)\n{\n    switch (animaName)\n    {\n        case \"Attack\":\n            // 发射法术\n            if (HaveTarget)\n            {\n                ShootSpellAtTarget();\n            }\n            break;\n\n        case \"AttackFinish\":\n            // 攻击完成 → 返回待机\n            state = UnitState.Idle;\n            PlayAnimation(\"Idle\");\n            break;\n\n        case \"LongAttackBeforeFinish\":\n            // 长攻击前摇完成 → 进入持续攻击\n            state = UnitState.PermanentAttack;\n            PlayAnimation(\"LongAttack\");\n            break;\n\n        case \"LongAttackOverFinish\":\n            // 长攻击完成 → 返回待机\n            state = UnitState.Idle;\n            PlayAnimation(\"Idle\");\n            break;\n    }\n}\n```\n\n#### 8.5.6 跳跃 (Jump)\n\n```csharp\nvoid UpdateJump()\n{\n    // 跳跃由物理系统控制\n    // 落地时通过碰撞检测触发\n}\n\nvoid OnCollisionEnter(Collision collision)\n{\n    if (state == UnitState.Jump && collision.gameObject.layer == GameConst.Layer_Ground)\n    {\n        // 落地\n        JumpStop_Dots();\n\n        // 落地特效\n        SpawnLandingEffect();\n\n        // 返回待机\n        state = UnitState.Idle;\n        PlayAnimation(\"Idle\");\n\n        // 更新腿部动画\n        for (int i = 0; i < legs.Length; i++)\n        {\n            legs[i].SetIdle();\n        }\n    }\n}\n```\n\n### 8.6 跳跃检查机制\n\n```csharp\npublic void JumpCheck()\n{\n    // 只有特定AI模式才会跳跃\n    if (pattern == AIPattern.Pattern4 ||\n        pattern == AIPattern.Pattern5 ||\n        pattern == AIPattern.Pattern7 ||\n        pattern == AIPattern.Pattern8)\n    {\n        jumpCheckTimer += Time.deltaTime;\n\n        if (jumpCheckTimer > jumpCheckTime.result)\n        {\n            jumpCheckTimer = 0f;\n            jumpCheckTime.RandomResult();\n\n            // 进入跳跃准备状态\n            state = UnitState.JumpPrepare;\n            PlayAnimation(\"JumpPrepare\");\n        }\n    }\n}\n```\n\n### 8.7 AI模式 (AIPattern)\n\n```csharp\npublic enum AIPattern\n{\n    Pattern1,  // 近战普通攻击\n    Pattern2,  // 远程单发攻击\n    Pattern3,  // 远程快速攻击\n    Pattern4,  // 跳跃攻击\n    Pattern5,  // 跳跃+毒素攻击\n    Pattern6,  // 双向同时射击\n    Pattern7,  // 跳跃变体1\n    Pattern8,  // 双向分散射击\n    Pattern9   // 三向散射\n}\n```\n\n**不同AI模式的射击逻辑**：\n\n```csharp\nvoid ShootSpellAtTarget()\n{\n    UnitSpellModifier sSPModifier = UnitBase.GetSSPModifier(in ssp);\n\n    switch (pattern)\n    {\n        case AIPattern.Pattern2:\n        case AIPattern.Pattern3:\n            // 单发射击\n            sSPModifier.Direction = ToTargetDir();\n            sSPModifier.SpawnPosition = transform.position + new Vector3(0f, 0f, -spellHeight);\n            sSPModifier.ApplyToSSP(ref ssp);\n            ShootSpell(ssp);\n            break;\n\n        case AIPattern.Pattern6:\n            // 双向同时射击（左右各一发）\n            sSPModifier.Direction = ToTargetDir();\n            sSPModifier.SpawnPosition = transform.position +\n                                       new Vector3(0f, 0f, -spellHeight) +\n                                       ToTargetDir(-90f) * bulletOffset;\n            sSPModifier.ApplyToSSP(ref ssp);\n            ShootSpell(ssp);\n\n            sSPModifier.SpawnPosition = transform.position +\n                                       new Vector3(0f, 0f, -spellHeight) +\n                                       ToTargetDir(90f) * bulletOffset;\n            sSPModifier.ApplyToSSP(ref ssp);\n            ShootSpell(ssp);\n            break;\n\n        case AIPattern.Pattern8:\n            // 双向分散射击（±5度）\n            sSPModifier.Direction = ToTargetDir(-5f);\n            sSPModifier.SpawnPosition = transform.position + new Vector3(0f, 0f, -spellHeight);\n            sSPModifier.ApplyToSSP(ref ssp);\n            ShootSpell(ssp);\n\n            sSPModifier.Direction = ToTargetDir(5f);\n            sSPModifier.SpawnPosition = transform.position + new Vector3(0f, 0f, -spellHeight);\n            sSPModifier.ApplyToSSP(ref ssp);\n            ShootSpell(ssp);\n            break;\n\n        case AIPattern.Pattern9:\n            // 三向散射（0度, 120度, 240度）\n            for (int i = 0; i < 3; i++)\n            {\n                float angle = i * 120f;\n                sSPModifier.Direction = ToTargetDir(angle);\n                sSPModifier.SpawnPosition = transform.position +\n                                           new Vector3(0f, 0f, -spellHeight) +\n                                           ToTargetDir(angle) * bulletOffset;\n                sSPModifier.ApplyToSSP(ref ssp);\n                ShootSpell(ssp);\n            }\n            break;\n    }\n}\n```\n\n---\n\n## 9. 移动与寻路系统\n\n### 9.1 NavMesh寻路\n\n**NavInfo结构**：\n```csharp\npublic struct NavInfo\n{\n    public Vector3[] corners;           // 路径拐点数组\n    public int currentCornerIndex;      // 当前拐点索引\n    public bool allCornerArrived;       // 是否到达所有拐点\n}\n```\n\n**获取导航路径**：\n```csharp\npublic void GetNavInfo(Vector3 targetPoint)\n{\n    // 使用NavMesh计算路径\n    NavMeshPath navMeshPath = Tool2D.GetNavMeshPath(\n        transform.position,\n        targetPoint,\n        navAreaMask\n    );\n\n    navInfo.corners = navMeshPath.corners;\n    navInfo.currentCornerIndex = 0;\n    navInfo.allCornerArrived = false;\n\n    CheckNavInfo();\n}\n\n// 带定时器的版本（避免每帧计算）\npublic void GetNavInfoWithTimer(Vector3 targetPoint)\n{\n    if (navInfo.corners == null)\n    {\n        GetNavInfo(targetPoint);\n    }\n\n    checkTargetIntervalTimer += Time.deltaTime;\n    if (checkTargetIntervalTimer > 0.1f)\n    {\n        checkTargetIntervalTimer = 0f;\n        GetNavInfo(targetPoint);\n    }\n}\n```\n\n**检查路径拐点**：\n```csharp\npublic void CheckNavInfo()\n{\n    for (int i = navInfo.currentCornerIndex; i < navInfo.corners.Length; i++)\n    {\n        // 计算到当前拐点的距离\n        float distanceSqr = (Tool2D.IgnoreZPoint(transform.position) -\n                            Tool2D.IgnoreZPoint(navInfo.corners[i])).sqrMagnitude;\n\n        // 到达拐点\n        if (distanceSqr < moveThreshold * moveThreshold)\n        {\n            navInfo.currentCornerIndex++;\n\n            // 到达最后一个拐点\n            if (navInfo.currentCornerIndex == navInfo.corners.Length)\n            {\n                navInfo.allCornerArrived = true;\n                navInfo.currentCornerIndex = navInfo.corners.Length - 1;\n            }\n        }\n        else\n        {\n            break;  // 未到达当前拐点，停止检查\n        }\n    }\n}\n```\n\n**沿路径移动**：\n```csharp\nvoid MoveAlongPath()\n{\n    if (!navInfo.allCornerArrived)\n    {\n        // 获取当前目标拐点\n        Vector3 targetCorner = navInfo.corners[navInfo.currentCornerIndex];\n\n        // 计算移动方向\n        Vector3 moveDir = ToPointDir(targetCorner);\n\n        // 应用移动\n        SetMove(moveDir * myPpt.unitCfg.moveSpeed);\n\n        // 检查是否到达拐点\n        CheckNavInfo();\n    }\n    else\n    {\n        // 到达目的地，停止移动\n        SetMove(Vector3.zero);\n    }\n}\n```\n\n### 9.2 NavMesh区域遮罩\n\n```csharp\n// 设置导航区域遮罩\npublic void SetNavMeshArea(int layer)\n{\n    navAreaMask = layer;\n}\n\n// 使用示例\n// -1 = 所有区域\n// GameConst.NavMesh_Ground = 只在地面区域\n// GameConst.NavMesh_Air = 只在空中区域\nSetNavMeshArea(-1);  // 使用所有区域\n```\n\n### 9.3 DOTS移动系统\n\n**UnitBase_Dots移动逻辑**：\n```csharp\n// 设置移动（DOTS版本）\npublic void SetMove(float3 motion, bool thisTimeShouldFlip = true)\n{\n    targetMotion = motion;\n\n    if (isAutoFlip && thisTimeShouldFlip)\n    {\n        SetFlip(motion.x < 0f);\n    }\n}\n\n// ISystem更新移动\n[BurstCompile]\npublic partial struct UnitMoveSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        float deltaTime = SystemAPI.Time.DeltaTime;\n\n        foreach (var (baseData, pptData, transform, velocity) in\n                 SystemAPI.Query<RefRW<UnitBase_Dots>,\n                                RefRO<UnitProperty_Dots>,\n                                RefRW<LocalTransform>,\n                                RefRW<PhysicsVelocity>>())\n        {\n            // 应用粘液减速\n            float moveSpeedRatio = pptData.ValueRO.affect_MucusMoveSpeedRatio;\n            if (moveSpeedRatio == 0f)\n                moveSpeedRatio = 1f;\n\n            // 计算最终速度\n            float3 finalMotion = baseData.ValueRO.targetMotion * moveSpeedRatio;\n\n            // 应用到物理速度\n            velocity.ValueRW.Linear.xy = finalMotion.xy;\n\n            // 速度衰减\n            if (pptData.ValueRO.IsVelocityDeclice)\n            {\n                velocity.ValueRW.Linear *= 0.9f;\n            }\n        }\n    }\n}\n```\n\n### 9.4 跳跃物理\n\n```csharp\n// 普通跳跃\npublic void NormalJump(Vector3 forwardForce, float upForce, float gravity)\n{\n    // 注册飞行状态\n    UnitProperty_Dots componentData = GetComponentData<UnitProperty_Dots>();\n    componentData.FlyRegister();\n    SetComponentData(componentData);\n\n    // 获取目标点\n    GetNearestTarget();\n    Vector3 targetPos = HaveTarget ?\n        Tool2D.GetNavMeshPointIngoreZ(transform.position + forwardForce) :\n        Tool2D.GetNavMeshPointIngoreZ(transform.position + forwardForce.normalized);\n\n    // 计算水平速度（炮弹轨迹计算）\n    float horizontalSpeed = GeneralTool.CannonSpeed(\n        upForce,\n        0f,\n        gravity,\n        Vector3.Distance(transform.position, targetPos)\n    );\n\n    // 应用速度\n    Rigid.linearVelocity = ToPointDir(targetPos) * horizontalSpeed;\n\n    // 同步到DOTS\n    PhysicsVelocity componentData2 = GetComponentData<PhysicsVelocity>();\n    componentData2.Linear = Rigid.linearVelocity;\n    SetComponentData(componentData2);\n\n    // 开始跳跃\n    JumpStart_Dots(upForce, gravity);\n\n    state = UnitState.Jump;\n}\n\n// 出生跳跃（固定速度）\npublic void BornJump(Vector3 forwardForce, float upForce, float gravity)\n{\n    Rigid.linearVelocity = forwardForce;\n\n    PhysicsVelocity componentData = GetComponentData<PhysicsVelocity>();\n    componentData.Linear = Rigid.linearVelocity;\n    SetComponentData(componentData);\n\n    JumpStart_Dots(upForce, gravity);\n\n    UnitProperty_Dots componentData2 = GetComponentData<UnitProperty_Dots>();\n    componentData2.FlyRegister();\n    SetComponentData(componentData2);\n\n    state = UnitState.Fly;\n}\n```\n\n**跳跃物理系统（DOTS）**：\n```csharp\n[BurstCompile]\npublic partial struct UnitJumpSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        float deltaTime = SystemAPI.Time.DeltaTime;\n\n        foreach (var (baseData, transform, velocity) in\n                 SystemAPI.Query<RefRW<UnitBase_Dots>,\n                                RefRW<LocalTransform>,\n                                RefRW<PhysicsVelocity>>())\n        {\n            if (baseData.ValueRO.isJumping)\n            {\n                // 应用垂直速度\n                velocity.ValueRW.Linear.z = baseData.ValueRO.jumpUpForce;\n\n                // 应用重力\n                baseData.ValueRW.jumpUpForce += baseData.ValueRO.jumpGravity * deltaTime;\n\n                // 落地检测\n                if (transform.ValueRO.Position.z <= 0f && baseData.ValueRO.jumpUpForce < 0f)\n                {\n                    // 落地，停止跳跃\n                    transform.ValueRW.Position.z = 0f;\n                    velocity.ValueRW.Linear.z = 0f;\n                    baseData.ValueRW.isJumping = false;\n                }\n            }\n        }\n    }\n}\n```\n\n---\n\n## 10. 召唤物系统\n\n### 10.1 召唤物管理\n\n**召唤物列表**：\n```csharp\npublic List<UnitProperty> mateSummonsPpts;          // 会攻击的召唤物\npublic List<UnitProperty> mateSummonsNotAttackPpts; // 不攻击的召唤物\n```\n\n### 10.2 召唤物初始化\n\n```csharp\npublic void SummonsInitial(SpellBase spellBase)\n{\n    SummonerSpellBase = spellBase;\n\n    // 获取基础配置\n    UnitConfig unitConfig = UnitConfig.map[myPpt.unitCfg.id];\n\n    // ====== 计算生命值 ======\n    int gainHP = 0;\n\n    // 从主人获得生命值\n    if (spellBase.SpellSummonGainOwnerHpRatio > 0f)\n    {\n        UnitBase unitBas = spellBase.ownerPpt.UnitBas;\n\n        // 特殊召唤物（Teammate5）使用自己的HP\n        if (unitBas is Teammate5 || unitBas is Teammate5FuseController)\n        {\n            gainHP = Mathf.CeilToInt(\n                spellBase.ownerPpt.unitCfg.maxHP *\n                spellBase.SpellSummonGainOwnerHpRatio\n            );\n        }\n        else\n        {\n            // 普通召唤物使用玩家的HP\n            gainHP = Mathf.CeilToInt(\n                PlayerMgr.Inst.PlayerPpt.unitCfg.maxHP *","numLines":2000,"startLine":1,"totalLines":3200}}}
{"parentUuid":"067ed8d2-4080-420e-a181-e61aa0f90ffd","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0143U7qSjBQVbxCZdc1JPwmt","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我读取AI战斗逻辑文档的更多内容："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":86914,"cache_read_input_tokens":61978,"cache_creation":{"ephemeral_5m_input_tokens":86914,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"94115bf8-6468-4e50-9c8a-7110fab50502","timestamp":"2025-12-18T11:35:26.493Z"}
{"parentUuid":"94115bf8-6468-4e50-9c8a-7110fab50502","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0143U7qSjBQVbxCZdc1JPwmt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GqCz2FzAjbb7WYRjtLFvtv","name":"Read","input":{"file_path":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\05-AI战斗逻辑详细文档.md","limit":2000,"offset":1}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":86914,"cache_read_input_tokens":61978,"cache_creation":{"ephemeral_5m_input_tokens":86914,"ephemeral_1h_input_tokens":0},"output_tokens":157,"service_tier":"standard"}},"type":"assistant","uuid":"9fdcfae3-6273-4ad3-a375-2d7d3f5a9b05","timestamp":"2025-12-18T11:35:27.598Z"}
{"parentUuid":"30a3a8c0-eaee-47f7-8d60-a828672ad374","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GqCz2FzAjbb7WYRjtLFvtv","type":"tool_result","content":"     1→# AI战斗逻辑详细文档\n     2→\n     3→## 目录\n     4→- [1. 系统总览](#1-系统总览)\n     5→- [2. AI模式系统 (AIPattern)](#2-ai模式系统-aipattern)\n     6→- [3. 状态机架构](#3-状态机架构)\n     7→- [4. 普通怪物AI (Monster)](#4-普通怪物ai-monster)\n     8→- [5. 精英怪物AI (Elite)](#5-精英怪物ai-elite)\n     9→- [6. Boss AI系统](#6-boss-ai系统)\n    10→- [7. 目标选择策略](#7-目标选择策略)\n    11→- [8. 攻击决策系统](#8-攻击决策系统)\n    12→- [9. 移动行为模式](#9-移动行为模式)\n    13→- [10. 实战案例分析](#10-实战案例分析)\n    14→\n    15→---\n    16→\n    17→## 1. 系统总览\n    18→\n    19→### 1.1 AI层级结构\n    20→\n    21→```\n    22→              AI战斗逻辑系统\n    23→                    ↓\n    24→        ┌───────────┼───────────┐\n    25→        ↓           ↓           ↓\n    26→   普通怪物      精英怪物      Boss\n    27→  (Monster)    (Elite)      (Boss)\n    28→   175+种       17种         13种\n    29→        │           │           │\n    30→        └───────────┼───────────┘\n    31→                    ↓\n    32→              共同AI组件\n    33→         ┌──────────┴──────────┐\n    34→         ↓                     ↓\n    35→    状态机系统            AI模式系统\n    36→  (State Machine)      (AIPattern)\n    37→         │                     │\n    38→         ↓                     ↓\n    39→   目标选择系统          攻击决策系统\n    40→ (Target Selection)  (Attack Decision)\n    41→         │                     │\n    42→         └──────────┬──────────┘\n    43→                    ↓\n    44→              移动行为系统\n    45→           (Movement Behavior)\n    46→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"6be2275b-0374-4da3-9ccf-d5ea37d157bf","timestamp":"2025-12-18T11:35:30.082Z","toolUseResult":{"type":"text","file":{"filePath":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\05-AI战斗逻辑详细文档.md","content":"# AI战斗逻辑详细文档\n\n## 目录\n- [1. 系统总览](#1-系统总览)\n- [2. AI模式系统 (AIPattern)](#2-ai模式系统-aipattern)\n- [3. 状态机架构](#3-状态机架构)\n- [4. 普通怪物AI (Monster)](#4-普通怪物ai-monster)\n- [5. 精英怪物AI (Elite)](#5-精英怪物ai-elite)\n- [6. Boss AI系统](#6-boss-ai系统)\n- [7. 目标选择策略](#7-目标选择策略)\n- [8. 攻击决策系统](#8-攻击决策系统)\n- [9. 移动行为模式](#9-移动行为模式)\n- [10. 实战案例分析](#10-实战案例分析)\n\n---\n\n## 1. 系统总览\n\n### 1.1 AI层级结构\n\n```\n              AI战斗逻辑系统\n                    ↓\n        ┌───────────┼───────────┐\n        ↓           ↓           ↓\n   普通怪物      精英怪物      Boss\n  (Monster)    (Elite)      (Boss)\n   175+种       17种         13种\n        │           │           │\n        └───────────┼───────────┘\n                    ↓\n              共同AI组件\n         ┌──────────┴──────────┐\n         ↓                     ↓\n    状态机系统            AI模式系统\n  (State Machine)      (AIPattern)\n         │                     │\n         ↓                     ↓\n   目标选择系统          攻击决策系统\n (Target Selection)  (Attack Decision)\n         │                     │\n         └──────────┬──────────┘\n                    ↓\n              移动行为系统\n           (Movement Behavior)\n","numLines":46,"startLine":1,"totalLines":46}}}
{"parentUuid":"6be2275b-0374-4da3-9ccf-d5ea37d157bf","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01HuzEKMJ8UpCFEkjHZSYw6k","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我也读取伤害计算系统文档："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":57812,"cache_read_input_tokens":34602,"cache_creation":{"ephemeral_5m_input_tokens":57812,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"aebf7956-9fad-4cb1-8c85-2fd42a924b01","timestamp":"2025-12-18T11:35:35.258Z"}
{"parentUuid":"aebf7956-9fad-4cb1-8c85-2fd42a924b01","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01HuzEKMJ8UpCFEkjHZSYw6k","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01V7jjpzve81QMNDvxAoyTRb","name":"Read","input":{"file_path":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\02-伤害计算系统详细.md","limit":2000,"offset":1}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":57812,"cache_read_input_tokens":34602,"cache_creation":{"ephemeral_5m_input_tokens":57812,"ephemeral_1h_input_tokens":0},"output_tokens":149,"service_tier":"standard"}},"type":"assistant","uuid":"78aef4b8-c721-445e-8e0e-92e56557c289","timestamp":"2025-12-18T11:35:36.310Z"}
{"parentUuid":"e1121c82-3ffb-419d-82ac-745bd909e2b7","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01V7jjpzve81QMNDvxAoyTRb","type":"tool_result","content":"     1→# 伤害计算系统详细文档\n     2→\n     3→## 目录\n     4→1. [系统概述](#系统概述)\n     5→2. [伤害信息结构 (TakeDamageInfo)](#伤害信息结构-takedamageinfo)\n     6→3. [伤害计算流程](#伤害计算流程)\n     7→4. [伤害预处理系统](#伤害预处理系统)\n     8→5. [受伤前处理系统](#受伤前处理系统)\n     9→6. [受伤后处理系统](#受伤后处理系统)\n    10→7. [死亡判定系统](#死亡判定系统)\n    11→8. [护盾系统](#护盾系统)\n    12→9. [暴击系统](#暴击系统)\n    13→10. [特殊伤害类型](#特殊伤害类型)\n    14→11. [伤害修正系统](#伤害修正系统)\n    15→12. [伤害公式总结](#伤害公式总结)\n    16→\n    17→---\n    18→\n    19→## 系统概述\n    20→\n    21→伤害计算系统是战斗系统的核心,负责处理所有单位受到的伤害。该系统采用**多阶段流水线架构**,每个阶段负责不同的处理逻辑。\n    22→\n    23→### 设计原则\n    24→\n    25→1. **数据驱动**: 所有伤害数据封装在 `TakeDamageInfo_Dots` 结构体中\n    26→2. **流水线处理**: 伤害信息经过多个 System 依次处理\n    27→3. **可中断性**: 任何阶段都可以将伤害标记为免疫 (`immuneDamage`)\n    28→4. **可扩展性**: 遗物/诅咒效果可以在各个阶段插入逻辑\n    29→\n    30→### 系统架构\n    31→\n    32→```\n    33→[技能碰撞]\n    34→    ↓ 创建 TakeDamageInfo_Dots\n    35→[TakeDamageInfoPreProcessSystem]   预处理伤害\n    36→    ↓ 计算暴击、应用遗物/诅咒修正\n    37→[UnitBeforeTakeDamageSystem]       受伤前处理\n    38→    ↓ 无敌帧、闪避、反弹\n    39→[UnitPropertySystem]                属性更新\n    40→    ↓ 扣除护盾和生命值\n    41→[UnitAfterTakeDamageSystem]        受伤后处理\n    42→    ↓ 击退、特效、音效\n    43→[UnitTakeDamageDeadSystem]         死亡判定\n    44→    ↓ 检查死亡、触发死亡事件\n    45→[DamageRecordSystem]               伤害记录\n    46→    ↓ 统计伤害数据\n    47→[UnitTakeDamageClearSystem]        清除伤害信息\n    48→    ↓ 清空本帧的伤害缓冲区\n    49→```\n    50→\n    51→### System 执行顺序\n    52→\n    53→**文件位置**: 各个System文件头部的 `[UpdateInGroup]` 和 `[UpdateBefore/After]` 特性\n    54→\n    55→```csharp\n    56→[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n    57→[UpdateBefore(typeof(UnitBeforeTakeDamageSystem))]\n    58→[UpdateAfter(typeof(UnitEnvironmentSystem))]\n    59→public struct TakeDamageInfoPreProcessSystem : ISystem\n    60→\n    61→[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n    62→[UpdateBefore(typeof(UnitPropertySystem))]\n    63→public struct UnitBeforeTakeDamageSystem : ISystem\n    64→\n    65→[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n    66→[UpdateAfter(typeof(UnitPropertySystem))]\n    67→[UpdateBefore(typeof(UnitTakeDamageDeadSystem))]\n    68→public struct UnitAfterTakeDamageSystem : ISystem\n    69→\n    70→[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n    71→[UpdateAfter(typeof(UnitAfterTakeDamageSystem))]\n    72→[UpdateBefore(typeof(SpellTakeDamageResultSystem))]\n    73→public class UnitTakeDamageDeadSystem : SystemBase\n    74→```\n    75→\n    76→---\n    77→\n    78→## 伤害信息结构 (TakeDamageInfo)\n    79→\n    80→**文件位置**: [TakeDamageInfo.cs](TakeDamageInfo.cs:1)\n    81→\n    82→### 数据结构\n    83→\n    84→伤害系统使用两个版本的数据结构:\n    85→- **TakeDamageInfo**: MonoBehaviour 使用的版本\n    86→- **TakeDamageInfo_Dots**: DOTS/ECS 使用的版本\n    87→\n    88→#### TakeDamageInfo (MonoBehaviour版本)\n    89→\n    90→```csharp\n    91→public class TakeDamageInfo\n    92→{\n    93→    // ========== 攻击者信息 ==========\n    94→    public AttackerType attackerType;        // 攻击者类型\n    95→    public UnitProperty attackerPpt;         // 攻击者单位属性\n    96→\n    97→    // ========== 被击者信息 ==========\n    98→    public UnitProperty beHitPpt;            // 被击者单位属性\n    99→\n   100→    // ========== 伤害数值 ==========\n   101→    public float damage;                     // 伤害值\n   102→    public float criticalChance;             // 暴击率\n   103→    public bool isCriticalDamage;            // 是否暴击\n   104→\n   105→    // ========== 击退信息 ==========\n   106→    public Vector3 knockbackForce;           // 击退力度\n   107→\n   108→    // ========== 控制标志 ==========\n   109→    public bool considerPlayerInInvincibleFrame = true;   // 是否考虑玩家无敌帧\n   110→    public bool considerUmbrella = true;                  // 是否考虑雨伞格挡\n   111→    public bool considerRelicDodge = true;                // 是否考虑遗物闪避\n   112→    public bool considerRelicOrCurseDamageRatioChange = true;  // 是否应用遗物/诅咒伤害修正\n   113→\n   114→    // ========== 特效控制 ==========\n   115→    public bool isPlayHitSE = true;          // 是否播放受击音效\n   116→    public bool isPlayDeadSE = true;         // 是否播放死亡音效\n   117→    public bool isCreateDeadEF = true;       // 是否创建死亡特效\n   118→    public bool isCreatebloodSplat = true;   // 是否创建血迹\n   119→    public bool beHitColor = true;           // 是否显示受击变色\n   120→    public bool beHitShake = true;           // 是否镜头震动\n   121→    public bool isFloatText = true;          // 是否显示浮动伤害数字\n   122→\n   123→    // ========== 特殊标志 ==========\n   124→    public bool immuneDamage;                // 是否免疫此伤害\n   125→    public bool isTargetDead;                // 目标是否死亡\n   126→    public bool isTrapDamage;                // 是否为陷阱伤害\n   127→    public bool canRebound;                  // 是否可以反弹\n   128→    public bool stopAnnouncedDeath;          // 是否阻止宣布死亡\n   129→    public bool isUndifferDamage;            // 是否为真实伤害\n   130→    public bool isPercentageDamage;          // 是否为百分比伤害\n   131→    public bool isTeammateThrough;           // 是否穿透队友\n   132→\n   133→    // ========== 伤害来源 ==========\n   134→    public SpellBase spellBase;              // 技能对象引用\n   135→\n   136→    // ========== 充能数据 ==========\n   137→    public WandPostSlotChargeData wandChargeData;  // 魔杖后置槽位充能数据\n   138→\n   139→    // ========== 伤害比例 ==========\n   140→    public float playerTakeDamageRatio = 1f;       // 玩家受伤比例\n   141→    public float teammateTakeDamageRatio = 1f;     // 队友受伤比例\n   142→\n   143→    // ========== 触发器 ==========\n   144→    public bool postSlotSpellTakeDamageTrigger = true;  // 是否触发后置槽位技能\n   145→}\n   146→```\n   147→\n   148→#### TakeDamageInfo_Dots (DOTS版本)\n   149→\n   150→**文件位置**: [TakeDamageInfo_Dots.cs](TakeDamageInfo_Dots.cs:1)\n   151→\n   152→```csharp\n   153→public struct TakeDamageInfo_Dots : IBufferElementData\n   154→{\n   155→    // ========== Entity引用 ==========\n   156→    public Entity attackerEntity;            // 攻击者Entity\n   157→    public Entity targetEntity;              // 目标Entity\n   158→\n   159→    // ========== 攻击者类型 ==========\n   160→    public AttackerType attackerType;\n   161→\n   162→    // ========== 伤害数值 ==========\n   163→    public float damage;                     // 原始伤害\n   164→    public float realDamage;                 // 实际造成的伤害(扣除护盾后)\n   165→    public float hitMagicShieldDamage;       // 击中魔法盾的伤害\n   166→\n   167→    // ========== 暴击系统 ==========\n   168→    public float extraCriticalChance;        // 额外暴击率\n   169→    public bool isDamageCritical;            // 是否暴击\n   170→\n   171→    // ========== 击退 ==========\n   172→    public float3 knockbackForce;            // 击退力(Unity.Mathematics)\n   173→\n   174→    // ========== 技能信息 ==========\n   175→    public SpellInfo spell;                  // 技能信息(DOTS版本)\n   176→\n   177→    // ========== 标志位(与MonoBehaviour版本类似) ==========\n   178→    public bool immuneDamage;\n   179→    public bool ignorePlayerInvincibleFrame;\n   180→    public bool ignoreRelicDodge;\n   181→    public bool ignoreUmbrella;\n   182→    public bool ignoreRelicOrCurseDamageRatioChange;\n   183→    public bool isTrapDamage;\n   184→    public bool isUndifferDamage;\n   185→    public bool isPercentageDamage;\n   186→    public bool isTeammateThrough;\n   187→    public bool stopAnnouncedDeath;\n   188→    public bool targetAlreadyDeadBeforeDamage;\n   189→\n   190→    // ========== 特效控制 ==========\n   191→    public bool dontCreateDeadEF;\n   192→    public bool dontCreatebloodSplat;\n   193→    public bool dontPlayDeadSE;\n   194→    public bool dontPlayHitSE;\n   195→    public bool dontPlayBeHitColor;\n   196→    public bool dontPlayBeHitShake;\n   197→    public bool dontFloatText;\n   198→\n   199→    // ========== 伤害比例 ==========\n   200→    public float playerTakeDamageRatio;\n   201→    public float teammateTakeDamageRatio;\n   202→\n   203→    // ========== 充能相关 ==========\n   204→    public bool chargeWand;                  // 是否充能魔杖\n   205→    public float chargeValue;                // 充能值\n   206→}\n   207→```\n   208→\n   209→### AttackerType 枚举\n   210→\n   211→**文件位置**: [AttackerType.cs](AttackerType.cs:1)\n   212→\n   213→```csharp\n   214→public enum AttackerType\n   215→{\n   216→    NothingSpecial,      // 普通攻击\n   217→    FromUI,              // 来自UI(点击返回营地按钮)\n   218→    FromRelic,           // 来自遗物效果\n   219→    FromCurse,           // 来自诅咒效果\n   220→    FromEnvironment,     // 来自环境(陷阱、地刺等)\n   221→    FromSpell,           // 来自技能\n   222→    FromSummon           // 来自召唤物\n   223→}\n   224→```\n   225→\n   226→---\n   227→\n   228→## 伤害计算流程\n   229→\n   230→### 完整流程图\n   231→\n   232→```\n   233→┌─────────────────────────────────────────────────┐\n   234→│ 阶段 0: 伤害信息创建                            │\n   235→│ 触发: 技能碰撞、技能持续伤害、环境伤害         │\n   236→├─────────────────────────────────────────────────┤\n   237→│ 创建 TakeDamageInfo_Dots 对象                   │\n   238→│ - attackerEntity = spell.ownerEntity            │\n   239→│ - targetEntity = hitUnit.entity                 │\n   240→│ - damage = spell.damage                         │\n   241→│ - criticalChance = spell.criticalChance         │\n   242→│ - knockbackForce = spell.knockback * direction  │\n   243→│                                                  │\n   244→│ 添加到目标Entity的 DynamicBuffer                │\n   245→│ entityMgr.GetBuffer<TakeDamageInfo_Dots>(target)│\n   246→│           .Add(damageInfo);                      │\n   247→└─────────────────────────────────────────────────┘\n   248→                    ↓\n   249→┌─────────────────────────────────────────────────┐\n   250→│ 阶段 1: 伤害预处理                              │\n   251→│ System: TakeDamageInfoPreProcessSystem          │\n   252→│ 文件: TakeDamageInfoPreProcessSystem.cs:157-336 │\n   253→├─────────────────────────────────────────────────┤\n   254→│ 1.1 检查无敌/禁用状态                           │\n   255→│   if (unitPpt.IsInvincible)                     │\n   256→│       info.immuneDamage = true                  │\n   257→│   if (unitPpt.isSolidObj && !info.isUndifferDamage)│\n   258→│       info.immuneDamage = true                  │\n   259→│                                                  │\n   260→│ 1.2 特殊技能伤害修正                            │\n   261→│   - Boss技能对队友伤害 x2~x3                    │\n   262→│   - 特定技能对玩家伤害 x0.05                    │\n   263→│                                                  │\n   264→│ 1.3 根据目标类型应用修正                        │\n   265→│   switch (unitPpt.unitType):                    │\n   266→│     case Player:                                │\n   267→│       - 检查无敌帧                              │\n   268→│       - 应用闪避遗物                            │\n   269→│       - 应用减伤遗物                            │\n   270→│       - 应用增伤诅咒                            │\n   271→│       - 应用玩家受伤比例                        │\n   272→│     case Teammate:                              │\n   273→│       - 应用队友受伤比例                        │\n   274→│     case Monster/Elite/Boss:                    │\n   275→│       - 应用敌人减伤诅咒                        │\n   276→│                                                  │\n   277→│ 1.4 暴击判定                                    │\n   278→│   if (Random.value <= criticalChance)           │\n   279→│       info.isDamageCritical = true              │\n   280→│       info.damage *= criticalDamageRatio        │\n   281→│                                                  │\n   282→│ 1.5 伤害取整                                    │\n   283→│   info.damage = ceil(info.damage)               │\n   284→└─────────────────────────────────────────────────┘\n   285→                    ↓\n   286→┌─────────────────────────────────────────────────┐\n   287→│ 阶段 2: 受伤前处理 (MonoBehaviour)              │\n   288→│ System: UnitBeforeTakeDamageSystem              │\n   289→│ 文件: UnitBeforeTakeDamageSystem.cs:255-276     │\n   290→├─────────────────────────────────────────────────┤\n   291→│ 调用 MonoBehaviour 的 BeforeTakeDamage() 方法  │\n   292→│   unitPpt.UnitBas.BeforeTakeDamage_Dots(info)   │\n   293→│                                                  │\n   294→│ 此阶段由各个单位的 UnitBase 子类实现           │\n   295→│ 常见逻辑:                                       │\n   296→│ - Boss特殊阶段判定                              │\n   297→│ - Elite特殊技能触发                             │\n   298→│ - 遗物/诅咒特殊效果                             │\n   299→└─────────────────────────────────────────────────┘\n   300→                    ↓\n   301→┌─────────────────────────────────────────────────┐\n   302→│ 阶段 3: 属性更新 (护盾和生命值扣除)            │\n   303→│ System: UnitPropertySystem                      │\n   304→│ 文件: UnitPropertySystem.cs (DOTS Job)          │\n   305→├─────────────────────────────────────────────────┤\n   306→│ 3.1 扣除护盾                                    │\n   307→│   if (shield > 0)                               │\n   308→│       damageToShield = min(damage, shield)      │\n   309→│       shield -= damageToShield                  │\n   310→│       damage -= damageToShield                  │\n   311→│       realDamage = 0                            │\n   312→│                                                  │\n   313→│ 3.2 扣除临时护盾                                │\n   314→│   if (shieldTemp > 0 && damage > 0)             │\n   315→│       damageToTempShield = min(damage, shieldTemp)│\n   316→│       shieldTemp -= damageToTempShield          │\n   317→│       damage -= damageToTempShield              │\n   318→│       realDamage += damageToTempShield          │\n   319→│                                                  │\n   320→│ 3.3 扣除生命值                                  │\n   321→│   if (damage > 0)                               │\n   322→│       currentHP -= damage                       │\n   323→│       realDamage += damage                      │\n   324→│                                                  │\n   325→│ 3.4 应用击退                                    │\n   326→│   if (!IsImmuneKnockback)                       │\n   327→│       AddForce(knockbackForce * knockbackRatio) │\n   328→│                                                  │\n   329→│ 3.5 检查死亡                                    │\n   330→│   if (currentHP <= 0)                           │\n   331→│       isDead = true                             │\n   332→└─────────────────────────────────────────────────┘\n   333→                    ↓\n   334→┌─────────────────────────────────────────────────┐\n   335→│ 阶段 4: 受伤后处理 (特效和音效)                │\n   336→│ System: UnitAfterTakeDamageSystem               │\n   337→│ 文件: UnitAfterTakeDamageSystem.cs:271-357      │\n   338→├─────────────────────────────────────────────────┤\n   339→│ 4.1 调用 MonoBehaviour 的 AfterTakeDamage()    │\n   340→│   unitPpt.UnitBas.AfterTakeDamage_Dots(info)    │\n   341→│                                                  │\n   342→│ 4.2 播放受击音效                                │\n   343→│   - 玩家: 根据外观播放不同音效                 │\n   344→│     (Huang/Dave/Frog/Normal)                    │\n   345→│   - 敌人: 播放配置的 beHitSE                    │\n   346→│                                                  │\n   347→│ 4.3 更新UI                                      │\n   348→│   - 玩家: 更新HP条                              │\n   349→│   - 玩家: 播放受击闪红动画                     │\n   350→│                                                  │\n   351→│ 4.4 触发遗物/诅咒效果                           │\n   352→│   - OnTakeDamage 事件                           │\n   353→│   - OnPlayerTakeDamage 事件                     │\n   354→└─────────────────────────────────────────────────┘\n   355→                    ↓\n   356→┌─────────────────────────────────────────────────┐\n   357→│ 阶段 5: 死亡判定                                │\n   358→│ System: UnitTakeDamageDeadSystem                │\n   359→│ 文件: UnitTakeDamageDeadSystem.cs:224-410       │\n   360→├─────────────────────────────────────────────────┤\n   361→│ 5.1 检查是否死亡                                │\n   362→│   if (!unitPpt.isDead) continue                 │\n   363→│                                                  │\n   364→│ 5.2 根据单位类型处理死亡                        │\n   365→│   switch (unitType):                            │\n   366→│     case Player:                                │\n   367→│       - 记录死亡日志                            │\n   368→│       - 显示死亡UI                              │\n   369→│       - 触发 GameOver 事件                      │\n   370→│                                                  │\n   371→│     case Teammate:                              │\n   372→│       - 添加 TeammateDeadTag 组件               │\n   373→│       - 从房间管理器注销                        │\n   374→│                                                  │\n   375→│     case Monster/Elite/Boss:                    │\n   376→│       - 掉落物品                                │\n   377→│       - 创建死亡特效                            │\n   378→│       - 播放死亡音效                            │\n   379→│       - 创建尸体                                │\n   380→│       - 创建血迹                                │\n   381→│       - 从房间管理器注销                        │\n   382→│       - 触发死亡事件                            │\n   383→│                                                  │\n   384→│ 5.3 特殊死亡效果                                │\n   385→│   - 虚空爆炸 (Spell3129VoidExplosion)           │\n   386→│   - 死亡蠕虫生成                                │\n   387→│   - 召唤物死亡爆炸                              │\n   388→└─────────────────────────────────────────────────┘\n   389→                    ↓\n   390→┌─────────────────────────────────────────────────┐\n   391→│ 阶段 6: 伤害记录                                │\n   392→│ System: DamageRecordSystem                      │\n   393→│ 文件: DamageRecordSystem.cs                     │\n   394→├─────────────────────────────────────────────────┤\n   395→│ 记录伤害到 DamageRecorder                       │\n   396→│ - 按攻击者统计总伤害                            │\n   397→│ - 按技能统计使用次数                            │\n   398→│ - 更新伤害排行榜                                │\n   399→│ - 更新UI显示                                    │\n   400→└─────────────────────────────────────────────────┘\n   401→                    ↓\n   402→┌─────────────────────────────────────────────────┐\n   403→│ 阶段 7: 清除伤害信息                            │\n   404→│ System: UnitTakeDamageClearSystem               │\n   405→│ 文件: UnitTakeDamageClearSystem.cs              │\n   406→├─────────────────────────────────────────────────┤\n   407→│ 清空所有 Entity 的 TakeDamageInfo_Dots Buffer  │\n   408→│ foreach (entity in allUnits)                    │\n   409→│     GetBuffer<TakeDamageInfo_Dots>(entity).Clear()│\n   410→└─────────────────────────────────────────────────┘\n   411→```\n   412→\n   413→---\n   414→\n   415→## 伤害预处理系统\n   416→\n   417→**文件位置**: [TakeDamageInfoPreProcessSystem.cs](TakeDamageInfoPreProcessSystem.cs:1)\n   418→\n   419→这是伤害计算的第一个阶段,负责计算最终伤害值。\n   420→\n   421→### 主要职责\n   422→\n   423→1. 检查无敌状态\n   424→2. 特殊技能伤害修正\n   425→3. 应用遗物/诅咒修正\n   426→4. 暴击判定\n   427→5. 伤害取整\n   428→\n   429→### Execute 方法解析\n   430→\n   431→**位置**: [TakeDamageInfoPreProcessSystem.cs:157-336](TakeDamageInfoPreProcessSystem.cs:157-336)\n   432→\n   433→```csharp\n   434→private void Execute(DynamicBuffer<TakeDamageInfo_Dots> takeDamageBuffer,\n   435→                     ref UnitProperty_Dots unitPpt,\n   436→                     Entity entity,\n   437→                     [ChunkIndexInQuery] int index)\n   438→{\n   439→    // 1. 检查单位是否禁用\n   440→    if (unitPpt.disabled)\n   441→        return;\n   442→\n   443→    // 获取单位位置(用于闪避文字显示)\n   444→    RefRO<LocalTransform> transform = cluLocalTsf.GetRefRO(entity);\n   445→\n   446→    // 遍历所有伤害信息\n   447→    for (int i = 0; i < takeDamageBuffer.Length; i++)\n   448→    {\n   449→        ref TakeDamageInfo_Dots info = ref takeDamageBuffer.ElementAt(i);\n   450→\n   451→        // ========== 1. 基础免疫检查 ==========\n   452→\n   453→        // 1.1 无敌状态\n   454→        if (unitPpt.IsInvincible)\n   455→        {\n   456→            info.immuneDamage = true;\n   457→        }\n   458→\n   459→        // 1.2 固体物体免疫(除非是真实伤害)\n   460→        if (unitPpt.unitCfg.isSolidObj && !info.isUndifferDamage)\n   461→        {\n   462→            info.immuneDamage = true;\n   463→        }\n   464→\n   465→        // 1.3 已经死亡\n   466→        if (unitPpt.isDead)\n   467→        {\n   468→            info.targetAlreadyDeadBeforeDamage = true;\n   469→            continue;\n   470→        }\n   471→\n   472→        // ========== 2. 特殊技能伤害修正 ==========\n   473→\n   474→        if (info.spell.Entity != Entity.Null)\n   475→        {\n   476→            int spellBaseID = info.spell.Config.Id / 10;\n   477→\n   478→            switch (spellBaseID)\n   479→            {\n   480→                // Boss技能对队友伤害 x2\n   481→                case 9002: case 9004: case 9006: case 9017: case 9045:\n   482→                    if (unitPpt.unitCfg.unitType == UnitType.Teammate ||\n   483→                        unitPpt.unitCfg.unitType == UnitType.TeammateNotAttack)\n   484→                    {\n   485→                        info.damage *= 2f;\n   486→                    }\n   487→                    break;\n   488→\n   489→                // Boss技能对队友伤害 x3\n   490→                case 9012: case 9020: case 9043:\n   491→                case 9021: case 9022: case 9026: case 9027: case 9044:\n   492→                    if (unitPpt.unitCfg.unitType == UnitType.Teammate ||\n   493→                        unitPpt.unitCfg.unitType == UnitType.TeammateNotAttack)\n   494→                    {\n   495→                        info.damage *= 3f;\n   496→                    }\n   497→                    break;\n   498→\n   499→                // Boss15技能对玩家伤害 x0.05\n   500→                case 9015:\n   501→                    if (unitPpt.unitCfg.unitType == UnitType.Player)\n   502→                    {\n   503→                        info.damage *= 0.05f;\n   504→                    }\n   505→                    break;\n   506→            }\n   507→        }\n   508→\n   509→        // ========== 3. 根据目标类型应用修正 ==========\n   510→\n   511→        switch (unitPpt.unitCfg.unitType)\n   512→        {\n   513→            case UnitType.Player:\n   514→                ProcessPlayerDamage(ref info, unitPpt, transform, index);\n   515→                break;\n   516→\n   517→            case UnitType.Teammate:\n   518→            case UnitType.TeammateNotAttack:\n   519→                ProcessTeammateDamage(ref info);\n   520→                break;\n   521→\n   522→            case UnitType.Monster:\n   523→            case UnitType.Elite:\n   524→            case UnitType.Boss:\n   525→            case UnitType.WillAttack:\n   526→            case UnitType.NotAttack:\n   527→            case UnitType.Brittleness:\n   528→                ProcessEnemyDamage(ref info);\n   529→                break;\n   530→        }\n   531→\n   532→        // ========== 4. 易伤效果 ==========\n   533→\n   534→        if (unitPpt.DamageReciveIncresePercent > 0f &&\n   535→            !info.isPercentageDamage)\n   536→        {\n   537→            info.damage *= unitPpt.DamageReciveIncresePercent;\n   538→        }\n   539→\n   540→        // ========== 5. 暴击判定 ==========\n   541→\n   542→        if (!info.isDamageCritical)\n   543→        {\n   544→            float critChance = info.extraCriticalChance;\n   545→            if (info.spell.Entity != Entity.Null)\n   546→            {\n   547→                critChance = info.spell.Config.CriticalChance;\n   548→            }\n   549→\n   550→            if (critChance > 0f &&\n   551→                DTool.RandomValue(ref gRandom.ValueRW.random) <= critChance)\n   552→            {\n   553→                info.isDamageCritical = true;\n   554→\n   555→                // 暴击伤害倍率\n   556→                if (IsPlayerAttack(info) && relic_AddCriticleDamageRatio > 0f)\n   557→                {\n   558→                    // 玩家有暴击伤害遗物\n   559→                    info.damage *= relic_AddCriticleDamageRatio;\n   560→                }\n   561→                else\n   562→                {\n   563→                    // 默认暴击伤害 x2\n   564→                    info.damage *= 2f;\n   565→                }\n   566→            }\n   567→        }\n   568→\n   569→        // ========== 6. 伤害取整 ==========\n   570→\n   571→        info.damage = (int)math.ceil(info.damage);\n   572→    }\n   573→}\n   574→```\n   575→\n   576→### 玩家伤害处理 (ProcessPlayerDamage)\n   577→\n   578→```csharp\n   579→private void ProcessPlayerDamage(ref TakeDamageInfo_Dots info,\n   580→                                  UnitProperty_Dots unitPpt,\n   581→                                  RefRO<LocalTransform> transform,\n   582→                                  int index)\n   583→{\n   584→    // 1. 特殊攻击类型: 来自UI(返回营地)\n   585→    if (info.attackerType == AttackerType.FromUI)\n   586→    {\n   587→        // 直接清空生命值和护盾\n   588→        unitPpt.unitCfg.currentHP = 0f;\n   589→        unitPpt.unitCfg.shield = 0f;\n   590→        unitPpt.unitCfg.shieldTemp = 0f;\n   591→        return;\n   592→    }\n   593→\n   594→    // 2. 无敌帧检查\n   595→    if (!info.ignorePlayerInvincibleFrame &&\n   596→        unitPpt.IsPlayerInInvincibleFrame)\n   597→    {\n   598→        info.knockbackForce = Vector3.zero;\n   599→        info.immuneDamage = true;\n   600→    }\n   601→\n   602→    // 3. 陷阱伤害加成 (诅咒: 陷阱目标)\n   603→    if (info.isTrapDamage && curse_TargetedTrapExtraDamageRatio > 0f)\n   604→    {\n   605→        info.damage *= 1f + curse_TargetedTrapExtraDamageRatio;\n   606→    }\n   607→\n   608→    // 4. 闪避检查 (遗物)\n   609→    if (relic_DodgeChance > 0f &&\n   610→        !info.ignoreRelicDodge &&\n   611→        DTool.RandomValue(ref gRandom.ValueRW.random) <= relic_DodgeChance)\n   612→    {\n   613→        info.knockbackForce = Vector3.zero;\n   614→        info.immuneDamage = true;\n   615→\n   616→        // 显示\"闪避\"浮动文字\n   617→        ecb.AppendToBuffer(index, uiTextFloatByJobEtt,\n   618→            new UITextFloatByJobBED\n   619→            {\n   620→                textID = 1002001,  // \"闪避\"\n   621→                type = UITextFloatType.Normal,\n   622→                worldPos = transform.ValueRO.Position\n   623→            });\n   624→    }\n   625→\n   626→    // 5. 减伤遗物\n   627→    if (relic_ReduceDamageRatio > 0f &&\n   628→        !info.ignoreRelicOrCurseDamageRatioChange)\n   629→    {\n   630→        info.damage *= 1f - relic_ReduceDamageRatio;\n   631→    }\n   632→\n   633→    // 6. 增伤遗物: 强者\n   634→    if (relic_PowerfulManIncreaseDamage > 0f &&\n   635→        !info.ignoreRelicOrCurseDamageRatioChange)\n   636→    {\n   637→        info.damage *= 1f + relic_PowerfulManIncreaseDamage;\n   638→    }\n   639→\n   640→    // 7. 增伤诅咒: 脆弱\n   641→    if (curse_VulnerabilityExtraDamageRatio > 0f &&\n   642→        !info.ignoreRelicOrCurseDamageRatioChange)\n   643→    {\n   644→        info.damage *= 1f + curse_VulnerabilityExtraDamageRatio;\n   645→    }\n   646→\n   647→    // 8. 增伤诅咒: 金币越多受伤越高\n   648→    if (curse_MoreMoneyMoreInjuredExtraDamageRatio > 0f &&\n   649→        !info.ignoreRelicOrCurseDamageRatioChange)\n   650→    {\n   651→        info.damage *= 1f + curse_MoreMoneyMoreInjuredExtraDamageRatio;\n   652→    }\n   653→\n   654→    // 9. 应用玩家受伤比例\n   655→    if (info.playerTakeDamageRatio != 1f)\n   656→    {\n   657→        info.damage *= info.playerTakeDamageRatio;\n   658→    }\n   659→\n   660→    // 10. 真实伤害特殊处理\n   661→    if (info.isUndifferDamage)\n   662→    {\n   663→        if (info.spell.Entity != Entity.Null)\n   664→        {\n   665→            // 限制真实伤害最多为33.33%\n   666→            info.damage *= math.min(\n   667→                info.spell.Config.UndifferDamageRatio,\n   668→                0.3333f\n   669→            );\n   670→        }\n   671→        else\n   672→        {\n   673→            info.damage *= 0.3333f;\n   674→        }\n   675→    }\n   676→}\n   677→```\n   678→\n   679→### 队友伤害处理\n   680→\n   681→```csharp\n   682→private void ProcessTeammateDamage(ref TakeDamageInfo_Dots info)\n   683→{\n   684→    // 1. 陷阱伤害加成\n   685→    if (info.isTrapDamage && curse_TargetedTrapExtraDamageRatio > 0f)\n   686→    {\n   687→        info.damage *= 1f + curse_TargetedTrapExtraDamageRatio;\n   688→    }\n   689→\n   690→    // 2. 应用队友受伤比例\n   691→    info.damage *= info.teammateTakeDamageRatio;\n   692→}\n   693→```\n   694→\n   695→### 敌人伤害处理\n   696→\n   697→```csharp\n   698→private void ProcessEnemyDamage(ref TakeDamageInfo_Dots info)\n   699→{\n   700→    // 诅咒: 敌人减伤\n   701→    if (curse_EnemyReduceDamageRatio > 0f &&\n   702→        !info.isPercentageDamage)\n   703→    {\n   704→        info.damage *= 1f - curse_EnemyReduceDamageRatio;\n   705→    }\n   706→}\n   707→```\n   708→\n   709→---\n   710→\n   711→## 受伤前处理系统\n   712→\n   713→**文件位置**: [UnitBeforeTakeDamageSystem.cs](UnitBeforeTakeDamageSystem.cs:1)\n   714→\n   715→这个系统在伤害应用前调用各个单位的 `BeforeTakeDamage_Dots` 方法,允许单位进行自定义处理。\n   716→\n   717→### OnUpdate 方法\n   718→\n   719→**位置**: [UnitBeforeTakeDamageSystem.cs:255-286](UnitBeforeTakeDamageSystem.cs:255-286)\n   720→\n   721→```csharp\n   722→public void OnUpdate(ref SystemState state)\n   723→{\n   724→    // 特殊处理: Boss6第二阶段\n   725→    bool isBoss6Stage2 = false;\n   726→    if (Boss6_Stage2.Inst != null &&\n   727→        !Boss6_Stage2.Inst.myPpt.AlreadyDead &&\n   728→        UnitDotsSyncSystem.EntityIsValid(Boss6_Stage2.Inst.myPpt.myEntity))\n   729→    {\n   730→        isBoss6Stage2 = true;\n   731→        Boss6_Stage2.Inst.takeDamageInfoBuffer =\n   732→            state.EntityManager.GetBuffer<TakeDamageInfo_Dots>(\n   733→                Boss6_Stage2.Inst.myPpt.myEntity);\n   734→    }\n   735→\n   736→    // 遍历所有有伤害信息的单位\n   737→    foreach (var (unitPptReference, damageBuffer) in Query(...))\n   738→    {\n   739→        if (damageBuffer.Length <= 0)\n   740→            continue;\n   741→\n   742→        // 遍历该单位的所有伤害信息\n   743→        for (int i = 0; i < damageBuffer.Length; i++)\n   744→        {\n   745→            // 特殊排除: 某个特定单位ID\n   746→            if (unitPptReference.unitPpt.unitCfg.id != 500621)\n   747→            {\n   748→                // 调用 MonoBehaviour 的受伤前处理\n   749→                unitPptReference.unitPpt.UnitBas.BeforeTakeDamage_Dots(\n   750→                    ref damageBuffer.ElementAt(i)\n   751→                );\n   752→            }\n   753→        }\n   754→    }\n   755→\n   756→    // Boss6特殊处理\n   757→    if (isBoss6Stage2)\n   758→    {\n   759→        DynamicBuffer<TakeDamageInfo_Dots> buffer =\n   760→            state.EntityManager.GetBuffer<TakeDamageInfo_Dots>(\n   761→                Boss6_Stage2.Inst.myPpt.myEntity);\n   762→\n   763→        for (int j = 0; j < buffer.Length; j++)\n   764→        {\n   765→            Boss6_Stage2.Inst.BeforeTakeDamage_Dots(\n   766→                ref buffer.ElementAt(j)\n   767→            );\n   768→        }\n   769→    }\n   770→}\n   771→```\n   772→\n   773→### UnitBase.BeforeTakeDamage_Dots 虚方法\n   774→\n   775→**文件位置**: [UnitBase.cs:453-455](UnitBase.cs:453-455)\n   776→\n   777→```csharp\n   778→public virtual void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n   779→{\n   780→    // 默认为空,由子类重写\n   781→    // 例如:\n   782→    // - Boss进入特殊阶段\n   783→    // - Elite触发特殊技能\n   784→    // - 遗物效果触发\n   785→}\n   786→```\n   787→\n   788→### 常见用途示例\n   789→\n   790→#### 示例 1: Boss阶段切换\n   791→\n   792→```csharp\n   793→// Boss1.cs\n   794→public override void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n   795→{\n   796→    UnitProperty_Dots ppt = GetComponentData<UnitProperty_Dots>();\n   797→\n   798→    // 当HP低于50%时进入狂暴阶段\n   799→    if (!isEnraged && ppt.unitCfg.currentHP < ppt.unitCfg.maxHP * 0.5f)\n   800→    {\n   801→        isEnraged = true;\n   802→        EnterEnragedPhase();\n   803→    }\n   804→}\n   805→```\n   806→\n   807→#### 示例 2: 遗物触发\n   808→\n   809→```csharp\n   810→// PlayerController.cs\n   811→public override void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n   812→{\n   813→    // 遗物: 受伤时获得护盾\n   814→    if (PlayerMgr.Inst.ItemCtrller.relic_ShieldOnHit != null)\n   815→    {\n   816→        float shieldAmount = info.damage * 0.2f;\n   817→        PlayerMgr.Inst.ChangeShield(shieldAmount);\n   818→    }\n   819→\n   820→    // 遗物: 受伤时触发反击\n   821→    if (PlayerMgr.Inst.ItemCtrller.relic_CounterAttack != null)\n   822→    {\n   823→        LaunchCounterAttack(info.attackerEntity);\n   824→    }\n   825→}\n   826→```\n   827→\n   828→---\n   829→\n   830→## 受伤后处理系统\n   831→\n   832→**文件位置**: [UnitAfterTakeDamageSystem.cs](UnitAfterTakeDamageSystem.cs:1)\n   833→\n   834→这个系统在伤害应用后处理特效、音效和UI更新。\n   835→\n   836→### OnUpdate 方法\n   837→\n   838→**位置**: [UnitAfterTakeDamageSystem.cs:271-357](UnitAfterTakeDamageSystem.cs:271-357)\n   839→\n   840→```csharp\n   841→public void OnUpdate(ref SystemState state)\n   842→{\n   843→    foreach (var (unitDead, unitPpt, damageBuffer, entity) in Query(...))\n   844→    {\n   845→        if (damageBuffer.Length <= 0)\n   846→            continue;\n   847→\n   848→        bool hasRealDamage = false;\n   849→\n   850→        // ========== 1. 检查是否有实际伤害 ==========\n   851→\n   852→        if (unitPpt.ValueRO.unitCfg.isHybirdUnit)\n   853→        {\n   854→            // 混合单位(Mono + DOTS)\n   855→            UnitPptReference unitPptRef = null;\n   856→\n   857→            for (int i = 0; i < damageBuffer.Length; i++)\n   858→            {\n   859→                if (!damageBuffer[i].immuneDamage &&\n   860→                    damageBuffer[i].realDamage > 0f)\n   861→                {\n   862→                    hasRealDamage = true;\n   863→\n   864→                    if (unitPptRef == null)\n   865→                    {\n   866→                        unitPptRef = state.EntityManager\n   867→                            .GetComponentObject<UnitPptReference>(entity);\n   868→                    }\n   869→\n   870→                    if (!unitPpt.ValueRO.isDead)\n   871→                    {\n   872→                        // 调用 MonoBehaviour 的受伤后处理\n   873→                        unitPptRef.unitPpt.UnitBas.AfterTakeDamage_Dots(\n   874→                            ref damageBuffer.ElementAt(i)\n   875→                        );\n   876→                    }\n   877→                }\n   878→            }\n   879→        }\n   880→        else\n   881→        {\n   882→            // 纯 DOTS 单位\n   883→            for (int j = 0; j < damageBuffer.Length; j++)\n   884→            {\n   885→                if (!damageBuffer[j].immuneDamage &&\n   886→                    damageBuffer[j].realDamage > 0f)\n   887→                {\n   888→                    hasRealDamage = true;\n   889→                    break;\n   890→                }\n   891→            }\n   892→        }\n   893→\n   894→        // ========== 2. 播放受击音效 ==========\n   895→\n   896→        if (unitPpt.ValueRO.unitCfg.id == 800001)  // 玩家\n   897→        {\n   898→            ref PlayerController_Dots playerCtrl =\n   899→                ref GetComponentRW<PlayerController_Dots>(entity).ValueRW;\n   900→\n   901→            if (playerCtrl.isHurtThisFrameForPlayer)\n   902→            {\n   903→                playerCtrl.isHurtThisFrameForPlayer = false;\n   904→\n   905→                // 更新HP UI\n   906→                UIPlayerDataMgr.Inst.UpdateHP();\n   907→\n   908→                // 根据外观播放不同音效\n   909→                if (PlayerMgr.Inst.ItemCtrller.relic_Huang != null)\n   910→                {\n   911→                    SEMgr.Inst.injured_Huang.PlaySE();\n   912→                }\n   913→                else if (PlayerMgr.Inst.ItemCtrller.uiRelic_DaveHarpoons != null)\n   914→                {\n   915→                    SEMgr.Inst.injured_Dave.PlaySE();\n   916→                }\n   917→                else if (DataMgr.selectedWorldData.playerLook == PlayerLook.Frog)\n   918→                {\n   919→                    SEMgr.Inst.injured_Frog.PlaySE();\n   920→                }\n   921→                else\n   922→                {\n   923→                    SEMgr.Inst.injured_Player.PlaySE();\n   924→                }\n   925→\n   926→                // 播放受击闪红动画\n   927→                if (!GameMgr.IsHarmony_Static)\n   928→                {\n   929→                    UIPlayerDataMgr.Inst.UIPlayerInjuredPlay();\n   930→                }\n   931→            }\n   932→        }\n   933→        else if (hasRealDamage && unitPpt.ValueRO.unitCfg.id != 800001)  // 敌人\n   934→        {\n   935→            // 播放敌人受击音效\n   936→            UnitConfig.map[unitPpt.ValueRO.unitCfg.id]\n   937→                .beHitSE.Value.PlaySE(SEPlayMode.Unique, 3, 0.2f);\n   938→        }\n   939→    }\n   940→\n   941→    // ========== 3. 玩家特殊处理 ==========\n   942→\n   943→    DynamicBuffer<TakeDamageInfo_Dots> playerDamageBuffer =\n   944→        GetBuffer<TakeDamageInfo_Dots>(PlayerMgr.Inst.PlayerEtt);\n   945→    UnitProperty_Dots playerPpt =\n   946→        GetComponent<UnitProperty_Dots>(PlayerMgr.Inst.PlayerEtt);\n   947→\n   948→    for (int k = 0; k < playerDamageBuffer.Length; k++)\n   949→    {\n   950→        TakeDamageInfo_Dots info = playerDamageBuffer[k];\n   951→\n   952→        if (!info.immuneDamage &&\n   953→            (info.realDamage > 0f || info.hitMagicShieldDamage > 0f) &&\n   954→            !playerPpt.isDead)\n   955→        {\n   956→            // 调用玩家控制器的受伤后处理\n   957→            PlayerMgr.Inst.PlayerCtrller.AfterTakeDamage(\n   958→                ref playerDamageBuffer.ElementAt(k)\n   959→            );\n   960→        }\n   961→    }\n   962→}\n   963→```\n   964→\n   965→### UnitBase.AfterTakeDamage_Dots 虚方法\n   966→\n   967→**文件位置**: [UnitBase.cs:461-463](UnitBase.cs:461-463)\n   968→\n   969→```csharp\n   970→public virtual void AfterTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n   971→{\n   972→    // 默认为空,由子类重写\n   973→    // 例如:\n   974→    // - 播放受击动画\n   975→    // - 创建受击特效\n   976→    // - 触发反弹\n   977→    // - 生成血液粒子\n   978→}\n   979→```\n   980→\n   981→---\n   982→\n   983→## 死亡判定系统\n   984→\n   985→**文件位置**: [UnitTakeDamageDeadSystem.cs](UnitTakeDamageDeadSystem.cs:1)\n   986→\n   987→### OnUpdate 方法\n   988→\n   989→**位置**: [UnitTakeDamageDeadSystem.cs:210-410](UnitTakeDamageDeadSystem.cs:210-410)\n   990→\n   991→```csharp\n   992→protected unsafe override void OnUpdate()\n   993→{\n   994→    EntityCommandBuffer ecb = GetSingleton<EndSimulationECBSystem.Singleton>()\n   995→        .CreateCommandBuffer(World.Unmanaged);\n   996→\n   997→    Entity uiTextFloatEntity = GetSingletonEntity<UITextFloatByJobSingleton>();\n   998→\n   999→    // 清理缓存\n  1000→    _deadPpts.Clear();\n  1001→    _deadInfos.Clear();\n  1002→    _deadInfoIndex.Clear();\n  1003→    deadEntities.Clear();\n  1004→\n  1005→    // 遍历所有已死亡的单位\n  1006→    foreach (var (unitDead, unitPpt, transform, entity) in Query(...))\n  1007→    {\n  1008→        if (!unitPpt.ValueRO.isDead)\n  1009→            continue;\n  1010→\n  1011→        ref UnitDead deadData = ref unitDead.ValueRW;\n  1012→        LocalTransform pos = transform.ValueRO;\n  1013→\n  1014→        // 玩家最终死亡检查\n  1015→        if (deadData.playerFinallyDead)\n  1016→            break;\n  1017→\n  1018→        // ========== 1. 队友死亡处理 ==========\n  1019→\n  1020→        if (unitPpt.ValueRO.unitCfg.unitType == UnitType.Teammate ||\n  1021→            unitPpt.ValueRO.unitCfg.unitType == UnitType.TeammateNotAttack)\n  1022→        {\n  1023→            // 添加队友死亡标签\n  1024→            SetComponentEnabled<TeammateDeadTag>(entity, true);\n  1025→            continue;\n  1026→        }\n  1027→\n  1028→        // ========== 2. 掉落物品 ==========\n  1029→\n  1030→        if (unitPpt.ValueRO.deadDropItemInfos.IsCreated &&\n  1031→            unitPpt.ValueRO.deadDropItemInfos.Value.Length > 0)\n  1032→        {\n  1033→            QuickCreateSystem.Inst.CreateItemDrop(\n  1034→                LevelMgr.Inst.CurrentRoomMapPos,\n  1035→                unitPpt.ValueRO.deadDropItemInfos,\n  1036→                Tool2D.IgnoreZPoint(pos.Position),\n  1037→                0.2f\n  1038→            );\n  1039→        }\n  1040→\n  1041→        // ========== 3. 虚空爆炸检查 ==========\n  1042→\n  1043→        if ((unitPpt.ValueRO.unitCfg.triggerDeadEvent ||\n  1044→             IsSpecialVoidExplosionUnit(unitPpt.ValueRO.unitCfg.id)) &&\n  1045→            unitPpt.ValueRO.voidExplosionData.InstantKillRatio > 0f)\n  1046→        {\n  1047→            // 创建虚空爆炸\n  1048→            GameObject voidExplosion = ObjPoolMgr.Inst.GetGO(\n  1049→                \"Prefabs/Spell/\" + 31291,\n  1050→                pos.Position,\n  1051→                2.5f\n  1052→            );\n  1053→            voidExplosion.transform.localScale = Vector3.one;\n  1054→            voidExplosion.GetComponent<Spell3129VoidExplosion>()\n  1055→                .DataInitialize_Dots(\n  1056→                    unitPpt.ValueRO.unitCfg.maxHP,\n  1057→                    unitPpt.ValueRO.voidExplosionData\n  1058→                );\n  1059→\n  1060→            // 创建爆炸粒子\n  1061→            ecb.AppendToBuffer(uiTextFloatEntity,\n  1062→                new GlobalParticleEmitParams(\n  1063→                    GlobalParticleType.Spell,\n  1064→                    \"3129_Explosion\",\n  1065→                    pos.Position\n  1066→                )\n  1067→                { Size = 0.417f }\n  1068→            );\n  1069→        }\n  1070→\n  1071→        // ========== 4. 死亡特效 ==========\n  1072→\n  1073→        if (!deadData.deadlyInfo.dontCreateDeadEF)\n  1074→        {\n  1075→            if (unitPpt.ValueRO.unitCfg.deadEF != \"\")\n  1076→            {\n  1077→                bool isSummonTransparent =\n  1078→                    (unitPpt.ValueRO.unitCfg.unitType == UnitType.Teammate ||\n  1079→                     unitPpt.ValueRO.unitCfg.unitType == UnitType.TeammateNotAttack) &&\n  1080→                    DataMgr.settingData.FinalSummonTransparent <= 0.01f;\n  1081→\n  1082→                if (!isSummonTransparent)\n  1083→                {\n  1084→                    string effectPath = \"Prefabs/EF/\" +\n  1085→                        unitPpt.ValueRO.unitCfg.deadEF.ToString();\n  1086→\n  1087→                    // 特殊处理: 血液/幽灵死亡特效有多个变体\n  1088→                    if (unitPpt.ValueRO.unitCfg.deadEF == \"EF_Dead_Blood\" ||\n  1089→                        unitPpt.ValueRO.unitCfg.deadEF == \"EF_Dead_Ghost\")\n  1090→                    {\n  1091→                        effectPath += \"_\" + UnityEngine.Random.Range(0, 2);\n  1092→\n  1093→                        // 使用精灵特效系统\n  1094→                        SpriteEffectAnima anima =\n  1095→                            ABResources.LoadAsset<SpriteEffectAnima>(effectPath);\n  1096→\n  1097→                        float3 offset = new float3(\n  1098→                            UnityEngine.Random.Range(-0.1f, 0.1f),\n  1099→                            0.3f + UnityEngine.Random.Range(-0.1f, 0.1f),\n  1100→                            0f\n  1101→                        );\n  1102→\n  1103→                        float radius = GetEntityRadius(entity);\n  1104→\n  1105→                        SpellSpriteEffectController.Inst.PlayEffect(anima,\n  1106→                            new EffectPlayParam\n  1107→                            {\n  1108→                                Position = pos.Position + offset,\n  1109→                                Scale = Vector3.one * Mathf.Max(1f, radius * 2f + 0.3f),\n  1110→                                FilpX = (UnityEngine.Random.Range(0, 2) == 0),\n  1111→                                Unlit = false\n  1112→                            }\n  1113→                        );\n  1114→                    }\n  1115→                    else\n  1116→                    {\n  1117→                        ObjPoolMgr.Inst.GetGO(effectPath, pos.Position, 5f);\n  1118→                    }\n  1119→                }\n  1120→            }\n  1121→        }\n  1122→\n  1123→        // ========== 5. 永久死亡特效 ==========\n  1124→\n  1125→        if (unitPpt.ValueRO.unitCfg.deadPermanentEF.ToString() != \"\")\n  1126→        {\n  1127→            ObjPoolMgr.Inst.GetGO(\n  1128→                \"Prefabs/EF/\" + unitPpt.ValueRO.unitCfg.deadPermanentEF.ToString(),\n  1129→                pos.Position\n  1130→            );\n  1131→        }\n  1132→\n  1133→        // ========== 6. 血迹 ==========\n  1134→\n  1135→        if (!deadData.deadlyInfo.dontCreatebloodSplat &&\n  1136→            unitPpt.ValueRO.unitCfg.bloodSplatSize > 0f)\n  1137→        {\n  1138→            if (deadData.deadlyInfo.knockbackForce == Vector3.zero)\n  1139→            {\n  1140→                // 无方向血迹\n  1141→                ObjPoolMgr.Inst.GetGO(\"Prefabs/EF/EF_BloodSplat\",\n  1142→                    Tool2D.IgnoreZPoint(pos.Position))\n  1143→                    .GetComponent<BloodSplat>()\n  1144→                    .Initialize(unitPpt.ValueRO.unitCfg.bloodSplatSize);\n  1145→            }\n  1146→            else\n  1147→            {\n  1148→                // 有方向血迹\n  1149→                ObjPoolMgr.Inst.GetGO(\"Prefabs/EF/EF_BloodSplatDirect\",\n  1150→                    Tool2D.IgnoreZPoint(pos.Position))\n  1151→                    .GetComponent<BloodSplat>()\n  1152→                    .Initialize(\n  1153→                        unitPpt.ValueRO.unitCfg.bloodSplatSize,\n  1154→                        deadData.deadlyInfo.knockbackForce\n  1155→                    );\n  1156→            }\n  1157→        }\n  1158→\n  1159→        // ========== 7. 尸体 ==========\n  1160→\n  1161→        int corpseCount = unitPpt.ValueRO.unitCfg.corpseCount;\n  1162→        if (GameMgr.IsMobile_Static)\n  1163→        {\n  1164→            corpseCount = (int)(corpseCount * 0.5);  // 移动端减半\n  1165→        }\n  1166→\n  1167→        if (unitPpt.ValueRO.unitCfg.corpseType != CorpseType.None)\n  1168→        {\n  1169→            for (int i = 0; i < corpseCount; i++)\n  1170→            {\n  1171→                CorpseSystem.Inst.CreateCorpse(\n  1172→                    unitPpt.ValueRO.unitCfg.corpseType,\n  1173→                    pos.Position,\n  1174→                    deadData.deadlyInfo.knockbackForce\n  1175→                );\n  1176→            }\n  1177→        }\n  1178→\n  1179→        // ========== 8. 死亡音效 ==========\n  1180→\n  1181→        if (!deadData.deadlyInfo.dontPlayDeadSE)\n  1182→        {\n  1183→            if (unitPpt.ValueRO.unitCfg.isDeadSE3D)\n  1184→            {\n  1185→                unitPpt.ValueRO.unitCfg.deadSEs.Value.PlaySE(pos.Position);\n  1186→            }\n  1187→            else\n  1188→            {\n  1189→                unitPpt.ValueRO.unitCfg.deadSEs.Value.PlaySE();\n  1190→            }\n  1191→        }\n  1192→\n  1193→        // ========== 9. 根据单位类型处理死亡 ==========\n  1194→\n  1195→        switch (unitPpt.ValueRO.unitCfg.unitType)\n  1196→        {\n  1197→            case UnitType.Player:\n  1198→                HandlePlayerDeath(ref deadData, entity);\n  1199→                break;\n  1200→\n  1201→            case UnitType.Teammate:\n  1202→            case UnitType.TeammateNotAttack:\n  1203→                LevelMgr.Inst.CurrentRoomCtrller.UnitUnregister(entity);\n  1204→                break;\n  1205→\n  1206→            case UnitType.Monster:\n  1207→            case UnitType.Elite:\n  1208→            case UnitType.Boss:\n  1209→            case UnitType.WillAttack:\n  1210→            case UnitType.NotAttack:\n  1211→            case UnitType.Brittleness:\n  1212→                if (!unitPpt.ValueRO.unitCfg.isHybirdUnit)\n  1213→                {\n  1214→                    LevelMgr.Inst.CurrentRoomCtrller.UnitUnregister(entity);\n  1215→                }\n  1216→                break;\n  1217→        }\n  1218→    }\n  1219→}\n  1220→```\n  1221→\n  1222→### 玩家死亡处理\n  1223→\n  1224→```csharp\n  1225→private void HandlePlayerDeath(ref UnitDead deadData, Entity entity)\n  1226→{\n  1227→    Debug.Log(\"Player Dead\");\n  1228→\n  1229→    // 记录死亡次数\n  1230→    DataMgr.selectedWorldData.deadCount++;\n  1231→\n  1232→    TakeDamageInfo_Dots deadlyInfo = deadData.deadlyInfo;\n  1233→\n  1234→    // 记录击杀者\n  1235→    if (deadlyInfo.attackerEntity != Entity.Null)\n  1236→    {\n  1237→        if (HasComponent<UnitProperty_Dots>(deadlyInfo.attackerEntity))\n  1238→        {\n  1239→            int killerID = GetComponent<UnitProperty_Dots>(\n  1240→                deadlyInfo.attackerEntity\n  1241→            ).unitCfg.id;\n  1242→            Debug.Log(\"击杀者id: \" + killerID);\n  1243→        }\n  1244→        else\n  1245→        {\n  1246→            Debug.Log(\"击杀者id已经不可考证\");\n  1247→        }\n  1248→    }\n  1249→\n  1250→    // 标记玩家最终死亡\n  1251→    deadData.playerFinallyDead = true;\n  1252→\n  1253→    // 记录死亡日志\n  1254→    PlayerDeathLogger logger = new PlayerDeathLogger();\n  1255→    logger.death_counter = DataMgr.selectedWorldData.deadCount;\n  1256→    logger.equips = PlayerEquips.CreateAuto();\n  1257→    logger.monsters = LevelMgr.Inst.CurrentRoomCtrller.MonsterPpts\n  1258→        .Select(e => e.unitCfg.id).ToList();\n  1259→    logger.resources = ResourcesStatus.CreateAuto();\n  1260→    logger.click_return_camp =\n  1261→        (deadlyInfo.attackerType == AttackerType.FromUI);\n  1262→    logger.Report();\n  1263→\n  1264→    // 移动端数据上报\n  1265→    if (GameMgr.IsMobile_Static)\n  1266→    {\n  1267→        MobileMgr.inst.PluginActivity.UploadItemSnapshot(1);\n  1268→    }\n  1269→\n  1270→    // 触发玩家死亡事件\n  1271→    EventMgr.PlayerDead?.Invoke();\n  1272→\n  1273→    // 显示死亡UI\n  1274→    GameUISingletonMono<UIPlayerDead>.ShowInit();\n  1275→}\n  1276→```\n  1277→\n  1278→---\n  1279→\n  1280→## 护盾系统\n  1281→\n  1282→护盾分为两种类型:\n  1283→1. **永久护盾 (shield)**: 不会随时间消失\n  1284→2. **临时护盾 (shieldTemp)**: 进门时清除\n  1285→\n  1286→### 护盾扣除顺序\n  1287→\n  1288→**位置**: [UnitPropertySystem.cs](UnitPropertySystem.cs:1) (DOTS Job)\n  1289→\n  1290→```\n  1291→伤害应用顺序:\n  1292→1. 永久护盾 (shield)\n  1293→2. 临时护盾 (shieldTemp)\n  1294→3. 生命值 (currentHP)\n  1295→```\n  1296→\n  1297→### 护盾计算伪代码\n  1298→\n  1299→```csharp\n  1300→float originalDamage = damageInfo.damage;\n  1301→float remainingDamage = originalDamage;\n  1302→float realDamage = 0f;  // 实际造成的伤害(用于统计)\n  1303→\n  1304→// 1. 扣除永久护盾\n  1305→if (shield > 0 && remainingDamage > 0)\n  1306→{\n  1307→    float damageToShield = Min(remainingDamage, shield);\n  1308→    shield -= damageToShield;\n  1309→    remainingDamage -= damageToShield;\n  1310→    // 注意: 护盾吸收的伤害不计入realDamage\n  1311→}\n  1312→\n  1313→// 2. 扣除临时护盾\n  1314→if (shieldTemp > 0 && remainingDamage > 0)\n  1315→{\n  1316→    float damageToTempShield = Min(remainingDamage, shieldTemp);\n  1317→    shieldTemp -= damageToTempShield;\n  1318→    remainingDamage -= damageToTempShield;\n  1319→    realDamage += damageToTempShield;  // 临时护盾计入实际伤害\n  1320→}\n  1321→\n  1322→// 3. 扣除生命值\n  1323→if (remainingDamage > 0)\n  1324→{\n  1325→    currentHP -= remainingDamage;\n  1326→    realDamage += remainingDamage;\n  1327→\n  1328→    if (currentHP < 0)\n  1329→    {\n  1330→        currentHP = 0;\n  1331→    }\n  1332→}\n  1333→\n  1334→// 4. 检查死亡\n  1335→if (currentHP <= 0 && !isDead)\n  1336→{\n  1337→    isDead = true;\n  1338→}\n  1339→```\n  1340→\n  1341→### 护盾来源\n  1342→\n  1343→#### 1. 遗物提供的护盾\n  1344→\n  1345→```csharp\n  1346→// 遗物: 进门获得护盾\n  1347→if (ItemCtrller.relicCfg_FloorShield != null)\n  1348→{\n  1349→    PlayerMgr.Inst.ChangeShield(relicCfg_FloorShield.int1.result);\n  1350→}\n  1351→\n  1352→// 遗物: 临时护盾\n  1353→if (ItemCtrller.relicCfg_TempShield != null)\n  1354→{\n  1355→    PlayerMgr.Inst.ChangeShieldTemp(relicCfg_TempShield.int1.result);\n  1356→}\n  1357→```\n  1358→\n  1359→#### 2. 遗物组提供的护盾\n  1360→\n  1361→```csharp\n  1362→// 遗物组1: 临时护盾转永久护盾\n  1363→if (ItemCtrller.relicGroupConfigs.TryGetValue(1, out var config))\n  1364→{\n  1365→    float shieldPercent = config.int1.result / 100f;\n  1366→    float permanentShield = playerPpt.unitCfg.shieldTemp * shieldPercent;\n  1367→    PlayerMgr.Inst.ChangeShield(permanentShield);\n  1368→}\n  1369→```\n  1370→\n  1371→### ChangeShield 方法\n  1372→\n  1373→**位置**: [PlayerMgr.cs](PlayerMgr.cs:1)\n  1374→\n  1375→```csharp\n  1376→public void ChangeShield(float value)\n  1377→{\n  1378→    EntityManager ettMgr = World.DefaultGameObjectInjectionWorld.EntityManager;\n  1379→    UnitProperty_Dots ppt = ettMgr.GetComponentData<UnitProperty_Dots>(PlayerEtt);\n  1380→\n  1381→    ppt.unitCfg.shield += value;\n  1382→\n  1383→    // 限制护盾上限\n  1384→    float maxShield = ppt.unitCfg.maxHP * 0.5f;  // 最大护盾为最大HP的50%\n  1385→    if (ppt.unitCfg.shield > maxShield)\n  1386→    {\n  1387→        ppt.unitCfg.shield = maxShield;\n  1388→    }\n  1389→\n  1390→    ettMgr.SetComponentData(PlayerEtt, ppt);\n  1391→\n  1392→    // 更新UI\n  1393→    UIPlayerDataMgr.Inst.UpdateHP();\n  1394→}\n  1395→```\n  1396→\n  1397→---\n  1398→\n  1399→## 暴击系统\n  1400→\n  1401→### 暴击判定流程\n  1402→\n  1403→```\n  1404→1. 获取暴击率\n  1405→   ├─ 技能配置的暴击率 (SpellConfig.criticalChance)\n  1406→   ├─ 额外暴击率 (TakeDamageInfo.extraCriticalChance)\n  1407→   └─ 玩家属性加成 (PlayerMgr.ExtraCriticalRatio)\n  1408→\n  1409→2. 随机判定\n  1410→   if (Random.value <= totalCriticalChance)\n  1411→       触发暴击\n  1412→\n  1413→3. 暴击伤害倍率\n  1414→   ├─ 默认: x2.0\n  1415→   └─ 遗物加成: x (2.0 + relic_AddCriticleDamageRatio)\n  1416→```\n  1417→\n  1418→### 暴击率计算\n  1419→\n  1420→**位置**: [PlayerMgr.cs:198-213](PlayerMgr.cs:198-213)\n  1421→\n  1422→```csharp\n  1423→public float ExtraCriticalRatio\n  1424→{\n  1425→    get\n  1426→    {\n  1427→        float ratio = BaData.extraCriticalChance;  // 基础额外暴击率\n  1428→\n  1429→        // 遗物: 增加暴击率\n  1430→        if (ItemCtrller.relicCfg_AddCriticalChance != null)\n  1431→        {\n  1432→            ratio += (float)relicCfg_AddCriticalChance.int1.result / 100f;\n  1433→        }\n  1434→\n  1435→        // 诅咒: 减少暴击率\n  1436→        if (ItemCtrller.curseCfg_ReduceCriticalRatio != null)\n  1437→        {\n  1438→            ratio += (float)curseCfg_ReduceCriticalRatio.int1.result / 100f;\n  1439→        }\n  1440→\n  1441→        return ratio;\n  1442→    }\n  1443→}\n  1444→```\n  1445→\n  1446→### 暴击判定代码\n  1447→\n  1448→**位置**: [TakeDamageInfoPreProcessSystem.cs:315-334](TakeDamageInfoPreProcessSystem.cs:315-334)\n  1449→\n  1450→```csharp\n  1451→if (!info.isDamageCritical)\n  1452→{\n  1453→    // 获取暴击率\n  1454→    float critChance = info.extraCriticalChance;\n  1455→    if (info.spell.Entity != Entity.Null)\n  1456→    {\n  1457→        critChance = info.spell.Config.CriticalChance;\n  1458→    }\n  1459→\n  1460→    // 暴击判定\n  1461→    if (critChance > 0f &&\n  1462→        DTool.RandomValue(ref gRandom.ValueRW.random) <= critChance)\n  1463→    {\n  1464→        info.isDamageCritical = true;\n  1465→\n  1466→        // 计算暴击伤害\n  1467→        if (IsPlayerAttack(info) && relic_AddCriticleDamageRatio > 0f)\n  1468→        {\n  1469→            // 玩家有暴击伤害遗物\n  1470→            info.damage *= relic_AddCriticleDamageRatio;\n  1471→        }\n  1472→        else\n  1473→        {\n  1474→            // 默认暴击伤害 x2\n  1475→            info.damage *= 2f;\n  1476→        }\n  1477→    }\n  1478→}\n  1479→```\n  1480→\n  1481→### 暴击显示\n  1482→\n  1483→```csharp\n  1484→// 创建伤害数字时检查暴击标志\n  1485→if (info.isDamageCritical)\n  1486→{\n  1487→    // 显示黄色大号字体\n  1488→    CreateFloatText(\n  1489→        damage,\n  1490→        position,\n  1491→        Color.yellow,\n  1492→        scale: 1.5f\n  1493→    );\n  1494→}\n  1495→else\n  1496→{\n  1497→    // 显示白色普通字体\n  1498→    CreateFloatText(\n  1499→        damage,\n  1500→        position,\n  1501→        Color.white,\n  1502→        scale: 1.0f\n  1503→    );\n  1504→}\n  1505→```\n  1506→\n  1507→---\n  1508→\n  1509→## 特殊伤害类型\n  1510→\n  1511→### 1. 真实伤害 (isUndifferDamage)\n  1512→\n  1513→真实伤害无视大部分防御机制,但有特殊限制。\n  1514→\n  1515→**特点**:\n  1516→- 无视固体物体免疫\n  1517→- 对玩家伤害限制在33.33%\n  1518→- 不受诅咒减伤影响\n  1519→\n  1520→**应用代码**: [TakeDamageInfoPreProcessSystem.cs:279-289](TakeDamageInfoPreProcessSystem.cs:279-289)\n  1521→\n  1522→```csharp\n  1523→if (info.isUndifferDamage)\n  1524→{\n  1525→    if (info.spell.Entity != Entity.Null)\n  1526→    {\n  1527→        // 限制真实伤害最多为配置值或33.33%,取较小值\n  1528→        info.damage *= math.min(\n  1529→            info.spell.Config.UndifferDamageRatio,\n  1530→            0.3333f\n  1531→        );\n  1532→    }\n  1533→    else\n  1534→    {\n  1535→        // 默认33.33%\n  1536→        info.damage *= 0.3333f;\n  1537→    }\n  1538→}\n  1539→```\n  1540→\n  1541→### 2. 百分比伤害 (isPercentageDamage)\n  1542→\n  1543→按目标最大生命值百分比造成伤害。\n  1544→\n  1545→**特点**:\n  1546→- 不受伤害加成/减免影响\n  1547→- 不受易伤效果影响\n  1548→- 适合对高血量敌人\n  1549→\n  1550→**计算代码**:\n  1551→\n  1552→```csharp\n  1553→if (info.isPercentageDamage)\n  1554→{\n  1555→    float maxHP = unitPpt.unitCfg.maxHP;\n  1556→    info.damage = maxHP * damagePercent;\n  1557→\n  1558→    // 注意: 百分比伤害不受以下影响\n  1559→    // - relic_ReduceDamageRatio\n  1560→    // - curse_VulnerabilityExtraDamageRatio\n  1561→    // - DamageReciveIncresePercent\n  1562→}\n  1563→```\n  1564→\n  1565→### 3. 陷阱伤害 (isTrapDamage)\n  1566→\n  1567→来自环境陷阱的伤害。\n  1568→\n  1569→**特点**:\n  1570→- 受诅咒\"陷阱目标\"影响\n  1571→- 可以同时伤害玩家和队友\n  1572→\n  1573→**修正代码**: [TakeDamageInfoPreProcessSystem.cs:244-247](TakeDamageInfoPreProcessSystem.cs:244-247)\n  1574→\n  1575→```csharp\n  1576→// 诅咒: 陷阱目标\n  1577→if (info.isTrapDamage && curse_TargetedTrapExtraDamageRatio > 0f)\n  1578→{\n  1579→    info.damage *= 1f + curse_TargetedTrapExtraDamageRatio;\n  1580→}\n  1581→```\n  1582→\n  1583→### 4. 穿透队友伤害 (isTeammateThrough)\n  1584→\n  1585→特殊技能可以穿透队友而不造成伤害。\n  1586→\n  1587→**应用场景**:\n  1588→- 某些特殊技能\n  1589→- 召唤物死亡爆炸\n  1590→\n  1591→**检查代码**:\n  1592→\n  1593→```csharp\n  1594→if (info.isTeammateThrough &&\n  1595→    targetPpt.unitCfg.unitType == UnitType.Teammate)\n  1596→{\n  1597→    info.immuneDamage = true;\n  1598→}\n  1599→```\n  1600→\n  1601→---\n  1602→\n  1603→## 伤害修正系统\n  1604→\n  1605→伤害修正分为多个层次:\n  1606→\n  1607→### 1. 基础伤害修正\n  1608→\n  1609→```\n  1610→基础伤害 = 技能配置伤害 * (1 + ExtraDamageRatio)\n  1611→\n  1612→ExtraDamageRatio 来源:\n  1613→- BattleData.extraDamageRatio          基础额外伤害\n  1614→- 遗物: 诅咒战士                       +5% per 诅咒\n  1615→- 遗物: 金钱即力量                     +X% per Y金币\n  1616→- 遗物: 增伤                           +固定%\n  1617→- 遗物: 强者                           +固定%\n  1618→- 遗物: 疯眼                           动态增长\n  1619→- 遗物: 狂战士                         低血增伤\n  1620→- 诅咒: 降低伤害和速度                 -固定%\n  1621→- 诅咒: 满血增伤                       动态变化\n  1622→```\n  1623→\n  1624→**计算位置**: [PlayerMgr.cs:157-196](PlayerMgr.cs:157-196)\n  1625→\n  1626→### 2. 受伤减免修正\n  1627→\n  1628→```\n  1629→最终伤害 = 基础伤害 * DamageReductionRatio\n  1630→\n  1631→DamageReductionRatio 来源:\n  1632→- 遗物: 减伤                           * (1 - X%)\n  1633→- 遗物: 强者增伤 (敌人)                * (1 + X%)\n  1634→- 诅咒: 脆弱                           * (1 + X%)\n  1635→- 诅咒: 金币增伤                       * (1 + X%)\n  1636→- 诅咒: 敌人减伤                       * (1 - X%)\n  1637→```\n  1638→\n  1639→### 3. 特殊比例修正\n  1640→\n  1641→```\n  1642→playerTakeDamageRatio:\n  1643→- 默认: 1.0\n  1644→- 特定技能可以修改\n  1645→\n  1646→teammateTakeDamageRatio:\n  1647→- 默认: 1.0\n  1648→- Boss技能对队友: 2.0 或 3.0\n  1649→```\n  1650→\n  1651→### 修正优先级\n  1652→\n  1653→```\n  1654→Priority 1: 特殊技能修正 (Boss技能对队友)\n  1655→    ↓\n  1656→Priority 2: 玩家基础修正 (无敌帧、闪避)\n  1657→    ↓\n  1658→Priority 3: 遗物/诅咒伤害比例\n  1659→    ↓\n  1660→Priority 4: 受伤比例 (playerTakeDamageRatio)\n  1661→    ↓\n  1662→Priority 5: 真实伤害特殊处理\n  1663→    ↓\n  1664→Priority 6: 易伤效果\n  1665→    ↓\n  1666→Priority 7: 暴击判定\n  1667→    ↓\n  1668→Priority 8: 伤害取整\n  1669→```\n  1670→\n  1671→---\n  1672→\n  1673→## 伤害公式总结\n  1674→\n  1675→### 完整伤害计算公式\n  1676→\n  1677→```\n  1678→最终伤害 = ⌈基础伤害 * 修正1 * 修正2 * ... * 修正N * 暴击倍率⌉\n  1679→\n  1680→其中:\n  1681→基础伤害 = 技能伤害 * (1 + ExtraDamageRatio)\n  1682→\n  1683→修正因子包括(按顺序):\n  1684→1. 特殊技能修正 (BossSpellModifier)\n  1685→2. 无敌帧检查 (→ immuneDamage)\n  1686→3. 闪避检查 (→ immuneDamage)\n  1687→4. 减伤遗物 (* (1 - relic_ReduceDamageRatio))\n  1688→5. 增伤遗物 (* (1 + relic_PowerfulManIncreaseDamage))\n  1689→6. 增伤诅咒 (* (1 + curse_VulnerabilityExtraDamageRatio))\n  1690→7. 金币增伤诅咒 (* (1 + curse_MoreMoneyMoreInjured))\n  1691→8. 受伤比例 (* playerTakeDamageRatio or teammateTakeDamageRatio)\n  1692→9. 真实伤害限制 (* min(undifferRatio, 0.3333))\n  1693→10. 易伤效果 (* DamageReciveIncresePercent)\n  1694→11. 暴击判定 (* criticalDamageRatio)\n  1695→\n  1696→⌈x⌉ = ceil(x)  // 向上取整\n  1697→```\n  1698→\n  1699→### 示例计算\n  1700→\n  1701→#### 场景: 玩家被敌人技能击中\n  1702→\n  1703→```\n  1704→技能原始伤害: 100\n  1705→玩家ExtraDamageRatio: 0  (敌人攻击不受玩家加成影响)\n  1706→遗物减伤20%\n  1707→诅咒脆弱+30%\n  1708→临时易伤+50%\n  1709→暴击率: 0.3 (30%)\n  1710→暴击判定: 成功\n  1711→\n  1712→计算过程:\n  1713→1. 基础伤害 = 100\n  1714→2. 应用减伤遗物: 100 * (1 - 0.2) = 80\n  1715→3. 应用脆弱诅咒: 80 * (1 + 0.3) = 104\n  1716→4. 应用易伤效果: 104 * 1.5 = 156\n  1717→5. 暴击判定成功: 156 * 2.0 = 312\n  1718→6. 向上取整: ⌈312⌉ = 312\n  1719→\n  1720→最终伤害: 312\n  1721→```\n  1722→\n  1723→#### 场景: 玩家攻击Boss\n  1724→\n  1725→```\n  1726→技能原始伤害: 50\n  1727→玩家ExtraDamageRatio: +50% (各种遗物)\n  1728→玩家ExtraCriticalRatio: +20%\n  1729→技能暴击率: 10%\n  1730→诅咒敌人减伤: -20%\n  1731→暴击判定: 失败\n  1732→\n  1733→计算过程:\n  1734→1. 基础伤害 = 50 * (1 + 0.5) = 75\n  1735→2. 敌人减伤诅咒: 75 * (1 - 0.2) = 60\n  1736→3. 暴击率 = 10% + 20% = 30%\n  1737→4. 暴击判定失败: 伤害不变\n  1738→5. 向上取整: ⌈60⌉ = 60\n  1739→\n  1740→最终伤害: 60\n  1741→```\n  1742→\n  1743→---\n  1744→\n  1745→## 总结\n  1746→\n  1747→### 关键特性\n  1748→\n  1749→1. **多阶段流水线**: 伤害经过7个系统依次处理\n  1750→2. **可中断性**: 任何阶段都可以将伤害设为免疫\n  1751→3. **护盾双重机制**: 永久护盾 + 临时护盾\n  1752→4. **暴击系统**: 默认x2,可通过遗物提升\n  1753→5. **特殊伤害类型**: 真实伤害、百分比伤害、陷阱伤害\n  1754→6. **伤害修正**: 遗物/诅咒/易伤多层修正\n  1755→\n  1756→### 性能优化\n  1757→\n  1758→1. **DOTS架构**: 使用Burst编译的Job进行并行处理\n  1759→2. **Buffer机制**: 每个Entity维护伤害信息缓冲区\n  1760→3. **每帧清理**: 避免内存泄漏\n  1761→\n  1762→### 扩展点\n  1763→\n  1764→1. **BeforeTakeDamage**: 受伤前自定义逻辑\n  1765→2. **AfterTakeDamage**: 受伤后自定义逻辑\n  1766→3. **遗物效果**: 在预处理阶段注入修正\n  1767→4. **诅咒效果**: 在预处理阶段注入修正\n  1768→\n  1769→---\n  1770→\n  1771→**文档版本**: 1.0\n  1772→**最后更新**: 2025-12-17\n  1773→**作者**: AI 代码分析助手\n  1774→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5a20920a-a3d6-4d3c-be6b-3d9dd6b251e4","timestamp":"2025-12-18T11:35:39.571Z","toolUseResult":{"type":"text","file":{"filePath":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script\\战斗系统文档\\02-伤害计算系统详细.md","content":"# 伤害计算系统详细文档\n\n## 目录\n1. [系统概述](#系统概述)\n2. [伤害信息结构 (TakeDamageInfo)](#伤害信息结构-takedamageinfo)\n3. [伤害计算流程](#伤害计算流程)\n4. [伤害预处理系统](#伤害预处理系统)\n5. [受伤前处理系统](#受伤前处理系统)\n6. [受伤后处理系统](#受伤后处理系统)\n7. [死亡判定系统](#死亡判定系统)\n8. [护盾系统](#护盾系统)\n9. [暴击系统](#暴击系统)\n10. [特殊伤害类型](#特殊伤害类型)\n11. [伤害修正系统](#伤害修正系统)\n12. [伤害公式总结](#伤害公式总结)\n\n---\n\n## 系统概述\n\n伤害计算系统是战斗系统的核心,负责处理所有单位受到的伤害。该系统采用**多阶段流水线架构**,每个阶段负责不同的处理逻辑。\n\n### 设计原则\n\n1. **数据驱动**: 所有伤害数据封装在 `TakeDamageInfo_Dots` 结构体中\n2. **流水线处理**: 伤害信息经过多个 System 依次处理\n3. **可中断性**: 任何阶段都可以将伤害标记为免疫 (`immuneDamage`)\n4. **可扩展性**: 遗物/诅咒效果可以在各个阶段插入逻辑\n\n### 系统架构\n\n```\n[技能碰撞]\n    ↓ 创建 TakeDamageInfo_Dots\n[TakeDamageInfoPreProcessSystem]   预处理伤害\n    ↓ 计算暴击、应用遗物/诅咒修正\n[UnitBeforeTakeDamageSystem]       受伤前处理\n    ↓ 无敌帧、闪避、反弹\n[UnitPropertySystem]                属性更新\n    ↓ 扣除护盾和生命值\n[UnitAfterTakeDamageSystem]        受伤后处理\n    ↓ 击退、特效、音效\n[UnitTakeDamageDeadSystem]         死亡判定\n    ↓ 检查死亡、触发死亡事件\n[DamageRecordSystem]               伤害记录\n    ↓ 统计伤害数据\n[UnitTakeDamageClearSystem]        清除伤害信息\n    ↓ 清空本帧的伤害缓冲区\n```\n\n### System 执行顺序\n\n**文件位置**: 各个System文件头部的 `[UpdateInGroup]` 和 `[UpdateBefore/After]` 特性\n\n```csharp\n[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n[UpdateBefore(typeof(UnitBeforeTakeDamageSystem))]\n[UpdateAfter(typeof(UnitEnvironmentSystem))]\npublic struct TakeDamageInfoPreProcessSystem : ISystem\n\n[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n[UpdateBefore(typeof(UnitPropertySystem))]\npublic struct UnitBeforeTakeDamageSystem : ISystem\n\n[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n[UpdateAfter(typeof(UnitPropertySystem))]\n[UpdateBefore(typeof(UnitTakeDamageDeadSystem))]\npublic struct UnitAfterTakeDamageSystem : ISystem\n\n[UpdateInGroup(typeof(UnitTakeDamageGroup))]\n[UpdateAfter(typeof(UnitAfterTakeDamageSystem))]\n[UpdateBefore(typeof(SpellTakeDamageResultSystem))]\npublic class UnitTakeDamageDeadSystem : SystemBase\n```\n\n---\n\n## 伤害信息结构 (TakeDamageInfo)\n\n**文件位置**: [TakeDamageInfo.cs](TakeDamageInfo.cs:1)\n\n### 数据结构\n\n伤害系统使用两个版本的数据结构:\n- **TakeDamageInfo**: MonoBehaviour 使用的版本\n- **TakeDamageInfo_Dots**: DOTS/ECS 使用的版本\n\n#### TakeDamageInfo (MonoBehaviour版本)\n\n```csharp\npublic class TakeDamageInfo\n{\n    // ========== 攻击者信息 ==========\n    public AttackerType attackerType;        // 攻击者类型\n    public UnitProperty attackerPpt;         // 攻击者单位属性\n\n    // ========== 被击者信息 ==========\n    public UnitProperty beHitPpt;            // 被击者单位属性\n\n    // ========== 伤害数值 ==========\n    public float damage;                     // 伤害值\n    public float criticalChance;             // 暴击率\n    public bool isCriticalDamage;            // 是否暴击\n\n    // ========== 击退信息 ==========\n    public Vector3 knockbackForce;           // 击退力度\n\n    // ========== 控制标志 ==========\n    public bool considerPlayerInInvincibleFrame = true;   // 是否考虑玩家无敌帧\n    public bool considerUmbrella = true;                  // 是否考虑雨伞格挡\n    public bool considerRelicDodge = true;                // 是否考虑遗物闪避\n    public bool considerRelicOrCurseDamageRatioChange = true;  // 是否应用遗物/诅咒伤害修正\n\n    // ========== 特效控制 ==========\n    public bool isPlayHitSE = true;          // 是否播放受击音效\n    public bool isPlayDeadSE = true;         // 是否播放死亡音效\n    public bool isCreateDeadEF = true;       // 是否创建死亡特效\n    public bool isCreatebloodSplat = true;   // 是否创建血迹\n    public bool beHitColor = true;           // 是否显示受击变色\n    public bool beHitShake = true;           // 是否镜头震动\n    public bool isFloatText = true;          // 是否显示浮动伤害数字\n\n    // ========== 特殊标志 ==========\n    public bool immuneDamage;                // 是否免疫此伤害\n    public bool isTargetDead;                // 目标是否死亡\n    public bool isTrapDamage;                // 是否为陷阱伤害\n    public bool canRebound;                  // 是否可以反弹\n    public bool stopAnnouncedDeath;          // 是否阻止宣布死亡\n    public bool isUndifferDamage;            // 是否为真实伤害\n    public bool isPercentageDamage;          // 是否为百分比伤害\n    public bool isTeammateThrough;           // 是否穿透队友\n\n    // ========== 伤害来源 ==========\n    public SpellBase spellBase;              // 技能对象引用\n\n    // ========== 充能数据 ==========\n    public WandPostSlotChargeData wandChargeData;  // 魔杖后置槽位充能数据\n\n    // ========== 伤害比例 ==========\n    public float playerTakeDamageRatio = 1f;       // 玩家受伤比例\n    public float teammateTakeDamageRatio = 1f;     // 队友受伤比例\n\n    // ========== 触发器 ==========\n    public bool postSlotSpellTakeDamageTrigger = true;  // 是否触发后置槽位技能\n}\n```\n\n#### TakeDamageInfo_Dots (DOTS版本)\n\n**文件位置**: [TakeDamageInfo_Dots.cs](TakeDamageInfo_Dots.cs:1)\n\n```csharp\npublic struct TakeDamageInfo_Dots : IBufferElementData\n{\n    // ========== Entity引用 ==========\n    public Entity attackerEntity;            // 攻击者Entity\n    public Entity targetEntity;              // 目标Entity\n\n    // ========== 攻击者类型 ==========\n    public AttackerType attackerType;\n\n    // ========== 伤害数值 ==========\n    public float damage;                     // 原始伤害\n    public float realDamage;                 // 实际造成的伤害(扣除护盾后)\n    public float hitMagicShieldDamage;       // 击中魔法盾的伤害\n\n    // ========== 暴击系统 ==========\n    public float extraCriticalChance;        // 额外暴击率\n    public bool isDamageCritical;            // 是否暴击\n\n    // ========== 击退 ==========\n    public float3 knockbackForce;            // 击退力(Unity.Mathematics)\n\n    // ========== 技能信息 ==========\n    public SpellInfo spell;                  // 技能信息(DOTS版本)\n\n    // ========== 标志位(与MonoBehaviour版本类似) ==========\n    public bool immuneDamage;\n    public bool ignorePlayerInvincibleFrame;\n    public bool ignoreRelicDodge;\n    public bool ignoreUmbrella;\n    public bool ignoreRelicOrCurseDamageRatioChange;\n    public bool isTrapDamage;\n    public bool isUndifferDamage;\n    public bool isPercentageDamage;\n    public bool isTeammateThrough;\n    public bool stopAnnouncedDeath;\n    public bool targetAlreadyDeadBeforeDamage;\n\n    // ========== 特效控制 ==========\n    public bool dontCreateDeadEF;\n    public bool dontCreatebloodSplat;\n    public bool dontPlayDeadSE;\n    public bool dontPlayHitSE;\n    public bool dontPlayBeHitColor;\n    public bool dontPlayBeHitShake;\n    public bool dontFloatText;\n\n    // ========== 伤害比例 ==========\n    public float playerTakeDamageRatio;\n    public float teammateTakeDamageRatio;\n\n    // ========== 充能相关 ==========\n    public bool chargeWand;                  // 是否充能魔杖\n    public float chargeValue;                // 充能值\n}\n```\n\n### AttackerType 枚举\n\n**文件位置**: [AttackerType.cs](AttackerType.cs:1)\n\n```csharp\npublic enum AttackerType\n{\n    NothingSpecial,      // 普通攻击\n    FromUI,              // 来自UI(点击返回营地按钮)\n    FromRelic,           // 来自遗物效果\n    FromCurse,           // 来自诅咒效果\n    FromEnvironment,     // 来自环境(陷阱、地刺等)\n    FromSpell,           // 来自技能\n    FromSummon           // 来自召唤物\n}\n```\n\n---\n\n## 伤害计算流程\n\n### 完整流程图\n\n```\n┌─────────────────────────────────────────────────┐\n│ 阶段 0: 伤害信息创建                            │\n│ 触发: 技能碰撞、技能持续伤害、环境伤害         │\n├─────────────────────────────────────────────────┤\n│ 创建 TakeDamageInfo_Dots 对象                   │\n│ - attackerEntity = spell.ownerEntity            │\n│ - targetEntity = hitUnit.entity                 │\n│ - damage = spell.damage                         │\n│ - criticalChance = spell.criticalChance         │\n│ - knockbackForce = spell.knockback * direction  │\n│                                                  │\n│ 添加到目标Entity的 DynamicBuffer                │\n│ entityMgr.GetBuffer<TakeDamageInfo_Dots>(target)│\n│           .Add(damageInfo);                      │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 1: 伤害预处理                              │\n│ System: TakeDamageInfoPreProcessSystem          │\n│ 文件: TakeDamageInfoPreProcessSystem.cs:157-336 │\n├─────────────────────────────────────────────────┤\n│ 1.1 检查无敌/禁用状态                           │\n│   if (unitPpt.IsInvincible)                     │\n│       info.immuneDamage = true                  │\n│   if (unitPpt.isSolidObj && !info.isUndifferDamage)│\n│       info.immuneDamage = true                  │\n│                                                  │\n│ 1.2 特殊技能伤害修正                            │\n│   - Boss技能对队友伤害 x2~x3                    │\n│   - 特定技能对玩家伤害 x0.05                    │\n│                                                  │\n│ 1.3 根据目标类型应用修正                        │\n│   switch (unitPpt.unitType):                    │\n│     case Player:                                │\n│       - 检查无敌帧                              │\n│       - 应用闪避遗物                            │\n│       - 应用减伤遗物                            │\n│       - 应用增伤诅咒                            │\n│       - 应用玩家受伤比例                        │\n│     case Teammate:                              │\n│       - 应用队友受伤比例                        │\n│     case Monster/Elite/Boss:                    │\n│       - 应用敌人减伤诅咒                        │\n│                                                  │\n│ 1.4 暴击判定                                    │\n│   if (Random.value <= criticalChance)           │\n│       info.isDamageCritical = true              │\n│       info.damage *= criticalDamageRatio        │\n│                                                  │\n│ 1.5 伤害取整                                    │\n│   info.damage = ceil(info.damage)               │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 2: 受伤前处理 (MonoBehaviour)              │\n│ System: UnitBeforeTakeDamageSystem              │\n│ 文件: UnitBeforeTakeDamageSystem.cs:255-276     │\n├─────────────────────────────────────────────────┤\n│ 调用 MonoBehaviour 的 BeforeTakeDamage() 方法  │\n│   unitPpt.UnitBas.BeforeTakeDamage_Dots(info)   │\n│                                                  │\n│ 此阶段由各个单位的 UnitBase 子类实现           │\n│ 常见逻辑:                                       │\n│ - Boss特殊阶段判定                              │\n│ - Elite特殊技能触发                             │\n│ - 遗物/诅咒特殊效果                             │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 3: 属性更新 (护盾和生命值扣除)            │\n│ System: UnitPropertySystem                      │\n│ 文件: UnitPropertySystem.cs (DOTS Job)          │\n├─────────────────────────────────────────────────┤\n│ 3.1 扣除护盾                                    │\n│   if (shield > 0)                               │\n│       damageToShield = min(damage, shield)      │\n│       shield -= damageToShield                  │\n│       damage -= damageToShield                  │\n│       realDamage = 0                            │\n│                                                  │\n│ 3.2 扣除临时护盾                                │\n│   if (shieldTemp > 0 && damage > 0)             │\n│       damageToTempShield = min(damage, shieldTemp)│\n│       shieldTemp -= damageToTempShield          │\n│       damage -= damageToTempShield              │\n│       realDamage += damageToTempShield          │\n│                                                  │\n│ 3.3 扣除生命值                                  │\n│   if (damage > 0)                               │\n│       currentHP -= damage                       │\n│       realDamage += damage                      │\n│                                                  │\n│ 3.4 应用击退                                    │\n│   if (!IsImmuneKnockback)                       │\n│       AddForce(knockbackForce * knockbackRatio) │\n│                                                  │\n│ 3.5 检查死亡                                    │\n│   if (currentHP <= 0)                           │\n│       isDead = true                             │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 4: 受伤后处理 (特效和音效)                │\n│ System: UnitAfterTakeDamageSystem               │\n│ 文件: UnitAfterTakeDamageSystem.cs:271-357      │\n├─────────────────────────────────────────────────┤\n│ 4.1 调用 MonoBehaviour 的 AfterTakeDamage()    │\n│   unitPpt.UnitBas.AfterTakeDamage_Dots(info)    │\n│                                                  │\n│ 4.2 播放受击音效                                │\n│   - 玩家: 根据外观播放不同音效                 │\n│     (Huang/Dave/Frog/Normal)                    │\n│   - 敌人: 播放配置的 beHitSE                    │\n│                                                  │\n│ 4.3 更新UI                                      │\n│   - 玩家: 更新HP条                              │\n│   - 玩家: 播放受击闪红动画                     │\n│                                                  │\n│ 4.4 触发遗物/诅咒效果                           │\n│   - OnTakeDamage 事件                           │\n│   - OnPlayerTakeDamage 事件                     │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 5: 死亡判定                                │\n│ System: UnitTakeDamageDeadSystem                │\n│ 文件: UnitTakeDamageDeadSystem.cs:224-410       │\n├─────────────────────────────────────────────────┤\n│ 5.1 检查是否死亡                                │\n│   if (!unitPpt.isDead) continue                 │\n│                                                  │\n│ 5.2 根据单位类型处理死亡                        │\n│   switch (unitType):                            │\n│     case Player:                                │\n│       - 记录死亡日志                            │\n│       - 显示死亡UI                              │\n│       - 触发 GameOver 事件                      │\n│                                                  │\n│     case Teammate:                              │\n│       - 添加 TeammateDeadTag 组件               │\n│       - 从房间管理器注销                        │\n│                                                  │\n│     case Monster/Elite/Boss:                    │\n│       - 掉落物品                                │\n│       - 创建死亡特效                            │\n│       - 播放死亡音效                            │\n│       - 创建尸体                                │\n│       - 创建血迹                                │\n│       - 从房间管理器注销                        │\n│       - 触发死亡事件                            │\n│                                                  │\n│ 5.3 特殊死亡效果                                │\n│   - 虚空爆炸 (Spell3129VoidExplosion)           │\n│   - 死亡蠕虫生成                                │\n│   - 召唤物死亡爆炸                              │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 6: 伤害记录                                │\n│ System: DamageRecordSystem                      │\n│ 文件: DamageRecordSystem.cs                     │\n├─────────────────────────────────────────────────┤\n│ 记录伤害到 DamageRecorder                       │\n│ - 按攻击者统计总伤害                            │\n│ - 按技能统计使用次数                            │\n│ - 更新伤害排行榜                                │\n│ - 更新UI显示                                    │\n└─────────────────────────────────────────────────┘\n                    ↓\n┌─────────────────────────────────────────────────┐\n│ 阶段 7: 清除伤害信息                            │\n│ System: UnitTakeDamageClearSystem               │\n│ 文件: UnitTakeDamageClearSystem.cs              │\n├─────────────────────────────────────────────────┤\n│ 清空所有 Entity 的 TakeDamageInfo_Dots Buffer  │\n│ foreach (entity in allUnits)                    │\n│     GetBuffer<TakeDamageInfo_Dots>(entity).Clear()│\n└─────────────────────────────────────────────────┘\n```\n\n---\n\n## 伤害预处理系统\n\n**文件位置**: [TakeDamageInfoPreProcessSystem.cs](TakeDamageInfoPreProcessSystem.cs:1)\n\n这是伤害计算的第一个阶段,负责计算最终伤害值。\n\n### 主要职责\n\n1. 检查无敌状态\n2. 特殊技能伤害修正\n3. 应用遗物/诅咒修正\n4. 暴击判定\n5. 伤害取整\n\n### Execute 方法解析\n\n**位置**: [TakeDamageInfoPreProcessSystem.cs:157-336](TakeDamageInfoPreProcessSystem.cs:157-336)\n\n```csharp\nprivate void Execute(DynamicBuffer<TakeDamageInfo_Dots> takeDamageBuffer,\n                     ref UnitProperty_Dots unitPpt,\n                     Entity entity,\n                     [ChunkIndexInQuery] int index)\n{\n    // 1. 检查单位是否禁用\n    if (unitPpt.disabled)\n        return;\n\n    // 获取单位位置(用于闪避文字显示)\n    RefRO<LocalTransform> transform = cluLocalTsf.GetRefRO(entity);\n\n    // 遍历所有伤害信息\n    for (int i = 0; i < takeDamageBuffer.Length; i++)\n    {\n        ref TakeDamageInfo_Dots info = ref takeDamageBuffer.ElementAt(i);\n\n        // ========== 1. 基础免疫检查 ==========\n\n        // 1.1 无敌状态\n        if (unitPpt.IsInvincible)\n        {\n            info.immuneDamage = true;\n        }\n\n        // 1.2 固体物体免疫(除非是真实伤害)\n        if (unitPpt.unitCfg.isSolidObj && !info.isUndifferDamage)\n        {\n            info.immuneDamage = true;\n        }\n\n        // 1.3 已经死亡\n        if (unitPpt.isDead)\n        {\n            info.targetAlreadyDeadBeforeDamage = true;\n            continue;\n        }\n\n        // ========== 2. 特殊技能伤害修正 ==========\n\n        if (info.spell.Entity != Entity.Null)\n        {\n            int spellBaseID = info.spell.Config.Id / 10;\n\n            switch (spellBaseID)\n            {\n                // Boss技能对队友伤害 x2\n                case 9002: case 9004: case 9006: case 9017: case 9045:\n                    if (unitPpt.unitCfg.unitType == UnitType.Teammate ||\n                        unitPpt.unitCfg.unitType == UnitType.TeammateNotAttack)\n                    {\n                        info.damage *= 2f;\n                    }\n                    break;\n\n                // Boss技能对队友伤害 x3\n                case 9012: case 9020: case 9043:\n                case 9021: case 9022: case 9026: case 9027: case 9044:\n                    if (unitPpt.unitCfg.unitType == UnitType.Teammate ||\n                        unitPpt.unitCfg.unitType == UnitType.TeammateNotAttack)\n                    {\n                        info.damage *= 3f;\n                    }\n                    break;\n\n                // Boss15技能对玩家伤害 x0.05\n                case 9015:\n                    if (unitPpt.unitCfg.unitType == UnitType.Player)\n                    {\n                        info.damage *= 0.05f;\n                    }\n                    break;\n            }\n        }\n\n        // ========== 3. 根据目标类型应用修正 ==========\n\n        switch (unitPpt.unitCfg.unitType)\n        {\n            case UnitType.Player:\n                ProcessPlayerDamage(ref info, unitPpt, transform, index);\n                break;\n\n            case UnitType.Teammate:\n            case UnitType.TeammateNotAttack:\n                ProcessTeammateDamage(ref info);\n                break;\n\n            case UnitType.Monster:\n            case UnitType.Elite:\n            case UnitType.Boss:\n            case UnitType.WillAttack:\n            case UnitType.NotAttack:\n            case UnitType.Brittleness:\n                ProcessEnemyDamage(ref info);\n                break;\n        }\n\n        // ========== 4. 易伤效果 ==========\n\n        if (unitPpt.DamageReciveIncresePercent > 0f &&\n            !info.isPercentageDamage)\n        {\n            info.damage *= unitPpt.DamageReciveIncresePercent;\n        }\n\n        // ========== 5. 暴击判定 ==========\n\n        if (!info.isDamageCritical)\n        {\n            float critChance = info.extraCriticalChance;\n            if (info.spell.Entity != Entity.Null)\n            {\n                critChance = info.spell.Config.CriticalChance;\n            }\n\n            if (critChance > 0f &&\n                DTool.RandomValue(ref gRandom.ValueRW.random) <= critChance)\n            {\n                info.isDamageCritical = true;\n\n                // 暴击伤害倍率\n                if (IsPlayerAttack(info) && relic_AddCriticleDamageRatio > 0f)\n                {\n                    // 玩家有暴击伤害遗物\n                    info.damage *= relic_AddCriticleDamageRatio;\n                }\n                else\n                {\n                    // 默认暴击伤害 x2\n                    info.damage *= 2f;\n                }\n            }\n        }\n\n        // ========== 6. 伤害取整 ==========\n\n        info.damage = (int)math.ceil(info.damage);\n    }\n}\n```\n\n### 玩家伤害处理 (ProcessPlayerDamage)\n\n```csharp\nprivate void ProcessPlayerDamage(ref TakeDamageInfo_Dots info,\n                                  UnitProperty_Dots unitPpt,\n                                  RefRO<LocalTransform> transform,\n                                  int index)\n{\n    // 1. 特殊攻击类型: 来自UI(返回营地)\n    if (info.attackerType == AttackerType.FromUI)\n    {\n        // 直接清空生命值和护盾\n        unitPpt.unitCfg.currentHP = 0f;\n        unitPpt.unitCfg.shield = 0f;\n        unitPpt.unitCfg.shieldTemp = 0f;\n        return;\n    }\n\n    // 2. 无敌帧检查\n    if (!info.ignorePlayerInvincibleFrame &&\n        unitPpt.IsPlayerInInvincibleFrame)\n    {\n        info.knockbackForce = Vector3.zero;\n        info.immuneDamage = true;\n    }\n\n    // 3. 陷阱伤害加成 (诅咒: 陷阱目标)\n    if (info.isTrapDamage && curse_TargetedTrapExtraDamageRatio > 0f)\n    {\n        info.damage *= 1f + curse_TargetedTrapExtraDamageRatio;\n    }\n\n    // 4. 闪避检查 (遗物)\n    if (relic_DodgeChance > 0f &&\n        !info.ignoreRelicDodge &&\n        DTool.RandomValue(ref gRandom.ValueRW.random) <= relic_DodgeChance)\n    {\n        info.knockbackForce = Vector3.zero;\n        info.immuneDamage = true;\n\n        // 显示\"闪避\"浮动文字\n        ecb.AppendToBuffer(index, uiTextFloatByJobEtt,\n            new UITextFloatByJobBED\n            {\n                textID = 1002001,  // \"闪避\"\n                type = UITextFloatType.Normal,\n                worldPos = transform.ValueRO.Position\n            });\n    }\n\n    // 5. 减伤遗物\n    if (relic_ReduceDamageRatio > 0f &&\n        !info.ignoreRelicOrCurseDamageRatioChange)\n    {\n        info.damage *= 1f - relic_ReduceDamageRatio;\n    }\n\n    // 6. 增伤遗物: 强者\n    if (relic_PowerfulManIncreaseDamage > 0f &&\n        !info.ignoreRelicOrCurseDamageRatioChange)\n    {\n        info.damage *= 1f + relic_PowerfulManIncreaseDamage;\n    }\n\n    // 7. 增伤诅咒: 脆弱\n    if (curse_VulnerabilityExtraDamageRatio > 0f &&\n        !info.ignoreRelicOrCurseDamageRatioChange)\n    {\n        info.damage *= 1f + curse_VulnerabilityExtraDamageRatio;\n    }\n\n    // 8. 增伤诅咒: 金币越多受伤越高\n    if (curse_MoreMoneyMoreInjuredExtraDamageRatio > 0f &&\n        !info.ignoreRelicOrCurseDamageRatioChange)\n    {\n        info.damage *= 1f + curse_MoreMoneyMoreInjuredExtraDamageRatio;\n    }\n\n    // 9. 应用玩家受伤比例\n    if (info.playerTakeDamageRatio != 1f)\n    {\n        info.damage *= info.playerTakeDamageRatio;\n    }\n\n    // 10. 真实伤害特殊处理\n    if (info.isUndifferDamage)\n    {\n        if (info.spell.Entity != Entity.Null)\n        {\n            // 限制真实伤害最多为33.33%\n            info.damage *= math.min(\n                info.spell.Config.UndifferDamageRatio,\n                0.3333f\n            );\n        }\n        else\n        {\n            info.damage *= 0.3333f;\n        }\n    }\n}\n```\n\n### 队友伤害处理\n\n```csharp\nprivate void ProcessTeammateDamage(ref TakeDamageInfo_Dots info)\n{\n    // 1. 陷阱伤害加成\n    if (info.isTrapDamage && curse_TargetedTrapExtraDamageRatio > 0f)\n    {\n        info.damage *= 1f + curse_TargetedTrapExtraDamageRatio;\n    }\n\n    // 2. 应用队友受伤比例\n    info.damage *= info.teammateTakeDamageRatio;\n}\n```\n\n### 敌人伤害处理\n\n```csharp\nprivate void ProcessEnemyDamage(ref TakeDamageInfo_Dots info)\n{\n    // 诅咒: 敌人减伤\n    if (curse_EnemyReduceDamageRatio > 0f &&\n        !info.isPercentageDamage)\n    {\n        info.damage *= 1f - curse_EnemyReduceDamageRatio;\n    }\n}\n```\n\n---\n\n## 受伤前处理系统\n\n**文件位置**: [UnitBeforeTakeDamageSystem.cs](UnitBeforeTakeDamageSystem.cs:1)\n\n这个系统在伤害应用前调用各个单位的 `BeforeTakeDamage_Dots` 方法,允许单位进行自定义处理。\n\n### OnUpdate 方法\n\n**位置**: [UnitBeforeTakeDamageSystem.cs:255-286](UnitBeforeTakeDamageSystem.cs:255-286)\n\n```csharp\npublic void OnUpdate(ref SystemState state)\n{\n    // 特殊处理: Boss6第二阶段\n    bool isBoss6Stage2 = false;\n    if (Boss6_Stage2.Inst != null &&\n        !Boss6_Stage2.Inst.myPpt.AlreadyDead &&\n        UnitDotsSyncSystem.EntityIsValid(Boss6_Stage2.Inst.myPpt.myEntity))\n    {\n        isBoss6Stage2 = true;\n        Boss6_Stage2.Inst.takeDamageInfoBuffer =\n            state.EntityManager.GetBuffer<TakeDamageInfo_Dots>(\n                Boss6_Stage2.Inst.myPpt.myEntity);\n    }\n\n    // 遍历所有有伤害信息的单位\n    foreach (var (unitPptReference, damageBuffer) in Query(...))\n    {\n        if (damageBuffer.Length <= 0)\n            continue;\n\n        // 遍历该单位的所有伤害信息\n        for (int i = 0; i < damageBuffer.Length; i++)\n        {\n            // 特殊排除: 某个特定单位ID\n            if (unitPptReference.unitPpt.unitCfg.id != 500621)\n            {\n                // 调用 MonoBehaviour 的受伤前处理\n                unitPptReference.unitPpt.UnitBas.BeforeTakeDamage_Dots(\n                    ref damageBuffer.ElementAt(i)\n                );\n            }\n        }\n    }\n\n    // Boss6特殊处理\n    if (isBoss6Stage2)\n    {\n        DynamicBuffer<TakeDamageInfo_Dots> buffer =\n            state.EntityManager.GetBuffer<TakeDamageInfo_Dots>(\n                Boss6_Stage2.Inst.myPpt.myEntity);\n\n        for (int j = 0; j < buffer.Length; j++)\n        {\n            Boss6_Stage2.Inst.BeforeTakeDamage_Dots(\n                ref buffer.ElementAt(j)\n            );\n        }\n    }\n}\n```\n\n### UnitBase.BeforeTakeDamage_Dots 虚方法\n\n**文件位置**: [UnitBase.cs:453-455](UnitBase.cs:453-455)\n\n```csharp\npublic virtual void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n{\n    // 默认为空,由子类重写\n    // 例如:\n    // - Boss进入特殊阶段\n    // - Elite触发特殊技能\n    // - 遗物效果触发\n}\n```\n\n### 常见用途示例\n\n#### 示例 1: Boss阶段切换\n\n```csharp\n// Boss1.cs\npublic override void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n{\n    UnitProperty_Dots ppt = GetComponentData<UnitProperty_Dots>();\n\n    // 当HP低于50%时进入狂暴阶段\n    if (!isEnraged && ppt.unitCfg.currentHP < ppt.unitCfg.maxHP * 0.5f)\n    {\n        isEnraged = true;\n        EnterEnragedPhase();\n    }\n}\n```\n\n#### 示例 2: 遗物触发\n\n```csharp\n// PlayerController.cs\npublic override void BeforeTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n{\n    // 遗物: 受伤时获得护盾\n    if (PlayerMgr.Inst.ItemCtrller.relic_ShieldOnHit != null)\n    {\n        float shieldAmount = info.damage * 0.2f;\n        PlayerMgr.Inst.ChangeShield(shieldAmount);\n    }\n\n    // 遗物: 受伤时触发反击\n    if (PlayerMgr.Inst.ItemCtrller.relic_CounterAttack != null)\n    {\n        LaunchCounterAttack(info.attackerEntity);\n    }\n}\n```\n\n---\n\n## 受伤后处理系统\n\n**文件位置**: [UnitAfterTakeDamageSystem.cs](UnitAfterTakeDamageSystem.cs:1)\n\n这个系统在伤害应用后处理特效、音效和UI更新。\n\n### OnUpdate 方法\n\n**位置**: [UnitAfterTakeDamageSystem.cs:271-357](UnitAfterTakeDamageSystem.cs:271-357)\n\n```csharp\npublic void OnUpdate(ref SystemState state)\n{\n    foreach (var (unitDead, unitPpt, damageBuffer, entity) in Query(...))\n    {\n        if (damageBuffer.Length <= 0)\n            continue;\n\n        bool hasRealDamage = false;\n\n        // ========== 1. 检查是否有实际伤害 ==========\n\n        if (unitPpt.ValueRO.unitCfg.isHybirdUnit)\n        {\n            // 混合单位(Mono + DOTS)\n            UnitPptReference unitPptRef = null;\n\n            for (int i = 0; i < damageBuffer.Length; i++)\n            {\n                if (!damageBuffer[i].immuneDamage &&\n                    damageBuffer[i].realDamage > 0f)\n                {\n                    hasRealDamage = true;\n\n                    if (unitPptRef == null)\n                    {\n                        unitPptRef = state.EntityManager\n                            .GetComponentObject<UnitPptReference>(entity);\n                    }\n\n                    if (!unitPpt.ValueRO.isDead)\n                    {\n                        // 调用 MonoBehaviour 的受伤后处理\n                        unitPptRef.unitPpt.UnitBas.AfterTakeDamage_Dots(\n                            ref damageBuffer.ElementAt(i)\n                        );\n                    }\n                }\n            }\n        }\n        else\n        {\n            // 纯 DOTS 单位\n            for (int j = 0; j < damageBuffer.Length; j++)\n            {\n                if (!damageBuffer[j].immuneDamage &&\n                    damageBuffer[j].realDamage > 0f)\n                {\n                    hasRealDamage = true;\n                    break;\n                }\n            }\n        }\n\n        // ========== 2. 播放受击音效 ==========\n\n        if (unitPpt.ValueRO.unitCfg.id == 800001)  // 玩家\n        {\n            ref PlayerController_Dots playerCtrl =\n                ref GetComponentRW<PlayerController_Dots>(entity).ValueRW;\n\n            if (playerCtrl.isHurtThisFrameForPlayer)\n            {\n                playerCtrl.isHurtThisFrameForPlayer = false;\n\n                // 更新HP UI\n                UIPlayerDataMgr.Inst.UpdateHP();\n\n                // 根据外观播放不同音效\n                if (PlayerMgr.Inst.ItemCtrller.relic_Huang != null)\n                {\n                    SEMgr.Inst.injured_Huang.PlaySE();\n                }\n                else if (PlayerMgr.Inst.ItemCtrller.uiRelic_DaveHarpoons != null)\n                {\n                    SEMgr.Inst.injured_Dave.PlaySE();\n                }\n                else if (DataMgr.selectedWorldData.playerLook == PlayerLook.Frog)\n                {\n                    SEMgr.Inst.injured_Frog.PlaySE();\n                }\n                else\n                {\n                    SEMgr.Inst.injured_Player.PlaySE();\n                }\n\n                // 播放受击闪红动画\n                if (!GameMgr.IsHarmony_Static)\n                {\n                    UIPlayerDataMgr.Inst.UIPlayerInjuredPlay();\n                }\n            }\n        }\n        else if (hasRealDamage && unitPpt.ValueRO.unitCfg.id != 800001)  // 敌人\n        {\n            // 播放敌人受击音效\n            UnitConfig.map[unitPpt.ValueRO.unitCfg.id]\n                .beHitSE.Value.PlaySE(SEPlayMode.Unique, 3, 0.2f);\n        }\n    }\n\n    // ========== 3. 玩家特殊处理 ==========\n\n    DynamicBuffer<TakeDamageInfo_Dots> playerDamageBuffer =\n        GetBuffer<TakeDamageInfo_Dots>(PlayerMgr.Inst.PlayerEtt);\n    UnitProperty_Dots playerPpt =\n        GetComponent<UnitProperty_Dots>(PlayerMgr.Inst.PlayerEtt);\n\n    for (int k = 0; k < playerDamageBuffer.Length; k++)\n    {\n        TakeDamageInfo_Dots info = playerDamageBuffer[k];\n\n        if (!info.immuneDamage &&\n            (info.realDamage > 0f || info.hitMagicShieldDamage > 0f) &&\n            !playerPpt.isDead)\n        {\n            // 调用玩家控制器的受伤后处理\n            PlayerMgr.Inst.PlayerCtrller.AfterTakeDamage(\n                ref playerDamageBuffer.ElementAt(k)\n            );\n        }\n    }\n}\n```\n\n### UnitBase.AfterTakeDamage_Dots 虚方法\n\n**文件位置**: [UnitBase.cs:461-463](UnitBase.cs:461-463)\n\n```csharp\npublic virtual void AfterTakeDamage_Dots(ref TakeDamageInfo_Dots info)\n{\n    // 默认为空,由子类重写\n    // 例如:\n    // - 播放受击动画\n    // - 创建受击特效\n    // - 触发反弹\n    // - 生成血液粒子\n}\n```\n\n---\n\n## 死亡判定系统\n\n**文件位置**: [UnitTakeDamageDeadSystem.cs](UnitTakeDamageDeadSystem.cs:1)\n\n### OnUpdate 方法\n\n**位置**: [UnitTakeDamageDeadSystem.cs:210-410](UnitTakeDamageDeadSystem.cs:210-410)\n\n```csharp\nprotected unsafe override void OnUpdate()\n{\n    EntityCommandBuffer ecb = GetSingleton<EndSimulationECBSystem.Singleton>()\n        .CreateCommandBuffer(World.Unmanaged);\n\n    Entity uiTextFloatEntity = GetSingletonEntity<UITextFloatByJobSingleton>();\n\n    // 清理缓存\n    _deadPpts.Clear();\n    _deadInfos.Clear();\n    _deadInfoIndex.Clear();\n    deadEntities.Clear();\n\n    // 遍历所有已死亡的单位\n    foreach (var (unitDead, unitPpt, transform, entity) in Query(...))\n    {\n        if (!unitPpt.ValueRO.isDead)\n            continue;\n\n        ref UnitDead deadData = ref unitDead.ValueRW;\n        LocalTransform pos = transform.ValueRO;\n\n        // 玩家最终死亡检查\n        if (deadData.playerFinallyDead)\n            break;\n\n        // ========== 1. 队友死亡处理 ==========\n\n        if (unitPpt.ValueRO.unitCfg.unitType == UnitType.Teammate ||\n            unitPpt.ValueRO.unitCfg.unitType == UnitType.TeammateNotAttack)\n        {\n            // 添加队友死亡标签\n            SetComponentEnabled<TeammateDeadTag>(entity, true);\n            continue;\n        }\n\n        // ========== 2. 掉落物品 ==========\n\n        if (unitPpt.ValueRO.deadDropItemInfos.IsCreated &&\n            unitPpt.ValueRO.deadDropItemInfos.Value.Length > 0)\n        {\n            QuickCreateSystem.Inst.CreateItemDrop(\n                LevelMgr.Inst.CurrentRoomMapPos,\n                unitPpt.ValueRO.deadDropItemInfos,\n                Tool2D.IgnoreZPoint(pos.Position),\n                0.2f\n            );\n        }\n\n        // ========== 3. 虚空爆炸检查 ==========\n\n        if ((unitPpt.ValueRO.unitCfg.triggerDeadEvent ||\n             IsSpecialVoidExplosionUnit(unitPpt.ValueRO.unitCfg.id)) &&\n            unitPpt.ValueRO.voidExplosionData.InstantKillRatio > 0f)\n        {\n            // 创建虚空爆炸\n            GameObject voidExplosion = ObjPoolMgr.Inst.GetGO(\n                \"Prefabs/Spell/\" + 31291,\n                pos.Position,\n                2.5f\n            );\n            voidExplosion.transform.localScale = Vector3.one;\n            voidExplosion.GetComponent<Spell3129VoidExplosion>()\n                .DataInitialize_Dots(\n                    unitPpt.ValueRO.unitCfg.maxHP,\n                    unitPpt.ValueRO.voidExplosionData\n                );\n\n            // 创建爆炸粒子\n            ecb.AppendToBuffer(uiTextFloatEntity,\n                new GlobalParticleEmitParams(\n                    GlobalParticleType.Spell,\n                    \"3129_Explosion\",\n                    pos.Position\n                )\n                { Size = 0.417f }\n            );\n        }\n\n        // ========== 4. 死亡特效 ==========\n\n        if (!deadData.deadlyInfo.dontCreateDeadEF)\n        {\n            if (unitPpt.ValueRO.unitCfg.deadEF != \"\")\n            {\n                bool isSummonTransparent =\n                    (unitPpt.ValueRO.unitCfg.unitType == UnitType.Teammate ||\n                     unitPpt.ValueRO.unitCfg.unitType == UnitType.TeammateNotAttack) &&\n                    DataMgr.settingData.FinalSummonTransparent <= 0.01f;\n\n                if (!isSummonTransparent)\n                {\n                    string effectPath = \"Prefabs/EF/\" +\n                        unitPpt.ValueRO.unitCfg.deadEF.ToString();\n\n                    // 特殊处理: 血液/幽灵死亡特效有多个变体\n                    if (unitPpt.ValueRO.unitCfg.deadEF == \"EF_Dead_Blood\" ||\n                        unitPpt.ValueRO.unitCfg.deadEF == \"EF_Dead_Ghost\")\n                    {\n                        effectPath += \"_\" + UnityEngine.Random.Range(0, 2);\n\n                        // 使用精灵特效系统\n                        SpriteEffectAnima anima =\n                            ABResources.LoadAsset<SpriteEffectAnima>(effectPath);\n\n                        float3 offset = new float3(\n                            UnityEngine.Random.Range(-0.1f, 0.1f),\n                            0.3f + UnityEngine.Random.Range(-0.1f, 0.1f),\n                            0f\n                        );\n\n                        float radius = GetEntityRadius(entity);\n\n                        SpellSpriteEffectController.Inst.PlayEffect(anima,\n                            new EffectPlayParam\n                            {\n                                Position = pos.Position + offset,\n                                Scale = Vector3.one * Mathf.Max(1f, radius * 2f + 0.3f),\n                                FilpX = (UnityEngine.Random.Range(0, 2) == 0),\n                                Unlit = false\n                            }\n                        );\n                    }\n                    else\n                    {\n                        ObjPoolMgr.Inst.GetGO(effectPath, pos.Position, 5f);\n                    }\n                }\n            }\n        }\n\n        // ========== 5. 永久死亡特效 ==========\n\n        if (unitPpt.ValueRO.unitCfg.deadPermanentEF.ToString() != \"\")\n        {\n            ObjPoolMgr.Inst.GetGO(\n                \"Prefabs/EF/\" + unitPpt.ValueRO.unitCfg.deadPermanentEF.ToString(),\n                pos.Position\n            );\n        }\n\n        // ========== 6. 血迹 ==========\n\n        if (!deadData.deadlyInfo.dontCreatebloodSplat &&\n            unitPpt.ValueRO.unitCfg.bloodSplatSize > 0f)\n        {\n            if (deadData.deadlyInfo.knockbackForce == Vector3.zero)\n            {\n                // 无方向血迹\n                ObjPoolMgr.Inst.GetGO(\"Prefabs/EF/EF_BloodSplat\",\n                    Tool2D.IgnoreZPoint(pos.Position))\n                    .GetComponent<BloodSplat>()\n                    .Initialize(unitPpt.ValueRO.unitCfg.bloodSplatSize);\n            }\n            else\n            {\n                // 有方向血迹\n                ObjPoolMgr.Inst.GetGO(\"Prefabs/EF/EF_BloodSplatDirect\",\n                    Tool2D.IgnoreZPoint(pos.Position))\n                    .GetComponent<BloodSplat>()\n                    .Initialize(\n                        unitPpt.ValueRO.unitCfg.bloodSplatSize,\n                        deadData.deadlyInfo.knockbackForce\n                    );\n            }\n        }\n\n        // ========== 7. 尸体 ==========\n\n        int corpseCount = unitPpt.ValueRO.unitCfg.corpseCount;\n        if (GameMgr.IsMobile_Static)\n        {\n            corpseCount = (int)(corpseCount * 0.5);  // 移动端减半\n        }\n\n        if (unitPpt.ValueRO.unitCfg.corpseType != CorpseType.None)\n        {\n            for (int i = 0; i < corpseCount; i++)\n            {\n                CorpseSystem.Inst.CreateCorpse(\n                    unitPpt.ValueRO.unitCfg.corpseType,\n                    pos.Position,\n                    deadData.deadlyInfo.knockbackForce\n                );\n            }\n        }\n\n        // ========== 8. 死亡音效 ==========\n\n        if (!deadData.deadlyInfo.dontPlayDeadSE)\n        {\n            if (unitPpt.ValueRO.unitCfg.isDeadSE3D)\n            {\n                unitPpt.ValueRO.unitCfg.deadSEs.Value.PlaySE(pos.Position);\n            }\n            else\n            {\n                unitPpt.ValueRO.unitCfg.deadSEs.Value.PlaySE();\n            }\n        }\n\n        // ========== 9. 根据单位类型处理死亡 ==========\n\n        switch (unitPpt.ValueRO.unitCfg.unitType)\n        {\n            case UnitType.Player:\n                HandlePlayerDeath(ref deadData, entity);\n                break;\n\n            case UnitType.Teammate:\n            case UnitType.TeammateNotAttack:\n                LevelMgr.Inst.CurrentRoomCtrller.UnitUnregister(entity);\n                break;\n\n            case UnitType.Monster:\n            case UnitType.Elite:\n            case UnitType.Boss:\n            case UnitType.WillAttack:\n            case UnitType.NotAttack:\n            case UnitType.Brittleness:\n                if (!unitPpt.ValueRO.unitCfg.isHybirdUnit)\n                {\n                    LevelMgr.Inst.CurrentRoomCtrller.UnitUnregister(entity);\n                }\n                break;\n        }\n    }\n}\n```\n\n### 玩家死亡处理\n\n```csharp\nprivate void HandlePlayerDeath(ref UnitDead deadData, Entity entity)\n{\n    Debug.Log(\"Player Dead\");\n\n    // 记录死亡次数\n    DataMgr.selectedWorldData.deadCount++;\n\n    TakeDamageInfo_Dots deadlyInfo = deadData.deadlyInfo;\n\n    // 记录击杀者\n    if (deadlyInfo.attackerEntity != Entity.Null)\n    {\n        if (HasComponent<UnitProperty_Dots>(deadlyInfo.attackerEntity))\n        {\n            int killerID = GetComponent<UnitProperty_Dots>(\n                deadlyInfo.attackerEntity\n            ).unitCfg.id;\n            Debug.Log(\"击杀者id: \" + killerID);\n        }\n        else\n        {\n            Debug.Log(\"击杀者id已经不可考证\");\n        }\n    }\n\n    // 标记玩家最终死亡\n    deadData.playerFinallyDead = true;\n\n    // 记录死亡日志\n    PlayerDeathLogger logger = new PlayerDeathLogger();\n    logger.death_counter = DataMgr.selectedWorldData.deadCount;\n    logger.equips = PlayerEquips.CreateAuto();\n    logger.monsters = LevelMgr.Inst.CurrentRoomCtrller.MonsterPpts\n        .Select(e => e.unitCfg.id).ToList();\n    logger.resources = ResourcesStatus.CreateAuto();\n    logger.click_return_camp =\n        (deadlyInfo.attackerType == AttackerType.FromUI);\n    logger.Report();\n\n    // 移动端数据上报\n    if (GameMgr.IsMobile_Static)\n    {\n        MobileMgr.inst.PluginActivity.UploadItemSnapshot(1);\n    }\n\n    // 触发玩家死亡事件\n    EventMgr.PlayerDead?.Invoke();\n\n    // 显示死亡UI\n    GameUISingletonMono<UIPlayerDead>.ShowInit();\n}\n```\n\n---\n\n## 护盾系统\n\n护盾分为两种类型:\n1. **永久护盾 (shield)**: 不会随时间消失\n2. **临时护盾 (shieldTemp)**: 进门时清除\n\n### 护盾扣除顺序\n\n**位置**: [UnitPropertySystem.cs](UnitPropertySystem.cs:1) (DOTS Job)\n\n```\n伤害应用顺序:\n1. 永久护盾 (shield)\n2. 临时护盾 (shieldTemp)\n3. 生命值 (currentHP)\n```\n\n### 护盾计算伪代码\n\n```csharp\nfloat originalDamage = damageInfo.damage;\nfloat remainingDamage = originalDamage;\nfloat realDamage = 0f;  // 实际造成的伤害(用于统计)\n\n// 1. 扣除永久护盾\nif (shield > 0 && remainingDamage > 0)\n{\n    float damageToShield = Min(remainingDamage, shield);\n    shield -= damageToShield;\n    remainingDamage -= damageToShield;\n    // 注意: 护盾吸收的伤害不计入realDamage\n}\n\n// 2. 扣除临时护盾\nif (shieldTemp > 0 && remainingDamage > 0)\n{\n    float damageToTempShield = Min(remainingDamage, shieldTemp);\n    shieldTemp -= damageToTempShield;\n    remainingDamage -= damageToTempShield;\n    realDamage += damageToTempShield;  // 临时护盾计入实际伤害\n}\n\n// 3. 扣除生命值\nif (remainingDamage > 0)\n{\n    currentHP -= remainingDamage;\n    realDamage += remainingDamage;\n\n    if (currentHP < 0)\n    {\n        currentHP = 0;\n    }\n}\n\n// 4. 检查死亡\nif (currentHP <= 0 && !isDead)\n{\n    isDead = true;\n}\n```\n\n### 护盾来源\n\n#### 1. 遗物提供的护盾\n\n```csharp\n// 遗物: 进门获得护盾\nif (ItemCtrller.relicCfg_FloorShield != null)\n{\n    PlayerMgr.Inst.ChangeShield(relicCfg_FloorShield.int1.result);\n}\n\n// 遗物: 临时护盾\nif (ItemCtrller.relicCfg_TempShield != null)\n{\n    PlayerMgr.Inst.ChangeShieldTemp(relicCfg_TempShield.int1.result);\n}\n```\n\n#### 2. 遗物组提供的护盾\n\n```csharp\n// 遗物组1: 临时护盾转永久护盾\nif (ItemCtrller.relicGroupConfigs.TryGetValue(1, out var config))\n{\n    float shieldPercent = config.int1.result / 100f;\n    float permanentShield = playerPpt.unitCfg.shieldTemp * shieldPercent;\n    PlayerMgr.Inst.ChangeShield(permanentShield);\n}\n```\n\n### ChangeShield 方法\n\n**位置**: [PlayerMgr.cs](PlayerMgr.cs:1)\n\n```csharp\npublic void ChangeShield(float value)\n{\n    EntityManager ettMgr = World.DefaultGameObjectInjectionWorld.EntityManager;\n    UnitProperty_Dots ppt = ettMgr.GetComponentData<UnitProperty_Dots>(PlayerEtt);\n\n    ppt.unitCfg.shield += value;\n\n    // 限制护盾上限\n    float maxShield = ppt.unitCfg.maxHP * 0.5f;  // 最大护盾为最大HP的50%\n    if (ppt.unitCfg.shield > maxShield)\n    {\n        ppt.unitCfg.shield = maxShield;\n    }\n\n    ettMgr.SetComponentData(PlayerEtt, ppt);\n\n    // 更新UI\n    UIPlayerDataMgr.Inst.UpdateHP();\n}\n```\n\n---\n\n## 暴击系统\n\n### 暴击判定流程\n\n```\n1. 获取暴击率\n   ├─ 技能配置的暴击率 (SpellConfig.criticalChance)\n   ├─ 额外暴击率 (TakeDamageInfo.extraCriticalChance)\n   └─ 玩家属性加成 (PlayerMgr.ExtraCriticalRatio)\n\n2. 随机判定\n   if (Random.value <= totalCriticalChance)\n       触发暴击\n\n3. 暴击伤害倍率\n   ├─ 默认: x2.0\n   └─ 遗物加成: x (2.0 + relic_AddCriticleDamageRatio)\n```\n\n### 暴击率计算\n\n**位置**: [PlayerMgr.cs:198-213](PlayerMgr.cs:198-213)\n\n```csharp\npublic float ExtraCriticalRatio\n{\n    get\n    {\n        float ratio = BaData.extraCriticalChance;  // 基础额外暴击率\n\n        // 遗物: 增加暴击率\n        if (ItemCtrller.relicCfg_AddCriticalChance != null)\n        {\n            ratio += (float)relicCfg_AddCriticalChance.int1.result / 100f;\n        }\n\n        // 诅咒: 减少暴击率\n        if (ItemCtrller.curseCfg_ReduceCriticalRatio != null)\n        {\n            ratio += (float)curseCfg_ReduceCriticalRatio.int1.result / 100f;\n        }\n\n        return ratio;\n    }\n}\n```\n\n### 暴击判定代码\n\n**位置**: [TakeDamageInfoPreProcessSystem.cs:315-334](TakeDamageInfoPreProcessSystem.cs:315-334)\n\n```csharp\nif (!info.isDamageCritical)\n{\n    // 获取暴击率\n    float critChance = info.extraCriticalChance;\n    if (info.spell.Entity != Entity.Null)\n    {\n        critChance = info.spell.Config.CriticalChance;\n    }\n\n    // 暴击判定\n    if (critChance > 0f &&\n        DTool.RandomValue(ref gRandom.ValueRW.random) <= critChance)\n    {\n        info.isDamageCritical = true;\n\n        // 计算暴击伤害\n        if (IsPlayerAttack(info) && relic_AddCriticleDamageRatio > 0f)\n        {\n            // 玩家有暴击伤害遗物\n            info.damage *= relic_AddCriticleDamageRatio;\n        }\n        else\n        {\n            // 默认暴击伤害 x2\n            info.damage *= 2f;\n        }\n    }\n}\n```\n\n### 暴击显示\n\n```csharp\n// 创建伤害数字时检查暴击标志\nif (info.isDamageCritical)\n{\n    // 显示黄色大号字体\n    CreateFloatText(\n        damage,\n        position,\n        Color.yellow,\n        scale: 1.5f\n    );\n}\nelse\n{\n    // 显示白色普通字体\n    CreateFloatText(\n        damage,\n        position,\n        Color.white,\n        scale: 1.0f\n    );\n}\n```\n\n---\n\n## 特殊伤害类型\n\n### 1. 真实伤害 (isUndifferDamage)\n\n真实伤害无视大部分防御机制,但有特殊限制。\n\n**特点**:\n- 无视固体物体免疫\n- 对玩家伤害限制在33.33%\n- 不受诅咒减伤影响\n\n**应用代码**: [TakeDamageInfoPreProcessSystem.cs:279-289](TakeDamageInfoPreProcessSystem.cs:279-289)\n\n```csharp\nif (info.isUndifferDamage)\n{\n    if (info.spell.Entity != Entity.Null)\n    {\n        // 限制真实伤害最多为配置值或33.33%,取较小值\n        info.damage *= math.min(\n            info.spell.Config.UndifferDamageRatio,\n            0.3333f\n        );\n    }\n    else\n    {\n        // 默认33.33%\n        info.damage *= 0.3333f;\n    }\n}\n```\n\n### 2. 百分比伤害 (isPercentageDamage)\n\n按目标最大生命值百分比造成伤害。\n\n**特点**:\n- 不受伤害加成/减免影响\n- 不受易伤效果影响\n- 适合对高血量敌人\n\n**计算代码**:\n\n```csharp\nif (info.isPercentageDamage)\n{\n    float maxHP = unitPpt.unitCfg.maxHP;\n    info.damage = maxHP * damagePercent;\n\n    // 注意: 百分比伤害不受以下影响\n    // - relic_ReduceDamageRatio\n    // - curse_VulnerabilityExtraDamageRatio\n    // - DamageReciveIncresePercent\n}\n```\n\n### 3. 陷阱伤害 (isTrapDamage)\n\n来自环境陷阱的伤害。\n\n**特点**:\n- 受诅咒\"陷阱目标\"影响\n- 可以同时伤害玩家和队友\n\n**修正代码**: [TakeDamageInfoPreProcessSystem.cs:244-247](TakeDamageInfoPreProcessSystem.cs:244-247)\n\n```csharp\n// 诅咒: 陷阱目标\nif (info.isTrapDamage && curse_TargetedTrapExtraDamageRatio > 0f)\n{\n    info.damage *= 1f + curse_TargetedTrapExtraDamageRatio;\n}\n```\n\n### 4. 穿透队友伤害 (isTeammateThrough)\n\n特殊技能可以穿透队友而不造成伤害。\n\n**应用场景**:\n- 某些特殊技能\n- 召唤物死亡爆炸\n\n**检查代码**:\n\n```csharp\nif (info.isTeammateThrough &&\n    targetPpt.unitCfg.unitType == UnitType.Teammate)\n{\n    info.immuneDamage = true;\n}\n```\n\n---\n\n## 伤害修正系统\n\n伤害修正分为多个层次:\n\n### 1. 基础伤害修正\n\n```\n基础伤害 = 技能配置伤害 * (1 + ExtraDamageRatio)\n\nExtraDamageRatio 来源:\n- BattleData.extraDamageRatio          基础额外伤害\n- 遗物: 诅咒战士                       +5% per 诅咒\n- 遗物: 金钱即力量                     +X% per Y金币\n- 遗物: 增伤                           +固定%\n- 遗物: 强者                           +固定%\n- 遗物: 疯眼                           动态增长\n- 遗物: 狂战士                         低血增伤\n- 诅咒: 降低伤害和速度                 -固定%\n- 诅咒: 满血增伤                       动态变化\n```\n\n**计算位置**: [PlayerMgr.cs:157-196](PlayerMgr.cs:157-196)\n\n### 2. 受伤减免修正\n\n```\n最终伤害 = 基础伤害 * DamageReductionRatio\n\nDamageReductionRatio 来源:\n- 遗物: 减伤                           * (1 - X%)\n- 遗物: 强者增伤 (敌人)                * (1 + X%)\n- 诅咒: 脆弱                           * (1 + X%)\n- 诅咒: 金币增伤                       * (1 + X%)\n- 诅咒: 敌人减伤                       * (1 - X%)\n```\n\n### 3. 特殊比例修正\n\n```\nplayerTakeDamageRatio:\n- 默认: 1.0\n- 特定技能可以修改\n\nteammateTakeDamageRatio:\n- 默认: 1.0\n- Boss技能对队友: 2.0 或 3.0\n```\n\n### 修正优先级\n\n```\nPriority 1: 特殊技能修正 (Boss技能对队友)\n    ↓\nPriority 2: 玩家基础修正 (无敌帧、闪避)\n    ↓\nPriority 3: 遗物/诅咒伤害比例\n    ↓\nPriority 4: 受伤比例 (playerTakeDamageRatio)\n    ↓\nPriority 5: 真实伤害特殊处理\n    ↓\nPriority 6: 易伤效果\n    ↓\nPriority 7: 暴击判定\n    ↓\nPriority 8: 伤害取整\n```\n\n---\n\n## 伤害公式总结\n\n### 完整伤害计算公式\n\n```\n最终伤害 = ⌈基础伤害 * 修正1 * 修正2 * ... * 修正N * 暴击倍率⌉\n\n其中:\n基础伤害 = 技能伤害 * (1 + ExtraDamageRatio)\n\n修正因子包括(按顺序):\n1. 特殊技能修正 (BossSpellModifier)\n2. 无敌帧检查 (→ immuneDamage)\n3. 闪避检查 (→ immuneDamage)\n4. 减伤遗物 (* (1 - relic_ReduceDamageRatio))\n5. 增伤遗物 (* (1 + relic_PowerfulManIncreaseDamage))\n6. 增伤诅咒 (* (1 + curse_VulnerabilityExtraDamageRatio))\n7. 金币增伤诅咒 (* (1 + curse_MoreMoneyMoreInjured))\n8. 受伤比例 (* playerTakeDamageRatio or teammateTakeDamageRatio)\n9. 真实伤害限制 (* min(undifferRatio, 0.3333))\n10. 易伤效果 (* DamageReciveIncresePercent)\n11. 暴击判定 (* criticalDamageRatio)\n\n⌈x⌉ = ceil(x)  // 向上取整\n```\n\n### 示例计算\n\n#### 场景: 玩家被敌人技能击中\n\n```\n技能原始伤害: 100\n玩家ExtraDamageRatio: 0  (敌人攻击不受玩家加成影响)\n遗物减伤20%\n诅咒脆弱+30%\n临时易伤+50%\n暴击率: 0.3 (30%)\n暴击判定: 成功\n\n计算过程:\n1. 基础伤害 = 100\n2. 应用减伤遗物: 100 * (1 - 0.2) = 80\n3. 应用脆弱诅咒: 80 * (1 + 0.3) = 104\n4. 应用易伤效果: 104 * 1.5 = 156\n5. 暴击判定成功: 156 * 2.0 = 312\n6. 向上取整: ⌈312⌉ = 312\n\n最终伤害: 312\n```\n\n#### 场景: 玩家攻击Boss\n\n```\n技能原始伤害: 50\n玩家ExtraDamageRatio: +50% (各种遗物)\n玩家ExtraCriticalRatio: +20%\n技能暴击率: 10%\n诅咒敌人减伤: -20%\n暴击判定: 失败\n\n计算过程:\n1. 基础伤害 = 50 * (1 + 0.5) = 75\n2. 敌人减伤诅咒: 75 * (1 - 0.2) = 60\n3. 暴击率 = 10% + 20% = 30%\n4. 暴击判定失败: 伤害不变\n5. 向上取整: ⌈60⌉ = 60\n\n最终伤害: 60\n```\n\n---\n\n## 总结\n\n### 关键特性\n\n1. **多阶段流水线**: 伤害经过7个系统依次处理\n2. **可中断性**: 任何阶段都可以将伤害设为免疫\n3. **护盾双重机制**: 永久护盾 + 临时护盾\n4. **暴击系统**: 默认x2,可通过遗物提升\n5. **特殊伤害类型**: 真实伤害、百分比伤害、陷阱伤害\n6. **伤害修正**: 遗物/诅咒/易伤多层修正\n\n### 性能优化\n\n1. **DOTS架构**: 使用Burst编译的Job进行并行处理\n2. **Buffer机制**: 每个Entity维护伤害信息缓冲区\n3. **每帧清理**: 避免内存泄漏\n\n### 扩展点\n\n1. **BeforeTakeDamage**: 受伤前自定义逻辑\n2. **AfterTakeDamage**: 受伤后自定义逻辑\n3. **遗物效果**: 在预处理阶段注入修正\n4. **诅咒效果**: 在预处理阶段注入修正\n\n---\n\n**文档版本**: 1.0\n**最后更新**: 2025-12-17\n**作者**: AI 代码分析助手\n","numLines":1774,"startLine":1,"totalLines":1774}}}
{"parentUuid":"5a20920a-a3d6-4d3c-be6b-3d9dd6b251e4","isSidechain":true,"userType":"external","cwd":"c:\\Users\\li182\\Desktop\\破解游戏\\mefagongyi_script","sessionId":"ff0b8ecb-a749-4e93-a698-3250860d7ed7","version":"2.0.72","gitBranch":"","agentId":"a029a18","slug":"mutable-yawning-narwhal","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01YFfSXZQnBsMsiR9p2iH4dW","type":"message","role":"assistant","content":[{"type":"text","text":"完美！我已经读取了所有战斗系统文档。现在让我提供一份详细的总结。\n\n## 战斗系统文档 - 详细总结\n\n我已完整读取了战斗系统文档的全部5个文档文件。以下是系统的全面总结：\n\n---\n\n## 1. 核心架构设计\n\n### 双层架构设计\n战斗系统采用**MonoBehaviour + DOTS ECS**的混合架构：\n\n**MonoBehaviour层**：\n- 渲染、动画、逻辑控制\n- 高阶状态机决策\n- 玩家/怪物AI行为\n\n**DOTS ECS层**：\n- 高性能计算（Burst编译）\n- 移动、物理、状态效果处理\n- 伤害系统的实际执行\n\n这种设计方案实现了逻辑清晰性和性能的平衡。\n\n---\n\n## 2. 技能系统详细实现\n\n### 2.1 系统核心组成\n```\nSpellConfig (配置) → SpellBase (基类) → Spell1001-4024 (100+种技能实现)\n         ↓\n      Wand (法杖发射器)\n         ↓\nSpellShootGroup (组织单位) → SpellShootData (配置容器)\n```\n\n### 2.2 技能配置系统 (SpellConfig)\n**核心属性**：\n- **基础信息**：ID、等级(1-3)、稀有度(普通/稀有/史诗/特殊)\n- **法力消耗**：基础消耗、加减修正、乘除修正\n- **伤害系统**：基础伤害、DPS标记、暴击率、是否持续伤害\n- **发射属性**：发射数量、散射角度、射击间隔修正\n- **物理属性**：飞行速度、持续时间、击退力、重力、影响半径\n- **特殊能力**：150+种能力类型(齐射、穿透、分裂、反弹等)\n- **召唤物**：召唤ID、数量上限\n- **扩展字段**：float1-3、int1-3用于各种特殊能力\n\n### 2.3 技能类型分类\n\n**按SpellType分类**：\n- **Missile** - 投射物类（基础子弹、滚球、蝴蝶等）\n- **Summon** - 召唤物类（9种召唤物）\n- **Enhance** - 增强类（齐射、穿透、分裂等）\n- **Passive** - 被动类（全局效果修改）\n\n**按能力分类**：\n- **1000系列**：基础投射物(1001-1031，35种)\n- **2000系列**：召唤物(2001-2009，9种)\n- **3000系列**：增强/修改类(3001-3125+，100+种)\n- **4000系列**：特殊被动技能\n- **9000系列**：怪物专用技能\n\n### 2.4 技能基类 (SpellBase)\n\n**关键属性结构**：\n- 物理组件：Rigidbody、TriggerIn、SphereCollider、BoxCollider\n- 拥有者信息：ownerPpt、OwnerTsf、OwnerSpell\n- 配置与参数：spellCfg、InitialParameter、ShootData\n- 属性修正：damageRatio、finalDamageRatio、speedRatio等\n- 特殊移动模式：AroundOwner、FollowTarget、FollowMouse、AroundMouse\n- 系统相关：穿透、反弹、折射、分裂、闪电链、生命线、虚空爆炸等\n\n**生命周期流程**：\n1. OnEnable - 对象池启用\n2. Initialize - 初始化技能\n3. FinalInitialize - 最终初始化（重置属性、应用参数）\n4. Update - 每帧更新（飞行更新、时间检测）\n5. OnRecycle - 回收到对象池\n\n**碰撞检测**：\n- TriggerIn回调处理Monster、Destructible、Wall、Spell碰撞\n- OnHitTarget - 造成伤害、应用状态效果\n- OnHitWall - 反弹或销毁\n- OnHitSpell - 技能间互动\n\n### 2.5 法杖系统 (Wand)\n\n**核心功能**：\n- 技能容器与发射器\n- 法力值管理系统\n- 插槽系统（普通+后置）\n- 被动效果管理\n\n**法杖配置(WandConfig)**：\n- 射击属性：间隔、冷却、散射角、发射数量\n- 法力系统：最大值、恢复速度、消耗修正\n- 伤害系统：暴击率、伤害修正\n- 特殊能力：15+种(随机颜色、高击退、环绕、追踪等)\n- 后置插槽触发系统\n\n**发射系统流程**：\n1. CanShoot - 检查冷却、间隔、法力、是否有技能\n2. ShootSpell - 消耗法力、重置计时器、发射组\n3. ShootSpellGroup - 遍历发射数据\n4. ShootSingleSpell - 创建参数、从对象池获取、初始化、播放音效\n\n**插槽被动效果检查**：\n- 插槽数量修改\n- 冷却和射击间隔修正\n- 法力相关加成(EmptyContainer、ManaEssence)\n- 特殊能力激活(ChargeMode、WandSpirit、EchoRune等)\n\n### 2.6 技能发射系统\n\n**SpellShootGroup (发射组)**：\n- 组织单位，一个法杖多个组循环发射\n- 计算组的后坐力、法力消耗、伤害比例\n\n**SpellShootData (发射数据)**：\n- 技能本体(Spell) + 增强列表(EnhanceList) + 触发器(Triggers)\n- 提供方法获取：速度、伤害、持续时间、影响半径、暴击率、散射角等\n- 元素效果数据：毒素、粘液、火焰、雷电、冰冻、虚空\n\n---\n\n## 3. 单位系统详细实现\n\n### 3.1 双架构设计\n\n```\nMonoBehaviour层（UnitBase + UnitProperty）\n    ↓\nAI逻辑、动画控制、目标搜索\n    ↓\nDOTS ECS层（UnitBase_Dots + UnitProperty_Dots）\n    ↓\n高性能移动、物理、状态效果、伤害计算\n```\n\n### 3.2 单位类型系统 (UnitType)\n\n```csharp\nPlayer              // 玩家\nTeammate            // 队友（会攻击）\nTeammateNotAttack   // 队友（不攻击）\nMonster             // 普通怪物\nElite               // 精英怪物\nBoss                // Boss\nWillAttack          // 会攻击的单位\nNotAttack           // 不攻击的单位\nBrittleness         // 易碎物（可破坏物体）\n```\n\n**阵营分类**：\n- 玩家阵营：Player, Teammate, TeammateNotAttack\n- 敌对阵营：Monster, Elite, Boss, WillAttack\n- 中立阵营：NotAttack, Brittleness\n\n### 3.3 单位配置 (UnitConfig)\n\n**基础属性**：\n- 单位ID、类型、生命值、移动速度\n- 战斗属性：击退比例、受击比例、冰冻时间比例\n\n**免疫属性**：\n- immuneMucus、immuneVenom、immuneSpike、immuneAbyss\n\n**物理特性**：\n- isFly、isCheckStuck、isSolidObj、isHybirdUnit\n\n**视觉表现**：\n- 受击变色、立即出生、血液飞溅大小\n- 尸体类型、尸体数量\n\n**音效特效**：\n- beHitSE、deadEF、deadEFH、deadPermanentEF\n- deadSEs数组、是否3D音效\n\n### 3.4 单位基类 (UnitBase)\n\n**核心方法**：\n- SingleInitial - 单次初始化\n- EveryInitial - 每次进门初始化\n- Frame1Initial / Frame2Initial - 分帧初始化\n- Update - 每帧更新\n- AfterDotsPhysicsUpdate - DOTS物理后更新\n\n**伤害钩子**：\n- BeforeTakeDamage / BeforeTakeDamage_Dots\n- AfterTakeDamage / AfterTakeDamage_Dots\n- BeforeAnnouncedDeath_Dots / AfterDead\n\n**目标搜索系统**：\n- GetNearestTarget - 获取最近可攻击目标\n- GetNearestTargetPlayerFirst - 优先锁定玩家\n- GetRandomTarget - 随机目标\n- ToTargetDistance / ToTargetDir / ToTargetDegree\n\n**移动与翻转**：\n- SetMove - 设置移动并自动翻转\n- SetFlip - 设置翻转方向\n- 支持MonoBehaviour和DOTS两层\n\n**跳跃系统**：\n- JumpStart_Dots / JumpStop_Dots - 管理跳跃状态\n- JumpRebounce - 跳跃反弹\n- 同步DOTS运动数据\n\n**冰冻系统**：\n- SetFrozen - 进入冰冻状态\n- SetUnfrozen - 解除冰冻状态\n- 暂停动画、停止运动\n\n### 3.5 单位属性 (UnitProperty)\n\n**核心属性**：\n- unitCfg、entity、tsf_Layer、SR_Models数组\n- isUnitDead、AlreadyDead、CanTouch\n\n**伤害接口**：\n- TakeDamage(float, UnitProperty) - 简化版\n- TakeDamage(TakeDamageInfo) - 完整版\n- TakeDamage_Dots(ref TakeDamageInfo_Dots) - DOTS版本\n\n### 3.6 DOTS架构组件\n\n**UnitBase_Dots (移动组件)**：\n```csharp\nfloat3 targetMotion         // 目标运动向量\nbool isAutoFlip             // 是否自动翻转\nbool isJumping              // 是否正在跳跃\nfloat jumpUpForce           // 跳跃上升力\nfloat jumpGravity           // 跳跃重力\n```\n\n**UnitProperty_Dots (属性组件)**：\n```csharp\n// 基础属性\nfloat maxHP, currentHP, shield, shieldTemp\nfloat moveSpeed\nbool IsVelocityDeclice      // 速度是否衰减\n\n// 状态效果\nfloat affect_MucusHitTimer, affect_MucusMoveSpeedRatio, affect_MucusSpellSpeedRatio\nfloat affect_VenomDurationTimer, affect_VenomCurrentStack\nfloat affect_burnDurationTimer, affect_burnHPRatio\nAffect_FrozenState FronzenState, float affect_FrozenTime\nVoidExplosionData_Dots voidExplosionData\nfloat abyssEffectTimer\n\n// 免疫计数器系统\nint flyCounter, invincibleCounter, immuneKnockbackCounter\nint immnueMucusCounter, immnueVenomCounter, immuneVoidCounter\n\n// 击退系统\nfloat3 knockbackVelocity\nfloat knockbackDurationTimer\n\n// 受击效果\nfloat beHitShakeTimer, beHitColorTimer\n\n// 特殊状态\nbool canTakeDamage, isInvincible\n```\n\n**免疫计数器机制**：\n- 使用计数器而非布尔值\n- 支持多个来源同时注册/注销\n- 示例：多个技能同时提供飞行，注销一个还能飞行\n\n---\n\n## 4. 伤害计算系统详细实现\n\n### 4.1 系统架构（7阶段流水线）\n\n```\n[技能碰撞] → TakeDamageInfo_Dots创建\n    ↓\n[阶段1] TakeDamageInfoPreProcessSystem - 预处理伤害\n    ├─ 检查无敌状态\n    ├─ 特殊技能伤害修正\n    ├─ 应用遗物/诅咒修正\n    ├─ 暴击判定\n    └─ 伤害取整\n    ↓\n[阶段2] UnitBeforeTakeDamageSystem - 受伤前处理\n    └─ 调用BeforeTakeDamage_Dots虚方法\n    ↓\n[阶段3] UnitPropertySystem - 属性更新\n    ├─ 扣除护盾 → 临时护盾 → 生命值\n    ├─ 应用击退\n    └─ 检查死亡\n    ↓\n[阶段4] UnitAfterTakeDamageSystem - 受伤后处理\n    ├─ 调用AfterTakeDamage_Dots\n    ├─ 播放受击音效\n    └─ 更新UI\n    ↓\n[阶段5] UnitTakeDamageDeadSystem - 死亡判定\n    ├─ 掉落物品\n    ├─ 虚空爆炸\n    ├─ 死亡特效/音效\n    ├─ 血迹/尸体\n    └─ 事件触发\n    ↓\n[阶段6] DamageRecordSystem - 伤害记录\n    └─ 统计伤害数据\n    ↓\n[阶段7] UnitTakeDamageClearSystem - 清除伤害信息\n    └─ 清空Buffer\n```\n\n### 4.2 伤害信息结构\n\n**TakeDamageInfo_Dots (DOTS版本)**：\n```csharp\nEntity attackerEntity, targetEntity\nAttackerType attackerType\nfloat damage, realDamage, hitMagicShieldDamage\nfloat extraCriticalChance\nbool isDamageCritical\nfloat3 knockbackForce\nSpellInfo spell\nbool immuneDamage, ignorePlayerInvincibleFrame, ignoreRelicDodge\nbool ignoreUmbrella, ignoreRelicOrCurseDamageRatioChange\nbool isTrapDamage, isUndifferDamage, isPercentageDamage\nbool isTeammateThrough, stopAnnouncedDeath\nbool targetAlreadyDeadBeforeDamage\nbool dontCreateDeadEF, dontCreatebloodSplat, dontPlayDeadSE\nbool dontPlayHitSE, dontPlayBeHitColor, dontPlayBeHitShake, dontFloatText\nfloat playerTakeDamageRatio, teammateTakeDamageRatio\nbool chargeWand, float chargeValue\n```\n\n**AttackerType枚举**：\n- NothingSpecial、FromUI、FromRelic、FromCurse\n- FromEnvironment、FromSpell、FromSummon\n\n### 4.3 伤害预处理系统\n\n**主要流程**：\n\n1. **基础免疫检查**：\n   - IsInvincible → immuneDamage = true\n   - isSolidObj && !isUndifferDamage → immuneDamage = true\n   - isDead → 标记targetAlreadyDeadBeforeDamage\n\n2. **特殊技能伤害修正**：\n   - Boss技能对队友伤害 x2-3\n   - Boss15对玩家伤害 x0.05\n\n3. **根据目标类型处理**：\n   - **玩家**：无敌帧、闪避、减伤、增伤、诅咒等\n   - **队友**：应用队友受伤比例\n   - **敌人**：敌人减伤诅咒\n\n4. **暴击判定**：\n   - 获取暴击率\n   - 随机判定\n   - 计算暴击伤害（默认x2或x2+遗物加成）\n\n5. **伤害取整**：\n   - ceil(damage)\n\n### 4.4 护盾系统\n\n**护盾扣除顺序**：\n1. 永久护盾 (shield)\n2. 临时护盾 (shieldTemp)\n3. 生命值 (currentHP)\n\n**护盾计算伪代码**：\n```\nif (shield > 0)\n    damageToShield = min(damage, shield)\n    shield -= damageToShield\n    damage -= damageToShield\n    \nif (shieldTemp > 0 && damage > 0)\n    damageToTempShield = min(damage, shieldTemp)\n    shieldTemp -= damageToTempShield\n    damage -= damageToTempShield\n    realDamage += damageToTempShield\n    \nif (damage > 0)\n    currentHP -= damage\n    realDamage += damage\n```\n\n### 4.5 暴击系统\n\n**暴击判定流程**：\n```\n1. 获取暴击率\n   - 技能配置暴击率\n   - 额外暴击率\n   - 玩家属性加成\n   \n2. 随机判定\n   if (Random.value <= totalCriticalChance)\n       触发暴击\n       \n3. 暴击伤害倍率\n   - 默认: x2.0\n   - 遗物加成: x(2.0 + relic_AddCriticleDamageRatio)\n```\n\n### 4.6 特殊伤害类型\n\n**真实伤害 (isUndifferDamage)**：\n- 无视固体物体免疫\n- 对玩家伤害限制在33.33%\n- 不受诅咒减伤影响\n\n**百分比伤害 (isPercentageDamage)**：\n- 按目标最大生命值百分比造成伤害\n- 不受伤害加成/减免影响\n\n**陷阱伤害 (isTrapDamage)**：\n- 来自环境陷阱\n- 受诅咒\"陷阱目标\"影响\n\n### 4.7 伤害公式总结\n\n```\n最终伤害 = ⌈基础伤害 × 修正因子1-10 × 暴击倍率⌉\n\n基础伤害 = 技能伤害 × (1 + ExtraDamageRatio)\n\n修正因子(按顺序):\n1. 特殊技能修正 (BossSpellModifier)\n2. 无敌帧检查 (→ immuneDamage)\n3. 闪避检查 (→ immuneDamage)\n4. 减伤遗物 × (1 - relic_ReduceDamageRatio)\n5. 增伤遗物 × (1 + relic_PowerfulManIncreaseDamage)\n6. 增伤诅咒 × (1 + curse_VulnerabilityExtraDamageRatio)\n7. 金币增伤诅咒 × (1 + curse_MoreMoneyMoreInjured)\n8. 受伤比例 × playerTakeDamageRatio/teammateTakeDamageRatio\n9. 真实伤害限制 × min(undifferRatio, 0.3333)\n10. 易伤效果 × DamageReciveIncresePercent\n\n暴击倍率 = 2.0 or (2.0 + relic_AddCriticleDamageRatio)\n```\n\n---\n\n## 5. 子弹和魔法系统深度分析\n\n### 5.1 移动机制\n\n**基础直线移动 (Spell1001Bullet)**：\n```csharp\n// 初始化时应用速度\nApplySpeedToVelocity()\nrigid.linearVelocity = Direction * CurrentSpeed\n\n// 每帧更新持续时间\nDurationTimer += Time.deltaTime\n\n// 超时处理\nif (DurationTimer > duration)\n    isFlyFinish = true\n    rigid.linearVelocity = Vector3.zero\n```\n\n**特殊移动模式**：\n\n1. **环绕拥有者 (AroundOwner)**：\n   ```csharp\n   spellAroundOwnerCurrentAngle += CurrentSpeed × Time.deltaTime\n   Position = OwnerTsf.position + offset(angle, radius)\n   ```\n\n2. **追踪目标 (FollowTarget)**：\n   ```csharp\n   targetDir = (target.position - transform.position).normalized\n   Direction = Vector3.RotateTowards(Direction, targetDir, rotateSpeed, 0)\n   rigid.linearVelocity = Direction × CurrentSpeed\n   ```\n\n3. **跟随鼠标 (FollowMouse)**：\n   ```csharp\n   mousePos = PlayerMgr.GetMousePoint()\n   targetDir = (mousePos - position).normalized\n   Direction = Vector3.Lerp(Direction, targetDir, lerpSpeed)\n   rigid.linearVelocity = Direction × CurrentSpeed\n   ```\n\n4. **环绕鼠标 (AroundMouse)**：\n   - 类似环绕拥有者但以鼠标位置为中心\n\n### 5.2 生命周期管理\n\n**完整生命周期**：\n```\n[OnEnable] - 对象池启用\n    ↓\n[Initialize] - 调用FinalInitialize\n    ↓\n[FinalInitialize] - 单次初始化、重置属性、应用参数\n    ↓ InitializeCallback()\n[飞行中]\n    ├─ FlyUpdate() - 更新移动/特殊移动\n    ├─ Update() - 检查超时、调用特殊逻辑\n    └─ 碰撞检测\n    ↓\n[OnFlyFinish] - 飞行结束处理\n    ├─ 悬停检测 (SpellHoverTime)\n    ├─ 触发器检测 (OnOverTrigger)\n    ├─ 分裂检测 (SpellSplit)\n    └─ 缩小消失动画\n    ↓\n[PoolRecycle] - 回收到对象池\n    └─ OnRecycle() - 清理引用、触发事件\n```\n\n### 5.3 伤害处理\n\n**碰撞检测系统**：\n```csharp\n// TriggerIn回调\nprotected virtual void TriggerIn(Collider col)\n{\n    if (!finishedInitialize || (isFlyFinish && SpellHoverTimer >= SpellHoverTime))\n        return;\n        \n    switch (col.tag)\n    {\n        case \"Monster\":\n        case \"Destructible\":\n        case \"RollBall\":\n        case \"Brittleness\":\n            OnHitTarget(col.gameObject);\n            break;\n            \n        case \"Wall\":\n            if (!isThroughWall)\n                OnHitWall(col);\n            break;\n            \n        case \"Spell\":\n            OnHitSpell(col);\n            break;\n    }\n}\n```\n\n**伤害制作流程**：\n```csharp\nprotected virtual TakeDamageInfo MakeDamageToUnit(UnitProperty unit)\n{\n    // 1. 计算最终伤害\n    float finalDamage = spellCfg.damage × (1 + damageRatio) × finalDamageRatio\n    \n    // 2. 创建伤害信息\n    TakeDamageInfo damageInfo = new TakeDamageInfo\n    {\n        attackerType = AttackerType.Spell,\n        attackerPpt = ownerPpt,\n        beHitPpt = unit,\n        damage = finalDamage,\n        criticalChance = overalCriticalChance,\n        spellBase = this,\n        knockbackForce = CalculateKnockbackForce(),\n        ...\n    };\n    \n    // 3. 应用状态效果\n    ApplyStatusEffects(unit, damageInfo);\n    \n    // 4. 单位受击处理\n    unit.TakeDamage(damageInfo);\n    \n    return damageInfo;\n}\n```\n\n**状态效果应用**：\n```csharp\nprotected virtual void ApplyStatusEffects(UnitProperty unit, TakeDamageInfo damageInfo)\n{\n    // 粘液\n    if (spellMucusTime > 0)\n        unit.MucusSlowDown(spellMucusTime, moveSpeedRatio, spellSpeedRatio);\n    \n    // 毒素\n    if (spellVenomTime > 0)\n        unit.AddVenomEffect(spellVenomTime, venomOnceCount);\n    \n    // 冰冻\n    if (spellFrozenTime > 0)\n        unit.AddFrozenEffect(spellFrozenTime);\n    \n    // 燃烧\n    if (spellBurnTime > 0)\n        unit.AddBurnEffect(spellBurnTime, burnHpRatioPerSeconds);\n}\n```\n\n### 5.4 Mono层交互方式\n\n**初始化参数传递**：\n```csharp\nSpellInitialParameter parameter = new SpellInitialParameter(...)\n{\n    ownerPpt,           // 拥有者属性\n    shootDirection,     // 发射方向\n    spelldataConfig,    // 技能配置\n    casterWand,         // 发射法杖\n    extraDamageRatio,   // 额外伤害\n    finalDamageRatio,   // 最终伤害比例\n    extraSpeedRatio,    // 额外速度\n    finalSpeedRatio,    // 最终速度比例\n    extraSizeRatio,     // 额外大小\n    finalSizeRatio,     // 最终大小比例\n    ...\n};\n\nspell.Initialize(ownerPpt, direction, config, wand);\n```\n\n**对象池集成**：\n```csharp\n// 从对象池获取\nGameObject spellGO = SpellPoolMgr.GetSpell(spellID);\nSpellBase spell = spellGO.GetComponent<SpellBase>();\n\n// 初始化\nspell.Initialize(parameter);\n\n// 设置位置和方向\nspell.transform.position = shootPosition;\nspell.transform.rotation = Quaternion.LookRotation(Vector3.forward, direction);\n\n// 播放音效（可选）\nif (config.playShootSE)\n    SEMgr.Inst.PlaySE(\"SE_Shoot\");\n```\n\n**属性修正系统**：\n```csharp\n// 在FinalInitialize中应用\ndamageRatio += initialParameter.extraDamageRatio;\nfinalDamageRatio *= initialParameter.finalDamageRatio;\nradiusRatio += initialParameter.extraSizeRatio;\nfinalRadiusRatio *= initialParameter.finalSizeRatio;\nspeedRatio += initialParameter.extraSpeedRatio;\nfinalSpeedRatio *= initialParameter.finalSpeedRatio;\nbonusDuration += initialParameter.extraDuration;\nfinalDurationRatio *= initialParameter.finalDurationRatio;\n\n// 应用特殊效果\nlightningChainDamage = initialParameter.lightningChainDamage;\nlifelineDamage = initialParameter.lifeLineData.damage;\nlifelineDamageInterval = initialParameter.lifeLineData.Interval;\n```\n\n### 5.5 DOTS系统架构\n\n**DOTS移动系统**：\n```csharp\n[BurstCompile]\npublic partial struct UnitMoveSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        float deltaTime = SystemAPI.Time.DeltaTime;\n        \n        foreach (var (baseData, pptData, transform, velocity) in\n                 SystemAPI.Query<RefRW<UnitBase_Dots>,\n                                RefRO<UnitProperty_Dots>,\n                                RefRW<LocalTransform>,\n                                RefRW<PhysicsVelocity>>())\n        {\n            // 应用粘液减速\n            float moveSpeedRatio = pptData.ValueRO.affect_MucusMoveSpeedRatio;\n            if (moveSpeedRatio == 0f)\n                moveSpeedRatio = 1f;\n            \n            // 计算最终速度\n            float3 finalMotion = baseData.ValueRO.targetMotion × moveSpeedRatio;\n            \n            // 应用到物理速度\n            velocity.ValueRW.Linear.xy = finalMotion.xy;\n            \n            // 速度衰减\n            if (pptData.ValueRO.IsVelocityDeclice)\n                velocity.ValueRW.Linear *= 0.9f;\n        }\n    }\n}\n```\n\n**DOTS跳跃系统**：\n```csharp\n[BurstCompile]\npublic partial struct UnitJumpSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        float deltaTime = SystemAPI.Time.DeltaTime;\n        \n        foreach (var (baseData, transform, velocity) in\n                 SystemAPI.Query<RefRW<UnitBase_Dots>,\n                                RefRW<LocalTransform>,\n                                RefRW<PhysicsVelocity>>())\n        {\n            if (baseData.ValueRO.isJumping)\n            {\n                // 应用垂直速度\n                velocity.ValueRW.Linear.z = baseData.ValueRO.jumpUpForce;\n                \n                // 应用重力\n                baseData.ValueRW.jumpUpForce += baseData.ValueRO.jumpGravity × deltaTime;\n                \n                // 落地检测\n                if (transform.ValueRO.Position.z <= 0f && baseData.ValueRO.jumpUpForce < 0f)\n                {\n                    transform.ValueRW.Position.z = 0f;\n                    velocity.ValueRW.Linear.z = 0f;\n                    baseData.ValueRW.isJumping = false;\n                }\n            }\n        }\n    }\n}\n```\n\n---\n\n## 6. 状态效果系统详解\n\n### 6.1 状态效果类型表\n\n| 状态效果 | 效果说明 | 数据结构 | 特点 |\n|---------|---------|---------|------|\n| **粘液** | 减速移动和法术速度 | duration, moveRatio, spellRatio | 受击刷新 |\n| **毒素** | 持续伤害，可叠加 | duration, stack | 可叠加层数 |\n| **燃烧** | 基于HP比例持续伤害 | duration, hpRatio | 有视觉特效 |\n| **冰冻** | 完全无法行动 | state, duration | 最高优先级 |\n| **虚空** | 虚空爆炸标记 | caster, radius, damage | 死亡触发爆炸 |\n| **深渊** | 深渊伤害标记 | duration | 特殊伤害类型 |\n\n### 6.2 优先级与叠加规则\n\n**优先级**（从高到低）：\n1. 冰冻 - 完全控制单位\n2. 击退 - 短暂失去控制\n3. 粘液 - 减速效果\n4. 毒素/燃烧 - 持续伤害\n5. 虚空/深渊 - 标记效果\n\n**叠加规则**：\n- 冰冻：不可叠加，只刷新持续时间\n- 粘液：不可叠加，受击刷新\n- 毒素：可叠加层数\n- 燃烧：不可叠加，刷新持续时间\n- 虚空：可多次标记\n- 击退：可叠加，向量累加\n\n---\n\n## 7. 核心系统总结\n\n### 7.1 技能系统关键设计\n\n1. **配置驱动**：所有技能属性在SpellConfig中定义\n2. **继承扩展**：100+种技能通过继承SpellBase实现\n3. **对象池**：频繁创建/销毁的技能使用对象池管理\n4. **属性修正链**：多层修正系统(基础→加法→乘法)\n5. **状态效果**：技能可应用6种不同的状态效果\n\n### 7.2 单位系统关键设计\n\n1. **双架构**：MonoBehaviour逻辑+DOTS高性能计算\n2. **免疫计数器**：支持多来源同时管理免疫状态\n3. **AI状态机**：多状态转移的战斗AI\n4. **寻路系统**：NavMesh+间隔检查的移动系统\n5. **生命周期**：三阶段初始化+完整生命周期\n\n### 7.3 伤害系统关键设计\n\n1. **7阶段流水线**：逐步处理伤害信息\n2. **可中断性**：任何阶段可以将伤害设为免疫\n3. **多修正层**：遗物、诅咒、易伤等多层修正\n4. **护盾双重**：永久护盾+临时护盾的机制\n5. **暴击系统**：独立的暴击判定和倍率计算\n\n### 7.4 性能优化策略\n\n1. **DOTS ECS**：使用Burst编译的Job进行并行处理\n2. **对象池**：频繁创建销毁的对象使用池管理\n3. **Buffer机制**：每个Entity维护伤害信息缓冲区\n4. **每帧清理**：避免内存泄漏和数据过期\n5. **定时器间隔**：目标搜索、寻路等操作不每帧执行\n\n---\n\n这个战斗系统是一个设计精良的大型系统，采用了模块化、可扩展的架构。关键特点是融合了MonoBehaviour和DOTS两套系统的优势，既保持了逻辑的清晰性，又获得了高性能的计算能力。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":26586,"cache_read_input_tokens":92414,"cache_creation":{"ephemeral_5m_input_tokens":26586,"ephemeral_1h_input_tokens":0},"output_tokens":9474,"service_tier":"standard"}},"type":"assistant","uuid":"185ed4c2-0d91-4f09-aaff-0838f23b12d8","timestamp":"2025-12-18T11:37:10.059Z"}
