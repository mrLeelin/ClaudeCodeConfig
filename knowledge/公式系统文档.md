# CompiledFormula 公式系统文档

## 概述

CompiledFormula 是一个高性能的泛型公式编译系统，支持将字符串公式编译为 Expression Tree 并缓存执行。适用于游戏中的伤害计算、属性计算、技能效果等场景。

**核心特性：**
- 支持多种数值类型：`double`、`float`、`FP`（定点数）
- Expression Tree 编译，高性能执行
- 预加载和缓存机制
- 调试追踪功能
- 可扩展的常量、函数、属性注册

**代码位置：**
```
Assets/HotFix/BusinessLogic/BattleV3/DataCenter/Server/Attribute/CompiledFormula/
```

---

## 快速开始

### 1. 初始化

```csharp
// 初始化公式系统（注册基础数学函数和常量）
FormulaInitializer.Initialize();      // double 类型
FormulaInitializer.InitializeFP();    // FP 定点数类型
FormulaInitializer.InitializeFloat(); // float 类型
```

### 2. 基本使用

```csharp
// 创建值提供器
var attacker = new DoubleAttributeProvider(100, 50, 1000); // Atk, Def, MaxHp
var defender = new DoubleAttributeProvider(80, 60, 800);

var providers = new Dictionary<string, IFormulaValueProvider<double>>
{
    { "a", attacker },
    { "b", defender }
};

// 方式1：直接创建公式对象
var formula = new DoubleFormula("{a.Atk} * 1.5 - {b.Def} * 0.5");
double result = formula.Calculate(providers);

// 方式2：使用计算器（自动缓存）
double result2 = DoubleFormulaCalculator.Calculate(
    "max({a.Atk}, {b.Atk}) + min({a.Def}, {b.Def})",
    providers);
```

---

## 公式语法

### 变量引用

| 语法 | 说明 | 示例 |
|------|------|------|
| `{varName}` | 自定义变量 | `{skillMultiplier}` |
| `{obj.prop}` | 对象属性访问 | `{a.Atk}`, `{b.Def}` |

### 运算符（按优先级从高到低）

| 优先级 | 运算符 | 说明 | 示例 |
|--------|--------|------|------|
| 1 | `()` | 括号 | `(a + b) * c` |
| 2 | `-`, `!` | 一元运算 | `-{a.Atk}`, `!({a.Atk} > 0)` |
| 3 | `*`, `/`, `%` | 乘除取模 | `{a.Atk} * 1.5` |
| 4 | `+`, `-` | 加减 | `{a.Atk} + {b.Atk}` |
| 5 | `>`, `<`, `>=`, `<=` | 比较 | `{a.Atk} > {b.Def}` |
| 6 | `==`, `!=` | 相等 | `{a.Atk} == 100` |
| 7 | `&&` | 逻辑与 | `{isCrit} > 0 && {a.Atk} > 50` |
| 8 | `\|\|` | 逻辑或 | `{isCrit} > 0 \|\| {isBackstab} > 0` |
| 9 | `? :` | 三元表达式 | `{isCrit} > 0 ? {a.Atk} * 2 : {a.Atk}` |

### 内置常量

| 常量 | 值 | 说明 |
|------|-----|------|
| `PI` | 3.14159... | 圆周率 |
| `E` | 2.71828... | 自然对数底 |
| `TAU` | 6.28318... | 2π |

### 内置函数

**三角函数：**
```
sin(x), cos(x), tan(x), asin(x), acos(x), atan(x), atan2(y, x)
```

**指数对数：**
```
sqrt(x), pow(x, y), exp(x), log(x), log10(x)
```

**取整函数：**
```
floor(x), ceil(x), round(x)
```

**其他：**
```
abs(x), sign(x), min(a, b), max(a, b), clamp(val, min, max), lerp(a, b, t)
```

---

## 高级功能

### 1. 自定义常量

```csharp
// 注册自定义常量
FormulaConstantRegistry.Register("CRIT_RATE", 0.15);
FormulaConstantRegistry.Register("BASE_DAMAGE", 50.0);

// 使用
var formula = new DoubleFormula("{a.Atk} * (1 + CRIT_RATE) + BASE_DAMAGE");
```

### 2. 自定义函数

```csharp
// 无参函数
FormulaFunctionRegistry.Register("random_seed", () => 42.0);

// 单参数函数
FormulaFunctionRegistry.Register("square", (double x) => x * x);

// 双参数函数
FormulaFunctionRegistry.Register("avg", (double a, double b) => (a + b) / 2);

// 三参数函数
FormulaFunctionRegistry.Register("weighted_avg",
    (double a, double b, double w) => a * (1 - w) + b * w);

// 使用
var formula = new DoubleFormula("avg({a.Atk}, {b.Atk}) + square(10)");
```

### 3. 注册属性（计算属性）

当某些属性不在 `IFormulaValueProvider` 中时，可以通过注册表提供计算值：

```csharp
// 注册计算属性（需要 provider）
FormulaPropertyRegistry.Register("TotalAtk",
    provider => provider.GetValue("Atk") * 1.5);

FormulaPropertyRegistry.Register("CombatPower",
    provider => provider.GetValue("Atk") * 2 + provider.GetValue("Def"));

// 注册全局属性（无需 provider）
FormulaPropertyRegistry.RegisterGlobal("GlobalMultiplier", () => 1.25);

// 使用 - 通过 {obj.PropertyName} 语法访问
var formula = new DoubleFormula("{a.TotalAtk} - {b.EffectiveDef}");
```

### 4. 预加载（预热）

```csharp
// 单个公式预加载
DoubleFormulaCalculator.Precompile("{a.Atk} * {skillRate} - {b.Def} * 0.5");

// 批量预加载
var formulas = new[]
{
    "{a.Atk} * {skillRate} - {b.Def} * 0.5",
    "{a.MaxHp} * 0.1 + {a.Def} * 0.2",
    "max({a.Atk}, {b.Atk}) * 1.5"
};
DoubleFormulaCalculator.PrecompileMany(formulas);

// 检查缓存状态
var stats = DoubleFormulaCalculator.GetCacheStats();
Debug.Log($"缓存公式数: {stats.CachedFormulas}");
```

### 5. 调试追踪

```csharp
// 使用调试器追踪计算过程
var trace = FormulaDebugger<double, DoubleOperations>.CalculateWithTrace(
    "{a.Atk} > {b.Def} ? ({a.Atk} - {b.Def}) * 1.5 : 10",
    providers);

// 输出追踪信息
Debug.Log(trace.ToFormattedString());
Debug.Log($"结果: {trace.Result}, 成功: {trace.Success}");
```

---

## 类型别名

| 类型 | 公式类 | 计算器 | 用途 |
|------|--------|--------|------|
| `double` | `DoubleFormula` | `DoubleFormulaCalculator` | 默认，向后兼容 |
| `float` | `FloatFormula` | `FloatFormulaCalculator` | 单精度浮点 |
| `FP` | `FPFormula` | `FPFormulaCalculator` | 定点数，确定性计算 |

---

## 实现 IFormulaValueProvider

```csharp
public class MyAttributeProvider : IFormulaValueProvider<double>
{
    public double Atk { get; set; }
    public double Def { get; set; }
    public double MaxHp { get; set; }

    public double GetValue(string propertyName)
    {
        return propertyName switch
        {
            "Atk" => Atk,
            "Def" => Def,
            "MaxHp" => MaxHp,
            _ => throw new FormulaException($"Unknown property: {propertyName}")
        };
    }

    public bool HasValue(string propertyName)
    {
        return propertyName is "Atk" or "Def" or "MaxHp";
    }
}
```

---

## 复杂公式示例

```csharp
// 完整伤害计算
"clamp(({a.Atk} - {b.Def} * 0.5) * ({isCrit} > 0 ? {critMultiplier} : 1), {minDamage}, {maxDamage})"

// 技能伤害（带等级加成）
"({a.Atk} * (1 + {level} * 0.02) - {b.Def}) * ({isCrit} > 0 ? {critMultiplier} : 1)"

// 治疗公式
"{a.MaxHp} * 0.1 + {a.Atk} * 0.5 + ({isPoisoned} > 0 ? -{a.MaxHp} * 0.05 : 0)"

// 护盾吸收
"{shieldValue} > 0 ? (({a.Atk} - {b.Def}) > {shieldValue} ? ({a.Atk} - {b.Def}) - {shieldValue} : 0) : {a.Atk} - {b.Def}"

// 多重状态效果
"{a.Atk} * (1 + ({isCrit} > 0 ? 0.5 : 0) + ({isBackstab} > 0 ? 0.3 : 0))"
```

---

## 工具类

### EnumCache<TEnum> - 枚举缓存

避免 `Enum.TryParse` 的反射开销：

```csharp
// 之前（反射，慢）
Enum.TryParse(propertyName, out BuffType buffType);

// 之后（O(1) 字典查找，快）
EnumCache<BuffType>.TryParse(propertyName, out BuffType buffType);

// 直接获取，失败返回默认值
var buffType = EnumCache<BuffType>.Parse(propertyName, BuffType.None);

// 避免 ToString() 装箱
var name = EnumCache<BuffType>.GetName(buffType);
```

---

## 重置和清理

```csharp
// 重置公式系统（清空所有注册表和缓存）
FormulaInitializer.Reset();

// 或者单独清理
FormulaConstantRegistry.Clear();
FormulaFunctionRegistry.Clear();
FormulaPropertyRegistry.Clear();
DoubleFormulaCalculator.ClearCache();
```

---

## 文件结构

```
CompiledFormula/
├── AST/                          # 抽象语法树节点
│   ├── AstNode.cs               # 基类
│   ├── NumberNode.cs            # 数字节点
│   ├── VariableNode.cs          # 变量节点
│   ├── PropertyAccessNode.cs    # 属性访问节点
│   ├── BinaryOpNode.cs          # 二元运算节点
│   ├── UnaryOpNode.cs           # 一元运算节点
│   ├── TernaryNode.cs           # 三元表达式节点
│   ├── FunctionCallNode.cs      # 函数调用节点
│   └── ...
├── Registry/                     # 注册表
│   ├── FormulaConstantRegistry.cs   # 常量注册表
│   ├── FormulaFunctionRegistry.cs   # 函数注册表
│   └── FormulaPropertyRegistry.cs   # 属性注册表
├── Numbers/                      # 数值运算实现
│   ├── INumericOperations.cs    # 接口
│   ├── DoubleOperations.cs      # double 实现
│   ├── FloatOperations.cs       # float 实现
│   └── FPOperations.cs          # FP 定点数实现
├── Tokens/                       # 词法分析
│   ├── Token.cs
│   └── TokenType.cs
├── FormulaLexer.cs              # 词法分析器
├── FormulaParser.cs             # 语法分析器
├── FormulaCompiler.cs           # 编译器
├── CompiledFormula.cs           # 编译后的公式
├── CompiledFormulaCalculator.cs # 计算器（带缓存）
├── FormulaInitializer.cs        # 初始化器
├── FormulaDebugger.cs           # 调试器
├── FormulaValidator.cs          # 验证器
├── FormulaTypeAliases.cs        # 类型别名
├── FormulaContext.cs            # 编译上下文
├── FormulaException.cs          # 异常类
├── IFormulaValueProvider.cs     # 值提供器接口
├── EnumCache.cs                 # 枚举缓存工具
└── Example/                      # 示例
    └── FormulaUsageExample.cs
```
